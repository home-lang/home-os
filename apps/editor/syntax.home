// home-os Syntax Highlighting
// Multi-language syntax highlighting engine

import "../../kernel/src/core/foundation.home" as foundation

const LANG_PLAINTEXT: u32 = 0
const LANG_HOME: u32 = 1
const LANG_C: u32 = 2
const LANG_JAVASCRIPT: u32 = 3
const LANG_PYTHON: u32 = 4
const LANG_RUST: u32 = 5
const LANG_GO: u32 = 6
const LANG_ZIG: u32 = 7

const TOKEN_DEFAULT: u32 = 0
const TOKEN_KEYWORD: u32 = 1
const TOKEN_TYPE: u32 = 2
const TOKEN_STRING: u32 = 3
const TOKEN_COMMENT: u32 = 4
const TOKEN_NUMBER: u32 = 5
const TOKEN_FUNCTION: u32 = 6
const TOKEN_OPERATOR: u32 = 7

var syntax_initialized: u32 = 0

// Color scheme
const COLOR_DEFAULT: u32 = 0xD4D4D4
const COLOR_KEYWORD: u32 = 0xC586C0
const COLOR_TYPE: u32 = 0x4EC9B0
const COLOR_STRING: u32 = 0xCE9178
const COLOR_COMMENT: u32 = 0x6A9955
const COLOR_NUMBER: u32 = 0xB5CEA8
const COLOR_FUNCTION: u32 = 0xDCDCAA
const COLOR_OPERATOR: u32 = 0xD4D4D4

export fn syntax_init() {
  if syntax_initialized == 1 { return }
  
  syntax_initialized = 1
  foundation.serial_write_string("[Syntax] Highlighting initialized\n")
}

export fn syntax_detect_language(filename: u64) -> u32 {
  // Detect language from file extension
  var i: u32 = 0
  var last_dot: u32 = 0
  
  while i < 256 {
    var ch: u8 = @intToPtr(filename + i, u8)
    if ch == 0 { break }
    if ch == '.' { last_dot = i + 1 }
    i = i + 1
  }
  
  if last_dot == 0 { return LANG_PLAINTEXT }
  
  var ext: u64 = filename + last_dot
  
  // Check extensions
  if syntax_str_equals(ext, "home") { return LANG_HOME }
  if syntax_str_equals(ext, "c") or syntax_str_equals(ext, "h") { return LANG_C }
  if syntax_str_equals(ext, "js") { return LANG_JAVASCRIPT }
  if syntax_str_equals(ext, "py") { return LANG_PYTHON }
  if syntax_str_equals(ext, "rs") { return LANG_RUST }
  if syntax_str_equals(ext, "go") { return LANG_GO }
  if syntax_str_equals(ext, "zig") { return LANG_ZIG }
  
  return LANG_PLAINTEXT
}

fn syntax_str_equals(str1: u64, str2: u64) -> u32 {
  var i: u32 = 0
  while i < 32 {
    var ch1: u8 = @intToPtr(str1 + i, u8)
    var ch2: u8 = @intToPtr(str2 + i, u8)
    
    if ch1 != ch2 { return 0 }
    if ch1 == 0 { return 1 }
    
    i = i + 1
  }
  return 1
}

fn syntax_is_keyword(word: u64, language: u32) -> u32 {
  if language == LANG_HOME {
    if syntax_str_equals(word, "fn") { return 1 }
    if syntax_str_equals(word, "var") { return 1 }
    if syntax_str_equals(word, "const") { return 1 }
    if syntax_str_equals(word, "if") { return 1 }
    if syntax_str_equals(word, "else") { return 1 }
    if syntax_str_equals(word, "while") { return 1 }
    if syntax_str_equals(word, "return") { return 1 }
    if syntax_str_equals(word, "import") { return 1 }
    if syntax_str_equals(word, "export") { return 1 }
    if syntax_str_equals(word, "struct") { return 1 }
    if syntax_str_equals(word, "break") { return 1 }
    if syntax_str_equals(word, "continue") { return 1 }
  } else if language == LANG_C {
    if syntax_str_equals(word, "int") { return 1 }
    if syntax_str_equals(word, "void") { return 1 }
    if syntax_str_equals(word, "char") { return 1 }
    if syntax_str_equals(word, "if") { return 1 }
    if syntax_str_equals(word, "else") { return 1 }
    if syntax_str_equals(word, "while") { return 1 }
    if syntax_str_equals(word, "for") { return 1 }
    if syntax_str_equals(word, "return") { return 1 }
    if syntax_str_equals(word, "struct") { return 1 }
  }
  
  return 0
}

fn syntax_is_type(word: u64, language: u32) -> u32 {
  if language == LANG_HOME {
    if syntax_str_equals(word, "u8") { return 1 }
    if syntax_str_equals(word, "u16") { return 1 }
    if syntax_str_equals(word, "u32") { return 1 }
    if syntax_str_equals(word, "u64") { return 1 }
    if syntax_str_equals(word, "i32") { return 1 }
    if syntax_str_equals(word, "f32") { return 1 }
  }
  
  return 0
}

export fn syntax_highlight_line(line: u64, length: u32, language: u32, tokens: u64) {
  if language == LANG_PLAINTEXT {
    var i: u32 = 0
    while i < length {
      @ptrToInt(tokens + (i * 4), u32) = TOKEN_DEFAULT
      i = i + 1
    }
    return
  }
  
  var i: u32 = 0
  var in_string: u32 = 0
  var in_comment: u32 = 0
  
  while i < length {
    var ch: u8 = @intToPtr(line + i, u8)
    
    // Check for comment
    if in_comment == 0 and ch == '/' and i + 1 < length {
      var next: u8 = @intToPtr(line + i + 1, u8)
      if next == '/' {
        in_comment = 1
      }
    }
    
    if in_comment == 1 {
      @ptrToInt(tokens + (i * 4), u32) = TOKEN_COMMENT
      i = i + 1
      continue
    }
    
    // Check for string
    if ch == '"' {
      in_string = 1 - in_string
      @ptrToInt(tokens + (i * 4), u32) = TOKEN_STRING
      i = i + 1
      continue
    }
    
    if in_string == 1 {
      @ptrToInt(tokens + (i * 4), u32) = TOKEN_STRING
      i = i + 1
      continue
    }
    
    // Check for number
    if ch >= '0' and ch <= '9' {
      @ptrToInt(tokens + (i * 4), u32) = TOKEN_NUMBER
      i = i + 1
      continue
    }
    
    // Check for operator
    if ch == '+' or ch == '-' or ch == '*' or ch == '/' or 
       ch == '=' or ch == '<' or ch == '>' or ch == '!' {
      @ptrToInt(tokens + (i * 4), u32) = TOKEN_OPERATOR
      i = i + 1
      continue
    }
    
    // Check for keyword/type
    if (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or ch == '_' {
      var word_start: u32 = i
      var word: [u8; 64]
      var word_len: u32 = 0
      
      while i < length and word_len < 63 {
        ch = @intToPtr(line + i, u8)
        if (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or 
           (ch >= '0' and ch <= '9') or ch == '_' {
          word[word_len] = ch
          word_len = word_len + 1
          i = i + 1
        } else {
          break
        }
      }
      
      word[word_len] = 0
      
      var token_type: u32 = TOKEN_DEFAULT
      if syntax_is_keyword(@ptrFromInt(word), language) == 1 {
        token_type = TOKEN_KEYWORD
      } else if syntax_is_type(@ptrFromInt(word), language) == 1 {
        token_type = TOKEN_TYPE
      }
      
      var j: u32 = word_start
      while j < i {
        @ptrToInt(tokens + (j * 4), u32) = token_type
        j = j + 1
      }
      
      continue
    }
    
    @ptrToInt(tokens + (i * 4), u32) = TOKEN_DEFAULT
    i = i + 1
  }
}

export fn syntax_get_color(token_type: u32) -> u32 {
  if token_type == TOKEN_KEYWORD { return COLOR_KEYWORD }
  if token_type == TOKEN_TYPE { return COLOR_TYPE }
  if token_type == TOKEN_STRING { return COLOR_STRING }
  if token_type == TOKEN_COMMENT { return COLOR_COMMENT }
  if token_type == TOKEN_NUMBER { return COLOR_NUMBER }
  if token_type == TOKEN_FUNCTION { return COLOR_FUNCTION }
  if token_type == TOKEN_OPERATOR { return COLOR_OPERATOR }
  
  return COLOR_DEFAULT
}
