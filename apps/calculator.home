// home-os Calculator
// Scientific calculator with programmer mode and history

import "../kernel/src/core/foundation.home" as foundation

const MAX_HISTORY: u32 = 50
const MAX_DISPLAY: u32 = 32

// Calculator modes
const MODE_BASIC: u32 = 0
const MODE_SCIENTIFIC: u32 = 1
const MODE_PROGRAMMER: u32 = 2

// Number bases for programmer mode
const BASE_DEC: u32 = 10
const BASE_HEX: u32 = 16
const BASE_OCT: u32 = 8
const BASE_BIN: u32 = 2

struct HistoryEntry {
  expression: [u8; 64],
  result: f64
}

var display: [u8; 32]
var display_len: u32 = 0
var accumulator: f64 = 0.0
var current_value: f64 = 0.0
var operation: u8 = 0  // +, -, *, /, etc.
var mode: u32 = MODE_BASIC
var base: u32 = BASE_DEC
var history: [HistoryEntry; 50]
var history_count: u32 = 0
var memory: f64 = 0.0
var calc_initialized: u32 = 0

export fn calc_init() {
  if calc_initialized == 1 { return }
  
  display[0] = '0'
  display[1] = 0
  display_len = 1
  accumulator = 0.0
  current_value = 0.0
  operation = 0
  mode = MODE_BASIC
  base = BASE_DEC
  history_count = 0
  memory = 0.0
  
  calc_initialized = 1
  foundation.serial_write_string("[Calculator] Initialized\n")
}

// Basic operations
export fn calc_add(a: f64, b: f64) -> f64 {
  return a + b
}

export fn calc_subtract(a: f64, b: f64) -> f64 {
  return a - b
}

export fn calc_multiply(a: f64, b: f64) -> f64 {
  return a * b
}

export fn calc_divide(a: f64, b: f64) -> f64 {
  if b == 0.0 { return 0.0 }  // Avoid division by zero
  return a / b
}

export fn calc_modulo(a: f64, b: f64) -> f64 {
  if b == 0.0 { return 0.0 }
  return a % b
}

// Scientific operations
export fn calc_power(base: f64, exp: f64) -> f64 {
  if exp == 0.0 { return 1.0 }
  if exp == 1.0 { return base }
  
  var result: f64 = 1.0
  var i: u32 = 0
  var exp_int: u32 = @truncate(exp, u32)
  
  while i < exp_int {
    result = result * base
    i = i + 1
  }
  
  return result
}

export fn calc_sqrt(x: f64) -> f64 {
  if x < 0.0 { return 0.0 }
  if x == 0.0 { return 0.0 }
  
  // Newton's method
  var guess: f64 = x / 2.0
  var i: u32 = 0
  
  while i < 10 {
    guess = (guess + x / guess) / 2.0
    i = i + 1
  }
  
  return guess
}

export fn calc_factorial(n: u32) -> u64 {
  if n == 0 or n == 1 { return 1 }
  
  var result: u64 = 1
  var i: u32 = 2
  
  while i <= n {
    result = result * i
    i = i + 1
  }
  
  return result
}

export fn calc_sin(x: f64) -> f64 {
  // Taylor series approximation
  var result: f64 = 0.0
  var term: f64 = x
  var i: u32 = 1
  
  while i < 10 {
    result = result + term
    term = term * (-1.0) * x * x / ((2.0 * @intToFloat(i, f64)) * (2.0 * @intToFloat(i, f64) + 1.0))
    i = i + 1
  }
  
  return result
}

export fn calc_cos(x: f64) -> f64 {
  // Taylor series approximation
  var result: f64 = 1.0
  var term: f64 = 1.0
  var i: u32 = 1
  
  while i < 10 {
    term = term * (-1.0) * x * x / ((2.0 * @intToFloat(i, f64) - 1.0) * (2.0 * @intToFloat(i, f64)))
    result = result + term
    i = i + 1
  }
  
  return result
}

export fn calc_tan(x: f64) -> f64 {
  var cos_x: f64 = calc_cos(x)
  if cos_x == 0.0 { return 0.0 }
  return calc_sin(x) / cos_x
}

export fn calc_log(x: f64) -> f64 {
  if x <= 0.0 { return 0.0 }
  
  // Natural logarithm using series expansion
  var result: f64 = 0.0
  var y: f64 = (x - 1.0) / (x + 1.0)
  var y_squared: f64 = y * y
  var term: f64 = y
  var i: u32 = 1
  
  while i < 20 {
    result = result + term / @intToFloat(i, f64)
    term = term * y_squared
    i = i + 2
  }
  
  return 2.0 * result
}

export fn calc_exp(x: f64) -> f64 {
  // e^x using Taylor series
  var result: f64 = 1.0
  var term: f64 = 1.0
  var i: u32 = 1
  
  while i < 20 {
    term = term * x / @intToFloat(i, f64)
    result = result + term
    i = i + 1
  }
  
  return result
}

// Programmer mode operations
export fn calc_and(a: u64, b: u64) -> u64 {
  return a & b
}

export fn calc_or(a: u64, b: u64) -> u64 {
  return a | b
}

export fn calc_xor(a: u64, b: u64) -> u64 {
  return a ^ b
}

export fn calc_not(a: u64) -> u64 {
  return ~a
}

export fn calc_shl(a: u64, bits: u32) -> u64 {
  return a << bits
}

export fn calc_shr(a: u64, bits: u32) -> u64 {
  return a >> bits
}

// Number base conversion
export fn calc_to_hex(num: u64, buffer: u64) {
  if num == 0 {
    @intToPtr(buffer, u8) = '0'
    @intToPtr(buffer + 1, u8) = 0
    return
  }
  
  var digits: [u8; 16]
  var count: u32 = 0
  var n: u64 = num
  
  while n > 0 {
    var digit: u8 = @truncate(n % 16, u8)
    if digit < 10 {
      digits[count] = '0' + digit
    } else {
      digits[count] = 'A' + (digit - 10)
    }
    n = n / 16
    count = count + 1
  }
  
  @intToPtr(buffer, u8) = '0'
  @intToPtr(buffer + 1, u8) = 'x'
  
  var i: u32 = 0
  while i < count {
    @intToPtr(buffer + 2 + i, u8) = digits[count - i - 1]
    i = i + 1
  }
  @intToPtr(buffer + 2 + count, u8) = 0
}

export fn calc_to_bin(num: u64, buffer: u64) {
  if num == 0 {
    @intToPtr(buffer, u8) = '0'
    @intToPtr(buffer + 1, u8) = 'b'
    @intToPtr(buffer + 2, u8) = '0'
    @intToPtr(buffer + 3, u8) = 0
    return
  }
  
  var digits: [u8; 64]
  var count: u32 = 0
  var n: u64 = num
  
  while n > 0 {
    digits[count] = '0' + @truncate(n % 2, u8)
    n = n / 2
    count = count + 1
  }
  
  @intToPtr(buffer, u8) = '0'
  @intToPtr(buffer + 1, u8) = 'b'
  
  var i: u32 = 0
  while i < count {
    @intToPtr(buffer + 2 + i, u8) = digits[count - i - 1]
    i = i + 1
  }
  @intToPtr(buffer + 2 + count, u8) = 0
}

export fn calc_to_oct(num: u64, buffer: u64) {
  if num == 0 {
    @intToPtr(buffer, u8) = '0'
    @intToPtr(buffer + 1, u8) = 0
    return
  }
  
  var digits: [u8; 22]
  var count: u32 = 0
  var n: u64 = num
  
  while n > 0 {
    digits[count] = '0' + @truncate(n % 8, u8)
    n = n / 8
    count = count + 1
  }
  
  @intToPtr(buffer, u8) = '0'
  
  var i: u32 = 0
  while i < count {
    @intToPtr(buffer + 1 + i, u8) = digits[count - i - 1]
    i = i + 1
  }
  @intToPtr(buffer + 1 + count, u8) = 0
}

// History management
export fn calc_add_to_history(expr: u64, result: f64) {
  if history_count >= MAX_HISTORY {
    // Shift history
    var i: u32 = 0
    while i < MAX_HISTORY - 1 {
      var j: u32 = 0
      while j < 64 {
        history[i].expression[j] = history[i + 1].expression[j]
        j = j + 1
      }
      history[i].result = history[i + 1].result
      i = i + 1
    }
    history_count = MAX_HISTORY - 1
  }
  
  // Add new entry
  var i: u32 = 0
  while i < 64 {
    var ch: u8 = @intToPtr(expr + i, u8)
    history[history_count].expression[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  history[history_count].result = result
  history_count = history_count + 1
}

export fn calc_get_history_count() -> u32 {
  return history_count
}

export fn calc_get_history_entry(index: u32) -> u64 {
  if index >= history_count { return 0 }
  return @ptrFromInt(history[index].expression)
}

export fn calc_get_history_result(index: u32) -> f64 {
  if index >= history_count { return 0.0 }
  return history[index].result
}

export fn calc_clear_history() {
  history_count = 0
}

// Memory operations
export fn calc_memory_store(value: f64) {
  memory = value
}

export fn calc_memory_recall() -> f64 {
  return memory
}

export fn calc_memory_add(value: f64) {
  memory = memory + value
}

export fn calc_memory_clear() {
  memory = 0.0
}

export fn calc_main() {
  calc_init()
  
  foundation.vga_clear()
  foundation.vga_write_string("=== Calculator ===\n\n")
  foundation.vga_write_string("Mode: Basic\n")
  foundation.vga_write_string("Display: 0\n\n")
  foundation.vga_write_string("F1=Basic F2=Scientific F3=Programmer\n")
  foundation.vga_write_string("M=Memory H=History C=Clear Q=Quit\n")
  
  foundation.vga_write_string("\nCalculator loaded!\n")
}
