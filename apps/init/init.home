// home-os Init Process (PID 1)
// The first userspace process that manages system initialization
// Responsible for starting services, mounting filesystems, and reaping orphaned processes

import "../../kernel/src/core/foundation.home" as foundation

// Init configuration
const MAX_SERVICES: u32 = 64
const MAX_RUNLEVELS: u32 = 7
const CONFIG_PATH: *u8 = "/etc/inittab"

// Runlevels
const RUNLEVEL_HALT: u32 = 0
const RUNLEVEL_SINGLE: u32 = 1
const RUNLEVEL_MULTI_NO_NET: u32 = 2
const RUNLEVEL_MULTI: u32 = 3
const RUNLEVEL_UNUSED: u32 = 4
const RUNLEVEL_MULTI_GUI: u32 = 5
const RUNLEVEL_REBOOT: u32 = 6

// Service states
const SERVICE_STATE_STOPPED: u32 = 0
const SERVICE_STATE_STARTING: u32 = 1
const SERVICE_STATE_RUNNING: u32 = 2
const SERVICE_STATE_STOPPING: u32 = 3
const SERVICE_STATE_FAILED: u32 = 4

// Service types
const SERVICE_TYPE_ONCE: u32 = 0      // Run once at boot
const SERVICE_TYPE_RESPAWN: u32 = 1   // Restart if dies
const SERVICE_TYPE_WAIT: u32 = 2      // Wait for completion
const SERVICE_TYPE_ONDEMAND: u32 = 3  // Start on demand

// Service definition
struct Service {
  name: [64]u8
  command: [256]u8
  runlevels: u32          // Bitmask of runlevels
  type_: u32
  state: u32
  pid: u32
  restart_count: u32
  max_restarts: u32
  enabled: u32
}

// Init state
struct InitState {
  current_runlevel: u32
  target_runlevel: u32
  services: [MAX_SERVICES]Service
  num_services: u32
  initialized: u32
  shutdown_requested: u32
}

var init_state: InitState

// Syscall wrappers
fn syscall_fork(): u32 {
  // Would invoke fork() syscall
  return 0
}

fn syscall_exec(path: *u8, argv: **u8): u32 {
  // Would invoke execve() syscall
  return 0
}

fn syscall_wait(status: *u32): u32 {
  // Would invoke wait() syscall
  return 0
}

fn syscall_kill(pid: u32, signal: u32): u32 {
  // Would invoke kill() syscall
  return 0
}

fn syscall_reboot(cmd: u32): u32 {
  // Would invoke reboot() syscall
  return 0
}

fn syscall_mount(source: *u8, target: *u8, fstype: *u8, flags: u32): u32 {
  // Would invoke mount() syscall
  return 0
}

fn syscall_sleep(seconds: u32) {
  // Would invoke nanosleep() syscall
}

// Initialize init process
fn init_initialize() {
  foundation.serial_write_string("[INIT] Starting init process (PID 1)...\n")

  init_state.current_runlevel = RUNLEVEL_SINGLE
  init_state.target_runlevel = RUNLEVEL_MULTI
  init_state.num_services = 0
  init_state.shutdown_requested = 0

  // Initialize service table
  var i: u32 = 0
  loop {
    if i >= MAX_SERVICES { break }

    init_state.services[i].enabled = 0
    init_state.services[i].state = SERVICE_STATE_STOPPED
    init_state.services[i].pid = 0
    init_state.services[i].restart_count = 0

    i = i + 1
  }

  init_state.initialized = 1

  foundation.serial_write_string("[INIT] Init process initialized\n")
}

// Mount essential filesystems
fn mount_filesystems() {
  foundation.serial_write_string("[INIT] Mounting filesystems...\n")

  // Mount /proc
  syscall_mount("proc", "/proc", "proc", 0)
  foundation.serial_write_string("[INIT] Mounted /proc\n")

  // Mount /sys
  syscall_mount("sysfs", "/sys", "sysfs", 0)
  foundation.serial_write_string("[INIT] Mounted /sys\n")

  // Mount /dev
  syscall_mount("devtmpfs", "/dev", "devtmpfs", 0)
  foundation.serial_write_string("[INIT] Mounted /dev\n")

  // Mount /tmp
  syscall_mount("tmpfs", "/tmp", "tmpfs", 0)
  foundation.serial_write_string("[INIT] Mounted /tmp\n")

  foundation.serial_write_string("[INIT] Filesystems mounted\n")
}

// Register a service
fn register_service(name: *u8, command: *u8, runlevels: u32, type_: u32, max_restarts: u32) {
  if init_state.num_services >= MAX_SERVICES {
    foundation.serial_write_string("[INIT] Maximum services reached\n")
    return
  }

  let idx: u32 = init_state.num_services
  let service: *Service = &init_state.services[idx]

  // Copy name
  var i: u32 = 0
  loop {
    if i >= 64 { break }
    let ch: u8 = foundation.read_u8(name as u64 + i as u64)
    service.name[i] = ch
    if ch == 0 { break }
    i = i + 1
  }

  // Copy command
  i = 0
  loop {
    if i >= 256 { break }
    let ch: u8 = foundation.read_u8(command as u64 + i as u64)
    service.command[i] = ch
    if ch == 0 { break }
    i = i + 1
  }

  service.runlevels = runlevels
  service.type_ = type_
  service.state = SERVICE_STATE_STOPPED
  service.pid = 0
  service.restart_count = 0
  service.max_restarts = max_restarts
  service.enabled = 1

  init_state.num_services = init_state.num_services + 1

  foundation.serial_write_string("[INIT] Registered service: ")
  foundation.serial_write_string(name)
  foundation.serial_write_string("\n")
}

// Start a service
fn start_service(idx: u32) {
  if idx >= init_state.num_services { return }

  let service: *Service = &init_state.services[idx]

  if service.state == SERVICE_STATE_RUNNING {
    return
  }

  foundation.serial_write_string("[INIT] Starting service: ")
  foundation.serial_write_string(&service.name[0] as *u8)
  foundation.serial_write_string("\n")

  service.state = SERVICE_STATE_STARTING

  // Fork child process
  let pid: u32 = syscall_fork()

  if pid == 0 {
    // Child process - exec service
    syscall_exec(&service.command[0] as *u8, 0)
    // If exec fails, exit
    return
  }

  // Parent process
  service.pid = pid
  service.state = SERVICE_STATE_RUNNING

  foundation.serial_write_string("[INIT] Service started with PID ")
  foundation.serial_write_u64(pid)
  foundation.serial_write_string("\n")
}

// Stop a service
fn stop_service(idx: u32) {
  if idx >= init_state.num_services { return }

  let service: *Service = &init_state.services[idx]

  if service.state != SERVICE_STATE_RUNNING {
    return
  }

  foundation.serial_write_string("[INIT] Stopping service: ")
  foundation.serial_write_string(&service.name[0] as *u8)
  foundation.serial_write_string("\n")

  service.state = SERVICE_STATE_STOPPING

  // Send SIGTERM
  syscall_kill(service.pid, 15)

  // Wait a bit
  syscall_sleep(2)

  // Send SIGKILL if still running
  syscall_kill(service.pid, 9)

  service.state = SERVICE_STATE_STOPPED
  service.pid = 0

  foundation.serial_write_string("[INIT] Service stopped\n")
}

// Change runlevel
fn change_runlevel(new_level: u32) {
  if new_level >= MAX_RUNLEVELS { return }

  foundation.serial_write_string("[INIT] Changing runlevel: ")
  foundation.serial_write_u64(init_state.current_runlevel)
  foundation.serial_write_string(" -> ")
  foundation.serial_write_u64(new_level)
  foundation.serial_write_string("\n")

  init_state.target_runlevel = new_level

  // Stop services not in new runlevel
  var i: u32 = 0
  loop {
    if i >= init_state.num_services { break }

    let service: *Service = &init_state.services[i]
    let in_new_level: u32 = (service.runlevels >> new_level) & 1
    let in_old_level: u32 = (service.runlevels >> init_state.current_runlevel) & 1

    if in_old_level == 1 && in_new_level == 0 {
      stop_service(i)
    }

    i = i + 1
  }

  // Start services in new runlevel
  i = 0
  loop {
    if i >= init_state.num_services { break }

    let service: *Service = &init_state.services[i]
    let in_new_level: u32 = (service.runlevels >> new_level) & 1

    if in_new_level == 1 && service.state != SERVICE_STATE_RUNNING {
      start_service(i)
    }

    i = i + 1
  }

  init_state.current_runlevel = new_level

  foundation.serial_write_string("[INIT] Runlevel change complete\n")
}

// Handle child process exit
fn handle_child_exit(pid: u32, status: u32) {
  // Find service with this PID
  var i: u32 = 0
  loop {
    if i >= init_state.num_services { break }

    let service: *Service = &init_state.services[i]

    if service.pid == pid {
      foundation.serial_write_string("[INIT] Service ")
      foundation.serial_write_string(&service.name[0] as *u8)
      foundation.serial_write_string(" exited with status ")
      foundation.serial_write_u64(status)
      foundation.serial_write_string("\n")

      service.state = SERVICE_STATE_STOPPED
      service.pid = 0

      // Respawn if needed
      if service.type_ == SERVICE_TYPE_RESPAWN {
        service.restart_count = service.restart_count + 1

        if service.max_restarts == 0 || service.restart_count < service.max_restarts {
          foundation.serial_write_string("[INIT] Respawning service (attempt ")
          foundation.serial_write_u64(service.restart_count)
          foundation.serial_write_string(")\n")

          start_service(i)
        } else {
          foundation.serial_write_string("[INIT] Max restart count reached\n")
          service.state = SERVICE_STATE_FAILED
        }
      }

      return
    }

    i = i + 1
  }

  foundation.serial_write_string("[INIT] Reaped orphaned process ")
  foundation.serial_write_u64(pid)
  foundation.serial_write_string("\n")
}

// Main init loop
fn init_main_loop() {
  foundation.serial_write_string("[INIT] Entering main loop\n")

  loop {
    // Wait for child process to exit
    var status: u32 = 0
    let pid: u32 = syscall_wait(&status)

    if pid > 0 {
      handle_child_exit(pid, status)
    }

    // Check for shutdown
    if init_state.shutdown_requested == 1 {
      foundation.serial_write_string("[INIT] Shutdown requested\n")
      break
    }

    // Check for runlevel change
    if init_state.target_runlevel != init_state.current_runlevel {
      change_runlevel(init_state.target_runlevel)
    }
  }
}

// Shutdown system
fn init_shutdown() {
  foundation.serial_write_string("[INIT] Shutting down system...\n")

  // Change to runlevel 0 (halt) or 6 (reboot)
  change_runlevel(RUNLEVEL_HALT)

  // Stop all remaining services
  var i: u32 = 0
  loop {
    if i >= init_state.num_services { break }

    if init_state.services[i].state == SERVICE_STATE_RUNNING {
      stop_service(i)
    }

    i = i + 1
  }

  // Sync filesystems
  foundation.serial_write_string("[INIT] Syncing filesystems...\n")

  // Unmount filesystems
  foundation.serial_write_string("[INIT] Unmounting filesystems...\n")

  foundation.serial_write_string("[INIT] Shutdown complete\n")
}

// Main entry point
export fn main(): u32 {
  foundation.serial_write_string("\n")
  foundation.serial_write_string("========================================\n")
  foundation.serial_write_string("  home-os Init Process (PID 1)\n")
  foundation.serial_write_string("========================================\n")
  foundation.serial_write_string("\n")

  // Initialize init
  init_initialize()

  // Mount filesystems
  mount_filesystems()

  // Register essential services
  register_service("udevd", "/sbin/udevd", 0b00111110, SERVICE_TYPE_RESPAWN, 5)
  register_service("syslogd", "/sbin/syslogd", 0b00111110, SERVICE_TYPE_RESPAWN, 5)
  register_service("network", "/etc/init.d/network start", 0b00111000, SERVICE_TYPE_ONCE, 0)
  register_service("sshd", "/usr/sbin/sshd", 0b00111000, SERVICE_TYPE_RESPAWN, 3)
  register_service("getty", "/sbin/getty ttyS0", 0b00111110, SERVICE_TYPE_RESPAWN, 0)

  // Start default runlevel
  change_runlevel(RUNLEVEL_MULTI)

  // Enter main loop
  init_main_loop()

  // Shutdown
  init_shutdown()

  // Reboot or halt
  syscall_reboot(if init_state.current_runlevel == RUNLEVEL_REBOOT { 1 } else { 0 })

  return 0
}
