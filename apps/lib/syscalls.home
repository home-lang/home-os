// HomeOS Userspace Syscall Library
// Real syscall wrappers using the kernel interface

const serial = @import("../../kernel/src/drivers/serial.home")

// ============================================================================
// Syscall Numbers (must match kernel/src/sys/syscall.home)
// ============================================================================

// Core syscalls (0-28)
const SYS_EXIT: u32 = 0
const SYS_FORK: u32 = 1
const SYS_READ: u32 = 2
const SYS_WRITE: u32 = 3
const SYS_OPEN: u32 = 4
const SYS_CLOSE: u32 = 5
const SYS_WAIT: u32 = 6
const SYS_EXEC: u32 = 7
const SYS_GETPID: u32 = 8
const SYS_KILL: u32 = 9
const SYS_MMAP: u32 = 10
const SYS_MUNMAP: u32 = 11
const SYS_BRK: u32 = 12
const SYS_LSEEK: u32 = 13
const SYS_MKDIR: u32 = 14
const SYS_RMDIR: u32 = 15
const SYS_SETUID: u32 = 16
const SYS_SETGID: u32 = 17
const SYS_CHROOT: u32 = 18
const SYS_PTRACE: u32 = 19
const SYS_REBOOT: u32 = 20
const SYS_MKNOD: u32 = 21
const SYS_SOCKET: u32 = 22
const SYS_BIND: u32 = 23
const SYS_IOCTL: u32 = 24
const SYS_CAPGET: u32 = 25
const SYS_CAPSET: u32 = 26
const SYS_SETTIMEOFDAY: u32 = 27
const SYS_SETRLIMIT: u32 = 28

// POSIX file operations (29-43)
const SYS_STAT: u32 = 29
const SYS_FSTAT: u32 = 30
const SYS_LSTAT: u32 = 31
const SYS_UNLINK: u32 = 32
const SYS_LINK: u32 = 33
const SYS_SYMLINK: u32 = 34
const SYS_READLINK: u32 = 35
const SYS_RENAME: u32 = 36
const SYS_ACCESS: u32 = 37
const SYS_CHMOD: u32 = 38
const SYS_CHOWN: u32 = 39
const SYS_FCHMOD: u32 = 40
const SYS_FCHOWN: u32 = 41
const SYS_TRUNCATE: u32 = 42
const SYS_FTRUNCATE: u32 = 43

// Directory operations (44-47)
const SYS_CHDIR: u32 = 44
const SYS_FCHDIR: u32 = 45
const SYS_GETCWD: u32 = 46
const SYS_GETDENTS: u32 = 47

// Process operations (48-58)
const SYS_GETPPID: u32 = 48
const SYS_GETUID: u32 = 49
const SYS_GETGID: u32 = 50
const SYS_GETEUID: u32 = 51
const SYS_GETEGID: u32 = 52
const SYS_SETPGID: u32 = 53
const SYS_GETPGID: u32 = 54
const SYS_SETSID: u32 = 55
const SYS_GETSID: u32 = 56
const SYS_GETGROUPS: u32 = 57
const SYS_SETGROUPS: u32 = 58

// Time operations (59-62)
const SYS_GETTIMEOFDAY: u32 = 59
const SYS_CLOCK_GETTIME: u32 = 60
const SYS_CLOCK_GETRES: u32 = 61
const SYS_NANOSLEEP: u32 = 62

// Signal operations (63-66)
const SYS_SIGACTION: u32 = 63
const SYS_SIGPROCMASK: u32 = 64
const SYS_SIGPENDING: u32 = 65
const SYS_SIGSUSPEND: u32 = 66

// Memory operations (67-70)
const SYS_MPROTECT: u32 = 67
const SYS_MSYNC: u32 = 68
const SYS_MADVISE: u32 = 69
const SYS_MINCORE: u32 = 70

// Networking operations (71-82)
const SYS_CONNECT: u32 = 71
const SYS_LISTEN: u32 = 72
const SYS_ACCEPT: u32 = 73
const SYS_SEND: u32 = 74
const SYS_RECV: u32 = 75
const SYS_SENDTO: u32 = 76
const SYS_RECVFROM: u32 = 77
const SYS_SHUTDOWN: u32 = 78
const SYS_GETSOCKOPT: u32 = 79
const SYS_SETSOCKOPT: u32 = 80
const SYS_GETPEERNAME: u32 = 81
const SYS_GETSOCKNAME: u32 = 82

// Polling/event operations (83-91)
const SYS_POLL: u32 = 83
const SYS_SELECT: u32 = 84
const SYS_EPOLL_CREATE: u32 = 85
const SYS_EPOLL_CTL: u32 = 86
const SYS_EPOLL_WAIT: u32 = 87
const SYS_EVENTFD: u32 = 88
const SYS_TIMERFD_CREATE: u32 = 89
const SYS_TIMERFD_SETTIME: u32 = 90
const SYS_TIMERFD_GETTIME: u32 = 91

// File descriptor operations (92-100)
const SYS_DUP: u32 = 92
const SYS_DUP2: u32 = 93
const SYS_DUP3: u32 = 94
const SYS_PIPE: u32 = 95
const SYS_PIPE2: u32 = 96
const SYS_FCNTL: u32 = 97
const SYS_FLOCK: u32 = 98
const SYS_FSYNC: u32 = 99
const SYS_FDATASYNC: u32 = 100

// System information (101-104)
const SYS_UNAME: u32 = 101
const SYS_GETRLIMIT: u32 = 102
const SYS_GETRUSAGE: u32 = 103
const SYS_SYSINFO: u32 = 104

// Miscellaneous (105-107)
const SYS_UMASK: u32 = 105
const SYS_MOUNT: u32 = 106
const SYS_UMOUNT: u32 = 107

// Async I/O (io_uring) syscalls
const SYS_IO_URING_SETUP: u32 = 425
const SYS_IO_URING_ENTER: u32 = 426
const SYS_IO_URING_REGISTER: u32 = 427

// Waitpid alias (uses SYS_WAIT)
const SYS_WAITPID: u32 = 6

// ============================================================================
// Error Codes
// ============================================================================

export const EPERM: i32 = -1       // Operation not permitted
export const ENOENT: i32 = -2      // No such file or directory
export const ESRCH: i32 = -3       // No such process
export const EINTR: i32 = -4       // Interrupted system call
export const EIO: i32 = -5         // I/O error
export const ENXIO: i32 = -6       // No such device or address
export const ENOEXEC: i32 = -8     // Exec format error
export const EBADF: i32 = -9       // Bad file descriptor
export const ECHILD: i32 = -10     // No child processes
export const EAGAIN: i32 = -11     // Try again
export const ENOMEM: i32 = -12     // Out of memory
export const EACCES: i32 = -13     // Permission denied
export const EFAULT: i32 = -14     // Bad address
export const EBUSY: i32 = -16      // Device or resource busy
export const EEXIST: i32 = -17     // File exists
export const ENODEV: i32 = -19     // No such device
export const ENOTDIR: i32 = -20    // Not a directory
export const EISDIR: i32 = -21     // Is a directory
export const EINVAL: i32 = -22     // Invalid argument
export const ENFILE: i32 = -23     // File table overflow
export const EMFILE: i32 = -24     // Too many open files
export const ENOSYS: i32 = -38     // Function not implemented

// ============================================================================
// Signal Numbers
// ============================================================================

export const SIGHUP: u32 = 1       // Hangup
export const SIGINT: u32 = 2       // Interrupt
export const SIGQUIT: u32 = 3      // Quit
export const SIGILL: u32 = 4       // Illegal instruction
export const SIGTRAP: u32 = 5      // Trace trap
export const SIGABRT: u32 = 6      // Abort
export const SIGBUS: u32 = 7       // Bus error
export const SIGFPE: u32 = 8       // Floating point exception
export const SIGKILL: u32 = 9      // Kill (cannot be caught)
export const SIGUSR1: u32 = 10     // User defined signal 1
export const SIGSEGV: u32 = 11     // Segmentation fault
export const SIGUSR2: u32 = 12     // User defined signal 2
export const SIGPIPE: u32 = 13     // Broken pipe
export const SIGALRM: u32 = 14     // Alarm clock
export const SIGTERM: u32 = 15     // Termination
export const SIGCHLD: u32 = 17     // Child status changed
export const SIGCONT: u32 = 18     // Continue
export const SIGSTOP: u32 = 19     // Stop (cannot be caught)
export const SIGTSTP: u32 = 20     // Keyboard stop

// Wait flags
export const WNOHANG: u32 = 1
export const WUNTRACED: u32 = 2

// Reboot commands
export const LINUX_REBOOT_CMD_RESTART: u32 = 0x01234567
export const LINUX_REBOOT_CMD_HALT: u32 = 0xCDEF0123
export const LINUX_REBOOT_CMD_POWER_OFF: u32 = 0x4321FEDC

// ============================================================================
// Syscall Invocation (architecture-specific inline assembly)
// ============================================================================

// For x86_64, syscalls use: rax = syscall number, rdi/rsi/rdx/r10/r8/r9 = args
// Returns result in rax

fn syscall0(num: u32) i64 {
    // In real implementation, this would be inline assembly:
    // asm volatile ("syscall" : "=a"(ret) : "a"(num) : "rcx", "r11", "memory");
    // For now, we call into kernel space directly

    // Placeholder: would invoke kernel syscall entry
    return do_syscall(num, 0, 0, 0, 0, 0, 0)
}

fn syscall1(num: u32, arg1: u64) i64 {
    return do_syscall(num, arg1, 0, 0, 0, 0, 0)
}

fn syscall2(num: u32, arg1: u64, arg2: u64) i64 {
    return do_syscall(num, arg1, arg2, 0, 0, 0, 0)
}

fn syscall3(num: u32, arg1: u64, arg2: u64, arg3: u64) i64 {
    return do_syscall(num, arg1, arg2, arg3, 0, 0, 0)
}

fn syscall4(num: u32, arg1: u64, arg2: u64, arg3: u64, arg4: u64) i64 {
    return do_syscall(num, arg1, arg2, arg3, arg4, 0, 0)
}

fn syscall5(num: u32, arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64) i64 {
    return do_syscall(num, arg1, arg2, arg3, arg4, arg5, 0)
}

fn syscall6(num: u32, arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64, arg6: u64) i64 {
    return do_syscall(num, arg1, arg2, arg3, arg4, arg5, arg6)
}

// Kernel entry point (in real implementation, this is the syscall instruction)
extern fn do_syscall(num: u32, a1: u64, a2: u64, a3: u64, a4: u64, a5: u64, a6: u64) i64

// ============================================================================
// Process Management Syscalls
// ============================================================================

export fn sys_exit(status: i32) noreturn {
    _ = syscall1(SYS_EXIT, @as(u64, @intCast(status)))
    // Should never return
    while (true) {}
}

export fn sys_fork() i32 {
    var ret: i64 = syscall0(SYS_FORK)
    return @as(i32, @truncate(ret))
}

export fn sys_getpid() u32 {
    var ret: i64 = syscall0(SYS_GETPID)
    return @as(u32, @truncate(ret))
}

export fn sys_getppid() u32 {
    var ret: i64 = syscall0(SYS_GETPPID)
    return @as(u32, @truncate(ret))
}

export fn sys_wait(status: *i32) i32 {
    var ret: i64 = syscall1(SYS_WAIT, @intFromPtr(status))
    return @as(i32, @truncate(ret))
}

export fn sys_waitpid(pid: i32, status: *i32, options: u32) i32 {
    var ret: i64 = syscall3(SYS_WAITPID,
        @as(u64, @intCast(pid)),
        @intFromPtr(status),
        @as(u64, options))
    return @as(i32, @truncate(ret))
}

export fn sys_execve(path: *u8, argv: **u8, envp: **u8) i32 {
    var ret: i64 = syscall3(SYS_EXEC,
        @intFromPtr(path),
        @intFromPtr(argv),
        @intFromPtr(envp))
    return @as(i32, @truncate(ret))
}

export fn sys_kill(pid: i32, sig: u32) i32 {
    var ret: i64 = syscall2(SYS_KILL,
        @as(u64, @intCast(pid)),
        @as(u64, sig))
    return @as(i32, @truncate(ret))
}

// ============================================================================
// File I/O Syscalls
// ============================================================================

export fn sys_open(path: *u8, flags: u32, mode: u32) i32 {
    var ret: i64 = syscall3(SYS_OPEN,
        @intFromPtr(path),
        @as(u64, flags),
        @as(u64, mode))
    return @as(i32, @truncate(ret))
}

export fn sys_close(fd: i32) i32 {
    var ret: i64 = syscall1(SYS_CLOSE, @as(u64, @intCast(fd)))
    return @as(i32, @truncate(ret))
}

export fn sys_read(fd: i32, buf: *u8, count: u64) i64 {
    return syscall3(SYS_READ, @as(u64, @intCast(fd)), @intFromPtr(buf), count)
}

export fn sys_write(fd: i32, buf: *u8, count: u64) i64 {
    return syscall3(SYS_WRITE, @as(u64, @intCast(fd)), @intFromPtr(buf), count)
}

export fn sys_lseek(fd: i32, offset: i64, whence: u32) i64 {
    return syscall3(SYS_LSEEK,
        @as(u64, @intCast(fd)),
        @as(u64, @bitCast(offset)),
        @as(u64, whence))
}

export fn sys_dup(oldfd: i32) i32 {
    var ret: i64 = syscall1(SYS_DUP, @as(u64, @intCast(oldfd)))
    return @as(i32, @truncate(ret))
}

export fn sys_dup2(oldfd: i32, newfd: i32) i32 {
    var ret: i64 = syscall2(SYS_DUP2,
        @as(u64, @intCast(oldfd)),
        @as(u64, @intCast(newfd)))
    return @as(i32, @truncate(ret))
}

export fn sys_pipe(pipefd: *[2]i32) i32 {
    var ret: i64 = syscall1(SYS_PIPE, @intFromPtr(pipefd))
    return @as(i32, @truncate(ret))
}

// ============================================================================
// Filesystem Syscalls
// ============================================================================

export fn sys_mkdir(path: *u8, mode: u32) i32 {
    var ret: i64 = syscall2(SYS_MKDIR, @intFromPtr(path), @as(u64, mode))
    return @as(i32, @truncate(ret))
}

export fn sys_rmdir(path: *u8) i32 {
    var ret: i64 = syscall1(SYS_RMDIR, @intFromPtr(path))
    return @as(i32, @truncate(ret))
}

export fn sys_chroot(path: *u8) i32 {
    var ret: i64 = syscall1(SYS_CHROOT, @intFromPtr(path))
    return @as(i32, @truncate(ret))
}

export fn sys_mount(source: *u8, target: *u8, fstype: *u8, flags: u64, data: *u8) i32 {
    var ret: i64 = syscall5(SYS_MOUNT,
        @intFromPtr(source),
        @intFromPtr(target),
        @intFromPtr(fstype),
        flags,
        @intFromPtr(data))
    return @as(i32, @truncate(ret))
}

export fn sys_umount(target: *u8) i32 {
    var ret: i64 = syscall1(SYS_UMOUNT, @intFromPtr(target))
    return @as(i32, @truncate(ret))
}

// ============================================================================
// Time Syscalls
// ============================================================================

struct Timespec {
    tv_sec: i64,
    tv_nsec: i64,
}

export fn sys_nanosleep(req: *Timespec, rem: *Timespec) i32 {
    var ret: i64 = syscall2(SYS_NANOSLEEP, @intFromPtr(req), @intFromPtr(rem))
    return @as(i32, @truncate(ret))
}

export fn sys_sleep(seconds: u32) u32 {
    var req: Timespec = undefined
    var rem: Timespec = undefined

    req.tv_sec = @as(i64, seconds)
    req.tv_nsec = 0

    while (true) {
        var ret: i32 = sys_nanosleep(&req, &rem)
        if (ret == 0) return 0
        if (ret != EINTR) return @as(u32, @intCast(rem.tv_sec))
        req = rem
    }
}

export fn sys_usleep(usec: u64) i32 {
    var req: Timespec = undefined
    var rem: Timespec = undefined

    req.tv_sec = @as(i64, @intCast(usec / 1000000))
    req.tv_nsec = @as(i64, @intCast((usec % 1000000) * 1000))

    return sys_nanosleep(&req, &rem)
}

// ============================================================================
// System Control Syscalls
// ============================================================================

export fn sys_reboot(cmd: u32) i32 {
    var ret: i64 = syscall1(SYS_REBOOT, @as(u64, cmd))
    return @as(i32, @truncate(ret))
}

export fn sys_setuid(uid: u32) i32 {
    var ret: i64 = syscall1(SYS_SETUID, @as(u64, uid))
    return @as(i32, @truncate(ret))
}

export fn sys_setgid(gid: u32) i32 {
    var ret: i64 = syscall1(SYS_SETGID, @as(u64, gid))
    return @as(i32, @truncate(ret))
}

// ============================================================================
// Wait Status Macros
// ============================================================================

export fn WIFEXITED(status: i32) u32 {
    return if ((status & 0x7f) == 0) @as(u32, 1) else @as(u32, 0)
}

export fn WEXITSTATUS(status: i32) i32 {
    return (status >> 8) & 0xff
}

export fn WIFSIGNALED(status: i32) u32 {
    return if ((status & 0x7f) != 0 and (status & 0x7f) != 0x7f) @as(u32, 1) else @as(u32, 0)
}

export fn WTERMSIG(status: i32) i32 {
    return status & 0x7f
}

export fn WIFSTOPPED(status: i32) u32 {
    return if ((status & 0xff) == 0x7f) @as(u32, 1) else @as(u32, 0)
}

export fn WSTOPSIG(status: i32) i32 {
    return (status >> 8) & 0xff
}

// ============================================================================
// Convenience Functions
// ============================================================================

export fn fork_and_exec(path: *u8, argv: **u8, envp: **u8) i32 {
    var pid: i32 = sys_fork()

    if (pid < 0) {
        // Fork failed
        return pid
    }

    if (pid == 0) {
        // Child process
        var ret: i32 = sys_execve(path, argv, envp)
        // If exec returns, it failed
        sys_exit(127)
    }

    // Parent returns child PID
    return pid
}

export fn spawn_detached(path: *u8, argv: **u8) i32 {
    var pid: i32 = sys_fork()

    if (pid < 0) return pid

    if (pid == 0) {
        // Child: fork again to become orphan (reparented to init)
        var pid2: i32 = sys_fork()
        if (pid2 < 0) sys_exit(1)
        if (pid2 > 0) sys_exit(0)  // First child exits

        // Grandchild: close fds, exec
        _ = sys_close(0)
        _ = sys_close(1)
        _ = sys_close(2)

        _ = sys_execve(path, argv, null)
        sys_exit(127)
    }

    // Parent: wait for first child (which exits immediately)
    var status: i32 = 0
    _ = sys_waitpid(pid, &status, 0)

    return 0  // Success, child is now running detached
}

