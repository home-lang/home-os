// home-os File Manager - File Preview
// Preview text files, images, and other content

import "../kernel/src/core/foundation.home" as foundation
import "../kernel/src/core/filesystem.home" as filesystem

const PREVIEW_BUFFER_SIZE: u32 = 8192
const MAX_PREVIEW_LINES: u32 = 20

var preview_buffer: [u8; 8192]
var preview_lines: u32 = 0

// Preview text file
export fn fm_preview_text(path: u64) -> u32 {
  foundation.serial_write_string("[FileManager] Previewing: ")
  foundation.serial_write_string(path)
  foundation.serial_write_string("\n")
  
  // Open file
  var fd: u32 = filesystem.vfs_open(path, 0, 0)
  if fd == 0xFFFFFFFF {
    foundation.serial_write_string("[FileManager] Failed to open file\n")
    return 1
  }
  
  // Read file
  var bytes_read: u32 = filesystem.vfs_read(fd, @ptrFromInt(preview_buffer), PREVIEW_BUFFER_SIZE - 1)
  filesystem.vfs_close(fd)
  
  if bytes_read == 0 {
    foundation.vga_write_string("\n[Empty file]\n")
    return 0
  }
  
  preview_buffer[bytes_read] = 0
  
  // Display preview
  foundation.vga_write_string("\n=== Preview ===\n")
  
  var line_count: u32 = 0
  var i: u32 = 0
  var line_start: u32 = 0
  
  while i < bytes_read and line_count < MAX_PREVIEW_LINES {
    if preview_buffer[i] == '\n' or i == bytes_read - 1 {
      // Print line
      var j: u32 = line_start
      while j <= i {
        if preview_buffer[j] >= 32 and preview_buffer[j] < 127 {
          foundation.vga_write_char(preview_buffer[j])
        } else if preview_buffer[j] == '\n' {
          foundation.vga_write_char('\n')
        } else if preview_buffer[j] == '\t' {
          foundation.vga_write_string("    ")
        }
        j = j + 1
      }
      
      line_count = line_count + 1
      line_start = i + 1
    }
    i = i + 1
  }
  
  if bytes_read >= PREVIEW_BUFFER_SIZE - 1 {
    foundation.vga_write_string("\n... (file truncated)\n")
  }
  
  foundation.vga_write_string("\n=== End Preview ===\n")
  preview_lines = line_count
  
  return 0
}

// Check if file is text
export fn fm_is_text_file(path: u64) -> u32 {
  // Check extension
  var len: u32 = 0
  while @intToPtr(path + len, u8) != 0 { len = len + 1 }
  
  if len < 4 { return 0 }
  
  // Check for common text extensions
  var ext_start: u32 = len - 4
  
  // .txt
  if @intToPtr(path + ext_start, u8) == '.' and
     @intToPtr(path + ext_start + 1, u8) == 't' and
     @intToPtr(path + ext_start + 2, u8) == 'x' and
     @intToPtr(path + ext_start + 3, u8) == 't' {
    return 1
  }
  
  // .log
  if @intToPtr(path + ext_start, u8) == '.' and
     @intToPtr(path + ext_start + 1, u8) == 'l' and
     @intToPtr(path + ext_start + 2, u8) == 'o' and
     @intToPtr(path + ext_start + 3, u8) == 'g' {
    return 1
  }
  
  // .md (markdown)
  if len >= 3 {
    ext_start = len - 3
    if @intToPtr(path + ext_start, u8) == '.' and
       @intToPtr(path + ext_start + 1, u8) == 'm' and
       @intToPtr(path + ext_start + 2, u8) == 'd' {
      return 1
    }
  }
  
  // .home (Home language)
  if len >= 5 {
    ext_start = len - 5
    if @intToPtr(path + ext_start, u8) == '.' and
       @intToPtr(path + ext_start + 1, u8) == 'h' and
       @intToPtr(path + ext_start + 2, u8) == 'o' and
       @intToPtr(path + ext_start + 3, u8) == 'm' and
       @intToPtr(path + ext_start + 4, u8) == 'e' {
      return 1
    }
  }
  
  // .c, .h, .cpp, .rs, .py, .js, .json, .xml, .html, .css
  // (Add more as needed)
  
  return 0
}

// Get file type icon/symbol
export fn fm_get_file_icon(path: u64, is_directory: u32) -> u8 {
  if is_directory == 1 {
    return 'üìÅ'  // Folder
  }
  
  var len: u32 = 0
  while @intToPtr(path + len, u8) != 0 { len = len + 1 }
  
  if len < 4 { return 'üìÑ' }
  
  var ext_start: u32 = len - 4
  
  // Check extensions
  if @intToPtr(path + ext_start, u8) == '.' {
    var ext1: u8 = @intToPtr(path + ext_start + 1, u8)
    var ext2: u8 = @intToPtr(path + ext_start + 2, u8)
    var ext3: u8 = @intToPtr(path + ext_start + 3, u8)
    
    // .txt, .log
    if (ext1 == 't' and ext2 == 'x' and ext3 == 't') or
       (ext1 == 'l' and ext2 == 'o' and ext3 == 'g') {
      return 'üìù'  // Text
    }
    
    // .png, .jpg, .gif
    if (ext1 == 'p' and ext2 == 'n' and ext3 == 'g') or
       (ext1 == 'j' and ext2 == 'p' and ext3 == 'g') or
       (ext1 == 'g' and ext2 == 'i' and ext3 == 'f') {
      return 'üñº'  // Image
    }
    
    // .mp3, .wav, .ogg
    if (ext1 == 'm' and ext2 == 'p' and ext3 == '3') or
       (ext1 == 'w' and ext2 == 'a' and ext3 == 'v') or
       (ext1 == 'o' and ext2 == 'g' and ext3 == 'g') {
      return 'üéµ'  // Audio
    }
    
    // .mp4, .avi, .mkv
    if (ext1 == 'm' and ext2 == 'p' and ext3 == '4') or
       (ext1 == 'a' and ext2 == 'v' and ext3 == 'i') or
       (ext1 == 'm' and ext2 == 'k' and ext3 == 'v') {
      return 'üé¨'  // Video
    }
    
    // .zip, .tar, .gz
    if (ext1 == 'z' and ext2 == 'i' and ext3 == 'p') or
       (ext1 == 't' and ext2 == 'a' and ext3 == 'r') {
      return 'üì¶'  // Archive
    }
  }
  
  // Check for executables
  if len >= 3 {
    ext_start = len - 3
    if @intToPtr(path + ext_start, u8) == '.' and
       @intToPtr(path + ext_start + 1, u8) == 's' and
       @intToPtr(path + ext_start + 2, u8) == 'h' {
      return '‚öô'  // Script
    }
  }
  
  return 'üìÑ'  // Generic file
}

// Format file size for display
export fn fm_format_file_size(size: u64, buffer: u64) {
  if size < 1024 {
    // Bytes
    fm_uint_to_string(@truncate(size, u32), buffer)
    fm_string_append(buffer, " B")
  } else if size < 1048576 {
    // KB
    var kb: u32 = @truncate(size / 1024, u32)
    fm_uint_to_string(kb, buffer)
    fm_string_append(buffer, " KB")
  } else if size < 1073741824 {
    // MB
    var mb: u32 = @truncate(size / 1048576, u32)
    fm_uint_to_string(mb, buffer)
    fm_string_append(buffer, " MB")
  } else {
    // GB
    var gb: u32 = @truncate(size / 1073741824, u32)
    fm_uint_to_string(gb, buffer)
    fm_string_append(buffer, " GB")
  }
}

fn fm_uint_to_string(num: u32, buffer: u64) {
  if num == 0 {
    @intToPtr(buffer, u8) = '0'
    @intToPtr(buffer + 1, u8) = 0
    return
  }
  
  var digits: [u8; 10]
  var count: u32 = 0
  var n: u32 = num
  
  while n > 0 {
    digits[count] = '0' + (n % 10)
    n = n / 10
    count = count + 1
  }
  
  var i: u32 = 0
  while i < count {
    @intToPtr(buffer + i, u8) = digits[count - i - 1]
    i = i + 1
  }
  @intToPtr(buffer + count, u8) = 0
}

fn fm_string_append(dest: u64, src: u64) {
  var len: u32 = 0
  while @intToPtr(dest + len, u8) != 0 { len = len + 1 }
  
  var i: u32 = 0
  while @intToPtr(src + i, u8) != 0 {
    @intToPtr(dest + len + i, u8) = @intToPtr(src + i, u8)
    i = i + 1
  }
  @intToPtr(dest + len + i, u8) = 0
}
