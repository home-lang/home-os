// home-os File Manager
// Full-featured file browser with VFS integration

import "../kernel/src/core/foundation.home" as foundation
import "../kernel/src/core/filesystem.home" as filesystem
import "../kernel/src/lib/craft_lib.home" as craft

const MAX_FILES: u32 = 1000
const MAX_PATH: u32 = 4096
const MAX_NAME: u32 = 256

struct FileEntry {
  name: [u8; 256],
  size: u64,
  is_directory: u32,
  permissions: u32,
  modified_time: u64
}

var files: [FileEntry; 1000]
var file_count: u32 = 0
var selected: u32 = 0
var current_path: [u8; 4096]
var current_path_len: u32 = 0
var clipboard_path: [u8; 4096]
var clipboard_operation: u32 = 0  // 0=none, 1=copy, 2=cut
var view_mode: u32 = 0  // 0=list, 1=grid
var show_hidden: u32 = 0
var sort_mode: u32 = 0  // 0=name, 1=size, 2=date

export fn fm_init() {
  // Initialize with home directory
  current_path[0] = '/'
  current_path[1] = 'h'
  current_path[2] = 'o'
  current_path[3] = 'm'
  current_path[4] = 'e'
  current_path[5] = 0
  current_path_len = 5
  
  fm_list_files()
  foundation.serial_write_string("[FileManager] Initialized\n")
}

fn fm_list_files() {
  file_count = 0
  
  // Open directory using VFS
  var dir_fd: u32 = filesystem.vfs_open(@ptrFromInt(current_path), 0, 0)
  if dir_fd == 0xFFFFFFFF {
    foundation.serial_write_string("[FileManager] Failed to open directory\n")
    return
  }
  
  // Read directory entries
  var entry_buffer: [u8; 512]
  while file_count < MAX_FILES {
    var bytes_read: u32 = filesystem.vfs_read(dir_fd, @ptrFromInt(entry_buffer), 512)
    if bytes_read == 0 { break }
    
    // Parse directory entry
    var name_len: u32 = 0
    while name_len < MAX_NAME and entry_buffer[name_len] != 0 {
      files[file_count].name[name_len] = entry_buffer[name_len]
      name_len = name_len + 1
    }
    files[file_count].name[name_len] = 0
    
    // Skip hidden files if not showing them
    if show_hidden == 0 and files[file_count].name[0] == '.' {
      continue
    }
    
    // Get file stats
    var stat_buffer: [u8; 128]
    if filesystem.vfs_stat(@ptrFromInt(files[file_count].name), @ptrFromInt(stat_buffer)) == 0 {
      files[file_count].size = @intToPtr(stat_buffer, u64)
      files[file_count].is_directory = @intToPtr(stat_buffer + 8, u32)
      files[file_count].permissions = @intToPtr(stat_buffer + 12, u32)
      files[file_count].modified_time = @intToPtr(stat_buffer + 16, u64)
    }
    
    file_count = file_count + 1
  }
  
  filesystem.vfs_close(dir_fd)
  
  // Sort files
  fm_sort_files()
  
  foundation.serial_write_string("[FileManager] Listed ")
  foundation.serial_write_hex(file_count)
  foundation.serial_write_string(" files\n")
}

fn fm_sort_files() {
  // Bubble sort (simple for now)
  if file_count <= 1 { return }
  
  var i: u32 = 0
  while i < file_count - 1 {
    var j: u32 = 0
    while j < file_count - i - 1 {
      var swap: u32 = 0
      
      if sort_mode == 0 {
        // Sort by name
        swap = fm_compare_names(j, j + 1)
      } else if sort_mode == 1 {
        // Sort by size
        if files[j].size > files[j + 1].size { swap = 1 }
      } else if sort_mode == 2 {
        // Sort by date
        if files[j].modified_time > files[j + 1].modified_time { swap = 1 }
      }
      
      if swap == 1 {
        fm_swap_entries(j, j + 1)
      }
      
      j = j + 1
    }
    i = i + 1
  }
}

fn fm_compare_names(idx1: u32, idx2: u32) -> u32 {
  var i: u32 = 0
  while i < MAX_NAME {
    if files[idx1].name[i] == 0 and files[idx2].name[i] == 0 { return 0 }
    if files[idx1].name[i] == 0 { return 0 }
    if files[idx2].name[i] == 0 { return 1 }
    if files[idx1].name[i] > files[idx2].name[i] { return 1 }
    if files[idx1].name[i] < files[idx2].name[i] { return 0 }
    i = i + 1
  }
  return 0
}

fn fm_swap_entries(idx1: u32, idx2: u32) {
  var temp: FileEntry
  
  // Copy idx1 to temp
  var i: u32 = 0
  while i < MAX_NAME {
    temp.name[i] = files[idx1].name[i]
    i = i + 1
  }
  temp.size = files[idx1].size
  temp.is_directory = files[idx1].is_directory
  temp.permissions = files[idx1].permissions
  temp.modified_time = files[idx1].modified_time
  
  // Copy idx2 to idx1
  i = 0
  while i < MAX_NAME {
    files[idx1].name[i] = files[idx2].name[i]
    i = i + 1
  }
  files[idx1].size = files[idx2].size
  files[idx1].is_directory = files[idx2].is_directory
  files[idx1].permissions = files[idx2].permissions
  files[idx1].modified_time = files[idx2].modified_time
  
  // Copy temp to idx2
  i = 0
  while i < MAX_NAME {
    files[idx2].name[i] = temp.name[i]
    i = i + 1
  }
  files[idx2].size = temp.size
  files[idx2].is_directory = temp.is_directory
  files[idx2].permissions = temp.permissions
  files[idx2].modified_time = temp.modified_time
}

fn fm_draw() {
  foundation.vga_clear()
  
  // Header
  foundation.vga_write_string("=== File Manager ===")
  foundation.vga_write_string("  Path: ")
  foundation.vga_write_string(@ptrFromInt(current_path))
  foundation.vga_write_string("\n\n")
  
  // Column headers
  foundation.vga_write_string("  Name")
  var i: u32 = 0
  while i < 40 { foundation.vga_write_string(" ") i = i + 1 }
  foundation.vga_write_string("Size      Type      Modified\n")
  foundation.vga_write_string("  ")
  i = 0
  while i < 70 { foundation.vga_write_string("-") i = i + 1 }
  foundation.vga_write_string("\n")
  
  // File list
  i = 0
  while i < file_count {
    if i == selected {
      foundation.vga_write_string("> ")
    } else {
      foundation.vga_write_string("  ")
    }
    
    // Name
    if files[i].is_directory == 1 {
      foundation.vga_write_string("[")
    }
    foundation.vga_write_string(@ptrFromInt(files[i].name))
    if files[i].is_directory == 1 {
      foundation.vga_write_string("]")
    }
    
    // Padding
    var name_len: u32 = fm_strlen(@ptrFromInt(files[i].name))
    var pad: u32 = 40
    if name_len < pad {
      var j: u32 = 0
      while j < pad - name_len { foundation.vga_write_string(" ") j = j + 1 }
    }
    
    // Size
    if files[i].is_directory == 0 {
      fm_format_size(files[i].size)
    } else {
      foundation.vga_write_string("<DIR>    ")
    }
    
    // Type
    if files[i].is_directory == 1 {
      foundation.vga_write_string(" Folder   ")
    } else {
      foundation.vga_write_string(" File     ")
    }
    
    foundation.vga_write_string("\n")
    i = i + 1
  }
  
  // Footer
  foundation.vga_write_string("\n")
  foundation.vga_write_string("Arrows=Navigate Enter=Open Del=Delete F2=Rename F5=Copy F6=Move\n")
  foundation.vga_write_string("F7=NewDir Ctrl+H=Hidden Ctrl+S=Sort Q=Quit\n")
  foundation.vga_write_string("Files: ")
  foundation.vga_write_hex(file_count)
  if clipboard_operation == 1 {
    foundation.vga_write_string("  [Copied: ")
    foundation.vga_write_string(@ptrFromInt(clipboard_path))
    foundation.vga_write_string("]")
  } else if clipboard_operation == 2 {
    foundation.vga_write_string("  [Cut: ")
    foundation.vga_write_string(@ptrFromInt(clipboard_path))
    foundation.vga_write_string("]")
  }
}

fn fm_strlen(str: u64) -> u32 {
  var len: u32 = 0
  while @intToPtr(str + len, u8) != 0 {
    len = len + 1
  }
  return len
}

fn fm_format_size(size: u64) {
  if size < 1024 {
    foundation.serial_write_hex(@truncate(size, u32))
    foundation.vga_write_string(" B      ")
  } else if size < 1048576 {
    var kb: u32 = @truncate(size / 1024, u32)
    foundation.serial_write_hex(kb)
    foundation.vga_write_string(" KB     ")
  } else if size < 1073741824 {
    var mb: u32 = @truncate(size / 1048576, u32)
    foundation.serial_write_hex(mb)
    foundation.vga_write_string(" MB     ")
  } else {
    var gb: u32 = @truncate(size / 1073741824, u32)
    foundation.serial_write_hex(gb)
    foundation.vga_write_string(" GB     ")
  }
}

export fn filemanager_main() {
  fm_list_files()
  fm_draw()
  
  // Main loop would handle keyboard input
  foundation.vga_write_string("\n\nFile manager loaded!\n")
}
