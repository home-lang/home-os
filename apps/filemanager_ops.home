// home-os File Manager - File Operations
// Copy, move, delete, rename operations

import "../kernel/src/core/foundation.home" as foundation
import "../kernel/src/core/filesystem.home" as filesystem

const BUFFER_SIZE: u32 = 4096

// Copy file from src to dest
export fn fm_copy_file(src: u64, dest: u64): u32 {
  foundation.serial_write_string("[FileManager] Copying: ")
  foundation.serial_write_string(src)
  foundation.serial_write_string(" -> ")
  foundation.serial_write_string(dest)
  foundation.serial_write_string("\n")
  
  // Open source file
  var src_fd: u32 = filesystem.vfs_open(src, 0, 0)
  if src_fd == 0xFFFFFFFF {
    foundation.serial_write_string("[FileManager] Failed to open source\n")
    return 1
  }
  
  // Create destination file
  var dest_fd: u32 = filesystem.vfs_open(dest, 0x0200, 0x1B6)  // O_CREAT | O_WRONLY, 0666
  if dest_fd == 0xFFFFFFFF {
    filesystem.vfs_close(src_fd)
    foundation.serial_write_string("[FileManager] Failed to create destination\n")
    return 1
  }
  
  // Copy data
  var buffer: [u8; 4096]
  var total_bytes: u64 = 0
  
  loop {
    var bytes_read: u32 = filesystem.vfs_read(src_fd, @ptrFromInt(buffer), BUFFER_SIZE)
    if bytes_read == 0 { break }
    
    var bytes_written: u32 = filesystem.vfs_write(dest_fd, @ptrFromInt(buffer), bytes_read)
    if bytes_written != bytes_read {
      filesystem.vfs_close(src_fd)
      filesystem.vfs_close(dest_fd)
      foundation.serial_write_string("[FileManager] Write error\n")
      return 1
    }
    
    total_bytes = total_bytes + bytes_read
  }
  
  filesystem.vfs_close(src_fd)
  filesystem.vfs_close(dest_fd)
  
  foundation.serial_write_string("[FileManager] Copied ")
  foundation.serial_write_hex(@truncate(total_bytes, u32))
  foundation.serial_write_string(" bytes\n")
  
  return 0
}

// Move file (rename)
export fn fm_move_file(src: u64, dest: u64): u32 {
  foundation.serial_write_string("[FileManager] Moving: ")
  foundation.serial_write_string(src)
  foundation.serial_write_string(" -> ")
  foundation.serial_write_string(dest)
  foundation.serial_write_string("\n")
  
  // Try rename first (fast if same filesystem)
  if filesystem.vfs_rename(src, dest) == 0 {
    return 0
  }
  
  // Fall back to copy + delete
  if fm_copy_file(src, dest) == 0 {
    return fm_delete_file(src)
  }
  
  return 1
}

// Delete file
export fn fm_delete_file(path: u64): u32 {
  foundation.serial_write_string("[FileManager] Deleting: ")
  foundation.serial_write_string(path)
  foundation.serial_write_string("\n")
  
  if filesystem.vfs_unlink(path) == 0 {
    foundation.serial_write_string("[FileManager] Deleted successfully\n")
    return 0
  }
  
  foundation.serial_write_string("[FileManager] Delete failed\n")
  return 1
}

// Rename file
export fn fm_rename_file(old_name: u64, new_name: u64): u32 {
  foundation.serial_write_string("[FileManager] Renaming: ")
  foundation.serial_write_string(old_name)
  foundation.serial_write_string(" -> ")
  foundation.serial_write_string(new_name)
  foundation.serial_write_string("\n")
  
  if filesystem.vfs_rename(old_name, new_name) == 0 {
    foundation.serial_write_string("[FileManager] Renamed successfully\n")
    return 0
  }
  
  foundation.serial_write_string("[FileManager] Rename failed\n")
  return 1
}

// Create directory
export fn fm_create_directory(path: u64): u32 {
  foundation.serial_write_string("[FileManager] Creating directory: ")
  foundation.serial_write_string(path)
  foundation.serial_write_string("\n")
  
  if filesystem.vfs_mkdir(path, 0x1ED) == 0 {  // 0755
    foundation.serial_write_string("[FileManager] Directory created\n")
    return 0
  }
  
  foundation.serial_write_string("[FileManager] Failed to create directory\n")
  return 1
}

// Delete directory
export fn fm_delete_directory(path: u64): u32 {
  foundation.serial_write_string("[FileManager] Deleting directory: ")
  foundation.serial_write_string(path)
  foundation.serial_write_string("\n")
  
  if filesystem.vfs_rmdir(path) == 0 {
    foundation.serial_write_string("[FileManager] Directory deleted\n")
    return 0
  }
  
  foundation.serial_write_string("[FileManager] Failed to delete directory\n")
  return 1
}

// Copy directory recursively
export fn fm_copy_directory(src: u64, dest: u64): u32 {
  foundation.serial_write_string("[FileManager] Copying directory: ")
  foundation.serial_write_string(src)
  foundation.serial_write_string(" -> ")
  foundation.serial_write_string(dest)
  foundation.serial_write_string("\n")
  
  // Create destination directory
  if fm_create_directory(dest) != 0 {
    return 1
  }
  
  // Open source directory
  var dir_fd: u32 = filesystem.vfs_open(src, 0, 0)
  if dir_fd == 0xFFFFFFFF {
    return 1
  }
  
  // Read and copy each entry
  var entry_buffer: [u8; 512]
  loop {
    var bytes_read: u32 = filesystem.vfs_read(dir_fd, @ptrFromInt(entry_buffer), 512)
    if bytes_read == 0 { break }
    
    // Skip . and ..
    if entry_buffer[0] == '.' {
      if entry_buffer[1] == 0 { continue }
      if entry_buffer[1] == '.' and entry_buffer[2] == 0 { continue }
    }
    
    // Build full paths
    var src_path: [u8; 4096]
    var dest_path: [u8; 4096]
    
    // Copy src + "/" + entry
    var i: u32 = 0
    while @intToPtr(src + i, u8) != 0 {
      src_path[i] = @intToPtr(src + i, u8)
      i = i + 1
    }
    src_path[i] = '/'
    i = i + 1
    var j: u32 = 0
    while entry_buffer[j] != 0 {
      src_path[i] = entry_buffer[j]
      i = i + 1
      j = j + 1
    }
    src_path[i] = 0
    
    // Copy dest + "/" + entry
    i = 0
    while @intToPtr(dest + i, u8) != 0 {
      dest_path[i] = @intToPtr(dest + i, u8)
      i = i + 1
    }
    dest_path[i] = '/'
    i = i + 1
    j = 0
    while entry_buffer[j] != 0 {
      dest_path[i] = entry_buffer[j]
      i = i + 1
      j = j + 1
    }
    dest_path[i] = 0
    
    // Check if directory
    var stat_buffer: [u8; 128]
    if filesystem.vfs_stat(@ptrFromInt(src_path), @ptrFromInt(stat_buffer)) == 0 {
      var is_dir: u32 = @intToPtr(stat_buffer + 8, u32)
      
      if is_dir == 1 {
        // Recursively copy directory
        if fm_copy_directory(@ptrFromInt(src_path), @ptrFromInt(dest_path)) != 0 {
          filesystem.vfs_close(dir_fd)
          return 1
        }
      } else {
        // Copy file
        if fm_copy_file(@ptrFromInt(src_path), @ptrFromInt(dest_path)) != 0 {
          filesystem.vfs_close(dir_fd)
          return 1
        }
      }
    }
  }
  
  filesystem.vfs_close(dir_fd)
  foundation.serial_write_string("[FileManager] Directory copied successfully\n")
  return 0
}

// Get file info
export fn fm_get_file_info(path: u64, size_out: u64, is_dir_out: u64, mtime_out: u64): u32 {
  var stat_buffer: [u8; 128]
  
  if filesystem.vfs_stat(path, @ptrFromInt(stat_buffer)) == 0 {
    @intToPtr(size_out, u64) = @intToPtr(stat_buffer, u64)
    @intToPtr(is_dir_out, u32) = @intToPtr(stat_buffer + 8, u32)
    @intToPtr(mtime_out, u64) = @intToPtr(stat_buffer + 16, u64)
    return 0
  }
  
  return 1
}

// Search files
export fn fm_search_files(dir: u64, pattern: u64, results: u64, max_results: u32): u32 {
  var count: u32 = 0
  
  // Open directory
  var dir_fd: u32 = filesystem.vfs_open(dir, 0, 0)
  if dir_fd == 0xFFFFFFFF {
    return 0
  }
  
  // Read entries
  var entry_buffer: [u8; 512]
  loop {
    if count >= max_results { break }
    
    var bytes_read: u32 = filesystem.vfs_read(dir_fd, @ptrFromInt(entry_buffer), 512)
    if bytes_read == 0 { break }
    
    // Simple pattern matching (contains)
    if fm_string_contains(@ptrFromInt(entry_buffer), pattern) == 1 {
      // Copy to results
      var i: u32 = 0
      while entry_buffer[i] != 0 and i < 256 {
        @intToPtr(results + (count * 256) + i, u8) = entry_buffer[i]
        i = i + 1
      }
      @intToPtr(results + (count * 256) + i, u8) = 0
      count = count + 1
    }
  }
  
  filesystem.vfs_close(dir_fd)
  return count
}

fn fm_string_contains(haystack: u64, needle: u64): u32 {
  var h_len: u32 = 0
  while @intToPtr(haystack + h_len, u8) != 0 { h_len = h_len + 1 }
  
  var n_len: u32 = 0
  while @intToPtr(needle + n_len, u8) != 0 { n_len = n_len + 1 }
  
  if n_len == 0 { return 1 }
  if n_len > h_len { return 0 }
  
  var i: u32 = 0
  while i <= h_len - n_len {
    var match: u32 = 1
    var j: u32 = 0
    while j < n_len {
      if @intToPtr(haystack + i + j, u8) != @intToPtr(needle + j, u8) {
        match = 0
        break
      }
      j = j + 1
    }
    if match == 1 { return 1 }
    i = i + 1
  }
  
  return 0
}
