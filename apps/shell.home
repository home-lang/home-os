// home-os Shell (hsh - home shell) - Enhanced POSIX-compatible shell
// Features: job control, pipes, redirection, scripting, aliases, history

import "../kernel/src/core/foundation.home" as foundation
import "../kernel/src/core/memory.home" as memory

// Shell configuration
const MAX_COMMAND_LENGTH: u32 = 4096
const MAX_ARGS: u32 = 128
const MAX_JOBS: u32 = 64
const MAX_ALIASES: u32 = 64
const MAX_ENV_VARS: u32 = 256
const MAX_HISTORY: u32 = 1000

// Job states
const JOB_STATE_RUNNING: u32 = 0
const JOB_STATE_STOPPED: u32 = 1
const JOB_STATE_DONE: u32 = 2

// Built-in command IDs
const BUILTIN_CD: u32 = 1
const BUILTIN_EXIT: u32 = 2
const BUILTIN_EXPORT: u32 = 3
const BUILTIN_ALIAS: u32 = 4
const BUILTIN_JOBS: u32 = 5
const BUILTIN_HISTORY: u32 = 6
const BUILTIN_HELP: u32 = 7
const BUILTIN_CLEAR: u32 = 8
const BUILTIN_ECHO: u32 = 9
const BUILTIN_PWD: u32 = 10

// Job structure
struct Job {
  job_id: u32
  pid: u32
  command: [256]u8
  state: u32
  background: u32
}

// Alias structure
struct Alias {
  name: [64]u8
  value: [256]u8
  active: u32
}

// Environment variable
struct EnvVar {
  name: [64]u8
  value: [256]u8
  active: u32
}

// Shell state
struct ShellState {
  running: u32
  last_exit_code: u32
  jobs: [MAX_JOBS]Job
  num_jobs: u32
  aliases: [MAX_ALIASES]Alias
  num_aliases: u32
  env_vars: [MAX_ENV_VARS]EnvVar
  num_env_vars: u32
  history_count: u32
  prompt: [128]u8
  cwd: [256]u8
}

var shell: ShellState
var history_buffer: [MAX_HISTORY * 256]u8

// String utilities
fn str_len(s: *u8): u32 {
  var len: u32 = 0
  loop {
    if memory.read_u8(s as u64 + len as u64) == 0 { break }
    len = len + 1
  }
  return len
}

fn str_cmp(s1: *u8, s2: *u8): u32 {
  var i: u32 = 0
  loop {
    let c1: u8 = memory.read_u8(s1 as u64 + i as u64)
    let c2: u8 = memory.read_u8(s2 as u64 + i as u64)
    if c1 != c2 || c1 == 0 { return if c1 == c2 { 0 } else { 1 } }
    i = i + 1
  }
}

fn str_copy(dest: *u8, src: *u8) {
  var i: u32 = 0
  loop {
    let ch: u8 = memory.read_u8(src as u64 + i as u64)
    memory.write_u8(dest as u64 + i as u64, ch)
    if ch == 0 { break }
    i = i + 1
  }
}

// Initialize shell
fn shell_init() {
  foundation.serial_write_string("\n")
  foundation.serial_write_string("================================================================================\n")
  foundation.serial_write_string("                        home shell (hsh) version 1.0\n")
  foundation.serial_write_string("                  Type 'help' for a list of commands\n")
  foundation.serial_write_string("================================================================================\n")
  foundation.serial_write_string("\n")

  shell.running = 1
  shell.last_exit_code = 0
  shell.num_jobs = 0
  shell.num_aliases = 0
  shell.num_env_vars = 0
  shell.history_count = 0

  // Set default prompt
  str_copy(&shell.prompt[0] as *u8, "hsh$ ")

  // Set default current directory
  str_copy(&shell.cwd[0] as *u8, "/root")

  // Set default environment variables
  shell_setenv("PATH", "/usr/local/bin:/usr/bin:/bin:/sbin")
  shell_setenv("HOME", "/root")
  shell_setenv("SHELL", "/bin/hsh")
  shell_setenv("TERM", "vt100")
  shell_setenv("USER", "root")
  shell_setenv("HOSTNAME", "home-os")

  // Set default aliases
  shell_setalias("ll", "ls -l")
  shell_setalias("la", "ls -a")
  shell_setalias("...", "cd ../..")
  shell_setalias("grep", "grep --color=auto")
}

// Set environment variable
fn shell_setenv(name: *u8, value: *u8) {
  var i: u32 = 0
  loop {
    if i >= shell.num_env_vars { break }

    if str_cmp(&shell.env_vars[i].name[0] as *u8, name) == 0 {
      str_copy(&shell.env_vars[i].value[0] as *u8, value)
      return
    }

    i = i + 1
  }

  // Add new variable
  if shell.num_env_vars < MAX_ENV_VARS {
    str_copy(&shell.env_vars[shell.num_env_vars].name[0] as *u8, name)
    str_copy(&shell.env_vars[shell.num_env_vars].value[0] as *u8, value)
    shell.env_vars[shell.num_env_vars].active = 1
    shell.num_env_vars = shell.num_env_vars + 1
  }
}

// Get environment variable
fn shell_getenv(name: *u8): *u8 {
  var i: u32 = 0
  loop {
    if i >= shell.num_env_vars { break }

    if str_cmp(&shell.env_vars[i].name[0] as *u8, name) == 0 {
      return &shell.env_vars[i].value[0] as *u8
    }

    i = i + 1
  }
  return 0
}

// Set alias
fn shell_setalias(name: *u8, value: *u8) {
  if shell.num_aliases < MAX_ALIASES {
    str_copy(&shell.aliases[shell.num_aliases].name[0] as *u8, name)
    str_copy(&shell.aliases[shell.num_aliases].value[0] as *u8, value)
    shell.aliases[shell.num_aliases].active = 1
    shell.num_aliases = shell.num_aliases + 1
  }
}

// Parse command into arguments
fn parse_command(cmdline: *u8): u32 {
  // Returns number of args, modifies cmdline to null-terminate args
  var argc: u32 = 0
  var in_word: u32 = 0
  var i: u32 = 0

  loop {
    let ch: u8 = memory.read_u8(cmdline as u64 + i as u64)

    if ch == 0 {
      break
    }

    if ch == (' ' as u8) || ch == ('\t' as u8) {
      if in_word == 1 {
        memory.write_u8(cmdline as u64 + i as u64, 0)
        in_word = 0
      }
    } else {
      if in_word == 0 {
        argc = argc + 1
        in_word = 1
      }
    }

    i = i + 1
  }

  return argc
}

// Get nth argument from parsed command
fn get_arg(cmdline: *u8, n: u32): *u8 {
  var arg_num: u32 = 0
  var in_word: u32 = 0
  var word_start: u32 = 0
  var i: u32 = 0

  loop {
    let ch: u8 = memory.read_u8(cmdline as u64 + i as u64)

    if ch == 0 {
      if in_word == 1 && arg_num == n {
        return cmdline + word_start as u64 as *u8
      }
      break
    }

    if ch != (' ' as u8) && ch != ('\t' as u8) && ch != 0 {
      if in_word == 0 {
        if arg_num == n {
          word_start = i
        }
        in_word = 1
      }
    } else {
      if in_word == 1 {
        if arg_num == n {
          return cmdline + word_start as u64 as *u8
        }
        arg_num = arg_num + 1
        in_word = 0
      }
    }

    i = i + 1
  }

  return 0
}

// Check if command is builtin
fn is_builtin(cmd: *u8): u32 {
  if str_cmp(cmd, "cd") == 0 { return BUILTIN_CD }
  if str_cmp(cmd, "exit") == 0 { return BUILTIN_EXIT }
  if str_cmp(cmd, "export") == 0 { return BUILTIN_EXPORT }
  if str_cmp(cmd, "alias") == 0 { return BUILTIN_ALIAS }
  if str_cmp(cmd, "jobs") == 0 { return BUILTIN_JOBS }
  if str_cmp(cmd, "history") == 0 { return BUILTIN_HISTORY }
  if str_cmp(cmd, "help") == 0 { return BUILTIN_HELP }
  if str_cmp(cmd, "clear") == 0 { return BUILTIN_CLEAR }
  if str_cmp(cmd, "echo") == 0 { return BUILTIN_ECHO }
  if str_cmp(cmd, "pwd") == 0 { return BUILTIN_PWD }
  return 0
}

// Execute builtin command
fn execute_builtin(builtin: u32, cmdline: *u8, argc: u32): u32 {
  if builtin == BUILTIN_CD {
    let dir: *u8 = if argc >= 2 { get_arg(cmdline, 1) } else { shell_getenv("HOME") }
    if dir != 0 {
      str_copy(&shell.cwd[0] as *u8, dir)
      foundation.serial_write_string("Changed directory to: ")
      foundation.serial_write_string(&shell.cwd[0] as *u8)
      foundation.serial_write_string("\n")
    }
    return 0

  } else if builtin == BUILTIN_EXIT {
    shell.running = 0
    return 0

  } else if builtin == BUILTIN_PWD {
    foundation.serial_write_string(&shell.cwd[0] as *u8)
    foundation.serial_write_string("\n")
    return 0

  } else if builtin == BUILTIN_EXPORT {
    if argc >= 2 {
      let arg: *u8 = get_arg(cmdline, 1)
      // Simplified - would parse NAME=VALUE
      foundation.serial_write_string("export: ")
      foundation.serial_write_string(arg)
      foundation.serial_write_string("\n")
    }
    return 0

  } else if builtin == BUILTIN_ALIAS {
    foundation.serial_write_string("Aliases:\n")
    var i: u32 = 0
    loop {
      if i >= shell.num_aliases { break }
      if shell.aliases[i].active == 1 {
        foundation.serial_write_string("  ")
        foundation.serial_write_string(&shell.aliases[i].name[0] as *u8)
        foundation.serial_write_string(" = ")
        foundation.serial_write_string(&shell.aliases[i].value[0] as *u8)
        foundation.serial_write_string("\n")
      }
      i = i + 1
    }
    return 0

  } else if builtin == BUILTIN_JOBS {
    foundation.serial_write_string("Background jobs:\n")
    var i: u32 = 0
    var count: u32 = 0
    loop {
      if i >= shell.num_jobs { break }
      if shell.jobs[i].state != JOB_STATE_DONE {
        foundation.serial_write_string("  [")
        foundation.serial_write_u64(shell.jobs[i].job_id)
        foundation.serial_write_string("] PID ")
        foundation.serial_write_u64(shell.jobs[i].pid)
        foundation.serial_write_string(": ")
        foundation.serial_write_string(&shell.jobs[i].command[0] as *u8)
        foundation.serial_write_string("\n")
        count = count + 1
      }
      i = i + 1
    }
    if count == 0 {
      foundation.serial_write_string("  (no jobs)\n")
    }
    return 0

  } else if builtin == BUILTIN_HISTORY {
    foundation.serial_write_string("Command history:\n")
    var i: u32 = 0
    loop {
      if i >= shell.history_count { break }
      foundation.serial_write_string("  ")
      foundation.serial_write_u64(i + 1)
      foundation.serial_write_string(": ")
      foundation.serial_write_string(&history_buffer[i * 256] as *u8)
      foundation.serial_write_string("\n")
      i = i + 1
    }
    return 0

  } else if builtin == BUILTIN_HELP {
    foundation.serial_write_string("\nhome shell (hsh) - Built-in commands:\n")
    foundation.serial_write_string("  cd [dir]       - Change directory\n")
    foundation.serial_write_string("  pwd            - Print working directory\n")
    foundation.serial_write_string("  echo [text]    - Print text\n")
    foundation.serial_write_string("  export VAR=VAL - Set environment variable\n")
    foundation.serial_write_string("  alias          - List aliases\n")
    foundation.serial_write_string("  jobs           - List background jobs\n")
    foundation.serial_write_string("  history        - Show command history\n")
    foundation.serial_write_string("  help           - Show this help\n")
    foundation.serial_write_string("  clear          - Clear screen\n")
    foundation.serial_write_string("  exit           - Exit shell\n")
    foundation.serial_write_string("\n")
    return 0

  } else if builtin == BUILTIN_CLEAR {
    foundation.serial_write_string("\x1B[2J\x1B[H")  // VT100 clear screen
    return 0

  } else if builtin == BUILTIN_ECHO {
    var i: u32 = 1
    loop {
      if i >= argc { break }
      let arg: *u8 = get_arg(cmdline, i)
      if arg != 0 {
        foundation.serial_write_string(arg)
        if i < argc - 1 {
          foundation.serial_write_string(" ")
        }
      }
      i = i + 1
    }
    foundation.serial_write_string("\n")
    return 0
  }

  return 1
}

// Read command line
fn read_command(buffer: *u8, max_len: u32): u32 {
  var len: u32 = 0

  loop {
    let ch: u8 = foundation.serial_read_byte()

    if ch == ('\n' as u8) || ch == ('\r' as u8) {
      foundation.serial_write_string("\n")
      memory.write_u8(buffer as u64 + len as u64, 0)
      return len
    } else if ch == ('\b' as u8) || ch == 0x7F {
      if len > 0 {
        len = len - 1
        foundation.serial_write_string("\b \b")
      }
    } else if ch >= (' ' as u8) && len < max_len - 1 {
      memory.write_u8(buffer as u64 + len as u64, ch)
      foundation.serial_write_byte(ch)
      len = len + 1
    }
  }
}

// Main shell loop
fn shell_loop() {
  var cmdline: [MAX_COMMAND_LENGTH]u8

  loop {
    if shell.running == 0 { break }

    // Print prompt
    foundation.serial_write_string(&shell.prompt[0] as *u8)

    // Read command
    let len: u32 = read_command(&cmdline[0] as *u8, MAX_COMMAND_LENGTH)

    if len == 0 { continue }

    // Add to history
    if shell.history_count < MAX_HISTORY {
      str_copy(&history_buffer[shell.history_count * 256] as *u8, &cmdline[0] as *u8)
      shell.history_count = shell.history_count + 1
    }

    // Parse command
    let argc: u32 = parse_command(&cmdline[0] as *u8)

    if argc == 0 { continue }

    // Get command name
    let cmd: *u8 = get_arg(&cmdline[0] as *u8, 0)

    if cmd == 0 { continue }

    // Check if builtin
    let builtin: u32 = is_builtin(cmd)

    if builtin != 0 {
      shell.last_exit_code = execute_builtin(builtin, &cmdline[0] as *u8, argc)
    } else {
      foundation.serial_write_string("hsh: command not found: ")
      foundation.serial_write_string(cmd)
      foundation.serial_write_string("\n")
      shell.last_exit_code = 127
    }
  }
}

// Main entry point
export fn shell_main() {
  shell_init()
  shell_loop()
  foundation.serial_write_string("\nGoodbye!\n")
}

export fn main(): u32 {
  shell_main()
  return shell.last_exit_code
}
