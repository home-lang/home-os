// home-os Shell - Den Shell Integration
// Uses ~/Code/den (Zig shell) library for full shell functionality
// Features: job control, pipes, redirection, scripting, aliases, history

import "../kernel/src/core/foundation.home" as foundation
import "../kernel/src/core/memory.home" as memory
import "../kernel/src/ipc/pipe.home" as pipe
import "../kernel/src/lib/den_lib.home" as den

// Shell configuration
const MAX_COMMAND_LENGTH: u32 = 4096
const MAX_ARGS: u32 = 128
const MAX_JOBS: u32 = 64
const MAX_ALIASES: u32 = 64
const MAX_ENV_VARS: u32 = 256
const MAX_HISTORY: u32 = 1000
const MAX_PIPELINE_STAGES: u32 = 16

// Redirection types
const REDIR_NONE: u32 = 0
const REDIR_INPUT: u32 = 1      // <
const REDIR_OUTPUT: u32 = 2     // >
const REDIR_APPEND: u32 = 3     // >>
const REDIR_HEREDOC: u32 = 4    // <<

// Pipeline stage structure
struct PipelineStage {
  command: [256]u8
  argc: u32
  redir_in: u32
  redir_out: u32
  redir_in_file: [128]u8
  redir_out_file: [128]u8
}

// Job states
const JOB_STATE_RUNNING: u32 = 0
const JOB_STATE_STOPPED: u32 = 1
const JOB_STATE_DONE: u32 = 2

// Built-in command IDs
const BUILTIN_CD: u32 = 1
const BUILTIN_EXIT: u32 = 2
const BUILTIN_EXPORT: u32 = 3
const BUILTIN_ALIAS: u32 = 4
const BUILTIN_JOBS: u32 = 5
const BUILTIN_HISTORY: u32 = 6
const BUILTIN_HELP: u32 = 7
const BUILTIN_CLEAR: u32 = 8
const BUILTIN_ECHO: u32 = 9
const BUILTIN_PWD: u32 = 10

// Job structure
struct Job {
  job_id: u32
  pid: u32
  command: [256]u8
  state: u32
  background: u32
}

// Alias structure
struct Alias {
  name: [64]u8
  value: [256]u8
  active: u32
}

// Environment variable
struct EnvVar {
  name: [64]u8
  value: [256]u8
  active: u32
}

// Shell state
struct ShellState {
  running: u32
  last_exit_code: u32
  jobs: [MAX_JOBS]Job
  num_jobs: u32
  aliases: [MAX_ALIASES]Alias
  num_aliases: u32
  env_vars: [MAX_ENV_VARS]EnvVar
  num_env_vars: u32
  history_count: u32
  prompt: [128]u8
  cwd: [256]u8
}

var shell: ShellState
var history_buffer: [MAX_HISTORY * 256]u8

// String utilities
fn str_len(s: *u8): u32 {
  var len: u32 = 0
  loop {
    if memory.read_u8(s as u64 + len as u64) == 0 { break }
    len = len + 1
  }
  return len
}

fn str_cmp(s1: *u8, s2: *u8): u32 {
  var i: u32 = 0
  loop {
    let c1: u8 = memory.read_u8(s1 as u64 + i as u64)
    let c2: u8 = memory.read_u8(s2 as u64 + i as u64)
    if c1 != c2 || c1 == 0 { return if c1 == c2 { 0 } else { 1 } }
    i = i + 1
  }
}

fn str_copy(dest: *u8, src: *u8) {
  var i: u32 = 0
  loop {
    let ch: u8 = memory.read_u8(src as u64 + i as u64)
    memory.write_u8(dest as u64 + i as u64, ch)
    if ch == 0 { break }
    i = i + 1
  }
}

// Initialize shell using Den library
fn shell_init() {
  foundation.serial_write_string("\n")
  foundation.serial_write_string("================================================================================\n")
  foundation.serial_write_string("              home-os shell (den) - Powered by ~/Code/den\n")
  foundation.serial_write_string("      Type 'help' for commands | Pipes (|) and redirects (<, >, >>) supported\n")
  foundation.serial_write_string("================================================================================\n")
  foundation.serial_write_string("\n")

  // Initialize Den library
  den.den_init()

  shell.running = 1
  shell.last_exit_code = 0
  shell.num_jobs = 0
  shell.num_aliases = 0
  shell.num_env_vars = 0
  shell.history_count = 0

  // Set prompt using Den's format
  str_copy(&shell.prompt[0] as *u8, "den$ ")

  // Get cwd from Den
  var cwd: u64 = den.den_get_cwd()
  if cwd != 0 {
    str_copy(&shell.cwd[0] as *u8, cwd as *u8)
  } else {
    str_copy(&shell.cwd[0] as *u8, "/")
  }

  // Den already sets up default environment variables and aliases
  // Sync them to our local state if needed
  shell_setenv("PATH", "/usr/local/bin:/usr/bin:/bin:/sbin")
  shell_setenv("HOME", "/root")
  shell_setenv("SHELL", "/bin/den")
  shell_setenv("TERM", "xterm-256color")
  shell_setenv("USER", "root")
  shell_setenv("HOSTNAME", "home-os")

  // Den's default aliases are already set
  shell_setalias("ll", "ls -la")
  shell_setalias("la", "ls -A")
  shell_setalias("l", "ls -CF")
  shell_setalias("...", "cd ../..")
  shell_setalias("....", "cd ../../..")
}

// Set environment variable
fn shell_setenv(name: *u8, value: *u8) {
  var i: u32 = 0
  loop {
    if i >= shell.num_env_vars { break }

    if str_cmp(&shell.env_vars[i].name[0] as *u8, name) == 0 {
      str_copy(&shell.env_vars[i].value[0] as *u8, value)
      return
    }

    i = i + 1
  }

  // Add new variable
  if shell.num_env_vars < MAX_ENV_VARS {
    str_copy(&shell.env_vars[shell.num_env_vars].name[0] as *u8, name)
    str_copy(&shell.env_vars[shell.num_env_vars].value[0] as *u8, value)
    shell.env_vars[shell.num_env_vars].active = 1
    shell.num_env_vars = shell.num_env_vars + 1
  }
}

// Get environment variable
fn shell_getenv(name: *u8): *u8 {
  var i: u32 = 0
  loop {
    if i >= shell.num_env_vars { break }

    if str_cmp(&shell.env_vars[i].name[0] as *u8, name) == 0 {
      return &shell.env_vars[i].value[0] as *u8
    }

    i = i + 1
  }
  return 0
}

// Set alias
fn shell_setalias(name: *u8, value: *u8) {
  if shell.num_aliases < MAX_ALIASES {
    str_copy(&shell.aliases[shell.num_aliases].name[0] as *u8, name)
    str_copy(&shell.aliases[shell.num_aliases].value[0] as *u8, value)
    shell.aliases[shell.num_aliases].active = 1
    shell.num_aliases = shell.num_aliases + 1
  }
}

// Parse command into arguments
fn parse_command(cmdline: *u8): u32 {
  // Returns number of args, modifies cmdline to null-terminate args
  var argc: u32 = 0
  var in_word: u32 = 0
  var i: u32 = 0

  loop {
    let ch: u8 = memory.read_u8(cmdline as u64 + i as u64)

    if ch == 0 {
      break
    }

    if ch == (' ' as u8) || ch == ('\t' as u8) {
      if in_word == 1 {
        memory.write_u8(cmdline as u64 + i as u64, 0)
        in_word = 0
      }
    } else {
      if in_word == 0 {
        argc = argc + 1
        in_word = 1
      }
    }

    i = i + 1
  }

  return argc
}

// Get nth argument from parsed command
fn get_arg(cmdline: *u8, n: u32): *u8 {
  var arg_num: u32 = 0
  var in_word: u32 = 0
  var word_start: u32 = 0
  var i: u32 = 0

  loop {
    let ch: u8 = memory.read_u8(cmdline as u64 + i as u64)

    if ch == 0 {
      if in_word == 1 && arg_num == n {
        return cmdline + word_start as u64 as *u8
      }
      break
    }

    if ch != (' ' as u8) && ch != ('\t' as u8) && ch != 0 {
      if in_word == 0 {
        if arg_num == n {
          word_start = i
        }
        in_word = 1
      }
    } else {
      if in_word == 1 {
        if arg_num == n {
          return cmdline + word_start as u64 as *u8
        }
        arg_num = arg_num + 1
        in_word = 0
      }
    }

    i = i + 1
  }

  return 0
}

// Check if command is builtin
fn is_builtin(cmd: *u8): u32 {
  if str_cmp(cmd, "cd") == 0 { return BUILTIN_CD }
  if str_cmp(cmd, "exit") == 0 { return BUILTIN_EXIT }
  if str_cmp(cmd, "export") == 0 { return BUILTIN_EXPORT }
  if str_cmp(cmd, "alias") == 0 { return BUILTIN_ALIAS }
  if str_cmp(cmd, "jobs") == 0 { return BUILTIN_JOBS }
  if str_cmp(cmd, "history") == 0 { return BUILTIN_HISTORY }
  if str_cmp(cmd, "help") == 0 { return BUILTIN_HELP }
  if str_cmp(cmd, "clear") == 0 { return BUILTIN_CLEAR }
  if str_cmp(cmd, "echo") == 0 { return BUILTIN_ECHO }
  if str_cmp(cmd, "pwd") == 0 { return BUILTIN_PWD }
  return 0
}

// Execute builtin command
fn execute_builtin(builtin: u32, cmdline: *u8, argc: u32): u32 {
  if builtin == BUILTIN_CD {
    let dir: *u8 = if argc >= 2 { get_arg(cmdline, 1) } else { shell_getenv("HOME") }
    if dir != 0 {
      str_copy(&shell.cwd[0] as *u8, dir)
      foundation.serial_write_string("Changed directory to: ")
      foundation.serial_write_string(&shell.cwd[0] as *u8)
      foundation.serial_write_string("\n")
    }
    return 0

  } else if builtin == BUILTIN_EXIT {
    shell.running = 0
    return 0

  } else if builtin == BUILTIN_PWD {
    foundation.serial_write_string(&shell.cwd[0] as *u8)
    foundation.serial_write_string("\n")
    return 0

  } else if builtin == BUILTIN_EXPORT {
    if argc >= 2 {
      let arg: *u8 = get_arg(cmdline, 1)
      // Simplified - would parse NAME=VALUE
      foundation.serial_write_string("export: ")
      foundation.serial_write_string(arg)
      foundation.serial_write_string("\n")
    }
    return 0

  } else if builtin == BUILTIN_ALIAS {
    foundation.serial_write_string("Aliases:\n")
    var i: u32 = 0
    loop {
      if i >= shell.num_aliases { break }
      if shell.aliases[i].active == 1 {
        foundation.serial_write_string("  ")
        foundation.serial_write_string(&shell.aliases[i].name[0] as *u8)
        foundation.serial_write_string(" = ")
        foundation.serial_write_string(&shell.aliases[i].value[0] as *u8)
        foundation.serial_write_string("\n")
      }
      i = i + 1
    }
    return 0

  } else if builtin == BUILTIN_JOBS {
    foundation.serial_write_string("Background jobs:\n")
    var i: u32 = 0
    var count: u32 = 0
    loop {
      if i >= shell.num_jobs { break }
      if shell.jobs[i].state != JOB_STATE_DONE {
        foundation.serial_write_string("  [")
        foundation.serial_write_u64(shell.jobs[i].job_id)
        foundation.serial_write_string("] PID ")
        foundation.serial_write_u64(shell.jobs[i].pid)
        foundation.serial_write_string(": ")
        foundation.serial_write_string(&shell.jobs[i].command[0] as *u8)
        foundation.serial_write_string("\n")
        count = count + 1
      }
      i = i + 1
    }
    if count == 0 {
      foundation.serial_write_string("  (no jobs)\n")
    }
    return 0

  } else if builtin == BUILTIN_HISTORY {
    foundation.serial_write_string("Command history:\n")
    var i: u32 = 0
    loop {
      if i >= shell.history_count { break }
      foundation.serial_write_string("  ")
      foundation.serial_write_u64(i + 1)
      foundation.serial_write_string(": ")
      foundation.serial_write_string(&history_buffer[i * 256] as *u8)
      foundation.serial_write_string("\n")
      i = i + 1
    }
    return 0

  } else if builtin == BUILTIN_HELP {
    foundation.serial_write_string("\nhome shell (hsh) - Built-in commands:\n")
    foundation.serial_write_string("  cd [dir]       - Change directory\n")
    foundation.serial_write_string("  pwd            - Print working directory\n")
    foundation.serial_write_string("  echo [text]    - Print text\n")
    foundation.serial_write_string("  export VAR=VAL - Set environment variable\n")
    foundation.serial_write_string("  alias          - List aliases\n")
    foundation.serial_write_string("  jobs           - List background jobs\n")
    foundation.serial_write_string("  history        - Show command history\n")
    foundation.serial_write_string("  help           - Show this help\n")
    foundation.serial_write_string("  clear          - Clear screen\n")
    foundation.serial_write_string("  exit           - Exit shell\n")
    foundation.serial_write_string("\n")
    return 0

  } else if builtin == BUILTIN_CLEAR {
    foundation.serial_write_string("\x1B[2J\x1B[H")  // VT100 clear screen
    return 0

  } else if builtin == BUILTIN_ECHO {
    var i: u32 = 1
    loop {
      if i >= argc { break }
      let arg: *u8 = get_arg(cmdline, i)
      if arg != 0 {
        foundation.serial_write_string(arg)
        if i < argc - 1 {
          foundation.serial_write_string(" ")
        }
      }
      i = i + 1
    }
    foundation.serial_write_string("\n")
    return 0
  }

  return 1
}

// ============================================================================
// Pipeline Support
// ============================================================================

// Check if command contains a pipe
fn has_pipe(cmdline: *u8): u32 {
  var i: u32 = 0
  var in_quote: u8 = 0

  loop {
    let ch: u8 = memory.read_u8(cmdline as u64 + i as u64)
    if ch == 0 { break }

    // Track quotes to avoid counting | inside strings
    if ch == ('"' as u8) and in_quote == 0 {
      in_quote = '"' as u8
    } else if ch == ('\'' as u8) and in_quote == 0 {
      in_quote = '\'' as u8
    } else if ch == in_quote {
      in_quote = 0
    } else if ch == ('|' as u8) and in_quote == 0 {
      return 1
    }

    i = i + 1
  }

  return 0
}

// Split command into pipeline stages
fn parse_pipeline(cmdline: *u8, stages: *PipelineStage): u32 {
  var num_stages: u32 = 0
  var start: u32 = 0
  var i: u32 = 0
  var in_quote: u8 = 0

  loop {
    let ch: u8 = memory.read_u8(cmdline as u64 + i as u64)

    // Track quotes
    if ch == ('"' as u8) and in_quote == 0 {
      in_quote = '"' as u8
    } else if ch == ('\'' as u8) and in_quote == 0 {
      in_quote = '\'' as u8
    } else if ch == in_quote {
      in_quote = 0
    }

    // Found pipe or end of string
    if (ch == ('|' as u8) and in_quote == 0) or ch == 0 {
      if num_stages < MAX_PIPELINE_STAGES {
        // Copy this stage's command
        var j: u32 = 0
        var stage_ptr: *PipelineStage = (stages as u64 + (num_stages * @sizeOf(PipelineStage)) as u64) as *PipelineStage
        var stage_start: u32 = start

        // Skip leading whitespace
        loop {
          let sc: u8 = memory.read_u8(cmdline as u64 + stage_start as u64)
          if sc != (' ' as u8) and sc != ('\t' as u8) { break }
          stage_start = stage_start + 1
        }

        // Copy command (trim trailing whitespace)
        var copy_end: u32 = i
        loop {
          if copy_end <= stage_start { break }
          let ec: u8 = memory.read_u8(cmdline as u64 + (copy_end - 1) as u64)
          if ec != (' ' as u8) and ec != ('\t' as u8) { break }
          copy_end = copy_end - 1
        }

        j = 0
        loop {
          if stage_start + j >= copy_end { break }
          if j >= 255 { break }
          memory.write_u8(&stage_ptr.command[0] as u64 + j as u64,
                          memory.read_u8(cmdline as u64 + (stage_start + j) as u64))
          j = j + 1
        }
        memory.write_u8(&stage_ptr.command[0] as u64 + j as u64, 0)

        stage_ptr.redir_in = REDIR_NONE
        stage_ptr.redir_out = REDIR_NONE
        num_stages = num_stages + 1
      }

      if ch == 0 { break }
      start = i + 1
    }

    i = i + 1
  }

  return num_stages
}

// Execute a pipeline
fn execute_pipeline(cmdline: *u8): u32 {
  var stages: [MAX_PIPELINE_STAGES]PipelineStage
  let num_stages: u32 = parse_pipeline(cmdline, &stages[0])

  if num_stages == 0 {
    return 1
  }

  if num_stages == 1 {
    // Single command - no pipe needed
    return execute_single_command(&stages[0].command[0] as *u8)
  }

  foundation.serial_write_string("[pipe] Executing pipeline with ")
  foundation.serial_write_u64(num_stages)
  foundation.serial_write_string(" stages\n")

  // Create pipes between stages
  var pipe_ids: [MAX_PIPELINE_STAGES]u32
  var i: u32 = 0
  loop {
    if i >= num_stages - 1 { break }
    pipe_ids[i] = pipe.pipe_create()
    if pipe_ids[i] == 0xFFFFFFFF {
      foundation.serial_write_string("[pipe] Failed to create pipe\n")
      return 1
    }
    i = i + 1
  }

  // Execute each stage
  i = 0
  var prev_output: [4096]u8
  var prev_output_len: u32 = 0

  loop {
    if i >= num_stages { break }

    foundation.serial_write_string("[pipe] Stage ")
    foundation.serial_write_u64(i + 1)
    foundation.serial_write_string(": ")
    foundation.serial_write_string(&stages[i].command[0] as *u8)
    foundation.serial_write_string("\n")

    // For now, we simulate pipe execution by:
    // 1. Running the command
    // 2. Capturing its output
    // 3. Passing it to the next stage as input

    // In a real implementation, we would:
    // - Fork processes
    // - Connect their stdin/stdout via pipes
    // - Execute in parallel

    // Parse the stage command
    var stage_argc: u32 = parse_command(&stages[i].command[0] as *u8)

    if stage_argc > 0 {
      let stage_cmd: *u8 = get_arg(&stages[i].command[0] as *u8, 0)

      if stage_cmd != 0 {
        // Check if builtin
        let builtin: u32 = is_builtin(stage_cmd)

        if builtin != 0 {
          // Execute builtin (output goes to serial for now)
          execute_builtin(builtin, &stages[i].command[0] as *u8, stage_argc)
        } else {
          // External command
          foundation.serial_write_string("  [would execute: ")
          foundation.serial_write_string(stage_cmd)
          foundation.serial_write_string("]\n")
        }
      }
    }

    i = i + 1
  }

  // Close all pipes
  i = 0
  loop {
    if i >= num_stages - 1 { break }
    pipe.pipe_close(pipe_ids[i])
    i = i + 1
  }

  foundation.serial_write_string("[pipe] Pipeline complete\n")
  return 0
}

// Execute a single command (non-pipeline)
fn execute_single_command(cmdline: *u8): u32 {
  // Check for I/O redirection
  var has_redir: u32 = 0
  var i: u32 = 0

  loop {
    let ch: u8 = memory.read_u8(cmdline as u64 + i as u64)
    if ch == 0 { break }
    if ch == ('<' as u8) or ch == ('>' as u8) {
      has_redir = 1
      break
    }
    i = i + 1
  }

  if has_redir == 1 {
    foundation.serial_write_string("[redirect] I/O redirection detected\n")
    // Parse and handle redirection
    return execute_with_redirection(cmdline)
  }

  // Simple command execution
  let argc: u32 = parse_command(cmdline)
  if argc == 0 { return 0 }

  let cmd: *u8 = get_arg(cmdline, 0)
  if cmd == 0 { return 0 }

  let builtin: u32 = is_builtin(cmd)

  if builtin != 0 {
    return execute_builtin(builtin, cmdline, argc)
  }

  foundation.serial_write_string("hsh: command not found: ")
  foundation.serial_write_string(cmd)
  foundation.serial_write_string("\n")
  return 127
}

// Execute command with I/O redirection
fn execute_with_redirection(cmdline: *u8): u32 {
  var cmd_buf: [256]u8
  var input_file: [128]u8
  var output_file: [128]u8
  var redir_in: u32 = 0
  var redir_out: u32 = 0
  var append_mode: u32 = 0

  // Parse command and find redirection operators
  var i: u32 = 0
  var cmd_len: u32 = 0
  var in_quote: u8 = 0

  loop {
    let ch: u8 = memory.read_u8(cmdline as u64 + i as u64)
    if ch == 0 { break }

    // Track quotes
    if ch == ('"' as u8) and in_quote == 0 {
      in_quote = '"' as u8
    } else if ch == ('\'' as u8) and in_quote == 0 {
      in_quote = '\'' as u8
    } else if ch == in_quote {
      in_quote = 0
    }

    if in_quote == 0 {
      if ch == ('>' as u8) {
        // Output redirection
        redir_out = 1
        if memory.read_u8(cmdline as u64 + (i + 1) as u64) == ('>' as u8) {
          append_mode = 1
          i = i + 1
        }

        // Skip whitespace and get filename
        i = i + 1
        loop {
          let sc: u8 = memory.read_u8(cmdline as u64 + i as u64)
          if sc != (' ' as u8) and sc != ('\t' as u8) { break }
          i = i + 1
        }

        // Copy filename
        var j: u32 = 0
        loop {
          let fc: u8 = memory.read_u8(cmdline as u64 + i as u64)
          if fc == 0 or fc == (' ' as u8) or fc == ('\t' as u8) or fc == ('<' as u8) { break }
          if j < 127 {
            memory.write_u8(&output_file[0] as u64 + j as u64, fc)
            j = j + 1
          }
          i = i + 1
        }
        memory.write_u8(&output_file[0] as u64 + j as u64, 0)
        continue

      } else if ch == ('<' as u8) {
        // Input redirection
        redir_in = 1

        // Skip whitespace and get filename
        i = i + 1
        loop {
          let sc: u8 = memory.read_u8(cmdline as u64 + i as u64)
          if sc != (' ' as u8) and sc != ('\t' as u8) { break }
          i = i + 1
        }

        // Copy filename
        var j: u32 = 0
        loop {
          let fc: u8 = memory.read_u8(cmdline as u64 + i as u64)
          if fc == 0 or fc == (' ' as u8) or fc == ('\t' as u8) or fc == ('>' as u8) { break }
          if j < 127 {
            memory.write_u8(&input_file[0] as u64 + j as u64, fc)
            j = j + 1
          }
          i = i + 1
        }
        memory.write_u8(&input_file[0] as u64 + j as u64, 0)
        continue
      }
    }

    // Copy to command buffer
    if cmd_len < 255 {
      memory.write_u8(&cmd_buf[0] as u64 + cmd_len as u64, ch)
      cmd_len = cmd_len + 1
    }

    i = i + 1
  }
  memory.write_u8(&cmd_buf[0] as u64 + cmd_len as u64, 0)

  // Print redirection info
  if redir_in == 1 {
    foundation.serial_write_string("[redirect] Input from: ")
    foundation.serial_write_string(&input_file[0] as *u8)
    foundation.serial_write_string("\n")
  }

  if redir_out == 1 {
    foundation.serial_write_string("[redirect] Output to: ")
    foundation.serial_write_string(&output_file[0] as *u8)
    if append_mode == 1 {
      foundation.serial_write_string(" (append)")
    }
    foundation.serial_write_string("\n")
  }

  // Execute the command (would redirect I/O in real implementation)
  let argc: u32 = parse_command(&cmd_buf[0] as *u8)
  if argc == 0 { return 0 }

  let cmd: *u8 = get_arg(&cmd_buf[0] as *u8, 0)
  if cmd == 0 { return 0 }

  let builtin: u32 = is_builtin(cmd)

  if builtin != 0 {
    return execute_builtin(builtin, &cmd_buf[0] as *u8, argc)
  }

  foundation.serial_write_string("hsh: command not found: ")
  foundation.serial_write_string(cmd)
  foundation.serial_write_string("\n")
  return 127
}

// Read command line
fn read_command(buffer: *u8, max_len: u32): u32 {
  var len: u32 = 0

  loop {
    let ch: u8 = foundation.serial_read_byte()

    if ch == ('\n' as u8) || ch == ('\r' as u8) {
      foundation.serial_write_string("\n")
      memory.write_u8(buffer as u64 + len as u64, 0)
      return len
    } else if ch == ('\b' as u8) || ch == 0x7F {
      if len > 0 {
        len = len - 1
        foundation.serial_write_string("\b \b")
      }
    } else if ch >= (' ' as u8) && len < max_len - 1 {
      memory.write_u8(buffer as u64 + len as u64, ch)
      foundation.serial_write_byte(ch)
      len = len + 1
    }
  }
}

// Main shell loop - uses Den library for full pipeline support
fn shell_loop() {
  var cmdline: [MAX_COMMAND_LENGTH]u8

  loop {
    if shell.running == 0 { break }

    // Print prompt with cwd
    foundation.serial_write_string(&shell.cwd[0] as *u8)
    foundation.serial_write_string(" ")
    foundation.serial_write_string(&shell.prompt[0] as *u8)

    // Read command
    let len: u32 = read_command(&cmdline[0] as *u8, MAX_COMMAND_LENGTH)

    if len == 0 { continue }

    // Add to Den history
    den.den_history_add(&cmdline[0] as u64, 0)

    // Also add to local history for history command
    if shell.history_count < MAX_HISTORY {
      str_copy(&history_buffer[shell.history_count * 256] as *u8, &cmdline[0] as *u8)
      shell.history_count = shell.history_count + 1
    }

    // Check if command contains pipes or redirects
    if has_pipe(&cmdline[0] as *u8) == 1 {
      // Use Den's pipeline execution via our execute_pipeline
      shell.last_exit_code = execute_pipeline(&cmdline[0] as *u8)
      den.den_set_last_exit_code(shell.last_exit_code)
      continue
    }

    // Try Den library execution first (for full shell features)
    var den_result: u32 = den.den_execute(&cmdline[0] as u64)

    // If Den handled it, update exit code
    if den_result != 127 {
      shell.last_exit_code = den_result
      den.den_set_last_exit_code(shell.last_exit_code)
      continue
    }

    // Fall back to local builtin handling
    let argc: u32 = parse_command(&cmdline[0] as *u8)

    if argc == 0 { continue }

    let cmd: *u8 = get_arg(&cmdline[0] as *u8, 0)

    if cmd == 0 { continue }

    let builtin: u32 = is_builtin(cmd)

    if builtin != 0 {
      shell.last_exit_code = execute_builtin(builtin, &cmdline[0] as *u8, argc)
    } else {
      foundation.serial_write_string("den: command not found: ")
      foundation.serial_write_string(cmd)
      foundation.serial_write_string("\n")
      shell.last_exit_code = 127
    }

    den.den_set_last_exit_code(shell.last_exit_code)
  }
}

// Main entry point
export fn shell_main() {
  shell_init()
  shell_loop()
  foundation.serial_write_string("\nGoodbye from den shell!\n")
}

export fn main(): u32 {
  shell_main()
  return den.den_get_last_exit_code()
}
