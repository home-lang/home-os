// home-os System Monitor
// Real-time system resource monitoring with graphs and process management

import "../kernel/src/core/foundation.home" as foundation
import "../kernel/src/core/process.home" as process
import "../kernel/src/core/memory.home" as memory
import "../kernel/src/drivers/storage.home" as storage
import "../kernel/src/network/network.home" as network
import "../kernel/src/drivers/timer.home" as timer

const MAX_PROCESSES: u32 = 256
const GRAPH_WIDTH: u32 = 60
const GRAPH_HEIGHT: u32 = 10
const HISTORY_SIZE: u32 = 60

struct ProcessInfo {
  pid: u32,
  name: [u8; 64],
  cpu_percent: u32,
  memory_kb: u64,
  state: u32,
  priority: u32
}

var processes: [ProcessInfo; 256]
var process_count: u32 = 0
var selected_process: u32 = 0

// History for graphs
var cpu_history: [u32; 60]
var mem_history: [u32; 60]
var net_history: [u32; 60]
var history_index: u32 = 0

var sysmon_initialized: u32 = 0
var update_interval: u32 = 1000  // ms
var last_update: u64 = 0
var view_mode: u32 = 0  // 0=overview, 1=processes, 2=graphs

export fn sysmon_init() {
  if sysmon_initialized == 1 { return }
  
  // Initialize history
  var i: u32 = 0
  while i < HISTORY_SIZE {
    cpu_history[i] = 0
    mem_history[i] = 0
    net_history[i] = 0
    i = i + 1
  }
  
  sysmon_initialized = 1
  foundation.serial_write_string("[SysMon] System monitor initialized\n")
}

export fn sysmon_get_cpu_usage() -> u32 {
  // Get CPU usage from kernel
  var total_time: u64 = timer.timer_get_ticks()
  var idle_time: u64 = process.process_get_idle_time()
  
  if total_time == 0 { return 0 }
  
  var busy_time: u64 = total_time - idle_time
  var usage: u32 = @truncate((busy_time * 100) / total_time, u32)
  
  if usage > 100 { usage = 100 }
  return usage
}

export fn sysmon_get_cpu_usage_per_core(core: u32) -> u32 {
  // Get per-core CPU usage
  var usage: u32 = process.process_get_cpu_usage(core)
  if usage > 100 { usage = 100 }
  return usage
}

export fn sysmon_get_memory_usage() -> u32 {
  var total: u64 = memory.memory_get_total()
  var used: u64 = memory.memory_get_used()
  
  if total == 0 { return 0 }
  
  var usage: u32 = @truncate((used * 100) / total, u32)
  if usage > 100 { usage = 100 }
  return usage
}

export fn sysmon_get_memory_total() -> u64 {
  return memory.memory_get_total()
}

export fn sysmon_get_memory_used() -> u64 {
  return memory.memory_get_used()
}

export fn sysmon_get_memory_free() -> u64 {
  return memory.memory_get_free()
}

export fn sysmon_get_process_count() -> u32 {
  return process.process_get_count()
}

export fn sysmon_get_thread_count() -> u32 {
  return process.thread_get_count()
}

export fn sysmon_get_disk_usage() -> u32 {
  var total: u64 = storage.storage_get_total_space()
  var used: u64 = storage.storage_get_used_space()
  
  if total == 0 { return 0 }
  
  var usage: u32 = @truncate((used * 100) / total, u32)
  if usage > 100 { usage = 100 }
  return usage
}

export fn sysmon_get_network_rx_bytes() -> u64 {
  return network.net_get_rx_bytes()
}

export fn sysmon_get_network_tx_bytes() -> u64 {
  return network.net_get_tx_bytes()
}

fn sysmon_update_processes() {
  process_count = 0
  
  // Get process list from kernel
  var i: u32 = 0
  while i < MAX_PROCESSES {
    var pid: u32 = process.process_get_pid_at_index(i)
    if pid == 0 { break }
    
    processes[process_count].pid = pid
    
    // Get process name
    process.process_get_name(pid, @ptrFromInt(processes[process_count].name))
    
    // Get process stats
    processes[process_count].cpu_percent = process.process_get_cpu_percent(pid)
    processes[process_count].memory_kb = process.process_get_memory_usage(pid)
    processes[process_count].state = process.process_get_state(pid)
    processes[process_count].priority = process.process_get_priority(pid)
    
    process_count = process_count + 1
    i = i + 1
  }
  
  // Sort by CPU usage (descending)
  sysmon_sort_processes()
}

fn sysmon_sort_processes() {
  if process_count <= 1 { return }
  
  // Bubble sort by CPU usage
  var i: u32 = 0
  while i < process_count - 1 {
    var j: u32 = 0
    while j < process_count - i - 1 {
      if processes[j].cpu_percent < processes[j + 1].cpu_percent {
        sysmon_swap_processes(j, j + 1)
      }
      j = j + 1
    }
    i = i + 1
  }
}

fn sysmon_swap_processes(idx1: u32, idx2: u32) {
  var temp: ProcessInfo
  
  temp.pid = processes[idx1].pid
  temp.cpu_percent = processes[idx1].cpu_percent
  temp.memory_kb = processes[idx1].memory_kb
  temp.state = processes[idx1].state
  temp.priority = processes[idx1].priority
  
  var i: u32 = 0
  while i < 64 {
    temp.name[i] = processes[idx1].name[i]
    i = i + 1
  }
  
  processes[idx1].pid = processes[idx2].pid
  processes[idx1].cpu_percent = processes[idx2].cpu_percent
  processes[idx1].memory_kb = processes[idx2].memory_kb
  processes[idx1].state = processes[idx2].state
  processes[idx1].priority = processes[idx2].priority
  
  i = 0
  while i < 64 {
    processes[idx1].name[i] = processes[idx2].name[i]
    i = i + 1
  }
  
  processes[idx2].pid = temp.pid
  processes[idx2].cpu_percent = temp.cpu_percent
  processes[idx2].memory_kb = temp.memory_kb
  processes[idx2].state = temp.state
  processes[idx2].priority = temp.priority
  
  i = 0
  while i < 64 {
    processes[idx2].name[i] = temp.name[i]
    i = i + 1
  }
}

fn sysmon_update_history() {
  // Add current values to history
  cpu_history[history_index] = sysmon_get_cpu_usage()
  mem_history[history_index] = sysmon_get_memory_usage()
  
  var net_rx: u64 = sysmon_get_network_rx_bytes()
  var net_usage: u32 = @truncate((net_rx / 1024) % 100, u32)  // Simplified
  net_history[history_index] = net_usage
  
  history_index = (history_index + 1) % HISTORY_SIZE
}

fn sysmon_draw() {
  foundation.vga_clear()
  foundation.vga_write_string("=== System Monitor ===\n\n")
  
  // CPU stats
  foundation.vga_write_string("CPU:\n")
  foundation.vga_write_string("  Usage: ")
  foundation.vga_write_string(@intToString(sysmon_get_cpu_usage(), 10))
  foundation.vga_write_string("%\n")
  
  // Memory stats
  foundation.vga_write_string("Memory:\n")
  foundation.vga_write_string("  Used: ")
  foundation.vga_write_string(@intToString(sysmon_get_memory_used() / 1024, 10))
  foundation.vga_write_string(" MB\n")
  foundation.vga_write_string("  Free: ")
  foundation.vga_write_string(@intToString(sysmon_get_memory_free() / 1024, 10))
  foundation.vga_write_string(" MB\n\n")
  
  // Disk stats
  foundation.vga_write_string("Disk:\n")
  foundation.vga_write_string("  Usage: ")
  foundation.vga_write_string(@intToString(sysmon_get_disk_usage(), 10))
  foundation.vga_write_string("%\n\n")
  
  // Network stats
  foundation.vga_write_string("Network:\n")
  foundation.vga_write_string("  RX: ")
  foundation.vga_write_string(@intToString(sysmon_get_network_rx_bytes() / 1024, 10))
  foundation.vga_write_string(" KB\n")
  foundation.vga_write_string("  TX: ")
  foundation.vga_write_string(@intToString(sysmon_get_network_tx_bytes() / 1024, 10))
  foundation.vga_write_string(" KB\n\n")
  
  // Process stats
  foundation.vga_write_string("Processes:\n")
  foundation.vga_write_string("  Count: ")
  foundation.vga_write_string(@intToString(sysmon_get_process_count(), 10))
  foundation.vga_write_string("\n\n")
  
  // Uptime
  foundation.vga_write_string("Uptime: ")
  var seconds: u64 = timer.timer_get_seconds()
  foundation.vga_write_string(@intToString(seconds, 10))
  foundation.vga_write_string(" seconds\n\n")
  
  foundation.vga_write_string("Press Q to quit")
}

export fn sysmon_main() {
  sysmon_draw()
  
  foundation.vga_write_string("\n\nSystem monitor loaded!\n")
}
