// home-os Cp
// Copy files and directories with full option support

import "../../kernel/src/core/foundation.home" as foundation
import "../../kernel/src/core/filesystem.home" as filesystem

// Configuration flags
var recursive: bool = false        // -r/-R: copy directories recursively
var preserve_mode: bool = false    // -p: preserve permissions
var force: bool = false            // -f: remove destination before copy
var interactive: bool = false      // -i: prompt before overwrite
var verbose: bool = false          // -v: explain what is being done
var no_clobber: bool = false       // -n: do not overwrite existing file
var update_only: bool = false      // -u: copy only when source is newer
var dereference: bool = false      // -L: follow symlinks
var no_dereference: bool = false   // -P: never follow symlinks (default)

// String comparison
fn strncmp(a: *u8, b: *u8, n: u32): bool {
  var i: u32 = 0
  while i < n {
    if a[i] != b[i] { return false }
    if a[i] == 0 { return true }
    i = i + 1
  }
  return true
}

fn str_equal(a: *u8, b: *u8): bool {
  var i: u32 = 0
  while a[i] != 0 and b[i] != 0 {
    if a[i] != b[i] { return false }
    i = i + 1
  }
  return a[i] == b[i]
}

fn str_len(s: *u8): u32 {
  var i: u32 = 0
  while s[i] != 0 { i = i + 1 }
  return i
}

fn str_copy(dest: *u8, src: *u8): u32 {
  var i: u32 = 0
  while src[i] != 0 {
    dest[i] = src[i]
    i = i + 1
  }
  dest[i] = 0
  return i
}

// Get the basename of a path
fn get_basename(path: *u8): *u8 {
  var len: u32 = str_len(path)
  var i: u32 = len
  while i > 0 {
    i = i - 1
    if path[i] == '/' {
      return &path[i + 1]
    }
  }
  return path
}

// Copy a single file
fn copy_file(src: *u8, dst: *u8): i32 {
  // Check if destination exists
  var dst_exists: bool = filesystem.vfs_exists(@ptrFromInt(dst))

  if dst_exists and no_clobber {
    return 0  // Skip without error
  }

  if dst_exists and interactive {
    foundation.serial_write_string("cp: overwrite '")
    foundation.serial_write_string(dst)
    foundation.serial_write_string("'? ")
    // Would read user input here - for now, assume no
    foundation.serial_write_string("(skipped - interactive mode)\n")
    return 0
  }

  if dst_exists and force {
    filesystem.vfs_unlink(@ptrFromInt(dst))
  }

  // Open source file
  var fd_src: u32 = filesystem.vfs_open(@ptrFromInt(src), 0)
  if fd_src == 0 {
    foundation.serial_write_string("cp: cannot stat '")
    foundation.serial_write_string(src)
    foundation.serial_write_string("': No such file or directory\n")
    return -1
  }

  // Create/open destination file (mode 1 = write/create)
  var fd_dst: u32 = filesystem.vfs_open(@ptrFromInt(dst), 1)
  if fd_dst == 0 {
    filesystem.vfs_close(fd_src)
    foundation.serial_write_string("cp: cannot create '")
    foundation.serial_write_string(dst)
    foundation.serial_write_string("'\n")
    return -1
  }

  // Copy content in chunks
  var buffer: [u8; 4096]
  var total_bytes: u64 = 0

  while true {
    var bytes: u64 = filesystem.vfs_read(fd_src, @ptrFromInt(&buffer[0]), 4096)
    if bytes == 0 { break }

    var written: u64 = filesystem.vfs_write(fd_dst, @ptrFromInt(&buffer[0]), bytes)
    if written != bytes {
      foundation.serial_write_string("cp: write error\n")
      filesystem.vfs_close(fd_src)
      filesystem.vfs_close(fd_dst)
      return -1
    }

    total_bytes = total_bytes + bytes
  }

  filesystem.vfs_close(fd_src)
  filesystem.vfs_close(fd_dst)

  // Preserve permissions if requested
  if preserve_mode {
    var src_perms: u32 = filesystem.vfs_get_permissions(@ptrFromInt(src))
    filesystem.vfs_chmod(@ptrFromInt(dst), src_perms)
  }

  if verbose {
    foundation.serial_write_string("'")
    foundation.serial_write_string(src)
    foundation.serial_write_string("' -> '")
    foundation.serial_write_string(dst)
    foundation.serial_write_string("'\n")
  }

  return 0
}

// Copy a directory recursively
fn copy_directory(src: *u8, dst: *u8): i32 {
  // Create destination directory
  var result: u32 = filesystem.vfs_mkdir(@ptrFromInt(dst), 0755)
  if result != 0 and result != 17 {  // 17 = EEXIST
    foundation.serial_write_string("cp: cannot create directory '")
    foundation.serial_write_string(dst)
    foundation.serial_write_string("'\n")
    return -1
  }

  if verbose {
    foundation.serial_write_string("'")
    foundation.serial_write_string(src)
    foundation.serial_write_string("' -> '")
    foundation.serial_write_string(dst)
    foundation.serial_write_string("'\n")
  }

  // Read directory entries
  var entries: [filesystem.DirEntryInfo; 256]
  var count: u32 = filesystem.vfs_readdir(@ptrFromInt(src), &entries, 256)

  var i: u32 = 0
  while i < count {
    var name: *u8 = &entries[i].name[0]

    // Skip . and ..
    if str_equal(name, ".") or str_equal(name, "..") {
      i = i + 1
      continue
    }

    // Build source and destination paths
    var child_src: [u8; 256]
    var child_dst: [u8; 256]

    var p: u32 = str_copy(&child_src[0], src)
    if p > 0 and child_src[p - 1] != '/' {
      child_src[p] = '/'
      p = p + 1
    }
    str_copy(&child_src[p], name)

    p = str_copy(&child_dst[0], dst)
    if p > 0 and child_dst[p - 1] != '/' {
      child_dst[p] = '/'
      p = p + 1
    }
    str_copy(&child_dst[p], name)

    // Recursively copy
    if entries[i].file_type == 2 {
      copy_directory(&child_src[0], &child_dst[0])
    } else {
      copy_file(&child_src[0], &child_dst[0])
    }

    i = i + 1
  }

  return 0
}

// Copy source to destination (file or directory)
fn do_copy(src: *u8, dst: *u8): i32 {
  var src_type: u32 = filesystem.vfs_get_type(@ptrFromInt(src))

  if src_type == 0 {
    foundation.serial_write_string("cp: cannot stat '")
    foundation.serial_write_string(src)
    foundation.serial_write_string("': No such file or directory\n")
    return -1
  }

  if src_type == 2 {
    // Source is a directory
    if !recursive {
      foundation.serial_write_string("cp: -r not specified; omitting directory '")
      foundation.serial_write_string(src)
      foundation.serial_write_string("'\n")
      return -1
    }
    return copy_directory(src, dst)
  }

  // Source is a regular file
  return copy_file(src, dst)
}

// Print usage
fn print_usage() {
  foundation.serial_write_string("\nUsage: cp [OPTION]... SOURCE... DEST\n")
  foundation.serial_write_string("Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n\n")
  foundation.serial_write_string("Options:\n")
  foundation.serial_write_string("  -f, --force          remove existing destination files\n")
  foundation.serial_write_string("  -i, --interactive    prompt before overwrite\n")
  foundation.serial_write_string("  -n, --no-clobber     do not overwrite existing file\n")
  foundation.serial_write_string("  -p, --preserve       preserve permissions\n")
  foundation.serial_write_string("  -r, -R, --recursive  copy directories recursively\n")
  foundation.serial_write_string("  -u, --update         copy only when source is newer\n")
  foundation.serial_write_string("  -v, --verbose        explain what is being done\n")
  foundation.serial_write_string("  -L, --dereference    follow symbolic links in SOURCE\n")
  foundation.serial_write_string("  -P, --no-dereference never follow symbolic links\n")
  foundation.serial_write_string("  --help               display this help and exit\n")
  foundation.serial_write_string("\n")
}

// Reset flags
fn reset_flags() {
  recursive = false
  preserve_mode = false
  force = false
  interactive = false
  verbose = false
  no_clobber = false
  update_only = false
  dereference = false
  no_dereference = false
}

// Main entry with argument parsing
export fn cp_main_args(argc: u32, argv: *[*u8; 16]) {
  reset_flags()

  var sources: [*u8; 15]
  var source_count: u32 = 0

  var i: u32 = 1
  while i < argc {
    var arg: *u8 = argv[i]

    if arg[0] == '-' and arg[1] != 0 {
      if arg[1] == '-' {
        // Long options
        if strncmp(&arg[2], "recursive", 9) {
          recursive = true
        } else if strncmp(&arg[2], "preserve", 8) {
          preserve_mode = true
        } else if strncmp(&arg[2], "force", 5) {
          force = true
        } else if strncmp(&arg[2], "interactive", 11) {
          interactive = true
        } else if strncmp(&arg[2], "verbose", 7) {
          verbose = true
        } else if strncmp(&arg[2], "no-clobber", 10) {
          no_clobber = true
        } else if strncmp(&arg[2], "update", 6) {
          update_only = true
        } else if strncmp(&arg[2], "dereference", 11) {
          dereference = true
        } else if strncmp(&arg[2], "no-dereference", 14) {
          no_dereference = true
        } else if strncmp(&arg[2], "help", 4) {
          print_usage()
          return
        }
      } else {
        // Short options - can be combined
        var j: u32 = 1
        while arg[j] != 0 {
          if arg[j] == 'r' or arg[j] == 'R' {
            recursive = true
          } else if arg[j] == 'p' {
            preserve_mode = true
          } else if arg[j] == 'f' {
            force = true
          } else if arg[j] == 'i' {
            interactive = true
          } else if arg[j] == 'v' {
            verbose = true
          } else if arg[j] == 'n' {
            no_clobber = true
          } else if arg[j] == 'u' {
            update_only = true
          } else if arg[j] == 'L' {
            dereference = true
          } else if arg[j] == 'P' {
            no_dereference = true
          }
          j = j + 1
        }
      }
    } else {
      // Source/destination argument
      if source_count < 15 {
        sources[source_count] = arg
        source_count = source_count + 1
      }
    }

    i = i + 1
  }

  if source_count < 2 {
    foundation.serial_write_string("cp: missing destination file operand\n")
    foundation.serial_write_string("Try 'cp --help' for more information.\n")
    return
  }

  // Last argument is destination
  var dest: *u8 = sources[source_count - 1]
  source_count = source_count - 1

  // Check if destination is a directory
  var dest_type: u32 = filesystem.vfs_get_type(@ptrFromInt(dest))
  var dest_is_dir: bool = (dest_type == 2)

  if source_count > 1 and !dest_is_dir {
    foundation.serial_write_string("cp: target '")
    foundation.serial_write_string(dest)
    foundation.serial_write_string("' is not a directory\n")
    return
  }

  // Copy each source
  i = 0
  while i < source_count {
    var src: *u8 = sources[i]
    var final_dest: [u8; 256]

    if dest_is_dir {
      // Build destination path: dest/basename(src)
      var p: u32 = str_copy(&final_dest[0], dest)
      if p > 0 and final_dest[p - 1] != '/' {
        final_dest[p] = '/'
        p = p + 1
      }
      str_copy(&final_dest[p], get_basename(src))
    } else {
      str_copy(&final_dest[0], dest)
    }

    do_copy(src, &final_dest[0])
    i = i + 1
  }
}

// Simple entry point for backward compatibility
export fn cp_main(source: u64, dest: u64) {
  reset_flags()

  var src: *u8 = @ptrFromInt(source)
  var dst: *u8 = @ptrFromInt(dest)

  if src[0] == 0 or dst[0] == 0 {
    foundation.serial_write_string("cp: missing file operand\n")
    return
  }

  do_copy(src, dst)
}

// Main entry point for standalone execution
export fn main(): i32 {
  foundation.serial_write_string("cp: missing file operand\n")
  foundation.serial_write_string("Try 'cp --help' for more information.\n")
  return 1
}
