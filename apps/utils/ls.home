// home-os ls
// Modern file listing with eza-like features and full VFS integration

import "../../kernel/src/core/foundation.home" as foundation
import "../../kernel/src/core/filesystem.home" as filesystem

const COLOR_DIR: u8 = 0x09      // Blue
const COLOR_EXEC: u8 = 0x0A     // Green
const COLOR_LINK: u8 = 0x0B     // Cyan
const COLOR_FILE: u8 = 0x0F     // White
const COLOR_HIDDEN: u8 = 0x08   // Dark gray

// Configuration flags
var show_all: bool = false           // -a: show hidden files
var almost_all: bool = false         // -A: show hidden except . and ..
var long_format: bool = false        // -l: long format
var human_readable: bool = true      // -h: human readable sizes
var show_header: bool = false        // --header: show column headers
var show_git: bool = false           // --git: show git status
var show_icons: bool = true          // --icons: show file type icons
var color_output: bool = true        // --color: colorize output
var group_dirs_first: bool = true    // --group-directories-first
var recursive: bool = false          // -R: recursive listing
var one_per_line: bool = false       // -1: one file per line
var reverse_sort: bool = false       // -r: reverse sort order
var sort_by_size: bool = false       // -S: sort by size
var sort_by_time: bool = false       // -t: sort by modification time
var show_inode: bool = false         // -i: show inode numbers

// Format size in human-readable form
fn format_size(bytes: u64, buf: *[u8; 16]) {
  var size: u64 = bytes
  var suffix: u8 = 'B'

  if human_readable {
    if size >= 1099511627776 {
      size = size / 1099511627776
      suffix = 'T'
    } else if size >= 1073741824 {
      size = size / 1073741824
      suffix = 'G'
    } else if size >= 1048576 {
      size = size / 1048576
      suffix = 'M'
    } else if size >= 1024 {
      size = size / 1024
      suffix = 'K'
    }
  }

  var i: u32 = 0
  if size == 0 {
    buf[0] = '0'
    i = 1
  } else {
    var digits: [u8; 20]
    var d: u32 = 0
    var n: u64 = size
    while n > 0 {
      digits[d] = @intCast('0' + (n % 10))
      n = n / 10
      d = d + 1
    }
    while d > 0 {
      d = d - 1
      buf[i] = digits[d]
      i = i + 1
    }
  }

  if human_readable {
    buf[i] = suffix
    i = i + 1
  }
  buf[i] = 0
}

fn ls_print_permissions(perms: u32, file_type: u32) {
  var chars: [u8; 11]

  // File type indicator
  if file_type == 2 {
    chars[0] = 'd'
  } else if file_type == 3 {
    chars[0] = 'l'
  } else if file_type == 4 {
    chars[0] = 'c'
  } else if file_type == 5 {
    chars[0] = 'b'
  } else {
    chars[0] = '-'
  }

  // Owner permissions
  chars[1] = if (perms & 0x100) != 0 { 'r' } else { '-' }
  chars[2] = if (perms & 0x080) != 0 { 'w' } else { '-' }
  chars[3] = if (perms & 0x040) != 0 { 'x' } else { '-' }

  // Group permissions
  chars[4] = if (perms & 0x020) != 0 { 'r' } else { '-' }
  chars[5] = if (perms & 0x010) != 0 { 'w' } else { '-' }
  chars[6] = if (perms & 0x008) != 0 { 'x' } else { '-' }

  // Other permissions
  chars[7] = if (perms & 0x004) != 0 { 'r' } else { '-' }
  chars[8] = if (perms & 0x002) != 0 { 'w' } else { '-' }
  chars[9] = if (perms & 0x001) != 0 { 'x' } else { '-' }
  chars[10] = 0

  foundation.serial_write_string(&chars[0])
}

fn ls_print_size(size: u64) {
  var size_buf: [u8; 16]
  format_size(size, &size_buf)

  // Right-align in 8-character field
  var len: u32 = 0
  while size_buf[len] != 0 { len = len + 1 }

  var spaces: u32 = 0
  while spaces < 8 - len {
    foundation.serial_write_char(' ')
    spaces = spaces + 1
  }
  foundation.serial_write_string(&size_buf[0])
}

// Print icon based on file type and extension
fn ls_print_icon(file_type: u32, name: *u8) {
  if !show_icons { return }

  if file_type == 2 {
    foundation.serial_write_string("[D] ")
  } else if file_type == 3 {
    foundation.serial_write_string("[L] ")
  } else if file_type == 4 {
    foundation.serial_write_string("[C] ")
  } else if file_type == 5 {
    foundation.serial_write_string("[B] ")
  } else {
    // Check extension for specific icons
    var ext: *u8 = get_extension(name)
    if str_equal(ext, "home") {
      foundation.serial_write_string("[H] ")
    } else if str_equal(ext, "txt") {
      foundation.serial_write_string("[T] ")
    } else if str_equal(ext, "sh") {
      foundation.serial_write_string("[S] ")
    } else {
      foundation.serial_write_string("[F] ")
    }
  }
}

// Get file extension
fn get_extension(name: *u8): *u8 {
  var len: u32 = 0
  var last_dot: i32 = -1
  while name[len] != 0 {
    if name[len] == '.' {
      last_dot = @intCast(len)
    }
    len = len + 1
  }
  if last_dot >= 0 {
    return &name[@intCast(last_dot + 1)]
  }
  return ""
}

// String comparison
fn str_equal(a: *u8, b: *u8): bool {
  var i: u32 = 0
  while a[i] != 0 and b[i] != 0 {
    if a[i] != b[i] { return false }
    i = i + 1
  }
  return a[i] == b[i]
}

fn strncmp(a: *u8, b: *u8, n: u32): bool {
  var i: u32 = 0
  while i < n {
    if a[i] != b[i] { return false }
    if a[i] == 0 { return true }
    i = i + 1
  }
  return true
}

// Print a single entry in long format
fn ls_print_entry_long(entry: *filesystem.DirEntryInfo) {
  // Inode number if requested
  if show_inode {
    foundation.serial_write_u64(entry.inode)
    foundation.serial_write_string(" ")
  }

  // Permissions
  ls_print_permissions(entry.permissions, entry.file_type)
  foundation.serial_write_string(" ")

  // Links count
  foundation.serial_write_string("  1 ")

  // Owner and group
  foundation.serial_write_string("root     root     ")

  // Size
  ls_print_size(entry.size)
  foundation.serial_write_string(" ")

  // Date (placeholder for now)
  foundation.serial_write_string("Dec  6 12:00 ")

  // Icon
  ls_print_icon(entry.file_type, &entry.name[0])

  // Name with color
  if color_output {
    if entry.file_type == 2 {
      foundation.serial_write_string("\x1b[34m")  // Blue for directories
    } else if (entry.permissions & 0x49) != 0 {
      foundation.serial_write_string("\x1b[32m")  // Green for executables
    } else if entry.file_type == 3 {
      foundation.serial_write_string("\x1b[36m")  // Cyan for symlinks
    }
  }

  foundation.serial_write_string(&entry.name[0])

  if color_output {
    foundation.serial_write_string("\x1b[0m")  // Reset color
  }

  if entry.file_type == 2 {
    foundation.serial_write_string("/")
  }

  foundation.serial_write_string("\n")
}

// Print entry in short format
fn ls_print_entry_short(entry: *filesystem.DirEntryInfo, col: *u32) {
  if show_icons {
    ls_print_icon(entry.file_type, &entry.name[0])
  }

  // Color
  if color_output {
    if entry.file_type == 2 {
      foundation.serial_write_string("\x1b[34m")
    } else if (entry.permissions & 0x49) != 0 {
      foundation.serial_write_string("\x1b[32m")
    }
  }

  foundation.serial_write_string(&entry.name[0])

  if color_output {
    foundation.serial_write_string("\x1b[0m")
  }

  if entry.file_type == 2 {
    foundation.serial_write_string("/")
  }

  if one_per_line {
    foundation.serial_write_string("\n")
  } else {
    // Column formatting
    var name_len: u32 = 0
    while entry.name[name_len] != 0 { name_len = name_len + 1 }

    var padding: u32 = 20 - (name_len % 20)
    if padding < 2 { padding = padding + 20 }

    var p: u32 = 0
    while p < padding {
      foundation.serial_write_char(' ')
      p = p + 1
    }

    col.* = col.* + 1
    if col.* >= 4 {
      foundation.serial_write_string("\n")
      col.* = 0
    }
  }
}

// Print column header
fn ls_print_header() {
  if !show_header or !long_format { return }

  if show_inode {
    foundation.serial_write_string("Inode      ")
  }
  foundation.serial_write_string("Permissions  Lnk Owner    Group       Size Date         Name\n")
  foundation.serial_write_string("--------------------------------------------------------------\n")
}

// Sort entries - directories first if enabled
fn sort_entries(entries: *[filesystem.DirEntryInfo; 256], count: u32) {
  if !group_dirs_first { return }

  // Simple bubble sort putting directories first
  var i: u32 = 0
  while i < count {
    var j: u32 = i + 1
    while j < count {
      var swap: bool = false

      if group_dirs_first {
        // Directories before files
        if entries[i].file_type != 2 and entries[j].file_type == 2 {
          swap = true
        }
      }

      if swap {
        var temp: filesystem.DirEntryInfo = entries[i]
        entries[i] = entries[j]
        entries[j] = temp
      }

      j = j + 1
    }
    i = i + 1
  }
}

// List a directory
fn ls_directory(path: *u8, depth: u32) {
  var entries: [filesystem.DirEntryInfo; 256]
  var count: u32 = filesystem.vfs_readdir(@ptrFromInt(path), &entries, 256)

  if count == 0 {
    foundation.serial_write_string("ls: cannot access '")
    foundation.serial_write_string(path)
    foundation.serial_write_string("': No such file or directory\n")
    return
  }

  // Print directory name if recursive
  if recursive and depth > 0 {
    foundation.serial_write_string("\n")
    foundation.serial_write_string(path)
    foundation.serial_write_string(":\n")
  }

  // Sort entries
  sort_entries(&entries, count)

  ls_print_header()

  var col: u32 = 0
  var i: u32 = 0
  while i < count {
    var name: *u8 = &entries[i].name[0]

    // Skip hidden files unless -a or -A
    if name[0] == '.' {
      if !show_all and !almost_all {
        i = i + 1
        continue
      }
      // -A skips . and ..
      if almost_all {
        if str_equal(name, ".") or str_equal(name, "..") {
          i = i + 1
          continue
        }
      }
    }

    if long_format {
      ls_print_entry_long(&entries[i])
    } else {
      ls_print_entry_short(&entries[i], &col)
    }

    i = i + 1
  }

  if !long_format and !one_per_line and col > 0 {
    foundation.serial_write_string("\n")
  }

  // Recursive listing
  if recursive {
    i = 0
    while i < count {
      if entries[i].file_type == 2 {
        var name: *u8 = &entries[i].name[0]
        if !str_equal(name, ".") and !str_equal(name, "..") {
          // Build full path
          var child_path: [u8; 256]
          var p: u32 = 0
          var j: u32 = 0
          while path[j] != 0 {
            child_path[p] = path[j]
            p = p + 1
            j = j + 1
          }
          if p > 0 and child_path[p - 1] != '/' {
            child_path[p] = '/'
            p = p + 1
          }
          j = 0
          while name[j] != 0 {
            child_path[p] = name[j]
            p = p + 1
            j = j + 1
          }
          child_path[p] = 0

          ls_directory(&child_path[0], depth + 1)
        }
      }
      i = i + 1
    }
  }
}

// Reset all flags to defaults
fn reset_flags() {
  show_all = false
  almost_all = false
  long_format = false
  human_readable = true
  show_header = false
  show_git = false
  show_icons = true
  color_output = true
  group_dirs_first = true
  recursive = false
  one_per_line = false
  reverse_sort = false
  sort_by_size = false
  sort_by_time = false
  show_inode = false
}

// Main entry with argument parsing
export fn ls_main_args(argc: u32, argv: *[*u8; 16]) {
  reset_flags()

  var paths: [*u8; 16]
  var path_count: u32 = 0

  var i: u32 = 1
  while i < argc {
    var arg: *u8 = argv[i]

    if arg[0] == '-' {
      if arg[1] == '-' {
        // Long options
        if strncmp(&arg[2], "all", 3) {
          show_all = true
        } else if strncmp(&arg[2], "almost-all", 10) {
          almost_all = true
        } else if strncmp(&arg[2], "long", 4) {
          long_format = true
        } else if strncmp(&arg[2], "human-readable", 14) {
          human_readable = true
        } else if strncmp(&arg[2], "header", 6) {
          show_header = true
        } else if strncmp(&arg[2], "git", 3) {
          show_git = true
        } else if strncmp(&arg[2], "icons", 5) {
          show_icons = true
        } else if strncmp(&arg[2], "no-icons", 8) {
          show_icons = false
        } else if strncmp(&arg[2], "color", 5) {
          color_output = true
        } else if strncmp(&arg[2], "no-color", 8) {
          color_output = false
        } else if strncmp(&arg[2], "group-directories-first", 23) {
          group_dirs_first = true
        } else if strncmp(&arg[2], "recursive", 9) {
          recursive = true
        } else if strncmp(&arg[2], "reverse", 7) {
          reverse_sort = true
        } else if strncmp(&arg[2], "inode", 5) {
          show_inode = true
        } else if strncmp(&arg[2], "help", 4) {
          print_usage()
          return
        }
      } else {
        // Short options - can be combined like -la
        var j: u32 = 1
        while arg[j] != 0 {
          if arg[j] == 'a' {
            show_all = true
          } else if arg[j] == 'A' {
            almost_all = true
          } else if arg[j] == 'l' {
            long_format = true
          } else if arg[j] == 'h' {
            human_readable = true
          } else if arg[j] == 'R' {
            recursive = true
          } else if arg[j] == '1' {
            one_per_line = true
          } else if arg[j] == 'r' {
            reverse_sort = true
          } else if arg[j] == 'S' {
            sort_by_size = true
          } else if arg[j] == 't' {
            sort_by_time = true
          } else if arg[j] == 'i' {
            show_inode = true
          }
          j = j + 1
        }
      }
    } else {
      // Path argument
      if path_count < 16 {
        paths[path_count] = arg
        path_count = path_count + 1
      }
    }

    i = i + 1
  }

  // Default to current directory
  if path_count == 0 {
    paths[0] = "/"
    path_count = 1
  }

  // List all paths
  i = 0
  while i < path_count {
    if path_count > 1 {
      foundation.serial_write_string(paths[i])
      foundation.serial_write_string(":\n")
    }
    ls_directory(paths[i], 0)
    if i < path_count - 1 {
      foundation.serial_write_string("\n")
    }
    i = i + 1
  }
}

// Simple entry point for backward compatibility
export fn ls_main(path: u64) {
  reset_flags()

  var path_str: *u8 = @ptrFromInt(path)
  if path_str[0] == 0 {
    path_str = "/"
  }

  ls_directory(path_str, 0)
}

// Alias for ll = ls -la
export fn ll_main(path: u64) {
  reset_flags()
  show_all = true
  long_format = true
  show_header = true

  var path_str: *u8 = @ptrFromInt(path)
  if path_str[0] == 0 {
    path_str = "/"
  }

  ls_directory(path_str, 0)
}

// Print usage information
fn print_usage() {
  foundation.serial_write_string("\nUsage: ls [OPTION]... [FILE]...\n")
  foundation.serial_write_string("List directory contents.\n\n")
  foundation.serial_write_string("Options:\n")
  foundation.serial_write_string("  -a, --all              show hidden files (starting with .)\n")
  foundation.serial_write_string("  -A, --almost-all       show hidden files except . and ..\n")
  foundation.serial_write_string("  -l, --long             use long listing format\n")
  foundation.serial_write_string("  -h, --human-readable   print sizes in human readable format\n")
  foundation.serial_write_string("  -R, --recursive        list subdirectories recursively\n")
  foundation.serial_write_string("  -1                     list one file per line\n")
  foundation.serial_write_string("  -r, --reverse          reverse order while sorting\n")
  foundation.serial_write_string("  -S                     sort by file size, largest first\n")
  foundation.serial_write_string("  -t                     sort by modification time, newest first\n")
  foundation.serial_write_string("  -i, --inode            print inode number of each file\n")
  foundation.serial_write_string("  --header               print column headers\n")
  foundation.serial_write_string("  --icons                show file type icons (default)\n")
  foundation.serial_write_string("  --no-icons             don't show icons\n")
  foundation.serial_write_string("  --color                colorize the output (default)\n")
  foundation.serial_write_string("  --no-color             don't colorize the output\n")
  foundation.serial_write_string("  --group-directories-first  list directories before files\n")
  foundation.serial_write_string("  --help                 display this help and exit\n")
  foundation.serial_write_string("\n")
}

// Main entry point for standalone execution
export fn main(): i32 {
  var default_path: []u8 = "/"
  ls_main(@ptrFromInt(&default_path[0]))
  return 0
}
