// home-os Disk Usage
// Show directory and file space usage

import "../../kernel/src/core/foundation.home" as foundation
import "../../kernel/src/core/filesystem.home" as filesystem

// Configuration flags
var show_all: bool = false        // -a: show all files, not just directories
var human_readable: bool = true   // -h: human readable sizes
var summarize: bool = false       // -s: only show total
var max_depth: u32 = 0xFFFFFFFF  // --max-depth=N

// Format size in human-readable form (K, M, G, T)
fn format_size(bytes: u64, buf: *[u8; 16]) {
  var size: u64 = bytes
  var suffix: u8 = 'B'

  if human_readable {
    if size >= 1099511627776 {  // TB
      size = size / 1099511627776
      suffix = 'T'
    } else if size >= 1073741824 {  // GB
      size = size / 1073741824
      suffix = 'G'
    } else if size >= 1048576 {  // MB
      size = size / 1048576
      suffix = 'M'
    } else if size >= 1024 {  // KB
      size = size / 1024
      suffix = 'K'
    }
  }

  // Convert to string
  var i: u32 = 0
  if size == 0 {
    buf[0] = '0'
    i = 1
  } else {
    var digits: [u8; 16]
    var d: u32 = 0
    var n: u64 = size
    while n > 0 {
      digits[d] = @intCast('0' + (n % 10))
      n = n / 10
      d = d + 1
    }
    // Reverse
    while d > 0 {
      d = d - 1
      buf[i] = digits[d]
      i = i + 1
    }
  }

  if human_readable {
    buf[i] = suffix
    i = i + 1
  }
  buf[i] = 0
}

// Print a single entry
fn print_entry(size: u64, path: *u8) {
  var size_buf: [u8; 16]
  format_size(size, &size_buf)

  // Right-align size in 8 character field
  var len: u32 = 0
  while size_buf[len] != 0 { len = len + 1 }

  var spaces: u32 = 0
  while spaces < 8 - len {
    foundation.serial_write_char(' ')
    spaces = spaces + 1
  }

  foundation.serial_write_string(&size_buf[0])
  foundation.serial_write_string("\t")
  foundation.serial_write_string(path)
  foundation.serial_write_string("\n")
}

// Recursively scan directory and print sizes
fn du_scan_directory(path: u64, depth: u32): u64 {
  var total: u64 = 0

  // Get file type
  var file_type: u32 = filesystem.vfs_get_type(path)

  if file_type == 1 {
    // Regular file
    var size: u64 = filesystem.vfs_get_size(path)
    total = size

    if show_all and depth <= max_depth {
      print_entry(size, @ptrFromInt(path))
    }
  } else if file_type == 2 {
    // Directory
    var entries: [filesystem.DirEntryInfo; 256]
    var count: u32 = filesystem.vfs_readdir(path, &entries, 256)

    var i: u32 = 0
    while i < count {
      // Build child path (simplified - just use entry name)
      var child_size: u64 = entries[i].size

      if entries[i].file_type == 2 {
        // Recursively scan subdirectory
        // In full implementation, would build full path
        child_size = du_scan_directory(@ptrFromInt(&entries[i].name), depth + 1)
      }

      total = total + child_size

      if show_all and depth + 1 <= max_depth {
        print_entry(child_size, &entries[i].name[0])
      }

      i = i + 1
    }

    // Print directory total
    if !summarize and depth <= max_depth {
      print_entry(total, @ptrFromInt(path))
    }
  }

  return total
}

export fn du_main(path: u64) {
  foundation.serial_write_string("\n=== Disk Usage (du) ===\n\n")

  var path_str: *u8 = @ptrFromInt(path)
  if path_str[0] == 0 {
    path_str = "/"
    path = @ptrFromInt(path_str)
  }

  var total: u64 = du_scan_directory(path, 0)

  if summarize {
    print_entry(total, @ptrFromInt(path))
  }

  foundation.serial_write_string("\n")
}

// Parse a number from string
fn parse_number(s: *u8): u32 {
  var result: u32 = 0
  var i: u32 = 0
  while s[i] != 0 {
    if s[i] >= '0' and s[i] <= '9' {
      result = result * 10 + @as(u32, s[i] - '0')
    } else {
      break
    }
    i = i + 1
  }
  return result
}

// Compare strings up to n characters
fn strncmp(a: *u8, b: *u8, n: u32): bool {
  var i: u32 = 0
  while i < n {
    if a[i] != b[i] { return false }
    if a[i] == 0 { return true }
    i = i + 1
  }
  return true
}

// Main entry with arguments
export fn du_main_args(argc: u32, argv: *[*u8; 16]) {
  // Reset flags to defaults
  show_all = false
  human_readable = true
  summarize = false
  max_depth = 0xFFFFFFFF

  // Parse arguments
  var path: u64 = @ptrFromInt("/")

  var i: u32 = 1
  while i < argc {
    var arg: *u8 = argv[i]

    if arg[0] == '-' {
      if arg[1] == 'a' {
        show_all = true
      } else if arg[1] == 'h' {
        human_readable = true
      } else if arg[1] == 'H' {
        // SI units (1000-based instead of 1024)
        human_readable = true
      } else if arg[1] == 's' {
        summarize = true
      } else if arg[1] == 'b' {
        // Apparent size in bytes
        human_readable = false
      } else if arg[1] == 'c' {
        // Produce grand total (would need separate tracking)
        summarize = true
      } else if arg[1] == 'd' {
        // -d N is equivalent to --max-depth=N
        if i + 1 < argc {
          i = i + 1
          max_depth = parse_number(argv[i])
        }
      } else if arg[1] == '-' {
        // Long options
        if strncmp(&arg[2], "max-depth=", 10) {
          // Parse number after '='
          max_depth = parse_number(&arg[12])
        } else if strncmp(&arg[2], "all", 3) {
          show_all = true
        } else if strncmp(&arg[2], "summarize", 9) {
          summarize = true
        } else if strncmp(&arg[2], "human-readable", 14) {
          human_readable = true
        } else if strncmp(&arg[2], "bytes", 5) {
          human_readable = false
        } else if strncmp(&arg[2], "help", 4) {
          print_usage()
          return
        }
      }
    } else {
      path = @ptrFromInt(arg)
    }

    i = i + 1
  }

  du_main(path)
}

// Print usage information
fn print_usage() {
  foundation.serial_write_string("\nUsage: du [OPTION]... [FILE]...\n")
  foundation.serial_write_string("Summarize disk usage of files and directories.\n\n")
  foundation.serial_write_string("Options:\n")
  foundation.serial_write_string("  -a, --all            show all files, not just directories\n")
  foundation.serial_write_string("  -b, --bytes          print sizes in bytes\n")
  foundation.serial_write_string("  -h, --human-readable print sizes in human readable format\n")
  foundation.serial_write_string("  -s, --summarize      display only a total for each argument\n")
  foundation.serial_write_string("  -d N, --max-depth=N  print total for directory only if N or fewer\n")
  foundation.serial_write_string("                       levels below command line argument\n")
  foundation.serial_write_string("  --help               display this help and exit\n")
  foundation.serial_write_string("\n")
}

// Main entry point for standalone execution
export fn main(): i32 {
  var default_path: []u8 = "/"
  du_main(@ptrFromInt(&default_path[0]))
  return 0
}
