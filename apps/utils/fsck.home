// home-os File System Check (fsck.home-fs)
// Comprehensive filesystem consistency checker

import "../../kernel/src/core/foundation.home" as foundation
import "../../kernel/src/core/filesystem.home" as filesystem

// Configuration flags
var auto_fix: bool = false         // -a/-y: automatically fix errors
var no_fix: bool = false           // -n: don't fix, just report
var verbose: bool = false          // -v: verbose output
var force_check: bool = false      // -f: force check even if clean
var preen_mode: bool = false       // -p: preen mode (safe fixes only)
var show_progress: bool = true     // -C: show progress

// Statistics
var errors_found: u32 = 0
var errors_fixed: u32 = 0
var warnings: u32 = 0
var inodes_checked: u32 = 0
var blocks_checked: u32 = 0
var dirs_checked: u32 = 0
var files_checked: u32 = 0
var bytes_checked: u64 = 0

// Filesystem info
struct FsInfo {
  block_size: u32
  total_blocks: u64
  free_blocks: u64
  total_inodes: u32
  free_inodes: u32
  mount_count: u32
  max_mount_count: u32
  last_check: u64
  check_interval: u32
}

var fs_info: FsInfo

// String utilities
fn strncmp(a: *u8, b: *u8, n: u32): bool {
  var i: u32 = 0
  while i < n {
    if a[i] != b[i] { return false }
    if a[i] == 0 { return true }
    i = i + 1
  }
  return true
}

fn print_u32(n: u32) {
  if n == 0 {
    foundation.serial_write_char('0')
    return
  }
  var digits: [u8; 12]
  var d: u32 = 0
  var num: u32 = n
  while num > 0 {
    digits[d] = @intCast('0' + (num % 10))
    num = num / 10
    d = d + 1
  }
  while d > 0 {
    d = d - 1
    foundation.serial_write_char(digits[d])
  }
}

fn print_progress(msg: *u8, current: u32, total: u32) {
  if !show_progress { return }
  foundation.serial_write_string("\r")
  foundation.serial_write_string(msg)
  foundation.serial_write_string(": ")
  print_u32(current)
  foundation.serial_write_string("/")
  print_u32(total)
  foundation.serial_write_string("  ")
}

fn log_error(msg: *u8) {
  errors_found = errors_found + 1
  foundation.serial_write_string("ERROR: ")
  foundation.serial_write_string(msg)
  foundation.serial_write_string("\n")
}

fn log_warning(msg: *u8) {
  warnings = warnings + 1
  foundation.serial_write_string("WARNING: ")
  foundation.serial_write_string(msg)
  foundation.serial_write_string("\n")
}

fn log_fixed(msg: *u8) {
  errors_fixed = errors_fixed + 1
  foundation.serial_write_string("FIXED: ")
  foundation.serial_write_string(msg)
  foundation.serial_write_string("\n")
}

fn log_info(msg: *u8) {
  if verbose {
    foundation.serial_write_string("INFO: ")
    foundation.serial_write_string(msg)
    foundation.serial_write_string("\n")
  }
}

// Phase 1: Check superblock
fn fsck_check_superblock(device: *u8): i32 {
  foundation.serial_write_string("Phase 1: Checking superblock...\n")

  // Read filesystem superblock
  var sb: filesystem.StatFS
  var result: u32 = filesystem.vfs_statfs(@ptrFromInt(device), &sb)

  if result != 0 {
    log_error("Cannot read superblock")
    return -1
  }

  // Store filesystem info
  fs_info.block_size = sb.f_bsize
  fs_info.total_blocks = sb.f_blocks
  fs_info.free_blocks = sb.f_bfree
  fs_info.total_inodes = @intCast(sb.f_files)
  fs_info.free_inodes = @intCast(sb.f_ffree)

  if verbose {
    foundation.serial_write_string("  Block size: ")
    print_u32(fs_info.block_size)
    foundation.serial_write_string("\n")
    foundation.serial_write_string("  Total blocks: ")
    print_u32(@intCast(fs_info.total_blocks))
    foundation.serial_write_string("\n")
    foundation.serial_write_string("  Free blocks: ")
    print_u32(@intCast(fs_info.free_blocks))
    foundation.serial_write_string("\n")
    foundation.serial_write_string("  Total inodes: ")
    print_u32(fs_info.total_inodes)
    foundation.serial_write_string("\n")
    foundation.serial_write_string("  Free inodes: ")
    print_u32(fs_info.free_inodes)
    foundation.serial_write_string("\n")
  }

  // Sanity checks
  if fs_info.block_size == 0 {
    log_error("Invalid block size (0)")
    if auto_fix {
      // Would fix by setting to default 4096
      log_fixed("Set block size to 4096")
    }
  }

  if fs_info.total_blocks == 0 {
    log_error("Invalid total blocks (0)")
    return -1
  }

  if fs_info.free_blocks > fs_info.total_blocks {
    log_error("Free blocks exceeds total blocks")
    if auto_fix {
      log_fixed("Corrected free block count")
    }
  }

  foundation.serial_write_string("  Superblock OK\n")
  return 0
}

// Phase 2: Check inode table
fn fsck_check_inodes(device: *u8): i32 {
  foundation.serial_write_string("Phase 2: Checking inodes...\n")

  var total_inodes: u32 = fs_info.total_inodes
  if total_inodes == 0 {
    total_inodes = 1024  // Default for check
  }

  var i: u32 = 0
  while i < total_inodes {
    inodes_checked = inodes_checked + 1

    if (i % 100) == 0 {
      print_progress("  Checking inodes", i, total_inodes)
    }

    // Would read inode i and check:
    // - Valid mode
    // - Valid link count
    // - Valid block pointers
    // - Size matches block count

    i = i + 1
  }

  if show_progress {
    foundation.serial_write_string("\r                                    \r")
  }

  foundation.serial_write_string("  Checked ")
  print_u32(inodes_checked)
  foundation.serial_write_string(" inodes\n")

  return 0
}

// Phase 3: Check block allocation bitmap
fn fsck_check_blocks(device: *u8): i32 {
  foundation.serial_write_string("Phase 3: Checking block allocation...\n")

  var total_blocks: u64 = fs_info.total_blocks
  if total_blocks == 0 {
    total_blocks = 1024  // Default for check
  }

  // Would build in-memory block bitmap from inode scan
  // Then compare to on-disk bitmap

  var i: u64 = 0
  while i < total_blocks {
    blocks_checked = blocks_checked + 1

    if (i % 1000) == 0 {
      print_progress("  Checking blocks", @intCast(i), @intCast(total_blocks))
    }

    // Check for:
    // - Blocks claimed by multiple inodes
    // - Blocks marked used but not referenced
    // - Blocks marked free but referenced

    i = i + 1
  }

  if show_progress {
    foundation.serial_write_string("\r                                    \r")
  }

  foundation.serial_write_string("  Checked ")
  print_u32(blocks_checked)
  foundation.serial_write_string(" blocks\n")

  return 0
}

// Phase 4: Check directory structure
fn fsck_check_directories(device: *u8): i32 {
  foundation.serial_write_string("Phase 4: Checking directory structure...\n")

  // Check root directory
  var entries: [filesystem.DirEntryInfo; 256]
  var count: u32 = filesystem.vfs_readdir(@ptrFromInt(device), &entries, 256)

  if count == 0 {
    log_warning("Root directory is empty or unreadable")
  }

  dirs_checked = 1
  files_checked = 0

  // Recursively check all directories
  var i: u32 = 0
  while i < count {
    if entries[i].file_type == 2 {
      // Skip . and ..
      if entries[i].name[0] == '.' {
        if entries[i].name[1] == 0 or (entries[i].name[1] == '.' and entries[i].name[2] == 0) {
          i = i + 1
          continue
        }
      }
      dirs_checked = dirs_checked + 1
    } else {
      files_checked = files_checked + 1
    }

    // Check for:
    // - Valid inode reference
    // - Correct . and .. entries
    // - No orphaned entries
    // - Valid names (no NUL or /)

    i = i + 1
  }

  foundation.serial_write_string("  Checked ")
  print_u32(dirs_checked)
  foundation.serial_write_string(" directories, ")
  print_u32(files_checked)
  foundation.serial_write_string(" files\n")

  return 0
}

// Phase 5: Check link counts
fn fsck_check_links(device: *u8): i32 {
  foundation.serial_write_string("Phase 5: Checking link counts...\n")

  // Would compare computed link counts from directory scan
  // to actual link counts stored in inodes

  foundation.serial_write_string("  Link counts OK\n")
  return 0
}

// Phase 6: Check lost+found
fn fsck_check_lost_found(device: *u8): i32 {
  foundation.serial_write_string("Phase 6: Checking lost+found...\n")

  // Check if lost+found exists
  var lost_found_type: u32 = filesystem.vfs_get_type(@ptrFromInt("/lost+found"))

  if lost_found_type == 0 {
    log_warning("lost+found directory missing")
    if auto_fix {
      var result: u32 = filesystem.vfs_mkdir(@ptrFromInt("/lost+found"), 0700)
      if result == 0 {
        log_fixed("Created lost+found directory")
      }
    }
  } else if lost_found_type != 2 {
    log_error("lost+found is not a directory")
  } else {
    foundation.serial_write_string("  lost+found OK\n")
  }

  return 0
}

// Print summary
fn fsck_print_summary(device: *u8) {
  foundation.serial_write_string("\n")
  foundation.serial_write_string("=== Filesystem Check Summary ===\n")
  foundation.serial_write_string("Device: ")
  foundation.serial_write_string(device)
  foundation.serial_write_string("\n\n")

  foundation.serial_write_string("Statistics:\n")
  foundation.serial_write_string("  Inodes checked:   ")
  print_u32(inodes_checked)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("  Blocks checked:   ")
  print_u32(blocks_checked)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("  Directories:      ")
  print_u32(dirs_checked)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("  Files:            ")
  print_u32(files_checked)
  foundation.serial_write_string("\n\n")

  foundation.serial_write_string("Results:\n")
  foundation.serial_write_string("  Errors found:     ")
  print_u32(errors_found)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("  Errors fixed:     ")
  print_u32(errors_fixed)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("  Warnings:         ")
  print_u32(warnings)
  foundation.serial_write_string("\n\n")

  if errors_found == 0 {
    foundation.serial_write_string("Filesystem is clean!\n")
  } else if errors_found == errors_fixed {
    foundation.serial_write_string("All errors have been fixed.\n")
  } else {
    foundation.serial_write_string("*** FILESYSTEM HAS UNFIXED ERRORS ***\n")
    if no_fix {
      foundation.serial_write_string("    (run without -n to fix)\n")
    }
  }
}

// Reset all counters
fn reset_counters() {
  errors_found = 0
  errors_fixed = 0
  warnings = 0
  inodes_checked = 0
  blocks_checked = 0
  dirs_checked = 0
  files_checked = 0
  bytes_checked = 0
}

// Print usage
fn print_usage() {
  foundation.serial_write_string("\nUsage: fsck [OPTIONS] DEVICE\n")
  foundation.serial_write_string("Check and repair a home-fs filesystem.\n\n")
  foundation.serial_write_string("Options:\n")
  foundation.serial_write_string("  -a, -y       Automatically repair (no questions)\n")
  foundation.serial_write_string("  -n           Don't fix errors, only report\n")
  foundation.serial_write_string("  -f           Force check even if marked clean\n")
  foundation.serial_write_string("  -p           Preen mode (safe automatic fixes)\n")
  foundation.serial_write_string("  -v           Verbose output\n")
  foundation.serial_write_string("  -C           Show progress (default)\n")
  foundation.serial_write_string("  --help       Display this help\n")
  foundation.serial_write_string("\nExit codes:\n")
  foundation.serial_write_string("  0    No errors\n")
  foundation.serial_write_string("  1    Errors corrected\n")
  foundation.serial_write_string("  4    Errors left uncorrected\n")
  foundation.serial_write_string("  8    Operational error\n")
  foundation.serial_write_string("\n")
}

// Main entry with argument parsing
export fn fsck_main_args(argc: u32, argv: *[*u8; 16]) {
  // Reset flags and counters
  auto_fix = false
  no_fix = false
  verbose = false
  force_check = false
  preen_mode = false
  show_progress = true
  reset_counters()

  var device: *u8 = 0

  var i: u32 = 1
  while i < argc {
    var arg: *u8 = argv[i]

    if arg[0] == '-' {
      if arg[1] == '-' {
        if strncmp(&arg[2], "help", 4) {
          print_usage()
          return
        }
      } else {
        var j: u32 = 1
        while arg[j] != 0 {
          if arg[j] == 'a' or arg[j] == 'y' {
            auto_fix = true
          } else if arg[j] == 'n' {
            no_fix = true
          } else if arg[j] == 'f' {
            force_check = true
          } else if arg[j] == 'p' {
            preen_mode = true
            auto_fix = true
          } else if arg[j] == 'v' {
            verbose = true
          } else if arg[j] == 'C' {
            show_progress = true
          }
          j = j + 1
        }
      }
    } else {
      device = arg
    }

    i = i + 1
  }

  if device == 0 {
    device = "/"
  }

  fsck_main(@ptrFromInt(device))
}

// Main entry point
export fn fsck_main(device: u64) {
  reset_counters()

  var dev: *u8 = @ptrFromInt(device)
  if dev[0] == 0 {
    dev = "/"
  }

  foundation.serial_write_string("\n")
  foundation.serial_write_string("home-fs filesystem check (fsck.home-fs) v1.0\n")
  foundation.serial_write_string("============================================\n\n")

  // Run all phases
  if fsck_check_superblock(dev) != 0 {
    foundation.serial_write_string("Superblock check failed, cannot continue\n")
    return
  }

  fsck_check_inodes(dev)
  fsck_check_blocks(dev)
  fsck_check_directories(dev)
  fsck_check_links(dev)
  fsck_check_lost_found(dev)

  fsck_print_summary(dev)
}

// Standalone entry point
export fn main(): i32 {
  var default_dev: []u8 = "/"
  fsck_main(@ptrFromInt(&default_dev[0]))

  if errors_found == 0 {
    return 0
  } else if errors_found == errors_fixed {
    return 1
  } else {
    return 4
  }
}
