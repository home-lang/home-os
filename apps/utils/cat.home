// home-os Cat
// Concatenate and display files with full option support

import "../../kernel/src/core/foundation.home" as foundation
import "../../kernel/src/core/filesystem.home" as filesystem

// Configuration flags
var number_lines: bool = false        // -n: number all output lines
var number_nonblank: bool = false     // -b: number non-blank lines only
var show_ends: bool = false           // -E: display $ at end of each line
var show_tabs: bool = false           // -T: display TAB as ^I
var squeeze_blank: bool = false       // -s: suppress repeated empty lines
var show_nonprinting: bool = false    // -v: show non-printing characters

// Print line number
fn print_line_number(num: u32) {
  // Right-align in 6-character field
  var digits: [u8; 10]
  var d: u32 = 0
  var n: u32 = num

  if n == 0 {
    digits[0] = '0'
    d = 1
  } else {
    while n > 0 {
      digits[d] = @intCast('0' + (n % 10))
      n = n / 10
      d = d + 1
    }
  }

  // Print padding
  var spaces: u32 = 0
  while spaces < 6 - d {
    foundation.serial_write_char(' ')
    spaces = spaces + 1
  }

  // Print number (reversed)
  while d > 0 {
    d = d - 1
    foundation.serial_write_char(digits[d])
  }

  foundation.serial_write_string("  ")
}

// Display a single character, handling special cases
fn display_char(c: u8) {
  if show_tabs and c == '\t' {
    foundation.serial_write_string("^I")
  } else if show_nonprinting and c < 32 and c != '\n' and c != '\t' {
    foundation.serial_write_char('^')
    foundation.serial_write_char(@intCast(c + 64))
  } else if show_nonprinting and c == 127 {
    foundation.serial_write_string("^?")
  } else if show_nonprinting and c > 127 {
    foundation.serial_write_string("M-")
    if c < 160 {
      foundation.serial_write_char('^')
      foundation.serial_write_char(@intCast(c - 64))
    } else {
      foundation.serial_write_char(@intCast(c - 128))
    }
  } else {
    foundation.serial_write_char(c)
  }
}

// Cat a single file
fn cat_file(path: *u8): i32 {
  var fd: u32 = filesystem.vfs_open(@ptrFromInt(path), 0)
  if fd == 0 {
    foundation.serial_write_string("cat: ")
    foundation.serial_write_string(path)
    foundation.serial_write_string(": No such file or directory\n")
    return -1
  }

  var buffer: [u8; 4096]
  var line_num: u32 = 1
  var at_line_start: bool = true
  var prev_blank: bool = false
  var total_read: u64 = 0

  // Read file in chunks
  while true {
    var bytes: u64 = filesystem.vfs_read(fd, @ptrFromInt(&buffer[0]), 4096)
    if bytes == 0 { break }

    var i: u64 = 0
    while i < bytes {
      var c: u8 = buffer[i]

      // Check for blank line (newline at start of line)
      if c == '\n' and at_line_start {
        if squeeze_blank and prev_blank {
          i = i + 1
          continue
        }
        prev_blank = true

        // Print line number for blank lines if -n (but not -b)
        if number_lines and !number_nonblank {
          print_line_number(line_num)
          line_num = line_num + 1
        }

        if show_ends {
          foundation.serial_write_char('$')
        }
        foundation.serial_write_char('\n')
        at_line_start = true
        i = i + 1
        continue
      }

      prev_blank = false

      // Print line number at start of line
      if at_line_start {
        if number_lines or number_nonblank {
          print_line_number(line_num)
          line_num = line_num + 1
        }
        at_line_start = false
      }

      // Handle end of line
      if c == '\n' {
        if show_ends {
          foundation.serial_write_char('$')
        }
        foundation.serial_write_char('\n')
        at_line_start = true
      } else {
        display_char(c)
      }

      i = i + 1
    }

    total_read = total_read + bytes
  }

  filesystem.vfs_close(fd)
  return 0
}

// String comparison
fn strncmp(a: *u8, b: *u8, n: u32): bool {
  var i: u32 = 0
  while i < n {
    if a[i] != b[i] { return false }
    if a[i] == 0 { return true }
    i = i + 1
  }
  return true
}

// Print usage
fn print_usage() {
  foundation.serial_write_string("\nUsage: cat [OPTION]... [FILE]...\n")
  foundation.serial_write_string("Concatenate FILE(s) to standard output.\n\n")
  foundation.serial_write_string("Options:\n")
  foundation.serial_write_string("  -A, --show-all       equivalent to -vET\n")
  foundation.serial_write_string("  -b, --number-nonblank  number non-blank output lines\n")
  foundation.serial_write_string("  -e                   equivalent to -vE\n")
  foundation.serial_write_string("  -E, --show-ends      display $ at end of each line\n")
  foundation.serial_write_string("  -n, --number         number all output lines\n")
  foundation.serial_write_string("  -s, --squeeze-blank  suppress repeated empty output lines\n")
  foundation.serial_write_string("  -t                   equivalent to -vT\n")
  foundation.serial_write_string("  -T, --show-tabs      display TAB characters as ^I\n")
  foundation.serial_write_string("  -v, --show-nonprinting  use ^ and M- notation\n")
  foundation.serial_write_string("  --help               display this help and exit\n")
  foundation.serial_write_string("\nWith no FILE, or when FILE is -, read standard input.\n")
  foundation.serial_write_string("\n")
}

// Reset flags
fn reset_flags() {
  number_lines = false
  number_nonblank = false
  show_ends = false
  show_tabs = false
  squeeze_blank = false
  show_nonprinting = false
}

// Main entry with argument parsing
export fn cat_main_args(argc: u32, argv: *[*u8; 16]) {
  reset_flags()

  var files: [*u8; 16]
  var file_count: u32 = 0

  var i: u32 = 1
  while i < argc {
    var arg: *u8 = argv[i]

    if arg[0] == '-' and arg[1] != 0 {
      if arg[1] == '-' {
        // Long options
        if strncmp(&arg[2], "number-nonblank", 15) {
          number_nonblank = true
        } else if strncmp(&arg[2], "number", 6) {
          number_lines = true
        } else if strncmp(&arg[2], "show-ends", 9) {
          show_ends = true
        } else if strncmp(&arg[2], "show-tabs", 9) {
          show_tabs = true
        } else if strncmp(&arg[2], "squeeze-blank", 13) {
          squeeze_blank = true
        } else if strncmp(&arg[2], "show-nonprinting", 16) {
          show_nonprinting = true
        } else if strncmp(&arg[2], "show-all", 8) {
          show_nonprinting = true
          show_ends = true
          show_tabs = true
        } else if strncmp(&arg[2], "help", 4) {
          print_usage()
          return
        }
      } else {
        // Short options - can be combined
        var j: u32 = 1
        while arg[j] != 0 {
          if arg[j] == 'A' {
            show_nonprinting = true
            show_ends = true
            show_tabs = true
          } else if arg[j] == 'b' {
            number_nonblank = true
          } else if arg[j] == 'e' {
            show_nonprinting = true
            show_ends = true
          } else if arg[j] == 'E' {
            show_ends = true
          } else if arg[j] == 'n' {
            number_lines = true
          } else if arg[j] == 's' {
            squeeze_blank = true
          } else if arg[j] == 't' {
            show_nonprinting = true
            show_tabs = true
          } else if arg[j] == 'T' {
            show_tabs = true
          } else if arg[j] == 'v' {
            show_nonprinting = true
          }
          j = j + 1
        }
      }
    } else {
      // File argument
      if file_count < 16 {
        files[file_count] = arg
        file_count = file_count + 1
      }
    }

    i = i + 1
  }

  // -b overrides -n
  if number_nonblank {
    number_lines = false
  }

  // No files means read stdin (not supported yet)
  if file_count == 0 {
    foundation.serial_write_string("cat: reading from stdin not supported\n")
    return
  }

  // Cat all files
  i = 0
  while i < file_count {
    cat_file(files[i])
    i = i + 1
  }
}

// Simple entry point for backward compatibility
export fn cat_main(file: u64) {
  reset_flags()

  var path: *u8 = @ptrFromInt(file)
  if path[0] == 0 {
    foundation.serial_write_string("cat: missing file operand\n")
    return
  }

  cat_file(path)
}

// Main entry point for standalone execution
export fn main(): i32 {
  foundation.serial_write_string("cat: missing file operand\n")
  foundation.serial_write_string("Try 'cat --help' for more information.\n")
  return 1
}
