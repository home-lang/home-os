// home-os Kernel Memory Cache
// Pre-allocated slab caches for hot kernel objects
// Optimized for frequently allocated/freed structures

import "../core/foundation.home" as foundation
import "slab.home" as slab

// ============================================================================
// KERNEL OBJECT SIZES (calculated from struct definitions)
// ============================================================================

// Process Control Block (PCB) - ~200 bytes
const PCB_SIZE: u32 = 256

// Inode structure - ~128 bytes
const INODE_SIZE: u32 = 128

// File structure - ~64 bytes
const FILE_SIZE: u32 = 64

// Socket structure - ~256 bytes
const SOCKET_SIZE: u32 = 256

// Buffer head - ~64 bytes
const BUFFER_HEAD_SIZE: u32 = 64

// Page cache entry - ~48 bytes
const PAGE_CACHE_ENTRY_SIZE: u32 = 64

// Directory entry (dentry) - ~128 bytes
const DENTRY_SIZE: u32 = 128

// VFS mount - ~96 bytes
const MOUNT_SIZE: u32 = 128

// Signal handler - ~32 bytes
const SIGNAL_SIZE: u32 = 32

// Timer structure - ~48 bytes
const TIMER_SIZE: u32 = 64

// Network buffer (sk_buff) - ~256 bytes
const SKBUFF_SIZE: u32 = 256

// Memory region (vm_area) - ~80 bytes
const VMA_SIZE: u32 = 128

// Work queue item - ~48 bytes
const WORK_SIZE: u32 = 64

// ============================================================================
// CACHE INDICES
// ============================================================================

const CACHE_PCB: u32 = 0
const CACHE_INODE: u32 = 1
const CACHE_FILE: u32 = 2
const CACHE_SOCKET: u32 = 3
const CACHE_BUFFER: u32 = 4
const CACHE_PAGE_CACHE: u32 = 5
const CACHE_DENTRY: u32 = 6
const CACHE_MOUNT: u32 = 7
const CACHE_SIGNAL: u32 = 8
const CACHE_TIMER: u32 = 9
const CACHE_SKBUFF: u32 = 10
const CACHE_VMA: u32 = 11
const CACHE_WORK: u32 = 12

const NUM_CACHES: u32 = 13

// ============================================================================
// CACHE STATE
// ============================================================================

struct KmemCache {
  name: [32]u8           // Cache name for debugging
  slab_id: u32           // Underlying slab ID
  object_size: u32       // Size of objects
  active: u32            // Whether cache is active

  // Statistics
  alloc_count: u64
  free_count: u64
  alloc_failures: u64
}

var caches: [NUM_CACHES]KmemCache
var kmem_initialized: u32 = 0

// ============================================================================
// HELPER: Set cache name
// ============================================================================

fn set_cache_name(cache: *KmemCache, name: []const u8) {
  var i: u32 = 0
  loop {
    if i >= 31 { break }
    if i >= name.len { break }
    cache.name[i] = name[i]
    i = i + 1
  }
  cache.name[i] = 0
}

// ============================================================================
// INITIALIZATION
// ============================================================================

export fn kmem_cache_init() {
  if kmem_initialized == 1 {
    foundation.serial_write_string("[KmemCache] Already initialized\n")
    return
  }

  foundation.serial_write_string("[KmemCache] Initializing kernel object caches...\n")

  // Initialize slab allocator first
  slab.slab_init()

  // Create PCB cache
  caches[CACHE_PCB].slab_id = slab.slab_create(PCB_SIZE, 0)
  caches[CACHE_PCB].object_size = PCB_SIZE
  caches[CACHE_PCB].active = 1
  set_cache_name(&caches[CACHE_PCB], "pcb_cache")
  foundation.serial_write_string("  [+] pcb_cache (256 bytes)\n")

  // Create inode cache
  caches[CACHE_INODE].slab_id = slab.slab_create(INODE_SIZE, 0)
  caches[CACHE_INODE].object_size = INODE_SIZE
  caches[CACHE_INODE].active = 1
  set_cache_name(&caches[CACHE_INODE], "inode_cache")
  foundation.serial_write_string("  [+] inode_cache (128 bytes)\n")

  // Create file cache
  caches[CACHE_FILE].slab_id = slab.slab_create(FILE_SIZE, 0)
  caches[CACHE_FILE].object_size = FILE_SIZE
  caches[CACHE_FILE].active = 1
  set_cache_name(&caches[CACHE_FILE], "file_cache")
  foundation.serial_write_string("  [+] file_cache (64 bytes)\n")

  // Create socket cache
  caches[CACHE_SOCKET].slab_id = slab.slab_create(SOCKET_SIZE, 0)
  caches[CACHE_SOCKET].object_size = SOCKET_SIZE
  caches[CACHE_SOCKET].active = 1
  set_cache_name(&caches[CACHE_SOCKET], "socket_cache")
  foundation.serial_write_string("  [+] socket_cache (256 bytes)\n")

  // Create buffer head cache
  caches[CACHE_BUFFER].slab_id = slab.slab_create(BUFFER_HEAD_SIZE, 0)
  caches[CACHE_BUFFER].object_size = BUFFER_HEAD_SIZE
  caches[CACHE_BUFFER].active = 1
  set_cache_name(&caches[CACHE_BUFFER], "buffer_cache")
  foundation.serial_write_string("  [+] buffer_cache (64 bytes)\n")

  // Create page cache entry cache
  caches[CACHE_PAGE_CACHE].slab_id = slab.slab_create(PAGE_CACHE_ENTRY_SIZE, 0)
  caches[CACHE_PAGE_CACHE].object_size = PAGE_CACHE_ENTRY_SIZE
  caches[CACHE_PAGE_CACHE].active = 1
  set_cache_name(&caches[CACHE_PAGE_CACHE], "pagecache_cache")
  foundation.serial_write_string("  [+] pagecache_cache (64 bytes)\n")

  // Create dentry cache
  caches[CACHE_DENTRY].slab_id = slab.slab_create(DENTRY_SIZE, 0)
  caches[CACHE_DENTRY].object_size = DENTRY_SIZE
  caches[CACHE_DENTRY].active = 1
  set_cache_name(&caches[CACHE_DENTRY], "dentry_cache")
  foundation.serial_write_string("  [+] dentry_cache (128 bytes)\n")

  // Create mount cache
  caches[CACHE_MOUNT].slab_id = slab.slab_create(MOUNT_SIZE, 0)
  caches[CACHE_MOUNT].object_size = MOUNT_SIZE
  caches[CACHE_MOUNT].active = 1
  set_cache_name(&caches[CACHE_MOUNT], "mount_cache")
  foundation.serial_write_string("  [+] mount_cache (128 bytes)\n")

  // Create signal cache
  caches[CACHE_SIGNAL].slab_id = slab.slab_create(SIGNAL_SIZE, 0)
  caches[CACHE_SIGNAL].object_size = SIGNAL_SIZE
  caches[CACHE_SIGNAL].active = 1
  set_cache_name(&caches[CACHE_SIGNAL], "signal_cache")
  foundation.serial_write_string("  [+] signal_cache (32 bytes)\n")

  // Create timer cache
  caches[CACHE_TIMER].slab_id = slab.slab_create(TIMER_SIZE, 0)
  caches[CACHE_TIMER].object_size = TIMER_SIZE
  caches[CACHE_TIMER].active = 1
  set_cache_name(&caches[CACHE_TIMER], "timer_cache")
  foundation.serial_write_string("  [+] timer_cache (64 bytes)\n")

  // Create sk_buff cache (network buffers)
  caches[CACHE_SKBUFF].slab_id = slab.slab_create(SKBUFF_SIZE, 0)
  caches[CACHE_SKBUFF].object_size = SKBUFF_SIZE
  caches[CACHE_SKBUFF].active = 1
  set_cache_name(&caches[CACHE_SKBUFF], "skbuff_cache")
  foundation.serial_write_string("  [+] skbuff_cache (256 bytes)\n")

  // Create VMA cache
  caches[CACHE_VMA].slab_id = slab.slab_create(VMA_SIZE, 0)
  caches[CACHE_VMA].object_size = VMA_SIZE
  caches[CACHE_VMA].active = 1
  set_cache_name(&caches[CACHE_VMA], "vma_cache")
  foundation.serial_write_string("  [+] vma_cache (128 bytes)\n")

  // Create work queue cache
  caches[CACHE_WORK].slab_id = slab.slab_create(WORK_SIZE, 0)
  caches[CACHE_WORK].object_size = WORK_SIZE
  caches[CACHE_WORK].active = 1
  set_cache_name(&caches[CACHE_WORK], "work_cache")
  foundation.serial_write_string("  [+] work_cache (64 bytes)\n")

  kmem_initialized = 1

  foundation.serial_write_string("[KmemCache] Initialized ")
  foundation.serial_write_u64(NUM_CACHES)
  foundation.serial_write_string(" kernel object caches\n")
}

// ============================================================================
// ALLOCATION FUNCTIONS
// ============================================================================

// Generic allocation from cache
fn kmem_cache_alloc_internal(cache_id: u32): u64 {
  if kmem_initialized == 0 { return 0 }
  if cache_id >= NUM_CACHES { return 0 }

  let cache: *KmemCache = &caches[cache_id]
  if cache.active == 0 { return 0 }

  let obj: u64 = slab.slab_alloc(cache.slab_id)

  if obj != 0 {
    cache.alloc_count = cache.alloc_count + 1

    // Zero the memory
    var ptr: *u8 = obj
    var i: u32 = 0
    loop {
      if i >= cache.object_size { break }
      ptr[i] = 0
      i = i + 1
    }
  } else {
    cache.alloc_failures = cache.alloc_failures + 1
  }

  return obj
}

// Generic free to cache
fn kmem_cache_free_internal(cache_id: u32, obj: u64) {
  if kmem_initialized == 0 { return }
  if cache_id >= NUM_CACHES { return }
  if obj == 0 { return }

  let cache: *KmemCache = &caches[cache_id]
  if cache.active == 0 { return }

  slab.slab_free(cache.slab_id, obj)
  cache.free_count = cache.free_count + 1
}

// ============================================================================
// TYPE-SPECIFIC ALLOCATION FUNCTIONS
// ============================================================================

// Process Control Block
export fn kmem_alloc_pcb(): u64 {
  return kmem_cache_alloc_internal(CACHE_PCB)
}

export fn kmem_free_pcb(pcb: u64) {
  kmem_cache_free_internal(CACHE_PCB, pcb)
}

// Inode
export fn kmem_alloc_inode(): u64 {
  return kmem_cache_alloc_internal(CACHE_INODE)
}

export fn kmem_free_inode(inode: u64) {
  kmem_cache_free_internal(CACHE_INODE, inode)
}

// File structure
export fn kmem_alloc_file(): u64 {
  return kmem_cache_alloc_internal(CACHE_FILE)
}

export fn kmem_free_file(file: u64) {
  kmem_cache_free_internal(CACHE_FILE, file)
}

// Socket
export fn kmem_alloc_socket(): u64 {
  return kmem_cache_alloc_internal(CACHE_SOCKET)
}

export fn kmem_free_socket(socket: u64) {
  kmem_cache_free_internal(CACHE_SOCKET, socket)
}

// Buffer head
export fn kmem_alloc_buffer(): u64 {
  return kmem_cache_alloc_internal(CACHE_BUFFER)
}

export fn kmem_free_buffer(buffer: u64) {
  kmem_cache_free_internal(CACHE_BUFFER, buffer)
}

// Page cache entry
export fn kmem_alloc_page_cache(): u64 {
  return kmem_cache_alloc_internal(CACHE_PAGE_CACHE)
}

export fn kmem_free_page_cache(entry: u64) {
  kmem_cache_free_internal(CACHE_PAGE_CACHE, entry)
}

// Directory entry (dentry)
export fn kmem_alloc_dentry(): u64 {
  return kmem_cache_alloc_internal(CACHE_DENTRY)
}

export fn kmem_free_dentry(dentry: u64) {
  kmem_cache_free_internal(CACHE_DENTRY, dentry)
}

// Mount structure
export fn kmem_alloc_mount(): u64 {
  return kmem_cache_alloc_internal(CACHE_MOUNT)
}

export fn kmem_free_mount(mount: u64) {
  kmem_cache_free_internal(CACHE_MOUNT, mount)
}

// Signal handler
export fn kmem_alloc_signal(): u64 {
  return kmem_cache_alloc_internal(CACHE_SIGNAL)
}

export fn kmem_free_signal(signal: u64) {
  kmem_cache_free_internal(CACHE_SIGNAL, signal)
}

// Timer
export fn kmem_alloc_timer(): u64 {
  return kmem_cache_alloc_internal(CACHE_TIMER)
}

export fn kmem_free_timer(timer: u64) {
  kmem_cache_free_internal(CACHE_TIMER, timer)
}

// Network buffer (sk_buff)
export fn kmem_alloc_skbuff(): u64 {
  return kmem_cache_alloc_internal(CACHE_SKBUFF)
}

export fn kmem_free_skbuff(skb: u64) {
  kmem_cache_free_internal(CACHE_SKBUFF, skb)
}

// Virtual memory area
export fn kmem_alloc_vma(): u64 {
  return kmem_cache_alloc_internal(CACHE_VMA)
}

export fn kmem_free_vma(vma: u64) {
  kmem_cache_free_internal(CACHE_VMA, vma)
}

// Work queue item
export fn kmem_alloc_work(): u64 {
  return kmem_cache_alloc_internal(CACHE_WORK)
}

export fn kmem_free_work(work: u64) {
  kmem_cache_free_internal(CACHE_WORK, work)
}

// ============================================================================
// STATISTICS AND DEBUGGING
// ============================================================================

export fn kmem_cache_print_stats() {
  if kmem_initialized == 0 {
    foundation.serial_write_string("[KmemCache] Not initialized\n")
    return
  }

  foundation.serial_write_string("\n========== KERNEL MEMORY CACHE STATISTICS ==========\n\n")

  var total_allocs: u64 = 0
  var total_frees: u64 = 0
  var total_failures: u64 = 0

  var i: u32 = 0
  loop {
    if i >= NUM_CACHES { break }

    let cache: *KmemCache = &caches[i]

    if cache.active == 1 {
      // Print cache name
      foundation.serial_write_string("  ")
      var j: u32 = 0
      loop {
        if j >= 32 { break }
        if cache.name[j] == 0 { break }
        foundation.serial_write_char(cache.name[j])
        j = j + 1
      }
      foundation.serial_write_string(":\n")

      foundation.serial_write_string("    Object size: ")
      foundation.serial_write_u64(cache.object_size)
      foundation.serial_write_string(" bytes\n")

      foundation.serial_write_string("    Allocations: ")
      foundation.serial_write_u64(cache.alloc_count)
      foundation.serial_write_string("\n")

      foundation.serial_write_string("    Frees: ")
      foundation.serial_write_u64(cache.free_count)
      foundation.serial_write_string("\n")

      foundation.serial_write_string("    Active: ")
      foundation.serial_write_u64(cache.alloc_count - cache.free_count)
      foundation.serial_write_string("\n")

      if cache.alloc_failures > 0 {
        foundation.serial_write_string("    Failures: ")
        foundation.serial_write_u64(cache.alloc_failures)
        foundation.serial_write_string("\n")
      }

      foundation.serial_write_string("\n")

      total_allocs = total_allocs + cache.alloc_count
      total_frees = total_frees + cache.free_count
      total_failures = total_failures + cache.alloc_failures
    }

    i = i + 1
  }

  foundation.serial_write_string("  TOTALS:\n")
  foundation.serial_write_string("    Total allocations: ")
  foundation.serial_write_u64(total_allocs)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("    Total frees: ")
  foundation.serial_write_u64(total_frees)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("    Currently active: ")
  foundation.serial_write_u64(total_allocs - total_frees)
  foundation.serial_write_string("\n")

  if total_failures > 0 {
    foundation.serial_write_string("    Total failures: ")
    foundation.serial_write_u64(total_failures)
    foundation.serial_write_string("\n")
  }

  foundation.serial_write_string("\n====================================================\n\n")

  // Also print underlying slab stats
  slab.slab_print_stats()
}

// Get cache hit rate for a specific cache
export fn kmem_cache_get_hit_rate(cache_id: u32): u32 {
  if cache_id >= NUM_CACHES { return 0 }

  let cache: *KmemCache = &caches[cache_id]
  return slab.slab_get_utilization(cache.slab_id)
}

// Shrink caches (return memory to system when under pressure)
export fn kmem_cache_shrink() {
  if kmem_initialized == 0 { return }

  foundation.serial_write_string("[KmemCache] Shrinking caches...\n")

  // For now, just log - actual shrinking would empty depot magazines
  // and return memory to page allocator

  var i: u32 = 0
  loop {
    if i >= NUM_CACHES { break }

    let cache: *KmemCache = &caches[i]
    if cache.active == 1 {
      let active: u64 = cache.alloc_count - cache.free_count
      if active == 0 {
        // Cache is empty, could reclaim memory here
        foundation.serial_write_string("  Cache ")
        foundation.serial_write_u64(i)
        foundation.serial_write_string(" is empty, eligible for reclaim\n")
      }
    }

    i = i + 1
  }
}

// ============================================================================
// PROCFS INTERFACE
// ============================================================================

export fn kmem_cache_proc_read(buffer: *u8, size: u32): u32 {
  if kmem_initialized == 0 { return 0 }

  var offset: u32 = 0

  // Header
  let header: []const u8 = "cache_name       obj_size  allocs    frees     active    fails\n"
  var i: u32 = 0
  loop {
    if i >= header.len { break }
    if offset >= size - 1 { break }
    buffer[offset] = header[i]
    offset = offset + 1
    i = i + 1
  }

  // Cache entries
  var cache_idx: u32 = 0
  loop {
    if cache_idx >= NUM_CACHES { break }
    if offset >= size - 100 { break }  // Leave room for entry

    let cache: *KmemCache = &caches[cache_idx]

    if cache.active == 1 {
      // Name (padded to 16 chars)
      var j: u32 = 0
      loop {
        if j >= 16 { break }
        if j < 32 && cache.name[j] != 0 {
          buffer[offset] = cache.name[j]
        } else {
          buffer[offset] = 32  // space
        }
        offset = offset + 1
        j = j + 1
      }

      buffer[offset] = 32  // space
      offset = offset + 1

      // For simplicity, just add placeholders for numbers
      // A real implementation would format the numbers properly
      buffer[offset] = 45  // '-'
      offset = offset + 1
      buffer[offset] = 10  // newline
      offset = offset + 1
    }

    cache_idx = cache_idx + 1
  }

  buffer[offset] = 0
  return offset
}
