// home-os Memory Cgroups
// Memory resource control

import "../core/foundation.home" as foundation

const MAX_MEMCG: u32 = 32

struct MemoryCgroup {
  name: [u8; 64],
  limit: u64,
  usage: u64,
  in_use: u32
}

var memcgroups: [MemoryCgroup; 32]
var memcg_count: u32 = 0

export fn memcg_init() {
  memcg_count = 0
  foundation.serial_write_string("[MemCG] Memory cgroups initialized\n")
}

export fn memcg_create(name: u64, limit: u64) -> u32 {
  if memcg_count >= MAX_MEMCG { return 0xFFFFFFFF }
  
  var i: u32 = 0
  while i < 64 {
    memcgroups[memcg_count].name[i] = @intToPtr(name + i, u8)
    if memcgroups[memcg_count].name[i] == 0 { break }
    i = i + 1
  }
  
  memcgroups[memcg_count].limit = limit
  memcgroups[memcg_count].usage = 0
  memcgroups[memcg_count].in_use = 1
  
  var id: u32 = memcg_count
  memcg_count = memcg_count + 1
  
  return id
}

export fn memcg_charge(cgroup_id: u32, size: u64) -> u32 {
  if cgroup_id >= memcg_count { return 1 }
  
  if memcgroups[cgroup_id].usage + size > memcgroups[cgroup_id].limit {
    return 1  // Would exceed limit
  }
  
  memcgroups[cgroup_id].usage = memcgroups[cgroup_id].usage + size
  return 0
}

export fn memcg_uncharge(cgroup_id: u32, size: u64) {
  if cgroup_id >= memcg_count { return }
  
  if memcgroups[cgroup_id].usage >= size {
    memcgroups[cgroup_id].usage = memcgroups[cgroup_id].usage - size
  }
}

export fn memcg_get_usage(cgroup_id: u32) -> u64 {
  if cgroup_id >= memcg_count { return 0 }
  return memcgroups[cgroup_id].usage
}
