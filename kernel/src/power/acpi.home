// home-os ACPI (Advanced Configuration and Power Interface)
// ACPI table parsing, namespace, and power management

import "../core/types"
import "../mm/memory"
import "../sync/spinlock"

// =============================================================================
// ACPI Table Signatures
// =============================================================================

const RSDP_SIGNATURE: [u8; 8] = *b"RSD PTR "
const RSDT_SIGNATURE: [u8; 4] = *b"RSDT"
const XSDT_SIGNATURE: [u8; 4] = *b"XSDT"
const FADT_SIGNATURE: [u8; 4] = *b"FACP"
const MADT_SIGNATURE: [u8; 4] = *b"APIC"
const HPET_SIGNATURE: [u8; 4] = *b"HPET"
const MCFG_SIGNATURE: [u8; 4] = *b"MCFG"
const DSDT_SIGNATURE: [u8; 4] = *b"DSDT"
const SSDT_SIGNATURE: [u8; 4] = *b"SSDT"
const BGRT_SIGNATURE: [u8; 4] = *b"BGRT"
const SRAT_SIGNATURE: [u8; 4] = *b"SRAT"
const SLIT_SIGNATURE: [u8; 4] = *b"SLIT"
const DMAR_SIGNATURE: [u8; 4] = *b"DMAR"
const BERT_SIGNATURE: [u8; 4] = *b"BERT"
const EINJ_SIGNATURE: [u8; 4] = *b"EINJ"
const ERST_SIGNATURE: [u8; 4] = *b"ERST"
const HEST_SIGNATURE: [u8; 4] = *b"HEST"

// =============================================================================
// ACPI Structures
// =============================================================================

// Root System Description Pointer (RSDP)
#[repr(C, packed)]
struct RSDP {
    signature: [u8; 8],
    checksum: u8,
    oem_id: [u8; 6],
    revision: u8,
    rsdt_address: u32,
    // ACPI 2.0+ fields
    length: u32,
    xsdt_address: u64,
    extended_checksum: u8,
    reserved: [u8; 3],
}

// Standard ACPI Table Header
#[repr(C, packed)]
struct ACPITableHeader {
    signature: [u8; 4],
    length: u32,
    revision: u8,
    checksum: u8,
    oem_id: [u8; 6],
    oem_table_id: [u8; 8],
    oem_revision: u32,
    creator_id: u32,
    creator_revision: u32,
}

// Root System Description Table (RSDT)
#[repr(C, packed)]
struct RSDT {
    header: ACPITableHeader,
    // Followed by array of 32-bit physical addresses
}

// Extended System Description Table (XSDT)
#[repr(C, packed)]
struct XSDT {
    header: ACPITableHeader,
    // Followed by array of 64-bit physical addresses
}

// Fixed ACPI Description Table (FADT)
#[repr(C, packed)]
struct FADT {
    header: ACPITableHeader,
    firmware_ctrl: u32,
    dsdt: u32,
    reserved1: u8,
    preferred_pm_profile: u8,
    sci_int: u16,
    smi_cmd: u32,
    acpi_enable: u8,
    acpi_disable: u8,
    s4bios_req: u8,
    pstate_cnt: u8,
    pm1a_evt_blk: u32,
    pm1b_evt_blk: u32,
    pm1a_cnt_blk: u32,
    pm1b_cnt_blk: u32,
    pm2_cnt_blk: u32,
    pm_tmr_blk: u32,
    gpe0_blk: u32,
    gpe1_blk: u32,
    pm1_evt_len: u8,
    pm1_cnt_len: u8,
    pm2_cnt_len: u8,
    pm_tmr_len: u8,
    gpe0_blk_len: u8,
    gpe1_blk_len: u8,
    gpe1_base: u8,
    cst_cnt: u8,
    p_lvl2_lat: u16,
    p_lvl3_lat: u16,
    flush_size: u16,
    flush_stride: u16,
    duty_offset: u8,
    duty_width: u8,
    day_alrm: u8,
    mon_alrm: u8,
    century: u8,
    iapc_boot_arch: u16,
    reserved2: u8,
    flags: u32,
    reset_reg: GenericAddress,
    reset_value: u8,
    arm_boot_arch: u16,
    fadt_minor_version: u8,
    x_firmware_ctrl: u64,
    x_dsdt: u64,
    x_pm1a_evt_blk: GenericAddress,
    x_pm1b_evt_blk: GenericAddress,
    x_pm1a_cnt_blk: GenericAddress,
    x_pm1b_cnt_blk: GenericAddress,
    x_pm2_cnt_blk: GenericAddress,
    x_pm_tmr_blk: GenericAddress,
    x_gpe0_blk: GenericAddress,
    x_gpe1_blk: GenericAddress,
    sleep_control_reg: GenericAddress,
    sleep_status_reg: GenericAddress,
    hypervisor_vendor_id: u64,
}

// Generic Address Structure
#[repr(C, packed)]
struct GenericAddress {
    address_space_id: u8,
    register_bit_width: u8,
    register_bit_offset: u8,
    access_size: u8,
    address: u64,
}

// Address Space IDs
const ADDR_SPACE_SYSTEM_MEMORY: u8 = 0
const ADDR_SPACE_SYSTEM_IO: u8 = 1
const ADDR_SPACE_PCI_CONFIG: u8 = 2
const ADDR_SPACE_EMBEDDED_CTRL: u8 = 3
const ADDR_SPACE_SMBUS: u8 = 4
const ADDR_SPACE_PLATFORM_COMM: u8 = 10
const ADDR_SPACE_FUNCTIONAL_FIXED: u8 = 127

// Multiple APIC Description Table (MADT)
#[repr(C, packed)]
struct MADT {
    header: ACPITableHeader,
    local_apic_address: u32,
    flags: u32,
    // Followed by interrupt controller structures
}

// MADT Entry Types
const MADT_TYPE_LOCAL_APIC: u8 = 0
const MADT_TYPE_IO_APIC: u8 = 1
const MADT_TYPE_INT_SOURCE_OVERRIDE: u8 = 2
const MADT_TYPE_NMI_SOURCE: u8 = 3
const MADT_TYPE_LOCAL_APIC_NMI: u8 = 4
const MADT_TYPE_LOCAL_APIC_OVERRIDE: u8 = 5
const MADT_TYPE_IO_SAPIC: u8 = 6
const MADT_TYPE_LOCAL_SAPIC: u8 = 7
const MADT_TYPE_PLATFORM_INT_SOURCES: u8 = 8
const MADT_TYPE_LOCAL_X2APIC: u8 = 9
const MADT_TYPE_LOCAL_X2APIC_NMI: u8 = 10
const MADT_TYPE_GIC: u8 = 11
const MADT_TYPE_GICD: u8 = 12
const MADT_TYPE_GIC_MSI: u8 = 13
const MADT_TYPE_GIC_REDISTR: u8 = 14
const MADT_TYPE_GIC_ITS: u8 = 15

// MADT Entry Header
#[repr(C, packed)]
struct MADTEntryHeader {
    entry_type: u8,
    length: u8,
}

// Local APIC Entry
#[repr(C, packed)]
struct MADTLocalAPIC {
    header: MADTEntryHeader,
    acpi_processor_id: u8,
    apic_id: u8,
    flags: u32,
}

// I/O APIC Entry
#[repr(C, packed)]
struct MADTIoAPIC {
    header: MADTEntryHeader,
    io_apic_id: u8,
    reserved: u8,
    io_apic_address: u32,
    global_system_interrupt_base: u32,
}

// Interrupt Source Override
#[repr(C, packed)]
struct MADTIntSourceOverride {
    header: MADTEntryHeader,
    bus: u8,
    source: u8,
    global_system_interrupt: u32,
    flags: u16,
}

// HPET Table
#[repr(C, packed)]
struct HPET {
    header: ACPITableHeader,
    hardware_rev_id: u8,
    comparator_count: u8,  // bits 0-4
    counter_size: u8,      // bit 5
    reserved: u8,
    legacy_replacement: u8,
    pci_vendor_id: u16,
    address: GenericAddress,
    hpet_number: u8,
    minimum_tick: u16,
    page_protection: u8,
}

// MCFG (PCI Express configuration)
#[repr(C, packed)]
struct MCFG {
    header: ACPITableHeader,
    reserved: u64,
    // Followed by configuration space allocations
}

#[repr(C, packed)]
struct MCFGAllocation {
    base_address: u64,
    segment_group: u16,
    start_bus: u8,
    end_bus: u8,
    reserved: u32,
}

// =============================================================================
// FADT Flags
// =============================================================================

const FADT_WBINVD: u32 = 1 << 0
const FADT_WBINVD_FLUSH: u32 = 1 << 1
const FADT_PROC_C1: u32 = 1 << 2
const FADT_P_LVL2_UP: u32 = 1 << 3
const FADT_PWR_BUTTON: u32 = 1 << 4
const FADT_SLP_BUTTON: u32 = 1 << 5
const FADT_FIX_RTC: u32 = 1 << 6
const FADT_RTC_S4: u32 = 1 << 7
const FADT_TMR_VAL_EXT: u32 = 1 << 8
const FADT_DCK_CAP: u32 = 1 << 9
const FADT_RESET_REG_SUP: u32 = 1 << 10
const FADT_SEALED_CASE: u32 = 1 << 11
const FADT_HEADLESS: u32 = 1 << 12
const FADT_CPU_SW_SLP: u32 = 1 << 13
const FADT_PCI_EXP_WAK: u32 = 1 << 14
const FADT_USE_PLATFORM_CLOCK: u32 = 1 << 15
const FADT_S4_RTC_STS_VALID: u32 = 1 << 16
const FADT_REMOTE_POWER_ON: u32 = 1 << 17
const FADT_APIC_CLUSTER: u32 = 1 << 18
const FADT_APIC_PHYSICAL: u32 = 1 << 19
const FADT_HW_REDUCED: u32 = 1 << 20
const FADT_LOW_POWER_S0: u32 = 1 << 21

// =============================================================================
// Sleep States
// =============================================================================

enum SleepState {
    S0 = 0,     // Working
    S1 = 1,     // Sleeping with CPU context maintained
    S2 = 2,     // Sleeping with CPU context lost
    S3 = 3,     // Suspend to RAM
    S4 = 4,     // Suspend to Disk (Hibernation)
    S5 = 5,     // Soft Off
}

// PM1 Control Register Bits
const PM1_CNT_SCI_EN: u16 = 1 << 0
const PM1_CNT_BM_RLD: u16 = 1 << 1
const PM1_CNT_GBL_RLS: u16 = 1 << 2
const PM1_CNT_SLP_TYP_SHIFT: u16 = 10
const PM1_CNT_SLP_TYP_MASK: u16 = 0x7 << 10
const PM1_CNT_SLP_EN: u16 = 1 << 13

// PM1 Status Register Bits
const PM1_STS_TMR: u16 = 1 << 0
const PM1_STS_BM: u16 = 1 << 4
const PM1_STS_GBL: u16 = 1 << 5
const PM1_STS_PWRBTN: u16 = 1 << 8
const PM1_STS_SLPBTN: u16 = 1 << 9
const PM1_STS_RTC: u16 = 1 << 10
const PM1_STS_PCIEXP_WAKE: u16 = 1 << 14
const PM1_STS_WAK: u16 = 1 << 15

// =============================================================================
// ACPI State
// =============================================================================

const MAX_CPUS: usize = 256
const MAX_IO_APICS: usize = 8
const MAX_INT_OVERRIDES: usize = 32
const MAX_TABLES: usize = 64

struct CPUInfo {
    acpi_id: u8,
    apic_id: u8,
    enabled: bool,
}

struct IoAPICInfo {
    id: u8,
    address: u32,
    gsi_base: u32,
}

struct IntOverride {
    bus: u8,
    source: u8,
    gsi: u32,
    flags: u16,
}

struct ACPIState {
    // RSDP location
    rsdp_addr: u64,
    revision: u8,

    // Table pointers
    rsdt_addr: u64,
    xsdt_addr: u64,
    fadt_addr: u64,
    madt_addr: u64,
    dsdt_addr: u64,
    hpet_addr: u64,
    mcfg_addr: u64,

    // Parsed table addresses
    tables: [u64; MAX_TABLES],
    table_count: usize,

    // CPU information from MADT
    cpus: [CPUInfo; MAX_CPUS],
    cpu_count: usize,

    // I/O APIC information
    io_apics: [IoAPICInfo; MAX_IO_APICS],
    io_apic_count: usize,

    // Interrupt source overrides
    int_overrides: [IntOverride; MAX_INT_OVERRIDES],
    int_override_count: usize,

    // Local APIC address
    local_apic_addr: u64,

    // HPET info
    hpet_addr_phys: u64,
    hpet_present: bool,

    // PCIe configuration space
    pcie_base: u64,
    pcie_segment: u16,
    pcie_start_bus: u8,
    pcie_end_bus: u8,

    // Power management info
    sci_interrupt: u16,
    pm1a_evt_blk: u32,
    pm1b_evt_blk: u32,
    pm1a_cnt_blk: u32,
    pm1b_cnt_blk: u32,
    pm_tmr_blk: u32,
    gpe0_blk: u32,
    gpe1_blk: u32,
    pm1_evt_len: u8,
    pm1_cnt_len: u8,
    pm_tmr_len: u8,

    // Sleep state support
    sleep_type_a: [u8; 6],
    sleep_type_b: [u8; 6],

    // Flags
    hw_reduced: bool,
    low_power_s0: bool,

    lock: Spinlock,
}

static mut ACPI: ACPIState = ACPIState {
    rsdp_addr: 0,
    revision: 0,
    rsdt_addr: 0,
    xsdt_addr: 0,
    fadt_addr: 0,
    madt_addr: 0,
    dsdt_addr: 0,
    hpet_addr: 0,
    mcfg_addr: 0,
    tables: [0u64; MAX_TABLES],
    table_count: 0,
    cpus: [CPUInfo { acpi_id: 0, apic_id: 0, enabled: false }; MAX_CPUS],
    cpu_count: 0,
    io_apics: [IoAPICInfo { id: 0, address: 0, gsi_base: 0 }; MAX_IO_APICS],
    io_apic_count: 0,
    int_overrides: [IntOverride { bus: 0, source: 0, gsi: 0, flags: 0 }; MAX_INT_OVERRIDES],
    int_override_count: 0,
    local_apic_addr: 0xFEE00000,
    hpet_addr_phys: 0,
    hpet_present: false,
    pcie_base: 0,
    pcie_segment: 0,
    pcie_start_bus: 0,
    pcie_end_bus: 0,
    sci_interrupt: 0,
    pm1a_evt_blk: 0,
    pm1b_evt_blk: 0,
    pm1a_cnt_blk: 0,
    pm1b_cnt_blk: 0,
    pm_tmr_blk: 0,
    gpe0_blk: 0,
    gpe1_blk: 0,
    pm1_evt_len: 0,
    pm1_cnt_len: 0,
    pm_tmr_len: 0,
    sleep_type_a: [0u8; 6],
    sleep_type_b: [0u8; 6],
    hw_reduced: false,
    low_power_s0: false,
    lock: Spinlock::new(),
}

// =============================================================================
// Memory Access
// =============================================================================

fn read_u8(addr: u64): u8 {
    unsafe { *(addr as *const u8) }
}

fn read_u16(addr: u64): u16 {
    unsafe { *(addr as *const u16) }
}

fn read_u32(addr: u64): u32 {
    unsafe { *(addr as *const u32) }
}

fn read_u64(addr: u64): u64 {
    unsafe { *(addr as *const u64) }
}

fn write_u8(addr: u64, val: u8) {
    unsafe { *(addr as *mut u8) = val }
}

fn write_u16(addr: u64, val: u16) {
    unsafe { *(addr as *mut u16) = val }
}

fn write_u32(addr: u64, val: u32) {
    unsafe { *(addr as *mut u32) = val }
}

// I/O port access
fn inb(port: u16): u8 {
    let val: u8
    asm!("inb %dx, %al", out("al") val, in("dx") port)
    return val
}

fn inw(port: u16): u16 {
    let val: u16
    asm!("inw %dx, %ax", out("ax") val, in("dx") port)
    return val
}

fn inl(port: u16): u32 {
    let val: u32
    asm!("inl %dx, %eax", out("eax") val, in("dx") port)
    return val
}

fn outb(port: u16, val: u8) {
    asm!("outb %al, %dx", in("al") val, in("dx") port)
}

fn outw(port: u16, val: u16) {
    asm!("outw %ax, %dx", in("ax") val, in("dx") port)
}

fn outl(port: u16, val: u32) {
    asm!("outl %eax, %dx", in("eax") val, in("dx") port)
}

// =============================================================================
// RSDP Discovery
// =============================================================================

// Find RSDP in BIOS memory regions
export fn acpi_find_rsdp(): u64 {
    // Search EBDA (Extended BIOS Data Area)
    let ebda_seg = read_u16(0x40E) as u64
    let ebda_addr = ebda_seg << 4

    if let Some(addr) = search_rsdp(ebda_addr, 1024) {
        return addr
    }

    // Search main BIOS area (0xE0000 - 0xFFFFF)
    if let Some(addr) = search_rsdp(0xE0000, 0x20000) {
        return addr
    }

    return 0
}

fn search_rsdp(start: u64, length: u64): Option<u64> {
    let mut addr = start
    while addr < start + length {
        if check_rsdp_signature(addr) {
            if validate_rsdp_checksum(addr) {
                return Some(addr)
            }
        }
        addr += 16  // RSDP is 16-byte aligned
    }
    return None
}

fn check_rsdp_signature(addr: u64): bool {
    for i in 0..8 {
        if read_u8(addr + i) != RSDP_SIGNATURE[i as usize] {
            return false
        }
    }
    return true
}

fn validate_rsdp_checksum(addr: u64): bool {
    // Checksum first 20 bytes for ACPI 1.0
    let mut sum: u8 = 0
    for i in 0..20 {
        sum = sum.wrapping_add(read_u8(addr + i))
    }

    if sum != 0 {
        return false
    }

    // For ACPI 2.0+, also check extended checksum
    let revision = read_u8(addr + 15)
    if revision >= 2 {
        let length = read_u32(addr + 20)
        sum = 0
        for i in 0..length as u64 {
            sum = sum.wrapping_add(read_u8(addr + i))
        }
        if sum != 0 {
            return false
        }
    }

    return true
}

// =============================================================================
// Table Parsing
// =============================================================================

fn validate_table_checksum(addr: u64): bool {
    let length = read_u32(addr + 4)
    let mut sum: u8 = 0
    for i in 0..length as u64 {
        sum = sum.wrapping_add(read_u8(addr + i))
    }
    return sum == 0
}

fn signature_matches(addr: u64, sig: &[u8; 4]): bool {
    for i in 0..4 {
        if read_u8(addr + i as u64) != sig[i] {
            return false
        }
    }
    return true
}

// =============================================================================
// ACPI Initialization
// =============================================================================

export fn acpi_init(): i32 {
    unsafe {
        ACPI.lock.init()
    }

    // Find RSDP
    let rsdp_addr = acpi_find_rsdp()
    if rsdp_addr == 0 {
        return -1  // No ACPI
    }

    unsafe {
        ACPI.rsdp_addr = rsdp_addr
        ACPI.revision = read_u8(rsdp_addr + 15)

        // Get RSDT/XSDT addresses
        ACPI.rsdt_addr = read_u32(rsdp_addr + 16) as u64

        if ACPI.revision >= 2 {
            ACPI.xsdt_addr = read_u64(rsdp_addr + 24)
        }
    }

    // Parse tables from XSDT (preferred) or RSDT
    unsafe {
        if ACPI.xsdt_addr != 0 {
            parse_xsdt()
        } else if ACPI.rsdt_addr != 0 {
            parse_rsdt()
        } else {
            return -2
        }
    }

    // Parse individual tables
    parse_fadt()
    parse_madt()
    parse_hpet()
    parse_mcfg()

    return 0
}

fn parse_rsdt() {
    unsafe {
        let rsdt_addr = ACPI.rsdt_addr
        if !validate_table_checksum(rsdt_addr) {
            return
        }

        let length = read_u32(rsdt_addr + 4)
        let entries = (length as usize - 36) / 4

        for i in 0..entries.min(MAX_TABLES) {
            let table_addr = read_u32(rsdt_addr + 36 + (i * 4) as u64) as u64
            if table_addr != 0 {
                ACPI.tables[ACPI.table_count] = table_addr
                ACPI.table_count += 1
                identify_table(table_addr)
            }
        }
    }
}

fn parse_xsdt() {
    unsafe {
        let xsdt_addr = ACPI.xsdt_addr
        if !validate_table_checksum(xsdt_addr) {
            return
        }

        let length = read_u32(xsdt_addr + 4)
        let entries = (length as usize - 36) / 8

        for i in 0..entries.min(MAX_TABLES) {
            let table_addr = read_u64(xsdt_addr + 36 + (i * 8) as u64)
            if table_addr != 0 {
                ACPI.tables[ACPI.table_count] = table_addr
                ACPI.table_count += 1
                identify_table(table_addr)
            }
        }
    }
}

fn identify_table(addr: u64) {
    unsafe {
        if signature_matches(addr, &FADT_SIGNATURE) {
            ACPI.fadt_addr = addr
        } else if signature_matches(addr, &MADT_SIGNATURE) {
            ACPI.madt_addr = addr
        } else if signature_matches(addr, &HPET_SIGNATURE) {
            ACPI.hpet_addr = addr
        } else if signature_matches(addr, &MCFG_SIGNATURE) {
            ACPI.mcfg_addr = addr
        } else if signature_matches(addr, &DSDT_SIGNATURE) {
            ACPI.dsdt_addr = addr
        }
    }
}

fn parse_fadt() {
    unsafe {
        if ACPI.fadt_addr == 0 {
            return
        }

        let fadt = ACPI.fadt_addr

        // Get DSDT address
        let dsdt = read_u64(fadt + 140)  // X_DSDT
        if dsdt != 0 {
            ACPI.dsdt_addr = dsdt
        } else {
            ACPI.dsdt_addr = read_u32(fadt + 40) as u64  // DSDT
        }

        // Power management blocks
        ACPI.sci_interrupt = read_u16(fadt + 46)
        ACPI.pm1a_evt_blk = read_u32(fadt + 56)
        ACPI.pm1b_evt_blk = read_u32(fadt + 60)
        ACPI.pm1a_cnt_blk = read_u32(fadt + 64)
        ACPI.pm1b_cnt_blk = read_u32(fadt + 68)
        ACPI.pm_tmr_blk = read_u32(fadt + 76)
        ACPI.gpe0_blk = read_u32(fadt + 80)
        ACPI.gpe1_blk = read_u32(fadt + 84)
        ACPI.pm1_evt_len = read_u8(fadt + 88)
        ACPI.pm1_cnt_len = read_u8(fadt + 89)
        ACPI.pm_tmr_len = read_u8(fadt + 91)

        // FADT flags
        let flags = read_u32(fadt + 112)
        ACPI.hw_reduced = (flags & FADT_HW_REDUCED) != 0
        ACPI.low_power_s0 = (flags & FADT_LOW_POWER_S0) != 0
    }
}

fn parse_madt() {
    unsafe {
        if ACPI.madt_addr == 0 {
            return
        }

        let madt = ACPI.madt_addr
        ACPI.local_apic_addr = read_u32(madt + 36) as u64

        let length = read_u32(madt + 4)
        let mut offset: u64 = 44  // After header + LAPIC address + flags

        while offset < length as u64 {
            let entry_type = read_u8(madt + offset)
            let entry_len = read_u8(madt + offset + 1) as u64

            match entry_type {
                MADT_TYPE_LOCAL_APIC => {
                    if ACPI.cpu_count < MAX_CPUS {
                        let acpi_id = read_u8(madt + offset + 2)
                        let apic_id = read_u8(madt + offset + 3)
                        let flags = read_u32(madt + offset + 4)

                        ACPI.cpus[ACPI.cpu_count] = CPUInfo {
                            acpi_id: acpi_id,
                            apic_id: apic_id,
                            enabled: (flags & 1) != 0 || (flags & 2) != 0,
                        }
                        ACPI.cpu_count += 1
                    }
                },
                MADT_TYPE_IO_APIC => {
                    if ACPI.io_apic_count < MAX_IO_APICS {
                        let id = read_u8(madt + offset + 2)
                        let address = read_u32(madt + offset + 4)
                        let gsi_base = read_u32(madt + offset + 8)

                        ACPI.io_apics[ACPI.io_apic_count] = IoAPICInfo {
                            id: id,
                            address: address,
                            gsi_base: gsi_base,
                        }
                        ACPI.io_apic_count += 1
                    }
                },
                MADT_TYPE_INT_SOURCE_OVERRIDE => {
                    if ACPI.int_override_count < MAX_INT_OVERRIDES {
                        let bus = read_u8(madt + offset + 2)
                        let source = read_u8(madt + offset + 3)
                        let gsi = read_u32(madt + offset + 4)
                        let flags = read_u16(madt + offset + 8)

                        ACPI.int_overrides[ACPI.int_override_count] = IntOverride {
                            bus: bus,
                            source: source,
                            gsi: gsi,
                            flags: flags,
                        }
                        ACPI.int_override_count += 1
                    }
                },
                MADT_TYPE_LOCAL_APIC_OVERRIDE => {
                    ACPI.local_apic_addr = read_u64(madt + offset + 4)
                },
                MADT_TYPE_LOCAL_X2APIC => {
                    if ACPI.cpu_count < MAX_CPUS {
                        let apic_id = read_u32(madt + offset + 4)
                        let flags = read_u32(madt + offset + 8)
                        let acpi_id = read_u32(madt + offset + 12)

                        ACPI.cpus[ACPI.cpu_count] = CPUInfo {
                            acpi_id: acpi_id as u8,
                            apic_id: apic_id as u8,
                            enabled: (flags & 1) != 0,
                        }
                        ACPI.cpu_count += 1
                    }
                },
                _ => {}
            }

            offset += entry_len
        }
    }
}

fn parse_hpet() {
    unsafe {
        if ACPI.hpet_addr == 0 {
            return
        }

        let hpet = ACPI.hpet_addr
        ACPI.hpet_addr_phys = read_u64(hpet + 44)
        ACPI.hpet_present = true
    }
}

fn parse_mcfg() {
    unsafe {
        if ACPI.mcfg_addr == 0 {
            return
        }

        let mcfg = ACPI.mcfg_addr
        let length = read_u32(mcfg + 4)

        if length >= 44 + 16 {
            // First allocation entry
            ACPI.pcie_base = read_u64(mcfg + 44)
            ACPI.pcie_segment = read_u16(mcfg + 52)
            ACPI.pcie_start_bus = read_u8(mcfg + 54)
            ACPI.pcie_end_bus = read_u8(mcfg + 55)
        }
    }
}

// =============================================================================
// Power Management
// =============================================================================

// Enable ACPI mode
export fn acpi_enable(): i32 {
    unsafe {
        if ACPI.fadt_addr == 0 {
            return -1
        }

        let smi_cmd = read_u32(ACPI.fadt_addr + 48)
        let acpi_enable = read_u8(ACPI.fadt_addr + 52)

        if smi_cmd == 0 || acpi_enable == 0 {
            // Already in ACPI mode or HW reduced
            return 0
        }

        // Check if already enabled
        let pm1a = ACPI.pm1a_cnt_blk as u16
        if (inw(pm1a) & PM1_CNT_SCI_EN) != 0 {
            return 0  // Already enabled
        }

        // Send ACPI enable command
        outb(smi_cmd as u16, acpi_enable)

        // Wait for SCI_EN to be set
        for _ in 0..1000 {
            if (inw(pm1a) & PM1_CNT_SCI_EN) != 0 {
                return 0
            }
            // Small delay
            for _ in 0..1000 {
                asm!("pause")
            }
        }

        return -2  // Timeout
    }
}

// Enter sleep state
export fn acpi_enter_sleep(state: SleepState): i32 {
    unsafe {
        if ACPI.hw_reduced {
            return acpi_enter_sleep_hw_reduced(state)
        }

        let slp_typ_a = ACPI.sleep_type_a[state as usize] as u16
        let slp_typ_b = ACPI.sleep_type_b[state as usize] as u16

        let pm1a_cnt = ACPI.pm1a_cnt_blk as u16
        let pm1b_cnt = ACPI.pm1b_cnt_blk as u16

        // Disable interrupts
        asm!("cli")

        // Clear wake status
        let pm1a_sts = ACPI.pm1a_evt_blk as u16
        outw(pm1a_sts, PM1_STS_WAK)
        if pm1b_cnt != 0 {
            let pm1b_sts = ACPI.pm1b_evt_blk as u16
            outw(pm1b_sts, PM1_STS_WAK)
        }

        // Write SLP_TYP and SLP_EN
        let val_a = (slp_typ_a << PM1_CNT_SLP_TYP_SHIFT) | PM1_CNT_SLP_EN
        outw(pm1a_cnt, val_a)

        if pm1b_cnt != 0 {
            let val_b = (slp_typ_b << PM1_CNT_SLP_TYP_SHIFT) | PM1_CNT_SLP_EN
            outw(pm1b_cnt, val_b)
        }

        // Wait for wake
        loop {
            asm!("hlt")
        }
    }
}

fn acpi_enter_sleep_hw_reduced(state: SleepState): i32 {
    // HW-reduced ACPI uses sleep control/status registers
    // TODO: Implement for modern systems
    return -1
}

// System reset
export fn acpi_reset(): ! {
    unsafe {
        if ACPI.fadt_addr == 0 {
            // Fallback: keyboard controller reset
            outb(0x64, 0xFE)
            loop { asm!("hlt") }
        }

        let flags = read_u32(ACPI.fadt_addr + 112)
        if (flags & FADT_RESET_REG_SUP) == 0 {
            // Reset not supported, try keyboard controller
            outb(0x64, 0xFE)
            loop { asm!("hlt") }
        }

        // Read reset register info
        let reset_reg_addr = read_u64(ACPI.fadt_addr + 116 + 4)
        let reset_reg_space = read_u8(ACPI.fadt_addr + 116)
        let reset_value = read_u8(ACPI.fadt_addr + 128)

        match reset_reg_space {
            ADDR_SPACE_SYSTEM_IO => {
                outb(reset_reg_addr as u16, reset_value)
            },
            ADDR_SPACE_SYSTEM_MEMORY => {
                write_u8(reset_reg_addr, reset_value)
            },
            ADDR_SPACE_PCI_CONFIG => {
                // PCI config space reset - complex, skip for now
            },
            _ => {}
        }

        loop { asm!("hlt") }
    }
}

// System shutdown (S5)
export fn acpi_shutdown(): ! {
    acpi_enter_sleep(SleepState::S5)
    loop { asm!("hlt") }
}

// =============================================================================
// Query Functions
// =============================================================================

export fn acpi_get_cpu_count(): usize {
    unsafe { ACPI.cpu_count }
}

export fn acpi_get_cpu_info(index: usize): Option<(u8, u8, bool)> {
    unsafe {
        if index >= ACPI.cpu_count {
            return None
        }
        let cpu = &ACPI.cpus[index]
        return Some((cpu.acpi_id, cpu.apic_id, cpu.enabled))
    }
}

export fn acpi_get_io_apic_count(): usize {
    unsafe { ACPI.io_apic_count }
}

export fn acpi_get_io_apic_info(index: usize): Option<(u8, u32, u32)> {
    unsafe {
        if index >= ACPI.io_apic_count {
            return None
        }
        let io_apic = &ACPI.io_apics[index]
        return Some((io_apic.id, io_apic.address, io_apic.gsi_base))
    }
}

export fn acpi_get_local_apic_addr(): u64 {
    unsafe { ACPI.local_apic_addr }
}

export fn acpi_get_hpet_addr(): Option<u64> {
    unsafe {
        if ACPI.hpet_present {
            return Some(ACPI.hpet_addr_phys)
        }
        return None
    }
}

export fn acpi_get_pcie_config(): Option<(u64, u16, u8, u8)> {
    unsafe {
        if ACPI.pcie_base != 0 {
            return Some((ACPI.pcie_base, ACPI.pcie_segment,
                        ACPI.pcie_start_bus, ACPI.pcie_end_bus))
        }
        return None
    }
}

export fn acpi_get_int_override(irq: u8): Option<(u32, u16)> {
    unsafe {
        for i in 0..ACPI.int_override_count {
            if ACPI.int_overrides[i].source == irq {
                return Some((ACPI.int_overrides[i].gsi, ACPI.int_overrides[i].flags))
            }
        }
        return None
    }
}

export fn acpi_get_sci_interrupt(): u16 {
    unsafe { ACPI.sci_interrupt }
}

export fn acpi_is_hw_reduced(): bool {
    unsafe { ACPI.hw_reduced }
}

// Find table by signature
export fn acpi_find_table(signature: &[u8; 4]): Option<u64> {
    unsafe {
        for i in 0..ACPI.table_count {
            if signature_matches(ACPI.tables[i], signature) {
                return Some(ACPI.tables[i])
            }
        }
        return None
    }
}
