// home-os Wake-on-Interrupt Support
// Enables system wake from sleep via GPIO, RTC, network, and other interrupt sources

import "../core/foundation.home" as foundation
import "../drivers/gpio.home" as gpio

// ============================================================================
// Wake Source Types
// ============================================================================

const WAKE_TYPE_GPIO: u8 = 0            // GPIO pin edge/level
const WAKE_TYPE_RTC_ALARM: u8 = 1       // RTC scheduled alarm
const WAKE_TYPE_RTC_PERIODIC: u8 = 2    // RTC periodic interrupt
const WAKE_TYPE_TIMER: u8 = 3           // Hardware timer
const WAKE_TYPE_UART_RX: u8 = 4         // UART receive activity
const WAKE_TYPE_USB_CONNECT: u8 = 5     // USB device connect/disconnect
const WAKE_TYPE_NETWORK: u8 = 6         // Wake-on-LAN (WoL)
const WAKE_TYPE_POWER_BUTTON: u8 = 7    // Power button press
const WAKE_TYPE_LID_OPEN: u8 = 8        // Laptop lid open
const WAKE_TYPE_ACCEL_MOTION: u8 = 9    // Accelerometer motion detect
const WAKE_TYPE_TOUCH: u8 = 10          // Touch screen activity
const WAKE_TYPE_VOLTAGE: u8 = 11        // Voltage threshold (battery)
const WAKE_TYPE_TEMPERATURE: u8 = 12    // Temperature threshold
const WAKE_TYPE_COMPARATOR: u8 = 13     // Analog comparator

// Wake trigger modes
const WAKE_TRIGGER_RISING: u8 = 0
const WAKE_TRIGGER_FALLING: u8 = 1
const WAKE_TRIGGER_BOTH_EDGES: u8 = 2
const WAKE_TRIGGER_LEVEL_HIGH: u8 = 3
const WAKE_TRIGGER_LEVEL_LOW: u8 = 4
const WAKE_TRIGGER_THRESHOLD_ABOVE: u8 = 5
const WAKE_TRIGGER_THRESHOLD_BELOW: u8 = 6

// Wake priority levels
const WAKE_PRIORITY_CRITICAL: u8 = 0    // Always wake (power button)
const WAKE_PRIORITY_HIGH: u8 = 1        // Important events
const WAKE_PRIORITY_NORMAL: u8 = 2      // Standard wake sources
const WAKE_PRIORITY_LOW: u8 = 3         // Optional wake sources

// Wake status
const WAKE_STATUS_DISABLED: u8 = 0
const WAKE_STATUS_ARMED: u8 = 1
const WAKE_STATUS_TRIGGERED: u8 = 2
const WAKE_STATUS_PENDING: u8 = 3

const MAX_WAKE_INTERRUPTS: u32 = 64
const MAX_WAKE_HANDLERS: u32 = 16

// ============================================================================
// Hardware Register Definitions (Architecture-specific)
// ============================================================================

// x86_64 ACPI wake registers
const ACPI_PM1_STS: u16 = 0x00          // PM1 Status
const ACPI_PM1_EN: u16 = 0x02           // PM1 Enable
const ACPI_GPE0_STS: u16 = 0x00         // GPE0 Status
const ACPI_GPE0_EN: u16 = 0x04          // GPE0 Enable

// ACPI PM1 status bits
const PM1_TMR_STS: u16 = 0x0001         // Timer status
const PM1_BM_STS: u16 = 0x0010          // Bus master status
const PM1_GBL_STS: u16 = 0x0020         // Global status
const PM1_PWRBTN_STS: u16 = 0x0100      // Power button status
const PM1_SLPBTN_STS: u16 = 0x0200      // Sleep button status
const PM1_RTC_STS: u16 = 0x0400         // RTC status
const PM1_WAK_STS: u16 = 0x8000         // Wake status

// ARM GIC wake registers
const GIC_DIST_ISENABLER: u32 = 0x100   // Interrupt Set-Enable
const GIC_DIST_ICENABLER: u32 = 0x180   // Interrupt Clear-Enable
const GIC_DIST_ISPENDR: u32 = 0x200     // Interrupt Set-Pending

// ============================================================================
// Data Structures
// ============================================================================

// Wake interrupt configuration
struct WakeInterrupt {
    wake_type: u8,
    trigger_mode: u8,
    priority: u8,
    status: u8,

    // Source identification
    source_id: u32,              // GPIO pin, IRQ number, etc.
    source_name: [u8; 32],

    // Trigger configuration
    threshold_value: i32,        // For analog/threshold triggers
    debounce_ms: u16,            // Debounce time

    // Handler
    handler: u64,                // Callback function
    handler_data: u64,           // User data for callback

    // Statistics
    trigger_count: u32,
    last_trigger_time: u64,
    false_trigger_count: u32,

    // Hardware config
    hw_irq: u32,                 // Hardware IRQ number
    hw_register: u64,            // Control register address
    hw_enable_bit: u8,

    active: u8
}

// Wake handler (post-wake processing)
struct WakeHandler {
    name: [u8; 32],
    priority: u8,
    handler: u64,
    user_data: u64,
    enabled: u8,
    active: u8
}

// Wake event record
struct WakeEvent {
    wake_type: u8,
    source_id: u32,
    timestamp: u64,
    sleep_duration_ms: u64,
    sleep_mode: u8,
    handled: u8
}

// Wake controller state
struct WakeController {
    initialized: u8,
    sleep_armed: u8,
    pending_wake: u8,
    last_wake_source: u8,
    last_wake_time: u64,

    // ACPI base addresses (x86)
    acpi_pm1_base: u16,
    acpi_gpe0_base: u16,

    // ARM GIC base (ARM64)
    gic_dist_base: u64,
    gic_cpu_base: u64,

    // Statistics
    total_wakes: u64,
    gpio_wakes: u32,
    rtc_wakes: u32,
    network_wakes: u32,
    button_wakes: u32,
    other_wakes: u32
}

// ============================================================================
// Global State
// ============================================================================

var wake_interrupts: [WakeInterrupt; 64]
var wake_interrupt_count: u32 = 0
var wake_handlers: [WakeHandler; 16]
var wake_handler_count: u32 = 0
var wake_controller: WakeController
var wake_event_log: [WakeEvent; 32]
var wake_event_index: u32 = 0

// ============================================================================
// Initialization
// ============================================================================

export fn wake_interrupt_init(): u32 {
    if wake_controller.initialized == 1 {
        return 1
    }

    // Clear interrupts
    var i: u32 = 0
    while i < MAX_WAKE_INTERRUPTS {
        wake_interrupts[i].active = 0
        wake_interrupts[i].status = WAKE_STATUS_DISABLED
        wake_interrupts[i].trigger_count = 0
        i = i + 1
    }

    // Clear handlers
    i = 0
    while i < MAX_WAKE_HANDLERS {
        wake_handlers[i].active = 0
        i = i + 1
    }

    // Clear event log
    i = 0
    while i < 32 {
        wake_event_log[i].handled = 1
        i = i + 1
    }

    // Initialize controller state
    wake_controller.sleep_armed = 0
    wake_controller.pending_wake = 0
    wake_controller.last_wake_source = 0xFF
    wake_controller.last_wake_time = 0
    wake_controller.total_wakes = 0
    wake_controller.gpio_wakes = 0
    wake_controller.rtc_wakes = 0
    wake_controller.network_wakes = 0
    wake_controller.button_wakes = 0
    wake_controller.other_wakes = 0

    // Detect and configure hardware
    detect_wake_hardware()

    wake_interrupt_count = 0
    wake_handler_count = 0
    wake_event_index = 0
    wake_controller.initialized = 1

    foundation.serial_write_string("[Wake-IRQ] Initialized\n")
    return 1
}

// Detect wake-capable hardware
fn detect_wake_hardware() {
    // Try to detect ACPI (x86)
    // In a real implementation, would read ACPI tables
    wake_controller.acpi_pm1_base = 0x0400  // Common default
    wake_controller.acpi_gpe0_base = 0x0420

    // For ARM, would detect GIC
    wake_controller.gic_dist_base = 0x08000000  // Common for ARM
    wake_controller.gic_cpu_base = 0x08010000
}

// ============================================================================
// GPIO Wake Configuration
// ============================================================================

// Register GPIO pin as wake source
export fn wake_register_gpio(pin: u32, trigger: u8, priority: u8, handler: u64): u32 {
    if wake_interrupt_count >= MAX_WAKE_INTERRUPTS {
        return 0xFFFFFFFF
    }

    var idx: u32 = wake_interrupt_count

    wake_interrupts[idx].wake_type = WAKE_TYPE_GPIO
    wake_interrupts[idx].trigger_mode = trigger
    wake_interrupts[idx].priority = priority
    wake_interrupts[idx].status = WAKE_STATUS_DISABLED
    wake_interrupts[idx].source_id = pin
    wake_interrupts[idx].threshold_value = 0
    wake_interrupts[idx].debounce_ms = 50  // 50ms default debounce
    wake_interrupts[idx].handler = handler
    wake_interrupts[idx].handler_data = 0
    wake_interrupts[idx].trigger_count = 0
    wake_interrupts[idx].last_trigger_time = 0
    wake_interrupts[idx].false_trigger_count = 0
    wake_interrupts[idx].active = 1

    // Configure GPIO for interrupt
    configure_gpio_wake(idx, pin, trigger)

    wake_interrupt_count = wake_interrupt_count + 1

    foundation.serial_write_string("[Wake-IRQ] GPIO wake registered: pin ")
    foundation.serial_write_hex(pin)
    foundation.serial_write_string("\n")

    return idx
}

// Configure GPIO hardware for wake
fn configure_gpio_wake(idx: u32, pin: u32, trigger: u8) {
    // Map trigger mode to GPIO interrupt mode
    var gpio_mode: u8 = gpio.GPIO_INT_NONE

    if trigger == WAKE_TRIGGER_RISING {
        gpio_mode = gpio.GPIO_INT_RISING
    } else if trigger == WAKE_TRIGGER_FALLING {
        gpio_mode = gpio.GPIO_INT_FALLING
    } else if trigger == WAKE_TRIGGER_BOTH_EDGES {
        gpio_mode = gpio.GPIO_INT_BOTH
    } else if trigger == WAKE_TRIGGER_LEVEL_HIGH {
        gpio_mode = gpio.GPIO_INT_LEVEL_HIGH
    } else if trigger == WAKE_TRIGGER_LEVEL_LOW {
        gpio_mode = gpio.GPIO_INT_LEVEL_LOW
    }

    // Store GPIO interrupt mode
    wake_interrupts[idx].hw_enable_bit = gpio_mode
}

// ============================================================================
// RTC Wake Configuration
// ============================================================================

// Register RTC alarm wake source
export fn wake_register_rtc_alarm(seconds_from_now: u32, handler: u64): u32 {
    if wake_interrupt_count >= MAX_WAKE_INTERRUPTS {
        return 0xFFFFFFFF
    }

    var idx: u32 = wake_interrupt_count

    wake_interrupts[idx].wake_type = WAKE_TYPE_RTC_ALARM
    wake_interrupts[idx].trigger_mode = 0
    wake_interrupts[idx].priority = WAKE_PRIORITY_HIGH
    wake_interrupts[idx].status = WAKE_STATUS_DISABLED
    wake_interrupts[idx].source_id = seconds_from_now
    wake_interrupts[idx].handler = handler
    wake_interrupts[idx].active = 1

    // Configure RTC alarm
    configure_rtc_alarm(seconds_from_now)

    wake_interrupt_count = wake_interrupt_count + 1

    foundation.serial_write_string("[Wake-IRQ] RTC alarm registered: ")
    foundation.serial_write_hex(seconds_from_now)
    foundation.serial_write_string(" seconds\n")

    return idx
}

// Register periodic RTC wake
export fn wake_register_rtc_periodic(interval_seconds: u32, handler: u64): u32 {
    if wake_interrupt_count >= MAX_WAKE_INTERRUPTS {
        return 0xFFFFFFFF
    }

    var idx: u32 = wake_interrupt_count

    wake_interrupts[idx].wake_type = WAKE_TYPE_RTC_PERIODIC
    wake_interrupts[idx].trigger_mode = 0
    wake_interrupts[idx].priority = WAKE_PRIORITY_NORMAL
    wake_interrupts[idx].status = WAKE_STATUS_DISABLED
    wake_interrupts[idx].source_id = interval_seconds
    wake_interrupts[idx].handler = handler
    wake_interrupts[idx].active = 1

    wake_interrupt_count = wake_interrupt_count + 1

    return idx
}

// Configure RTC alarm hardware
fn configure_rtc_alarm(seconds: u32) {
    // Would configure CMOS RTC or platform RTC here
    // For x86: Set alarm registers at 0x01, 0x03, 0x05
    // For ARM: Configure platform-specific RTC
}

// ============================================================================
// Network Wake (Wake-on-LAN)
// ============================================================================

// Register Wake-on-LAN
export fn wake_register_wol(mac_filter: u64, handler: u64): u32 {
    if wake_interrupt_count >= MAX_WAKE_INTERRUPTS {
        return 0xFFFFFFFF
    }

    var idx: u32 = wake_interrupt_count

    wake_interrupts[idx].wake_type = WAKE_TYPE_NETWORK
    wake_interrupts[idx].trigger_mode = 0
    wake_interrupts[idx].priority = WAKE_PRIORITY_NORMAL
    wake_interrupts[idx].status = WAKE_STATUS_DISABLED
    wake_interrupts[idx].source_id = 0
    wake_interrupts[idx].handler = handler
    wake_interrupts[idx].handler_data = mac_filter
    wake_interrupts[idx].active = 1

    // Configure network card for WoL
    configure_wol(mac_filter)

    wake_interrupt_count = wake_interrupt_count + 1

    foundation.serial_write_string("[Wake-IRQ] Wake-on-LAN registered\n")

    return idx
}

// Configure Wake-on-LAN
fn configure_wol(mac_filter: u64) {
    // Would configure NIC wake capabilities here
    // Enable magic packet detection
    // Set MAC address filter
}

// ============================================================================
// Power Button Wake
// ============================================================================

// Register power button wake
export fn wake_register_power_button(handler: u64): u32 {
    if wake_interrupt_count >= MAX_WAKE_INTERRUPTS {
        return 0xFFFFFFFF
    }

    var idx: u32 = wake_interrupt_count

    wake_interrupts[idx].wake_type = WAKE_TYPE_POWER_BUTTON
    wake_interrupts[idx].trigger_mode = WAKE_TRIGGER_FALLING
    wake_interrupts[idx].priority = WAKE_PRIORITY_CRITICAL
    wake_interrupts[idx].status = WAKE_STATUS_DISABLED
    wake_interrupts[idx].source_id = 0
    wake_interrupts[idx].handler = handler
    wake_interrupts[idx].active = 1

    // Power button wake is typically always enabled
    wake_interrupts[idx].status = WAKE_STATUS_ARMED

    wake_interrupt_count = wake_interrupt_count + 1

    return idx
}

// ============================================================================
// Motion/Accelerometer Wake
// ============================================================================

// Register accelerometer motion wake
export fn wake_register_motion(threshold: i32, handler: u64): u32 {
    if wake_interrupt_count >= MAX_WAKE_INTERRUPTS {
        return 0xFFFFFFFF
    }

    var idx: u32 = wake_interrupt_count

    wake_interrupts[idx].wake_type = WAKE_TYPE_ACCEL_MOTION
    wake_interrupts[idx].trigger_mode = WAKE_TRIGGER_THRESHOLD_ABOVE
    wake_interrupts[idx].priority = WAKE_PRIORITY_NORMAL
    wake_interrupts[idx].status = WAKE_STATUS_DISABLED
    wake_interrupts[idx].source_id = 0
    wake_interrupts[idx].threshold_value = threshold
    wake_interrupts[idx].handler = handler
    wake_interrupts[idx].active = 1

    // Configure accelerometer interrupt
    configure_accel_wake(threshold)

    wake_interrupt_count = wake_interrupt_count + 1

    return idx
}

// Configure accelerometer for motion wake
fn configure_accel_wake(threshold: i32) {
    // Would configure accelerometer motion detection interrupt
    // Set threshold value
    // Enable motion detection interrupt output
}

// ============================================================================
// UART Wake
// ============================================================================

// Register UART receive wake
export fn wake_register_uart(uart_port: u8, handler: u64): u32 {
    if wake_interrupt_count >= MAX_WAKE_INTERRUPTS {
        return 0xFFFFFFFF
    }

    var idx: u32 = wake_interrupt_count

    wake_interrupts[idx].wake_type = WAKE_TYPE_UART_RX
    wake_interrupts[idx].trigger_mode = 0
    wake_interrupts[idx].priority = WAKE_PRIORITY_NORMAL
    wake_interrupts[idx].status = WAKE_STATUS_DISABLED
    wake_interrupts[idx].source_id = uart_port
    wake_interrupts[idx].handler = handler
    wake_interrupts[idx].active = 1

    wake_interrupt_count = wake_interrupt_count + 1

    return idx
}

// ============================================================================
// Wake Source Control
// ============================================================================

// Enable wake source
export fn wake_enable(handle: u32): u32 {
    if handle >= wake_interrupt_count { return 0 }
    if wake_interrupts[handle].active == 0 { return 0 }

    wake_interrupts[handle].status = WAKE_STATUS_ARMED

    // Enable hardware interrupt
    enable_wake_hardware(handle)

    return 1
}

// Disable wake source
export fn wake_disable(handle: u32) {
    if handle >= wake_interrupt_count { return }
    if wake_interrupts[handle].active == 0 { return }

    wake_interrupts[handle].status = WAKE_STATUS_DISABLED

    // Disable hardware interrupt
    disable_wake_hardware(handle)
}

// Enable hardware wake interrupt
fn enable_wake_hardware(handle: u32) {
    var wake_type: u8 = wake_interrupts[handle].wake_type

    if wake_type == WAKE_TYPE_GPIO {
        var pin: u32 = wake_interrupts[handle].source_id
        var mode: u8 = wake_interrupts[handle].hw_enable_bit
        // Would enable GPIO interrupt here
    } else if wake_type == WAKE_TYPE_RTC_ALARM {
        // Enable RTC alarm interrupt in ACPI
        if wake_controller.acpi_pm1_base != 0 {
            var pm1_en: u16 = inw(wake_controller.acpi_pm1_base + ACPI_PM1_EN)
            pm1_en = pm1_en | PM1_RTC_STS
            outw(wake_controller.acpi_pm1_base + ACPI_PM1_EN, pm1_en)
        }
    } else if wake_type == WAKE_TYPE_POWER_BUTTON {
        // Power button wake is typically always enabled
        if wake_controller.acpi_pm1_base != 0 {
            var pm1_en: u16 = inw(wake_controller.acpi_pm1_base + ACPI_PM1_EN)
            pm1_en = pm1_en | PM1_PWRBTN_STS
            outw(wake_controller.acpi_pm1_base + ACPI_PM1_EN, pm1_en)
        }
    }
}

// Disable hardware wake interrupt
fn disable_wake_hardware(handle: u32) {
    var wake_type: u8 = wake_interrupts[handle].wake_type

    if wake_type == WAKE_TYPE_GPIO {
        // Would disable GPIO interrupt here
    } else if wake_type == WAKE_TYPE_RTC_ALARM {
        if wake_controller.acpi_pm1_base != 0 {
            var pm1_en: u16 = inw(wake_controller.acpi_pm1_base + ACPI_PM1_EN)
            pm1_en = pm1_en & ~PM1_RTC_STS
            outw(wake_controller.acpi_pm1_base + ACPI_PM1_EN, pm1_en)
        }
    }
}

// ============================================================================
// Sleep Preparation
// ============================================================================

// Arm all enabled wake sources before sleep
export fn wake_arm_all(): u32 {
    var armed_count: u32 = 0

    var i: u32 = 0
    while i < wake_interrupt_count {
        if wake_interrupts[i].active == 1 {
            if wake_interrupts[i].status == WAKE_STATUS_ARMED {
                enable_wake_hardware(i)
                armed_count = armed_count + 1
            }
        }
        i = i + 1
    }

    wake_controller.sleep_armed = 1

    foundation.serial_write_string("[Wake-IRQ] Armed ")
    foundation.serial_write_hex(armed_count)
    foundation.serial_write_string(" wake sources\n")

    return armed_count
}

// Disarm all wake sources after wake
export fn wake_disarm_all() {
    var i: u32 = 0
    while i < wake_interrupt_count {
        if wake_interrupts[i].active == 1 {
            // Keep armed status but disable hardware
            // Hardware will be re-enabled on next sleep
        }
        i = i + 1
    }

    wake_controller.sleep_armed = 0
}

// ============================================================================
// Wake Detection and Handling
// ============================================================================

// Check for pending wake (called during sleep)
export fn wake_check_pending(): u8 {
    // Check ACPI wake status
    if wake_controller.acpi_pm1_base != 0 {
        var pm1_sts: u16 = inw(wake_controller.acpi_pm1_base + ACPI_PM1_STS)

        if (pm1_sts & PM1_PWRBTN_STS) != 0 {
            wake_controller.pending_wake = 1
            wake_controller.last_wake_source = WAKE_TYPE_POWER_BUTTON
            return 1
        }

        if (pm1_sts & PM1_RTC_STS) != 0 {
            wake_controller.pending_wake = 1
            wake_controller.last_wake_source = WAKE_TYPE_RTC_ALARM
            return 1
        }

        if (pm1_sts & PM1_WAK_STS) != 0 {
            wake_controller.pending_wake = 1
            return 1
        }
    }

    return 0
}

// Handle wake event (called after wake)
export fn wake_handle_event(sleep_duration_ms: u64, sleep_mode: u8) {
    var wake_source: u8 = determine_wake_source()

    // Log wake event
    log_wake_event(wake_source, sleep_duration_ms, sleep_mode)

    // Update statistics
    wake_controller.total_wakes = wake_controller.total_wakes + 1
    wake_controller.last_wake_source = wake_source
    wake_controller.last_wake_time = foundation.timer_get_ticks()

    if wake_source == WAKE_TYPE_GPIO {
        wake_controller.gpio_wakes = wake_controller.gpio_wakes + 1
    } else if wake_source == WAKE_TYPE_RTC_ALARM || wake_source == WAKE_TYPE_RTC_PERIODIC {
        wake_controller.rtc_wakes = wake_controller.rtc_wakes + 1
    } else if wake_source == WAKE_TYPE_NETWORK {
        wake_controller.network_wakes = wake_controller.network_wakes + 1
    } else if wake_source == WAKE_TYPE_POWER_BUTTON {
        wake_controller.button_wakes = wake_controller.button_wakes + 1
    } else {
        wake_controller.other_wakes = wake_controller.other_wakes + 1
    }

    // Find and call appropriate handler
    var i: u32 = 0
    while i < wake_interrupt_count {
        if wake_interrupts[i].active == 1 {
            if wake_interrupts[i].wake_type == wake_source {
                wake_interrupts[i].trigger_count = wake_interrupts[i].trigger_count + 1
                wake_interrupts[i].last_trigger_time = foundation.timer_get_ticks()

                // Call handler if registered
                if wake_interrupts[i].handler != 0 {
                    // Would call handler function here
                }
            }
        }
        i = i + 1
    }

    // Call registered wake handlers
    call_wake_handlers(wake_source)

    // Clear pending status
    clear_wake_status()
    wake_controller.pending_wake = 0

    foundation.serial_write_string("[Wake-IRQ] Wake handled: source=")
    foundation.serial_write_hex(wake_source)
    foundation.serial_write_string(", duration=")
    foundation.serial_write_hex(sleep_duration_ms)
    foundation.serial_write_string("ms\n")
}

// Determine which source caused wake
fn determine_wake_source(): u8 {
    // Check ACPI status registers
    if wake_controller.acpi_pm1_base != 0 {
        var pm1_sts: u16 = inw(wake_controller.acpi_pm1_base + ACPI_PM1_STS)

        if (pm1_sts & PM1_PWRBTN_STS) != 0 {
            return WAKE_TYPE_POWER_BUTTON
        }

        if (pm1_sts & PM1_RTC_STS) != 0 {
            return WAKE_TYPE_RTC_ALARM
        }
    }

    // Check GPIO interrupt status
    // Would check platform-specific GPIO status registers

    // Default to unknown
    return 0xFF
}

// Clear wake status registers
fn clear_wake_status() {
    if wake_controller.acpi_pm1_base != 0 {
        // Write 1 to clear status bits
        outw(wake_controller.acpi_pm1_base + ACPI_PM1_STS, 0xFFFF)
    }
}

// Log wake event
fn log_wake_event(wake_type: u8, duration_ms: u64, sleep_mode: u8) {
    var idx: u32 = wake_event_index

    wake_event_log[idx].wake_type = wake_type
    wake_event_log[idx].source_id = 0
    wake_event_log[idx].timestamp = foundation.timer_get_ticks()
    wake_event_log[idx].sleep_duration_ms = duration_ms
    wake_event_log[idx].sleep_mode = sleep_mode
    wake_event_log[idx].handled = 0

    wake_event_index = (wake_event_index + 1) % 32
}

// ============================================================================
// Wake Handler Registration
// ============================================================================

// Register post-wake handler
export fn wake_register_handler(priority: u8, handler: u64, user_data: u64): u32 {
    if wake_handler_count >= MAX_WAKE_HANDLERS {
        return 0xFFFFFFFF
    }

    var idx: u32 = wake_handler_count

    wake_handlers[idx].priority = priority
    wake_handlers[idx].handler = handler
    wake_handlers[idx].user_data = user_data
    wake_handlers[idx].enabled = 1
    wake_handlers[idx].active = 1

    wake_handler_count = wake_handler_count + 1

    return idx
}

// Call registered wake handlers
fn call_wake_handlers(wake_source: u8) {
    // Sort by priority and call
    var priority: u8 = 0
    while priority <= WAKE_PRIORITY_LOW {
        var i: u32 = 0
        while i < wake_handler_count {
            if wake_handlers[i].active == 1 && wake_handlers[i].enabled == 1 {
                if wake_handlers[i].priority == priority {
                    // Would call handler function here
                }
            }
            i = i + 1
        }
        priority = priority + 1
    }
}

// ============================================================================
// Query Functions
// ============================================================================

// Get last wake source
export fn wake_get_last_source(): u8 {
    return wake_controller.last_wake_source
}

// Get wake count
export fn wake_get_total_count(): u64 {
    return wake_controller.total_wakes
}

// Get wake source trigger count
export fn wake_get_trigger_count(handle: u32): u32 {
    if handle >= wake_interrupt_count { return 0 }
    return wake_interrupts[handle].trigger_count
}

// Check if wake source is enabled
export fn wake_is_enabled(handle: u32): u8 {
    if handle >= wake_interrupt_count { return 0 }
    return if wake_interrupts[handle].status == WAKE_STATUS_ARMED { 1 } else { 0 }
}

// ============================================================================
// Debug/Statistics
// ============================================================================

// Print wake statistics
export fn wake_print_stats() {
    foundation.serial_write_string("\n[Wake-IRQ] Statistics:\n")
    foundation.serial_write_string("  Total wakes: ")
    foundation.serial_write_hex(wake_controller.total_wakes)
    foundation.serial_write_string("\n  GPIO wakes: ")
    foundation.serial_write_hex(wake_controller.gpio_wakes)
    foundation.serial_write_string("\n  RTC wakes: ")
    foundation.serial_write_hex(wake_controller.rtc_wakes)
    foundation.serial_write_string("\n  Network wakes: ")
    foundation.serial_write_hex(wake_controller.network_wakes)
    foundation.serial_write_string("\n  Button wakes: ")
    foundation.serial_write_hex(wake_controller.button_wakes)
    foundation.serial_write_string("\n")
}

// ============================================================================
// I/O Port Access (x86)
// ============================================================================

fn inw(port: u16): u16 {
    var value: u16 = 0
    @asm("inw %[port], %[value]", .{ .port = port }, .{ .value = &value })
    return value
}

fn outw(port: u16, value: u16) {
    @asm("outw %[value], %[port]", .{ .value = value, .port = port }, .{})
}

// ============================================================================
// Cleanup
// ============================================================================

// Unregister wake source
export fn wake_unregister(handle: u32) {
    if handle >= wake_interrupt_count { return }

    wake_disable(handle)
    wake_interrupts[handle].active = 0
}

// Shutdown wake interrupt system
export fn wake_interrupt_shutdown() {
    if wake_controller.initialized == 0 { return }

    // Disable all wake sources
    var i: u32 = 0
    while i < wake_interrupt_count {
        if wake_interrupts[i].active == 1 {
            wake_disable(i)
        }
        i = i + 1
    }

    wake_controller.initialized = 0
    foundation.serial_write_string("[Wake-IRQ] Shutdown complete\n")
}
