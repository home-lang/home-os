// home-os CPU Frequency Scaling (DVFS - Dynamic Voltage and Frequency Scaling)
// Power management for ARM Cortex processors on Raspberry Pi
// Balances performance and power consumption

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "../rpi/mailbox_vc7.home" as mailbox7
import "../rpi/mailbox_vc6.home" as mailbox6

// CPU frequency scaling governors
const GOVERNOR_PERFORMANCE: u32 = 0  // Always maximum frequency
const GOVERNOR_POWERSAVE: u32 = 1    // Always minimum frequency
const GOVERNOR_ONDEMAND: u32 = 2     // Scale based on load
const GOVERNOR_CONSERVATIVE: u32 = 3 // Scale gradually based on load
const GOVERNOR_USERSPACE: u32 = 4    // User-controlled frequency

// CPU states
const CPU_STATE_OFFLINE: u32 = 0
const CPU_STATE_IDLE: u32 = 1
const CPU_STATE_ACTIVE: u32 = 2
const CPU_STATE_TURBO: u32 = 3

// Raspberry Pi models
const RPI_MODEL_PI4: u32 = 0
const RPI_MODEL_PI5: u32 = 1

// CPU frequency presets (Hz)
// Raspberry Pi 4 (Cortex-A72)
const PI4_FREQ_MIN: u32 = 600000000     // 600 MHz
const PI4_FREQ_DEFAULT: u32 = 1500000000  // 1.5 GHz
const PI4_FREQ_MAX: u32 = 1800000000    // 1.8 GHz (with cooling)

// Raspberry Pi 5 (Cortex-A76)
const PI5_FREQ_MIN: u32 = 1000000000    // 1.0 GHz
const PI5_FREQ_DEFAULT: u32 = 2400000000  // 2.4 GHz
const PI5_FREQ_MAX: u32 = 2400000000    // 2.4 GHz

// Load thresholds for ondemand governor (percentage)
const LOAD_THRESHOLD_UP: u32 = 80
const LOAD_THRESHOLD_DOWN: u32 = 20

// CPU frequency information
struct CPUFreqInfo {
  cpu_id: u32
  current_freq: u32     // Current frequency (Hz)
  min_freq: u32         // Minimum frequency (Hz)
  max_freq: u32         // Maximum frequency (Hz)
  target_freq: u32      // Target frequency (Hz)
  governor: u32         // Active governor
  state: u32            // CPU state
  load: u32             // Current load (0-100%)
  voltage: u32          // Current voltage (microvolts)
  turbo_enabled: u32    // Turbo mode flag
}

const MAX_CPUS: u32 = 4

var cpu_info: [MAX_CPUS]CPUFreqInfo
var num_cpus: u32 = 0
var rpi_model: u32 = RPI_MODEL_PI5
var initialized: u32 = 0

// Statistics
var freq_changes: u64 = 0
var governor_changes: u64 = 0
var throttle_events: u64 = 0
var turbo_activations: u64 = 0

// Initialize CPU frequency scaling
export fn cpufreq_init(model: u32, cpus: u32): u32 {
  if initialized == 1 {
    foundation.serial_write_string("[CPUFREQ] Already initialized\n")
    return 0
  }

  foundation.serial_write_string("[CPUFREQ] Initializing CPU frequency scaling...\n")

  rpi_model = model
  num_cpus = if cpus > MAX_CPUS { MAX_CPUS } else { cpus }

  // Initialize per-CPU information
  var i: u32 = 0
  loop {
    if i >= num_cpus { break }

    cpu_info[i].cpu_id = i
    cpu_info[i].governor = GOVERNOR_ONDEMAND
    cpu_info[i].state = CPU_STATE_ACTIVE
    cpu_info[i].load = 0
    cpu_info[i].turbo_enabled = 0

    if model == RPI_MODEL_PI5 {
      cpu_info[i].min_freq = PI5_FREQ_MIN
      cpu_info[i].max_freq = PI5_FREQ_MAX
      cpu_info[i].current_freq = PI5_FREQ_DEFAULT
      cpu_info[i].target_freq = PI5_FREQ_DEFAULT
    } else {
      cpu_info[i].min_freq = PI4_FREQ_MIN
      cpu_info[i].max_freq = PI4_FREQ_MAX
      cpu_info[i].current_freq = PI4_FREQ_DEFAULT
      cpu_info[i].target_freq = PI4_FREQ_DEFAULT
    }

    i = i + 1
  }

  // Query actual frequencies from firmware
  cpufreq_query_frequencies()

  initialized = 1

  foundation.serial_write_string("[CPUFREQ] Initialized for ")
  foundation.serial_write_u64(num_cpus)
  foundation.serial_write_string(" CPUs\n")

  return 0
}

// Query frequencies from firmware via mailbox
fn cpufreq_query_frequencies() {
  foundation.serial_write_string("[CPUFREQ] Querying frequencies from firmware...\n")

  // Get ARM clock rate
  let clock_rate: u32 = if rpi_model == RPI_MODEL_PI5 {
    mailbox7.mailbox_get_clock_rate(mailbox7.CLOCK_ARM)
  } else {
    mailbox6.mailbox_get_clock_rate(mailbox6.CLOCK_ARM)
  }

  if clock_rate > 0 {
    foundation.serial_write_string("[CPUFREQ] Current ARM clock: ")
    foundation.serial_write_u64(clock_rate / 1000000)
    foundation.serial_write_string(" MHz\n")

    // Update all CPUs
    var i: u32 = 0
    loop {
      if i >= num_cpus { break }
      cpu_info[i].current_freq = clock_rate
      i = i + 1
    }
  }
}

// Set CPU frequency
export fn cpufreq_set_frequency(cpu_id: u32, freq_hz: u32): u32 {
  if initialized == 0 { return 1 }
  if cpu_id >= num_cpus { return 1 }

  let info: *CPUFreqInfo = &cpu_info[cpu_id]

  // Clamp to min/max
  var target: u32 = freq_hz
  if target < info.min_freq {
    target = info.min_freq
  }
  if target > info.max_freq {
    target = info.max_freq
  }

  if target == info.current_freq {
    return 0  // Already at target frequency
  }

  foundation.serial_write_string("[CPUFREQ] CPU")
  foundation.serial_write_u64(cpu_id)
  foundation.serial_write_string(": ")
  foundation.serial_write_u64(info.current_freq / 1000000)
  foundation.serial_write_string(" MHz -> ")
  foundation.serial_write_u64(target / 1000000)
  foundation.serial_write_string(" MHz\n")

  // Set frequency via mailbox
  let result: u32 = if rpi_model == RPI_MODEL_PI5 {
    mailbox7.mailbox_set_clock_rate(mailbox7.CLOCK_ARM, target, 0)
  } else {
    mailbox6.mailbox_set_clock_rate(mailbox6.CLOCK_ARM, target, 0)
  }

  if result == 0 {
    info.current_freq = target
    info.target_freq = target
    freq_changes = freq_changes + 1
  }

  return result
}

// Set CPU governor
export fn cpufreq_set_governor(cpu_id: u32, governor: u32): u32 {
  if initialized == 0 { return 1 }
  if cpu_id >= num_cpus { return 1 }
  if governor > GOVERNOR_USERSPACE { return 1 }

  let info: *CPUFreqInfo = &cpu_info[cpu_id]

  if info.governor == governor {
    return 0  // Already using this governor
  }

  info.governor = governor
  governor_changes = governor_changes + 1

  foundation.serial_write_string("[CPUFREQ] CPU")
  foundation.serial_write_u64(cpu_id)
  foundation.serial_write_string(": Governor changed to ")

  if governor == GOVERNOR_PERFORMANCE {
    foundation.serial_write_string("PERFORMANCE\n")
    cpufreq_set_frequency(cpu_id, info.max_freq)
  } else if governor == GOVERNOR_POWERSAVE {
    foundation.serial_write_string("POWERSAVE\n")
    cpufreq_set_frequency(cpu_id, info.min_freq)
  } else if governor == GOVERNOR_ONDEMAND {
    foundation.serial_write_string("ONDEMAND\n")
  } else if governor == GOVERNOR_CONSERVATIVE {
    foundation.serial_write_string("CONSERVATIVE\n")
  } else if governor == GOVERNOR_USERSPACE {
    foundation.serial_write_string("USERSPACE\n")
  }

  return 0
}

// Update CPU load and adjust frequency based on governor
export fn cpufreq_update_load(cpu_id: u32, load_percent: u32) {
  if initialized == 0 { return }
  if cpu_id >= num_cpus { return }

  let info: *CPUFreqInfo = &cpu_info[cpu_id]
  info.load = load_percent

  // Apply governor policy
  if info.governor == GOVERNOR_ONDEMAND {
    if load_percent >= LOAD_THRESHOLD_UP {
      // High load - scale up to max
      cpufreq_set_frequency(cpu_id, info.max_freq)
    } else if load_percent <= LOAD_THRESHOLD_DOWN {
      // Low load - scale down to min
      cpufreq_set_frequency(cpu_id, info.min_freq)
    }
  } else if info.governor == GOVERNOR_CONSERVATIVE {
    // Scale gradually
    if load_percent >= LOAD_THRESHOLD_UP {
      // Increase by one step
      let step: u32 = (info.max_freq - info.min_freq) / 4
      let new_freq: u32 = info.current_freq + step
      cpufreq_set_frequency(cpu_id, new_freq)
    } else if load_percent <= LOAD_THRESHOLD_DOWN {
      // Decrease by one step
      let step: u32 = (info.max_freq - info.min_freq) / 4
      if info.current_freq > step {
        let new_freq: u32 = info.current_freq - step
        cpufreq_set_frequency(cpu_id, new_freq)
      }
    }
  }
}

// Enable turbo mode
export fn cpufreq_enable_turbo(cpu_id: u32): u32 {
  if initialized == 0 { return 1 }
  if cpu_id >= num_cpus { return 1 }

  let info: *CPUFreqInfo = &cpu_info[cpu_id]

  if info.turbo_enabled == 1 {
    return 0  // Already enabled
  }

  foundation.serial_write_string("[CPUFREQ] CPU")
  foundation.serial_write_u64(cpu_id)
  foundation.serial_write_string(": Enabling turbo mode\n")

  // Set turbo via mailbox
  let result: u32 = if rpi_model == RPI_MODEL_PI5 {
    mailbox7.mailbox_set_clock_rate(mailbox7.CLOCK_ARM, info.max_freq, 0)
  } else {
    mailbox6.mailbox_set_clock_rate(mailbox6.CLOCK_ARM, info.max_freq, 0)
  }

  if result == 0 {
    info.turbo_enabled = 1
    info.state = CPU_STATE_TURBO
    turbo_activations = turbo_activations + 1
  }

  return result
}

// Disable turbo mode
export fn cpufreq_disable_turbo(cpu_id: u32): u32 {
  if initialized == 0 { return 1 }
  if cpu_id >= num_cpus { return 1 }

  let info: *CPUFreqInfo = &cpu_info[cpu_id]

  if info.turbo_enabled == 0 {
    return 0  // Already disabled
  }

  foundation.serial_write_string("[CPUFREQ] CPU")
  foundation.serial_write_u64(cpu_id)
  foundation.serial_write_string(": Disabling turbo mode\n")

  info.turbo_enabled = 0
  info.state = CPU_STATE_ACTIVE

  // Restore normal frequency based on governor
  if info.governor == GOVERNOR_PERFORMANCE {
    cpufreq_set_frequency(cpu_id, info.max_freq)
  }

  return 0
}

// Get CPU information
export fn cpufreq_get_info(cpu_id: u32): *CPUFreqInfo {
  if cpu_id >= num_cpus { return 0 }
  return &cpu_info[cpu_id]
}

// Get current frequency
export fn cpufreq_get_frequency(cpu_id: u32): u32 {
  if cpu_id >= num_cpus { return 0 }
  return cpu_info[cpu_id].current_freq
}

// Handle thermal throttling
export fn cpufreq_throttle(cpu_id: u32) {
  if initialized == 0 { return }
  if cpu_id >= num_cpus { return }

  throttle_events = throttle_events + 1

  foundation.serial_write_string("[CPUFREQ] CPU")
  foundation.serial_write_u64(cpu_id)
  foundation.serial_write_string(": Thermal throttling activated\n")

  // Reduce to minimum frequency
  cpufreq_set_frequency(cpu_id, cpu_info[cpu_id].min_freq)

  // Disable turbo
  cpufreq_disable_turbo(cpu_id)
}

// Unthrottle CPU
export fn cpufreq_unthrottle(cpu_id: u32) {
  if initialized == 0 { return }
  if cpu_id >= num_cpus { return }

  foundation.serial_write_string("[CPUFREQ] CPU")
  foundation.serial_write_u64(cpu_id)
  foundation.serial_write_string(": Thermal throttling released\n")

  // Restore frequency based on governor
  let info: *CPUFreqInfo = &cpu_info[cpu_id]

  if info.governor == GOVERNOR_PERFORMANCE {
    cpufreq_set_frequency(cpu_id, info.max_freq)
  }
}

// Print CPU frequency information
export fn cpufreq_print_info() {
  foundation.serial_write_string("\n[CPUFREQ] CPU Frequency Information:\n")

  var i: u32 = 0
  loop {
    if i >= num_cpus { break }

    let info: *CPUFreqInfo = &cpu_info[i]

    foundation.serial_write_string("\n  CPU")
    foundation.serial_write_u64(i)
    foundation.serial_write_string(":\n")

    foundation.serial_write_string("    Current: ")
    foundation.serial_write_u64(info.current_freq / 1000000)
    foundation.serial_write_string(" MHz\n")

    foundation.serial_write_string("    Min: ")
    foundation.serial_write_u64(info.min_freq / 1000000)
    foundation.serial_write_string(" MHz\n")

    foundation.serial_write_string("    Max: ")
    foundation.serial_write_u64(info.max_freq / 1000000)
    foundation.serial_write_string(" MHz\n")

    foundation.serial_write_string("    Load: ")
    foundation.serial_write_u64(info.load)
    foundation.serial_write_string("%\n")

    foundation.serial_write_string("    Governor: ")
    if info.governor == GOVERNOR_PERFORMANCE {
      foundation.serial_write_string("PERFORMANCE")
    } else if info.governor == GOVERNOR_POWERSAVE {
      foundation.serial_write_string("POWERSAVE")
    } else if info.governor == GOVERNOR_ONDEMAND {
      foundation.serial_write_string("ONDEMAND")
    } else if info.governor == GOVERNOR_CONSERVATIVE {
      foundation.serial_write_string("CONSERVATIVE")
    } else {
      foundation.serial_write_string("USERSPACE")
    }
    foundation.serial_write_string("\n")

    foundation.serial_write_string("    Turbo: ")
    foundation.serial_write_string(if info.turbo_enabled == 1 { "ENABLED" } else { "DISABLED" })
    foundation.serial_write_string("\n")

    i = i + 1
  }
}

// Print statistics
export fn cpufreq_print_stats() {
  foundation.serial_write_string("\n[CPUFREQ] Statistics:\n")

  foundation.serial_write_string("  Frequency changes: ")
  foundation.serial_write_u64(freq_changes)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Governor changes: ")
  foundation.serial_write_u64(governor_changes)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Throttle events: ")
  foundation.serial_write_u64(throttle_events)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Turbo activations: ")
  foundation.serial_write_u64(turbo_activations)
  foundation.serial_write_string("\n")
}

// ============================================================================
// Userspace Interface - DVFS Policy Control
// ============================================================================

// Policy configuration structure (for userspace)
struct DVFSPolicy {
  governor: u32,
  min_freq_mhz: u32,
  max_freq_mhz: u32,
  target_load: u32,           // Target load percentage for ondemand
  sampling_rate_ms: u32,      // How often to check load
  up_threshold: u32,          // Load threshold to scale up
  down_threshold: u32,        // Load threshold to scale down
  turbo_allowed: u32,         // Whether turbo is allowed
  io_boost: u32               // Boost during I/O operations
}

var policy: DVFSPolicy
var policy_initialized: u32 = 0

// Initialize default policy
export fn cpufreq_policy_init() {
  if policy_initialized == 1 { return }

  policy.governor = GOVERNOR_ONDEMAND
  policy.min_freq_mhz = 600
  policy.max_freq_mhz = 1800
  policy.target_load = 50
  policy.sampling_rate_ms = 100
  policy.up_threshold = 80
  policy.down_threshold = 20
  policy.turbo_allowed = 1
  policy.io_boost = 1

  policy_initialized = 1

  foundation.serial_write_string("[CPUFREQ] Default DVFS policy initialized\n")
}

// Apply a named policy
export fn cpufreq_apply_policy(policy_name: u64): u32 {
  if initialized == 0 { return 1 }

  foundation.serial_write_string("[CPUFREQ] Applying policy: ")
  foundation.serial_write_string(policy_name)
  foundation.serial_write_string("\n")

  // Compare policy name
  var c0: u8 = @ptrLoad(policy_name, u8)
  var c1: u8 = @ptrLoad(policy_name + 1, u8)

  if c0 == 'p' and c1 == 'e' {
    // "performance"
    return cpufreq_apply_performance()
  } else if c0 == 'p' and c1 == 'o' {
    // "powersave"
    return cpufreq_apply_powersave()
  } else if c0 == 'o' and c1 == 'n' {
    // "ondemand"
    return cpufreq_apply_ondemand()
  } else if c0 == 'c' and c1 == 'o' {
    // "conservative"
    return cpufreq_apply_conservative()
  } else if c0 == 's' and c1 == 'c' {
    // "schedutil"
    return cpufreq_apply_schedutil()
  } else if c0 == 'b' and c1 == 'a' {
    // "balanced"
    return cpufreq_apply_balanced()
  }

  foundation.serial_write_string("[CPUFREQ] Unknown policy\n")
  return 1
}

// Performance policy - maximum frequency always
export fn cpufreq_apply_performance(): u32 {
  policy.governor = GOVERNOR_PERFORMANCE
  policy.turbo_allowed = 1

  var i: u32 = 0
  loop {
    if i >= num_cpus { break }
    cpufreq_set_governor(i, GOVERNOR_PERFORMANCE)
    cpufreq_enable_turbo(i)
    i = i + 1
  }

  foundation.serial_write_string("[CPUFREQ] Performance policy applied\n")
  return 0
}

// Powersave policy - minimum frequency always
export fn cpufreq_apply_powersave(): u32 {
  policy.governor = GOVERNOR_POWERSAVE
  policy.turbo_allowed = 0

  var i: u32 = 0
  loop {
    if i >= num_cpus { break }
    cpufreq_set_governor(i, GOVERNOR_POWERSAVE)
    cpufreq_disable_turbo(i)
    i = i + 1
  }

  foundation.serial_write_string("[CPUFREQ] Powersave policy applied\n")
  return 0
}

// Ondemand policy - scale based on load
export fn cpufreq_apply_ondemand(): u32 {
  policy.governor = GOVERNOR_ONDEMAND
  policy.up_threshold = 80
  policy.down_threshold = 20
  policy.sampling_rate_ms = 100
  policy.turbo_allowed = 1

  var i: u32 = 0
  loop {
    if i >= num_cpus { break }
    cpufreq_set_governor(i, GOVERNOR_ONDEMAND)
    i = i + 1
  }

  foundation.serial_write_string("[CPUFREQ] Ondemand policy applied\n")
  return 0
}

// Conservative policy - gradual scaling
export fn cpufreq_apply_conservative(): u32 {
  policy.governor = GOVERNOR_CONSERVATIVE
  policy.up_threshold = 80
  policy.down_threshold = 20
  policy.sampling_rate_ms = 200
  policy.turbo_allowed = 0

  var i: u32 = 0
  loop {
    if i >= num_cpus { break }
    cpufreq_set_governor(i, GOVERNOR_CONSERVATIVE)
    i = i + 1
  }

  foundation.serial_write_string("[CPUFREQ] Conservative policy applied\n")
  return 0
}

// Schedutil-like policy - scheduler-driven
export fn cpufreq_apply_schedutil(): u32 {
  policy.governor = GOVERNOR_ONDEMAND
  policy.up_threshold = 65
  policy.down_threshold = 30
  policy.sampling_rate_ms = 50
  policy.turbo_allowed = 1
  policy.io_boost = 1

  var i: u32 = 0
  loop {
    if i >= num_cpus { break }
    cpufreq_set_governor(i, GOVERNOR_ONDEMAND)
    i = i + 1
  }

  foundation.serial_write_string("[CPUFREQ] Schedutil-like policy applied\n")
  return 0
}

// Balanced policy - moderate power/performance tradeoff
export fn cpufreq_apply_balanced(): u32 {
  policy.governor = GOVERNOR_CONSERVATIVE
  policy.up_threshold = 70
  policy.down_threshold = 30
  policy.sampling_rate_ms = 150
  policy.turbo_allowed = 1

  var i: u32 = 0
  loop {
    if i >= num_cpus { break }
    cpufreq_set_governor(i, GOVERNOR_CONSERVATIVE)
    i = i + 1
  }

  foundation.serial_write_string("[CPUFREQ] Balanced policy applied\n")
  return 0
}

// ============================================================================
// Sysfs-like Interface for /sys/devices/system/cpu/cpufreq
// ============================================================================

// Generate /sys/devices/system/cpu/cpufreq/policy0 content
export fn cpufreq_sysfs_read(cpu_id: u32, attr: u64, buffer: u64, max_len: u32): u32 {
  if cpu_id >= num_cpus { return 0 }

  let info: *CPUFreqInfo = &cpu_info[cpu_id]

  // Compare attribute name
  var c0: u8 = @ptrLoad(attr, u8)
  var c1: u8 = @ptrLoad(attr + 1, u8)

  if c0 == 's' and c1 == 'c' {
    // "scaling_governor"
    return cpufreq_sysfs_write_governor(info.governor, buffer)
  } else if c0 == 'c' and c1 == 'u' {
    // "cur_freq" or "cpuinfo_cur_freq"
    return cpufreq_sysfs_write_u32(info.current_freq / 1000, buffer)  // kHz
  } else if c0 == 's' and c1 == 'm' {
    // "scaling_min_freq"
    return cpufreq_sysfs_write_u32(info.min_freq / 1000, buffer)
  } else if c0 == 's' and c1 == 'M' {
    // "scaling_max_freq"  (uppercase M to distinguish)
    return cpufreq_sysfs_write_u32(info.max_freq / 1000, buffer)
  } else if c0 == 'a' and c1 == 'v' {
    // "available_governors"
    return cpufreq_sysfs_write_str("performance powersave ondemand conservative userspace", buffer)
  } else if c0 == 'a' and c1 == 'f' {
    // "available_frequencies"
    return cpufreq_sysfs_available_freqs(info, buffer)
  }

  return 0
}

fn cpufreq_sysfs_write_governor(gov: u32, buffer: u64): u32 {
  var name: u64 = 0
  if gov == GOVERNOR_PERFORMANCE {
    name = "performance"
  } else if gov == GOVERNOR_POWERSAVE {
    name = "powersave"
  } else if gov == GOVERNOR_ONDEMAND {
    name = "ondemand"
  } else if gov == GOVERNOR_CONSERVATIVE {
    name = "conservative"
  } else {
    name = "userspace"
  }

  return cpufreq_sysfs_write_str(name, buffer)
}

fn cpufreq_sysfs_write_u32(val: u32, buffer: u64): u32 {
  // Simple decimal conversion
  var temp: [16]u8
  var i: u32 = 15
  var v: u32 = val

  if v == 0 {
    @ptrStore(buffer, u8, '0')
    @ptrStore(buffer + 1, u8, '\n')
    @ptrStore(buffer + 2, u8, 0)
    return 3
  }

  while v > 0 and i > 0 {
    temp[i] = '0' + @truncate(v % 10, u8)
    v = v / 10
    i = i - 1
  }

  var len: u32 = 0
  while i < 16 {
    @ptrStore(buffer + len, u8, temp[i])
    len = len + 1
    i = i + 1
  }

  @ptrStore(buffer + len, u8, '\n')
  @ptrStore(buffer + len + 1, u8, 0)
  return len + 2
}

fn cpufreq_sysfs_write_str(str: u64, buffer: u64): u32 {
  var i: u32 = 0
  while 1 == 1 {
    var c: u8 = @ptrLoad(str + i, u8)
    if c == 0 { break }
    @ptrStore(buffer + i, u8, c)
    i = i + 1
    if i >= 255 { break }
  }
  @ptrStore(buffer + i, u8, '\n')
  @ptrStore(buffer + i + 1, u8, 0)
  return i + 2
}

fn cpufreq_sysfs_available_freqs(info: *CPUFreqInfo, buffer: u64): u32 {
  // Generate available frequency steps (in kHz)
  var pos: u32 = 0
  var freq: u32 = info.min_freq / 1000

  while freq <= info.max_freq / 1000 {
    // Write frequency value
    var temp: [16]u8
    var i: u32 = 15
    var v: u32 = freq

    if v == 0 {
      temp[15] = '0'
    } else {
      while v > 0 and i > 0 {
        temp[i] = '0' + @truncate(v % 10, u8)
        v = v / 10
        i = i - 1
      }
    }

    while i < 16 {
      @ptrStore(buffer + pos, u8, temp[i])
      pos = pos + 1
      i = i + 1
    }

    @ptrStore(buffer + pos, u8, ' ')
    pos = pos + 1

    freq = freq + 100000  // 100 MHz steps
  }

  @ptrStore(buffer + pos, u8, '\n')
  @ptrStore(buffer + pos + 1, u8, 0)
  return pos + 2
}

// Handle sysfs write (set governor, frequency, etc.)
export fn cpufreq_sysfs_write(cpu_id: u32, attr: u64, value: u64): u32 {
  if cpu_id >= num_cpus { return 1 }

  var c0: u8 = @ptrLoad(attr, u8)
  var c1: u8 = @ptrLoad(attr + 1, u8)

  if c0 == 's' and c1 == 'c' {
    // "scaling_governor"
    return cpufreq_apply_policy(value)
  } else if c0 == 's' and c1 == 'm' {
    // "scaling_min_freq"
    var freq: u32 = cpufreq_parse_freq(value)
    cpu_info[cpu_id].min_freq = freq * 1000  // kHz to Hz
    return 0
  } else if c0 == 's' and c1 == 'M' {
    // "scaling_max_freq"
    var freq: u32 = cpufreq_parse_freq(value)
    cpu_info[cpu_id].max_freq = freq * 1000
    return 0
  } else if c0 == 's' and c1 == 's' {
    // "scaling_setspeed" (for userspace governor)
    var freq: u32 = cpufreq_parse_freq(value)
    return cpufreq_set_frequency(cpu_id, freq * 1000)
  }

  return 1
}

fn cpufreq_parse_freq(str: u64): u32 {
  var val: u32 = 0
  var i: u32 = 0

  while 1 == 1 {
    var c: u8 = @ptrLoad(str + i, u8)
    if c < '0' or c > '9' { break }
    val = val * 10 + (c - '0')
    i = i + 1
    if i >= 16 { break }
  }

  return val
}

// ============================================================================
// /proc/cpufreq Interface
// ============================================================================

export fn cpufreq_proc_read(buffer: u64, max_len: u32): u32 {
  var pos: u32 = 0

  // Header
  pos = pos + cpufreq_proc_write_line("cpufreq info:\n", buffer + pos)

  // Global policy
  pos = pos + cpufreq_proc_write_line("policy: ", buffer + pos)
  if policy.governor == GOVERNOR_PERFORMANCE {
    pos = pos + cpufreq_proc_write_line("performance\n", buffer + pos)
  } else if policy.governor == GOVERNOR_POWERSAVE {
    pos = pos + cpufreq_proc_write_line("powersave\n", buffer + pos)
  } else if policy.governor == GOVERNOR_ONDEMAND {
    pos = pos + cpufreq_proc_write_line("ondemand\n", buffer + pos)
  } else if policy.governor == GOVERNOR_CONSERVATIVE {
    pos = pos + cpufreq_proc_write_line("conservative\n", buffer + pos)
  } else {
    pos = pos + cpufreq_proc_write_line("userspace\n", buffer + pos)
  }

  pos = pos + cpufreq_proc_write_line("\n", buffer + pos)

  // Per-CPU info
  var i: u32 = 0
  loop {
    if i >= num_cpus { break }
    if pos >= max_len - 100 { break }

    pos = pos + cpufreq_proc_write_line("CPU", buffer + pos)
    @ptrStore(buffer + pos, u8, '0' + @truncate(i, u8))
    pos = pos + 1
    pos = pos + cpufreq_proc_write_line(":\n", buffer + pos)

    pos = pos + cpufreq_proc_write_line("  current: ", buffer + pos)
    pos = pos + cpufreq_proc_write_u32(cpu_info[i].current_freq / 1000000, buffer + pos)
    pos = pos + cpufreq_proc_write_line(" MHz\n", buffer + pos)

    pos = pos + cpufreq_proc_write_line("  min: ", buffer + pos)
    pos = pos + cpufreq_proc_write_u32(cpu_info[i].min_freq / 1000000, buffer + pos)
    pos = pos + cpufreq_proc_write_line(" MHz\n", buffer + pos)

    pos = pos + cpufreq_proc_write_line("  max: ", buffer + pos)
    pos = pos + cpufreq_proc_write_u32(cpu_info[i].max_freq / 1000000, buffer + pos)
    pos = pos + cpufreq_proc_write_line(" MHz\n", buffer + pos)

    pos = pos + cpufreq_proc_write_line("  load: ", buffer + pos)
    pos = pos + cpufreq_proc_write_u32(cpu_info[i].load, buffer + pos)
    pos = pos + cpufreq_proc_write_line("%\n", buffer + pos)

    pos = pos + cpufreq_proc_write_line("  turbo: ", buffer + pos)
    if cpu_info[i].turbo_enabled == 1 {
      pos = pos + cpufreq_proc_write_line("enabled\n", buffer + pos)
    } else {
      pos = pos + cpufreq_proc_write_line("disabled\n", buffer + pos)
    }

    pos = pos + cpufreq_proc_write_line("\n", buffer + pos)

    i = i + 1
  }

  // Statistics
  pos = pos + cpufreq_proc_write_line("statistics:\n", buffer + pos)
  pos = pos + cpufreq_proc_write_line("  freq_changes: ", buffer + pos)
  pos = pos + cpufreq_proc_write_u32(@truncate(freq_changes, u32), buffer + pos)
  pos = pos + cpufreq_proc_write_line("\n", buffer + pos)

  pos = pos + cpufreq_proc_write_line("  throttle_events: ", buffer + pos)
  pos = pos + cpufreq_proc_write_u32(@truncate(throttle_events, u32), buffer + pos)
  pos = pos + cpufreq_proc_write_line("\n", buffer + pos)

  @ptrStore(buffer + pos, u8, 0)
  return pos
}

fn cpufreq_proc_write_line(str: u64, buffer: u64): u32 {
  var i: u32 = 0
  while 1 == 1 {
    var c: u8 = @ptrLoad(str + i, u8)
    if c == 0 { break }
    @ptrStore(buffer + i, u8, c)
    i = i + 1
    if i >= 255 { break }
  }
  return i
}

fn cpufreq_proc_write_u32(val: u32, buffer: u64): u32 {
  var temp: [16]u8
  var i: u32 = 15
  var v: u32 = val

  if v == 0 {
    @ptrStore(buffer, u8, '0')
    return 1
  }

  while v > 0 and i > 0 {
    temp[i] = '0' + @truncate(v % 10, u8)
    v = v / 10
    i = i - 1
  }

  var len: u32 = 0
  while i < 16 {
    @ptrStore(buffer + len, u8, temp[i])
    len = len + 1
    i = i + 1
  }

  return len
}

// ============================================================================
// Policy Helper Functions for Userspace
// ============================================================================

// Get available policies as a list
export fn cpufreq_list_policies(buffer: u64): u32 {
  var str: u64 = "performance powersave ondemand conservative balanced schedutil"
  return cpufreq_sysfs_write_str(str, buffer)
}

// Get current policy name
export fn cpufreq_get_policy_name(buffer: u64): u32 {
  return cpufreq_sysfs_write_governor(policy.governor, buffer)
}

// Set policy parameters
export fn cpufreq_set_policy_param(param: u64, value: u32): u32 {
  var c0: u8 = @ptrLoad(param, u8)

  if c0 == 'u' {
    // "up_threshold"
    policy.up_threshold = value
    return 0
  } else if c0 == 'd' {
    // "down_threshold"
    policy.down_threshold = value
    return 0
  } else if c0 == 's' {
    // "sampling_rate"
    policy.sampling_rate_ms = value
    return 0
  } else if c0 == 't' {
    // "turbo"
    policy.turbo_allowed = if value != 0 { 1 } else { 0 }
    return 0
  } else if c0 == 'i' {
    // "io_boost"
    policy.io_boost = if value != 0 { 1 } else { 0 }
    return 0
  }

  return 1
}

// Get policy parameter
export fn cpufreq_get_policy_param(param: u64): u32 {
  var c0: u8 = @ptrLoad(param, u8)

  if c0 == 'u' { return policy.up_threshold }
  else if c0 == 'd' { return policy.down_threshold }
  else if c0 == 's' { return policy.sampling_rate_ms }
  else if c0 == 't' { return policy.turbo_allowed }
  else if c0 == 'i' { return policy.io_boost }

  return 0
}
