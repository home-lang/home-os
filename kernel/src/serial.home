// Serial port driver for home-os
// COM1 serial port at 0x3F8

// COM1 port base address
let PORT: u16 = 0x3F8

// Port offsets
let DATA: u16 = 0      // Data register (DLAB=0)
let IER: u16 = 1       // Interrupt Enable Register (DLAB=0)
let DLL: u16 = 0       // Divisor Latch Low (DLAB=1)
let DLH: u16 = 1       // Divisor Latch High (DLAB=1)
let IIR: u16 = 2       // Interrupt Identification Register
let LCR: u16 = 3       // Line Control Register
let MCR: u16 = 4       // Modem Control Register
let LSR: u16 = 5       // Line Status Register
let MSR: u16 = 6       // Modem Status Register
let SCRATCH: u16 = 7   // Scratch Register

// Line Status Register bits
let LSR_DATA_READY: u8 = 1 << 0
let LSR_TRANSMIT_EMPTY: u8 = 1 << 5

// I/O port operations
inline fn outb(port: u16, value: u8) {
    asm volatile ("outb %[value], %[port]"
        :
        : [port] "{dx}" (port),
          [value] "{al}" (value),
    )
}

inline fn inb(port: u16) -> u8 {
    return asm volatile ("inb %[port], %[result]"
        : [result] "={al}" (-> u8),
        : [port] "{dx}" (port),
    )
}

// Initialize serial port
export fn init() {
    // Disable interrupts
    outb(PORT + IER, 0x00)

    // Enable DLAB (set baud rate divisor)
    outb(PORT + LCR, 0x80)

    // Set divisor to 1 (115200 baud)
    outb(PORT + DLL, 0x01)
    outb(PORT + DLH, 0x00)

    // 8 bits, no parity, one stop bit
    outb(PORT + LCR, 0x03)

    // Enable FIFO, clear them, with 14-byte threshold
    outb(PORT + IIR, 0xC7)

    // IRQs enabled, RTS/DSR set
    outb(PORT + MCR, 0x0B)

    // Set in loopback mode, test the serial chip
    outb(PORT + MCR, 0x1E)

    // Test serial chip (send byte 0xAE and check if serial returns same byte)
    outb(PORT + DATA, 0xAE)

    // Check if serial is faulty (i.e. not same byte as sent)
    if inb(PORT + DATA) != 0xAE {
        // Serial is faulty, but we continue anyway
        return
    }

    // Set in normal operation mode
    outb(PORT + MCR, 0x0F)
}

// Check if transmit buffer is empty
fn isTransmitEmpty() -> bool {
    return (inb(PORT + LSR) & LSR_TRANSMIT_EMPTY) != 0
}

// Write a single character
export fn writeChar(c: u8) {
    // Wait for transmit buffer to be empty
    loop {
        if isTransmitEmpty() {
            break
        }
    }

    // Write character
    outb(PORT + DATA, c)
}

// Write a string
export fn writeString(s: []u8) {
    let i = 0
    loop {
        if i >= s.len {
            break
        }
        writeChar(s[i])
        i = i + 1
    }
}

// Write a hexadecimal number
export fn writeHex(value: u64) {
    let hex_chars = "0123456789ABCDEF"

    writeString("0x")

    let i: u6 = 60
    loop {
        let nibble: u4 = @truncate(value >> i)
        writeChar(hex_chars[nibble])

        if i == 0 {
            break
        }
        i = i - 4
    }
}

// Write a decimal number
export fn writeDec(value: u64) {
    if value == 0 {
        writeChar('0')
        return
    }

    let buf: [20]u8 = undefined
    let i: usize = 0
    let n = value

    loop {
        if n == 0 {
            break
        }
        buf[i] = @intCast('0' + (n % 10))
        n = n / 10
        i = i + 1
    }

    // Reverse and print
    loop {
        if i == 0 {
            break
        }
        i = i - 1
        writeChar(buf[i])
    }
}
