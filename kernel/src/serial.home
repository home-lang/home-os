// Serial port driver for home-os
// COM1 serial port at 0x3F8

// COM1 port base address
const PORT: u16 = 0x3F8;

// Port offsets
const DATA: u16 = 0;      // Data register (DLAB=0)
const IER: u16 = 1;       // Interrupt Enable Register (DLAB=0)
const DLL: u16 = 0;       // Divisor Latch Low (DLAB=1)
const DLH: u16 = 1;       // Divisor Latch High (DLAB=1)
const IIR: u16 = 2;       // Interrupt Identification Register
const LCR: u16 = 3;       // Line Control Register
const MCR: u16 = 4;       // Modem Control Register
const LSR: u16 = 5;       // Line Status Register
const MSR: u16 = 6;       // Modem Status Register
const SCRATCH: u16 = 7;   // Scratch Register

// Line Status Register bits
const LSR_DATA_READY: u8 = 1 << 0;
const LSR_TRANSMIT_EMPTY: u8 = 1 << 5;

// I/O port operations
inline fn outb(port: u16, value: u8) void {
    asm volatile ("outb %[value], %[port]"
        :
        : [port] "{dx}" (port),
          [value] "{al}" (value),
    );
}

inline fn inb(port: u16) u8 {
    return asm volatile ("inb %[port], %[result]"
        : [result] "={al}" (-> u8),
        : [port] "{dx}" (port),
    );
}

// Initialize serial port
pub fn init() void {
    // Disable interrupts
    outb(PORT + IER, 0x00);

    // Enable DLAB (set baud rate divisor)
    outb(PORT + LCR, 0x80);

    // Set divisor to 1 (115200 baud)
    outb(PORT + DLL, 0x01);
    outb(PORT + DLH, 0x00);

    // 8 bits, no parity, one stop bit
    outb(PORT + LCR, 0x03);

    // Enable FIFO, clear them, with 14-byte threshold
    outb(PORT + IIR, 0xC7);

    // IRQs enabled, RTS/DSR set
    outb(PORT + MCR, 0x0B);

    // Set in loopback mode, test the serial chip
    outb(PORT + MCR, 0x1E);

    // Test serial chip (send byte 0xAE and check if serial returns same byte)
    outb(PORT + DATA, 0xAE);

    // Check if serial is faulty (i.e. not same byte as sent)
    if (inb(PORT + DATA) != 0xAE) {
        // Serial is faulty, but we continue anyway
        return;
    }

    // Set in normal operation mode
    outb(PORT + MCR, 0x0F);
}

// Check if transmit buffer is empty
fn isTransmitEmpty() bool {
    return (inb(PORT + LSR) & LSR_TRANSMIT_EMPTY) != 0;
}

// Write a single character
pub fn writeChar(c: u8) void {
    // Wait for transmit buffer to be empty
    while (!isTransmitEmpty()) {}

    // Write character
    outb(PORT + DATA, c);
}

// Write a string
pub fn writeString(s: []const u8) void {
    for (s) |c| {
        writeChar(c);
    }
}

// Write a hexadecimal number
pub fn writeHex(value: u64) void {
    const hex_chars = "0123456789ABCDEF";

    writeString("0x");

    var i: u6 = 60;
    while (true) : (i -%= 4) {
        const nibble = @truncate(u4, (value >> i));
        writeChar(hex_chars[nibble]);

        if (i == 0) break;
    }
}

// Write a decimal number
pub fn writeDec(value: u64) void {
    if (value == 0) {
        writeChar('0');
        return;
    }

    var buf: [20]u8 = undefined;
    var i: usize = 0;
    var n = value;

    while (n > 0) {
        buf[i] = @intCast(u8, '0' + (n % 10));
        n /= 10;
        i += 1;
    }

    // Reverse and print
    while (i > 0) {
        i -= 1;
        writeChar(buf[i]);
    }
}
