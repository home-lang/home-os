// home-os ELF Loader
// Executable and Linkable Format loader

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "../core/filesystem.home" as filesystem

const ELF_MAGIC: u32 = 0x464C457F  // "\x7FELF"

const PT_NULL: u32 = 0
const PT_LOAD: u32 = 1
const PT_DYNAMIC: u32 = 2
const PT_INTERP: u32 = 3

struct ElfHeader {
  magic: u32,
  class: u8,
  data: u8,
  version: u8,
  osabi: u8,
  abiversion: u8,
  pad: [u8; 7],
  type: u16,
  machine: u16,
  version2: u32,
  entry: u64,
  phoff: u64,
  shoff: u64,
  flags: u32,
  ehsize: u16,
  phentsize: u16,
  phnum: u16,
  shentsize: u16,
  shnum: u16,
  shstrndx: u16
}

struct ElfProgramHeader {
  type: u32,
  flags: u32,
  offset: u64,
  vaddr: u64,
  paddr: u64,
  filesz: u64,
  memsz: u64,
  align: u64
}

export fn elf_init() {
  foundation.serial_write_string("[ELF] Loader initialized\n")
}

export fn elf_load(path: u64) -> u64 {
  var fd: u32 = filesystem.vfs_open(path, 0)
  if fd == 0 {
    foundation.serial_write_string("[ELF] Failed to open file\n")
    return 0
  }
  
  var header_buf: [u8; 64]
  var read: u64 = filesystem.vfs_read(fd, @ptrFromInt(header_buf), 64)
  
  if read < 64 {
    filesystem.vfs_close(fd)
    return 0
  }
  
  var header: ElfHeader = @intToPtr(@ptrFromInt(header_buf), ElfHeader)
  
  if header.magic != ELF_MAGIC {
    foundation.serial_write_string("[ELF] Invalid magic\n")
    filesystem.vfs_close(fd)
    return 0
  }
  
  var entry: u64 = header.entry
  
  // Load program headers
  var i: u16 = 0
  while i < header.phnum {
    var phdr_buf: [u8; 56]
    filesystem.vfs_lseek(fd, header.phoff + (i * header.phentsize), 0)
    filesystem.vfs_read(fd, @ptrFromInt(phdr_buf), 56)
    
    var phdr: ElfProgramHeader = @intToPtr(@ptrFromInt(phdr_buf), ElfProgramHeader)
    
    if phdr.type == PT_LOAD {
      var mem: u64 = memory.kmalloc(phdr.memsz)
      if mem != 0 {
        filesystem.vfs_lseek(fd, phdr.offset, 0)
        filesystem.vfs_read(fd, mem, phdr.filesz)
        
        // Map to virtual address
        memory.vmm_map_page(phdr.vaddr, mem, 7)
      }
    }
    
    i = i + 1
  }
  
  filesystem.vfs_close(fd)
  
  foundation.serial_write_string("[ELF] Loaded successfully\n")
  return entry
}

export fn elf_exec(path: u64) -> u32 {
  var entry: u64 = elf_load(path)
  if entry == 0 { return 1 }
  
  // Jump to entry point (stub)
  foundation.serial_write_string("[ELF] Would execute at entry point\n")
  
  return 0
}
