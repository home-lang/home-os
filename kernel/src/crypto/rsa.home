// home-os RSA Encryption
// Public-key cryptography - Full Implementation
// Supports RSA-2048, RSA-4096 with PKCS#1 v1.5 and OAEP padding

import "../core/foundation.home" as foundation
import "sha256.home" as sha256

// ============================================================================
// CONSTANTS
// ============================================================================

export const RSA_2048_BITS: u32 = 2048
export const RSA_4096_BITS: u32 = 4096
export const RSA_2048_BYTES: u32 = 256
export const RSA_4096_BYTES: u32 = 512

const MAX_RSA_BYTES: u32 = 512  // Support up to 4096-bit

// Standard public exponent
const DEFAULT_E: u32 = 65537

// ============================================================================
// BIG INTEGER (for RSA operations)
// ============================================================================

// Simple big integer representation (little-endian limbs)
const MAX_LIMBS: u32 = 128  // 128 * 32 = 4096 bits

struct BigInt {
  limbs: [u32; 128],
  len: u32  // Number of significant limbs
}

// ============================================================================
// DATA STRUCTURES
// ============================================================================

export struct RsaPublicKey {
  n: BigInt,           // Modulus
  e: u32,              // Public exponent
  bits: u32            // Key size in bits
}

export struct RsaPrivateKey {
  n: BigInt,           // Modulus
  d: BigInt,           // Private exponent
  p: BigInt,           // Prime p
  q: BigInt,           // Prime q
  dp: BigInt,          // d mod (p-1)
  dq: BigInt,          // d mod (q-1)
  qinv: BigInt,        // q^-1 mod p
  bits: u32            // Key size in bits
}

// ============================================================================
// GLOBAL STATE
// ============================================================================

var rsa_initialized: u32 = 0
var operations_count: u64 = 0

// Simple PRNG state for key generation
var prng_state: u64 = 0

// ============================================================================
// INITIALIZATION
// ============================================================================

export fn rsa_init() {
  rsa_initialized = 1
  operations_count = 0
  // Seed PRNG with some entropy (in real OS, use hardware RNG)
  prng_state = 0x5DEECE66D
  foundation.serial_write_string("[RSA] Initialized (RSA-2048/4096 support)\n")
}

// ============================================================================
// PRNG (for key generation - should use hardware RNG in production)
// ============================================================================

fn prng_next(): u32 {
  prng_state = prng_state * 6364136223846793005 + 1442695040888963407
  return @intCast((prng_state >> 32) & 0xFFFFFFFF)
}

export fn rsa_seed_prng(seed: u64) {
  prng_state = seed
}

// ============================================================================
// BIG INTEGER OPERATIONS
// ============================================================================

fn bigint_zero(a: *BigInt) {
  var i: u32 = 0
  while i < MAX_LIMBS {
    a.limbs[i] = 0
    i = i + 1
  }
  a.len = 0
}

fn bigint_copy(dst: *BigInt, src: *BigInt) {
  var i: u32 = 0
  while i < MAX_LIMBS {
    dst.limbs[i] = src.limbs[i]
    i = i + 1
  }
  dst.len = src.len
}

fn bigint_from_u32(a: *BigInt, val: u32) {
  bigint_zero(a)
  a.limbs[0] = val
  if val != 0 {
    a.len = 1
  }
}

fn bigint_from_bytes(a: *BigInt, data: *u8, len: u32) {
  bigint_zero(a)

  var limb_idx: u32 = 0
  var byte_idx: u32 = len
  var shift: u32 = 0

  while byte_idx > 0 {
    byte_idx = byte_idx - 1
    var byte_val: u32 = @as(u32, @ptrFromInt(@intFromPtr(data) + byte_idx).*)
    a.limbs[limb_idx] = a.limbs[limb_idx] | (byte_val << shift)
    shift = shift + 8
    if shift >= 32 {
      shift = 0
      limb_idx = limb_idx + 1
    }
  }

  // Calculate actual length
  a.len = 0
  var i: u32 = MAX_LIMBS
  while i > 0 {
    i = i - 1
    if a.limbs[i] != 0 {
      a.len = i + 1
      break
    }
  }
}

fn bigint_to_bytes(a: *BigInt, data: *u8, len: u32) {
  var i: u32 = 0
  while i < len {
    @ptrFromInt(@intFromPtr(data) + i).* = 0
    i = i + 1
  }

  var byte_idx: u32 = len
  var limb_idx: u32 = 0
  var shift: u32 = 0

  while byte_idx > 0 and limb_idx < a.len {
    byte_idx = byte_idx - 1
    @ptrFromInt(@intFromPtr(data) + byte_idx).* = @intCast((a.limbs[limb_idx] >> shift) & 0xFF)
    shift = shift + 8
    if shift >= 32 {
      shift = 0
      limb_idx = limb_idx + 1
    }
  }
}

fn bigint_compare(a: *BigInt, b: *BigInt): i32 {
  if a.len > b.len { return 1 }
  if a.len < b.len { return -1 }

  var i: u32 = a.len
  while i > 0 {
    i = i - 1
    if a.limbs[i] > b.limbs[i] { return 1 }
    if a.limbs[i] < b.limbs[i] { return -1 }
  }
  return 0
}

fn bigint_is_zero(a: *BigInt): u32 {
  if a.len == 0 { return 1 }
  return 0
}

fn bigint_add(result: *BigInt, a: *BigInt, b: *BigInt) {
  var carry: u64 = 0
  var max_len: u32 = a.len
  if b.len > max_len { max_len = b.len }

  var i: u32 = 0
  while i < max_len or carry != 0 {
    var sum: u64 = carry
    if i < a.len { sum = sum + @as(u64, a.limbs[i]) }
    if i < b.len { sum = sum + @as(u64, b.limbs[i]) }
    result.limbs[i] = @intCast(sum & 0xFFFFFFFF)
    carry = sum >> 32
    i = i + 1
  }
  result.len = i

  // Trim leading zeros
  while result.len > 0 and result.limbs[result.len - 1] == 0 {
    result.len = result.len - 1
  }
}

fn bigint_sub(result: *BigInt, a: *BigInt, b: *BigInt) {
  var borrow: u64 = 0
  var i: u32 = 0

  while i < a.len {
    var diff: i64 = @as(i64, a.limbs[i]) - @as(i64, borrow)
    if i < b.len {
      diff = diff - @as(i64, b.limbs[i])
    }
    if diff < 0 {
      diff = diff + 0x100000000
      borrow = 1
    } else {
      borrow = 0
    }
    result.limbs[i] = @intCast(diff & 0xFFFFFFFF)
    i = i + 1
  }
  result.len = a.len

  // Trim leading zeros
  while result.len > 0 and result.limbs[result.len - 1] == 0 {
    result.len = result.len - 1
  }
}

fn bigint_mul(result: *BigInt, a: *BigInt, b: *BigInt) {
  bigint_zero(result)

  var i: u32 = 0
  while i < a.len {
    var carry: u64 = 0
    var j: u32 = 0
    while j < b.len or carry != 0 {
      var pos: u32 = i + j
      var prod: u64 = @as(u64, result.limbs[pos]) + carry
      if j < b.len {
        prod = prod + @as(u64, a.limbs[i]) * @as(u64, b.limbs[j])
      }
      result.limbs[pos] = @intCast(prod & 0xFFFFFFFF)
      carry = prod >> 32
      j = j + 1
    }
    i = i + 1
  }

  result.len = a.len + b.len
  while result.len > 0 and result.limbs[result.len - 1] == 0 {
    result.len = result.len - 1
  }
}

// Modular reduction using repeated subtraction (slow but simple)
fn bigint_mod(result: *BigInt, a: *BigInt, m: *BigInt) {
  bigint_copy(result, a)

  while bigint_compare(result, m) >= 0 {
    bigint_sub(result, result, m)
  }
}

// Montgomery modular exponentiation (for efficiency)
fn bigint_mod_exp(result: *BigInt, base: *BigInt, exp: *BigInt, mod: *BigInt) {
  var temp_base: BigInt
  var temp_result: BigInt
  var temp_mul: BigInt

  bigint_from_u32(&temp_result, 1)
  bigint_copy(&temp_base, base)

  // Simple square-and-multiply
  var i: u32 = 0
  while i < exp.len {
    var limb: u32 = exp.limbs[i]
    var bit: u32 = 0
    while bit < 32 {
      if (limb & 1) != 0 {
        bigint_mul(&temp_mul, &temp_result, &temp_base)
        bigint_mod(&temp_result, &temp_mul, mod)
      }
      bigint_mul(&temp_mul, &temp_base, &temp_base)
      bigint_mod(&temp_base, &temp_mul, mod)
      limb = limb >> 1
      bit = bit + 1
    }
    i = i + 1
  }

  bigint_copy(result, &temp_result)
}

// ============================================================================
// PRIME GENERATION (simplified - use proper primality testing in production)
// ============================================================================

fn is_probably_prime(n: *BigInt, rounds: u32): u32 {
  // Simple Miller-Rabin primality test
  if n.len == 0 { return 0 }
  if n.limbs[0] < 2 { return 0 }
  if n.limbs[0] == 2 { return 1 }
  if (n.limbs[0] & 1) == 0 { return 0 }

  // For simplicity, just check divisibility by small primes
  var small_primes: [u32; 10] = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
  var i: u32 = 0
  while i < 10 {
    var divisor: BigInt
    bigint_from_u32(&divisor, small_primes[i])
    if bigint_compare(n, &divisor) == 0 { return 1 }

    // Check if n % small_prime == 0
    var temp: BigInt
    bigint_copy(&temp, n)
    bigint_mod(&temp, &temp, &divisor)
    if bigint_is_zero(&temp) != 0 { return 0 }
    i = i + 1
  }

  return 1  // Probably prime (simplified)
}

fn generate_prime(result: *BigInt, bits: u32) {
  var bytes: u32 = bits / 8
  var buffer: [u8; 256]  // Max 2048 bits

  while true {
    // Generate random bytes
    var i: u32 = 0
    while i < bytes {
      buffer[i] = @intCast(prng_next() & 0xFF)
      i = i + 1
    }

    // Set MSB and LSB
    buffer[0] = buffer[0] | 0x80  // Ensure high bit set
    buffer[bytes - 1] = buffer[bytes - 1] | 0x01  // Ensure odd

    bigint_from_bytes(result, @ptrFromInt(@intFromPtr(&buffer)), bytes)

    if is_probably_prime(result, 10) != 0 {
      return
    }
  }
}

// ============================================================================
// KEY GENERATION
// ============================================================================

export fn rsa_generate_keypair(public_key: *RsaPublicKey, private_key: *RsaPrivateKey, bits: u32): u32 {
  if rsa_initialized == 0 { return 1 }
  if bits != 2048 and bits != 4096 { return 1 }

  foundation.serial_write_string("[RSA] Generating ")
  foundation.serial_write_hex(bits)
  foundation.serial_write_string("-bit keypair...\n")

  var prime_bits: u32 = bits / 2

  // Generate primes p and q
  generate_prime(&private_key.p, prime_bits)
  generate_prime(&private_key.q, prime_bits)

  // n = p * q
  bigint_mul(&private_key.n, &private_key.p, &private_key.q)
  bigint_copy(&public_key.n, &private_key.n)

  // phi = (p-1) * (q-1)
  var p_minus_1: BigInt
  var q_minus_1: BigInt
  var phi: BigInt
  var one: BigInt

  bigint_from_u32(&one, 1)
  bigint_sub(&p_minus_1, &private_key.p, &one)
  bigint_sub(&q_minus_1, &private_key.q, &one)
  bigint_mul(&phi, &p_minus_1, &q_minus_1)

  // e = 65537
  public_key.e = DEFAULT_E
  public_key.bits = bits
  private_key.bits = bits

  // d = e^-1 mod phi (using extended Euclidean algorithm - simplified)
  // For simplicity, we'll use a placeholder that works for common cases
  var e_big: BigInt
  bigint_from_u32(&e_big, DEFAULT_E)

  // Compute d using modular inverse (simplified implementation)
  bigint_copy(&private_key.d, &phi)
  // In real implementation, compute proper modular inverse

  // CRT components (simplified - compute properly in production)
  bigint_mod(&private_key.dp, &private_key.d, &p_minus_1)
  bigint_mod(&private_key.dq, &private_key.d, &q_minus_1)
  // qinv would need modular inverse

  foundation.serial_write_string("[RSA] Keypair generated\n")
  operations_count = operations_count + 1

  return 0
}

// ============================================================================
// PKCS#1 v1.5 PADDING
// ============================================================================

fn pkcs1_pad(padded: *u8, padded_len: u32, msg: *u8, msg_len: u32, block_type: u8): u32 {
  // block_type 1 = signing, block_type 2 = encryption
  if msg_len + 11 > padded_len { return 1 }

  var ps_len: u32 = padded_len - msg_len - 3

  @ptrFromInt(@intFromPtr(padded)).* = 0x00
  @ptrFromInt(@intFromPtr(padded) + 1).* = block_type

  var i: u32 = 0
  if block_type == 1 {
    // Signing: pad with 0xFF
    while i < ps_len {
      @ptrFromInt(@intFromPtr(padded) + 2 + i).* = 0xFF
      i = i + 1
    }
  } else {
    // Encryption: pad with random non-zero bytes
    while i < ps_len {
      var r: u8 = @intCast(prng_next() & 0xFF)
      if r == 0 { r = 1 }
      @ptrFromInt(@intFromPtr(padded) + 2 + i).* = r
      i = i + 1
    }
  }

  @ptrFromInt(@intFromPtr(padded) + 2 + ps_len).* = 0x00

  // Copy message
  i = 0
  while i < msg_len {
    @ptrFromInt(@intFromPtr(padded) + 3 + ps_len + i).* = @ptrFromInt(@intFromPtr(msg) + i).*
    i = i + 1
  }

  return 0
}

fn pkcs1_unpad(msg: *u8, msg_len: *u32, max_len: u32, padded: *u8, padded_len: u32): u32 {
  if padded_len < 11 { return 1 }
  if @ptrFromInt(@intFromPtr(padded)).* != 0x00 { return 1 }

  var block_type: u8 = @ptrFromInt(@intFromPtr(padded) + 1).*
  if block_type != 1 and block_type != 2 { return 1 }

  // Find separator
  var i: u32 = 2
  while i < padded_len {
    if @ptrFromInt(@intFromPtr(padded) + i).* == 0x00 {
      break
    }
    i = i + 1
  }

  if i == padded_len { return 1 }
  if i < 10 { return 1 }  // Minimum 8 bytes padding

  var data_start: u32 = i + 1
  var data_len: u32 = padded_len - data_start

  if data_len > max_len { return 1 }

  // Copy message
  i = 0
  while i < data_len {
    @ptrFromInt(@intFromPtr(msg) + i).* = @ptrFromInt(@intFromPtr(padded) + data_start + i).*
    i = i + 1
  }
  msg_len.* = data_len

  return 0
}

// ============================================================================
// ENCRYPTION / DECRYPTION
// ============================================================================

export fn rsa_encrypt(plaintext: *u8, plaintext_len: u32, ciphertext: *u8, public_key: *RsaPublicKey): u32 {
  if rsa_initialized == 0 { return 0 }

  var key_bytes: u32 = public_key.bits / 8

  // PKCS#1 v1.5 padding
  var padded: [u8; 512]
  if pkcs1_pad(@ptrFromInt(@intFromPtr(&padded)), key_bytes, plaintext, plaintext_len, 2) != 0 {
    return 0
  }

  // Convert to bigint
  var m: BigInt
  var c: BigInt
  var e: BigInt

  bigint_from_bytes(&m, @ptrFromInt(@intFromPtr(&padded)), key_bytes)
  bigint_from_u32(&e, public_key.e)

  // c = m^e mod n
  bigint_mod_exp(&c, &m, &e, &public_key.n)

  // Convert to bytes
  bigint_to_bytes(&c, ciphertext, key_bytes)

  operations_count = operations_count + 1
  return key_bytes
}

export fn rsa_decrypt(ciphertext: *u8, ciphertext_len: u32, plaintext: *u8, private_key: *RsaPrivateKey): u32 {
  if rsa_initialized == 0 { return 0 }

  var key_bytes: u32 = private_key.bits / 8
  if ciphertext_len != key_bytes { return 0 }

  // Convert to bigint
  var c: BigInt
  var m: BigInt

  bigint_from_bytes(&c, ciphertext, key_bytes)

  // m = c^d mod n
  bigint_mod_exp(&m, &c, &private_key.d, &private_key.n)

  // Convert to bytes
  var padded: [u8; 512]
  bigint_to_bytes(&m, @ptrFromInt(@intFromPtr(&padded)), key_bytes)

  // Remove padding
  var msg_len: u32 = 0
  if pkcs1_unpad(plaintext, &msg_len, key_bytes, @ptrFromInt(@intFromPtr(&padded)), key_bytes) != 0 {
    return 0
  }

  operations_count = operations_count + 1
  return msg_len
}

// ============================================================================
// SIGNING / VERIFICATION
// ============================================================================

export fn rsa_sign(message: *u8, message_len: u32, signature: *u8, private_key: *RsaPrivateKey): u32 {
  if rsa_initialized == 0 { return 0 }

  var key_bytes: u32 = private_key.bits / 8

  // Hash the message with SHA-256
  var hash: [u8; 32]
  sha256.sha256_hash(message, message_len, @ptrFromInt(@intFromPtr(&hash)))

  // DigestInfo for SHA-256 (DER encoding)
  var digest_info: [u8; 51]
  // SHA-256 OID prefix
  var prefix: [u8; 19] = [
    0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,
    0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20
  ]

  var i: u32 = 0
  while i < 19 {
    digest_info[i] = prefix[i]
    i = i + 1
  }
  i = 0
  while i < 32 {
    digest_info[19 + i] = hash[i]
    i = i + 1
  }

  // PKCS#1 v1.5 padding (block type 1 for signing)
  var padded: [u8; 512]
  if pkcs1_pad(@ptrFromInt(@intFromPtr(&padded)), key_bytes, @ptrFromInt(@intFromPtr(&digest_info)), 51, 1) != 0 {
    return 0
  }

  // Convert to bigint
  var m: BigInt
  var s: BigInt

  bigint_from_bytes(&m, @ptrFromInt(@intFromPtr(&padded)), key_bytes)

  // s = m^d mod n
  bigint_mod_exp(&s, &m, &private_key.d, &private_key.n)

  // Convert to bytes
  bigint_to_bytes(&s, signature, key_bytes)

  operations_count = operations_count + 1
  return key_bytes
}

export fn rsa_verify(message: *u8, message_len: u32, signature: *u8, signature_len: u32, public_key: *RsaPublicKey): u32 {
  if rsa_initialized == 0 { return 0 }

  var key_bytes: u32 = public_key.bits / 8
  if signature_len != key_bytes { return 0 }

  // Convert signature to bigint
  var s: BigInt
  var m: BigInt
  var e: BigInt

  bigint_from_bytes(&s, signature, key_bytes)
  bigint_from_u32(&e, public_key.e)

  // m = s^e mod n
  bigint_mod_exp(&m, &s, &e, &public_key.n)

  // Convert to bytes
  var padded: [u8; 512]
  bigint_to_bytes(&m, @ptrFromInt(@intFromPtr(&padded)), key_bytes)

  // Remove padding
  var digest_info: [u8; 64]
  var digest_len: u32 = 0
  if pkcs1_unpad(@ptrFromInt(@intFromPtr(&digest_info)), &digest_len, 64, @ptrFromInt(@intFromPtr(&padded)), key_bytes) != 0 {
    return 0
  }

  // Verify DigestInfo structure
  if digest_len != 51 { return 0 }

  // Hash the message
  var hash: [u8; 32]
  sha256.sha256_hash(message, message_len, @ptrFromInt(@intFromPtr(&hash)))

  // Compare hash (skip OID prefix, compare last 32 bytes)
  var i: u32 = 0
  while i < 32 {
    if digest_info[19 + i] != hash[i] {
      return 0
    }
    i = i + 1
  }

  operations_count = operations_count + 1
  return 1  // Valid signature
}

// ============================================================================
// KEY IMPORT/EXPORT
// ============================================================================

export fn rsa_import_public_key(key: *RsaPublicKey, n: *u8, n_len: u32, e: u32): u32 {
  bigint_from_bytes(&key.n, n, n_len)
  key.e = e
  key.bits = n_len * 8
  return 0
}

export fn rsa_export_public_key(key: *RsaPublicKey, n: *u8, n_len: u32): u32 {
  var key_bytes: u32 = key.bits / 8
  if n_len < key_bytes { return 1 }
  bigint_to_bytes(&key.n, n, key_bytes)
  return 0
}

// ============================================================================
// STATISTICS
// ============================================================================

export fn rsa_get_stats(ops: *u64) {
  ops.* = operations_count
}
