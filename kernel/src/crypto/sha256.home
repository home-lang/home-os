// home-os SHA-256
// Secure Hash Algorithm 256-bit - Full Implementation
// FIPS 180-4 compliant

import "../core/foundation.home" as foundation

// ============================================================================
// CONSTANTS
// ============================================================================

export const SHA256_BLOCK_SIZE: u32 = 64
export const SHA256_DIGEST_SIZE: u32 = 32

// Initial hash values (first 32 bits of fractional parts of square roots of first 8 primes)
const H0: u32 = 0x6a09e667
const H1: u32 = 0xbb67ae85
const H2: u32 = 0x3c6ef372
const H3: u32 = 0xa54ff53a
const H4: u32 = 0x510e527f
const H5: u32 = 0x9b05688c
const H6: u32 = 0x1f83d9ab
const H7: u32 = 0x5be0cd19

// Round constants (first 32 bits of fractional parts of cube roots of first 64 primes)
const K: [u32; 64] = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]

// ============================================================================
// DATA STRUCTURES
// ============================================================================

export struct Sha256Context {
  state: [u32; 8],      // Hash state (a, b, c, d, e, f, g, h)
  count: u64,           // Number of bits processed
  buffer: [u8; 64]      // Input buffer
}

// ============================================================================
// GLOBAL STATE
// ============================================================================

var sha256_initialized: u32 = 0
var hashes_computed: u64 = 0
var bytes_processed: u64 = 0

// ============================================================================
// INITIALIZATION
// ============================================================================

export fn sha256_init() {
  sha256_initialized = 1
  hashes_computed = 0
  bytes_processed = 0
  foundation.serial_write_string("[SHA256] Initialized\n")
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Right rotate
fn rotr(x: u32, n: u32): u32 {
  return (x >> n) | (x << (32 - n))
}

// SHA-256 functions
fn ch(x: u32, y: u32, z: u32): u32 {
  return (x & y) ^ ((~x) & z)
}

fn maj(x: u32, y: u32, z: u32): u32 {
  return (x & y) ^ (x & z) ^ (y & z)
}

fn sigma0(x: u32): u32 {
  return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22)
}

fn sigma1(x: u32): u32 {
  return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25)
}

fn gamma0(x: u32): u32 {
  return rotr(x, 7) ^ rotr(x, 18) ^ (x >> 3)
}

fn gamma1(x: u32): u32 {
  return rotr(x, 17) ^ rotr(x, 19) ^ (x >> 10)
}

// ============================================================================
// CORE TRANSFORM
// ============================================================================

fn sha256_transform(ctx: *Sha256Context, block: *u8) {
  var w: [u32; 64]
  var a: u32 = ctx.state[0]
  var b: u32 = ctx.state[1]
  var c: u32 = ctx.state[2]
  var d: u32 = ctx.state[3]
  var e: u32 = ctx.state[4]
  var f: u32 = ctx.state[5]
  var g: u32 = ctx.state[6]
  var h: u32 = ctx.state[7]

  // Prepare message schedule (big-endian)
  var i: u32 = 0
  while i < 16 {
    var offset: u32 = i * 4
    var b0: u32 = @as(u32, @ptrFromInt(@intFromPtr(block) + offset).*)
    var b1: u32 = @as(u32, @ptrFromInt(@intFromPtr(block) + offset + 1).*)
    var b2: u32 = @as(u32, @ptrFromInt(@intFromPtr(block) + offset + 2).*)
    var b3: u32 = @as(u32, @ptrFromInt(@intFromPtr(block) + offset + 3).*)
    w[i] = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
    i = i + 1
  }

  // Extend message schedule
  while i < 64 {
    w[i] = gamma1(w[i - 2]) + w[i - 7] + gamma0(w[i - 15]) + w[i - 16]
    i = i + 1
  }

  // Main compression loop
  i = 0
  while i < 64 {
    var t1: u32 = h + sigma1(e) + ch(e, f, g) + K[i] + w[i]
    var t2: u32 = sigma0(a) + maj(a, b, c)

    h = g
    g = f
    f = e
    e = d + t1
    d = c
    c = b
    b = a
    a = t1 + t2

    i = i + 1
  }

  // Update state
  ctx.state[0] = ctx.state[0] + a
  ctx.state[1] = ctx.state[1] + b
  ctx.state[2] = ctx.state[2] + c
  ctx.state[3] = ctx.state[3] + d
  ctx.state[4] = ctx.state[4] + e
  ctx.state[5] = ctx.state[5] + f
  ctx.state[6] = ctx.state[6] + g
  ctx.state[7] = ctx.state[7] + h
}

// ============================================================================
// CONTEXT OPERATIONS
// ============================================================================

export fn sha256_ctx_init(ctx: *Sha256Context) {
  ctx.state[0] = H0
  ctx.state[1] = H1
  ctx.state[2] = H2
  ctx.state[3] = H3
  ctx.state[4] = H4
  ctx.state[5] = H5
  ctx.state[6] = H6
  ctx.state[7] = H7
  ctx.count = 0

  var i: u32 = 0
  while i < 64 {
    ctx.buffer[i] = 0
    i = i + 1
  }
}

export fn sha256_update(ctx: *Sha256Context, data: *u8, len: u32) {
  if len == 0 { return }

  var buffer_idx: u32 = @intCast((ctx.count / 8) % 64)
  ctx.count = ctx.count + (@as(u64, len) * 8)

  var data_offset: u32 = 0

  // Fill buffer if partial
  if buffer_idx != 0 {
    var fill: u32 = 64 - buffer_idx
    if len < fill {
      fill = len
    }

    var i: u32 = 0
    while i < fill {
      ctx.buffer[buffer_idx + i] = @ptrFromInt(@intFromPtr(data) + i).*
      i = i + 1
    }

    buffer_idx = buffer_idx + fill
    data_offset = fill

    if buffer_idx == 64 {
      sha256_transform(ctx, @ptrFromInt(@intFromPtr(&ctx.buffer)))
      buffer_idx = 0
    }
  }

  // Process full blocks
  while data_offset + 64 <= len {
    sha256_transform(ctx, @ptrFromInt(@intFromPtr(data) + data_offset))
    data_offset = data_offset + 64
  }

  // Copy remaining to buffer
  var remaining: u32 = len - data_offset
  var i: u32 = 0
  while i < remaining {
    ctx.buffer[i] = @ptrFromInt(@intFromPtr(data) + data_offset + i).*
    i = i + 1
  }

  bytes_processed = bytes_processed + len
}

export fn sha256_final(ctx: *Sha256Context, digest: *u8) {
  var buffer_idx: u32 = @intCast((ctx.count / 8) % 64)

  // Pad with 0x80
  ctx.buffer[buffer_idx] = 0x80
  buffer_idx = buffer_idx + 1

  // If not enough room for length, pad and transform
  if buffer_idx > 56 {
    while buffer_idx < 64 {
      ctx.buffer[buffer_idx] = 0
      buffer_idx = buffer_idx + 1
    }
    sha256_transform(ctx, @ptrFromInt(@intFromPtr(&ctx.buffer)))
    buffer_idx = 0
  }

  // Pad to 56 bytes
  while buffer_idx < 56 {
    ctx.buffer[buffer_idx] = 0
    buffer_idx = buffer_idx + 1
  }

  // Append length in bits (big-endian)
  ctx.buffer[56] = @intCast((ctx.count >> 56) & 0xFF)
  ctx.buffer[57] = @intCast((ctx.count >> 48) & 0xFF)
  ctx.buffer[58] = @intCast((ctx.count >> 40) & 0xFF)
  ctx.buffer[59] = @intCast((ctx.count >> 32) & 0xFF)
  ctx.buffer[60] = @intCast((ctx.count >> 24) & 0xFF)
  ctx.buffer[61] = @intCast((ctx.count >> 16) & 0xFF)
  ctx.buffer[62] = @intCast((ctx.count >> 8) & 0xFF)
  ctx.buffer[63] = @intCast(ctx.count & 0xFF)

  sha256_transform(ctx, @ptrFromInt(@intFromPtr(&ctx.buffer)))

  // Output digest (big-endian)
  var i: u32 = 0
  while i < 8 {
    var offset: u32 = i * 4
    @ptrFromInt(@intFromPtr(digest) + offset).* = @intCast((ctx.state[i] >> 24) & 0xFF)
    @ptrFromInt(@intFromPtr(digest) + offset + 1).* = @intCast((ctx.state[i] >> 16) & 0xFF)
    @ptrFromInt(@intFromPtr(digest) + offset + 2).* = @intCast((ctx.state[i] >> 8) & 0xFF)
    @ptrFromInt(@intFromPtr(digest) + offset + 3).* = @intCast(ctx.state[i] & 0xFF)
    i = i + 1
  }

  hashes_computed = hashes_computed + 1
}

// ============================================================================
// ONE-SHOT HASH
// ============================================================================

export fn sha256_hash(data: *u8, len: u32, digest: *u8) {
  if sha256_initialized == 0 { return }

  var ctx: Sha256Context
  sha256_ctx_init(&ctx)
  sha256_update(&ctx, data, len)
  sha256_final(&ctx, digest)
}

// ============================================================================
// HMAC-SHA256
// ============================================================================

export fn hmac_sha256(key: *u8, key_len: u32, data: *u8, data_len: u32, mac: *u8) {
  var k_ipad: [u8; 64]
  var k_opad: [u8; 64]
  var tk: [u8; 32]
  var actual_key: *u8 = key
  var actual_key_len: u32 = key_len

  // If key is longer than block size, hash it
  if key_len > 64 {
    sha256_hash(key, key_len, @ptrFromInt(@intFromPtr(&tk)))
    actual_key = @ptrFromInt(@intFromPtr(&tk))
    actual_key_len = 32
  }

  // Prepare pads
  var i: u32 = 0
  while i < 64 {
    if i < actual_key_len {
      k_ipad[i] = @ptrFromInt(@intFromPtr(actual_key) + i).* ^ 0x36
      k_opad[i] = @ptrFromInt(@intFromPtr(actual_key) + i).* ^ 0x5c
    } else {
      k_ipad[i] = 0x36
      k_opad[i] = 0x5c
    }
    i = i + 1
  }

  // Inner hash: H(K XOR ipad, data)
  var ctx: Sha256Context
  sha256_ctx_init(&ctx)
  sha256_update(&ctx, @ptrFromInt(@intFromPtr(&k_ipad)), 64)
  sha256_update(&ctx, data, data_len)

  var inner_hash: [u8; 32]
  sha256_final(&ctx, @ptrFromInt(@intFromPtr(&inner_hash)))

  // Outer hash: H(K XOR opad, inner_hash)
  sha256_ctx_init(&ctx)
  sha256_update(&ctx, @ptrFromInt(@intFromPtr(&k_opad)), 64)
  sha256_update(&ctx, @ptrFromInt(@intFromPtr(&inner_hash)), 32)
  sha256_final(&ctx, mac)
}

// ============================================================================
// PBKDF2-HMAC-SHA256
// ============================================================================

export fn pbkdf2_sha256(password: *u8, password_len: u32, salt: *u8, salt_len: u32, iterations: u32, dk: *u8, dk_len: u32) {
  var block_count: u32 = (dk_len + 31) / 32
  var remaining: u32 = dk_len
  var dk_offset: u32 = 0

  var block: u32 = 1
  while block <= block_count {
    // U1 = PRF(Password, Salt || INT(i))
    var u: [u8; 32]
    var t: [u8; 32]

    // Create Salt || INT(block)
    var salt_block: [u8; 68]  // Max salt + 4
    var j: u32 = 0
    while j < salt_len and j < 64 {
      salt_block[j] = @ptrFromInt(@intFromPtr(salt) + j).*
      j = j + 1
    }
    salt_block[salt_len] = @intCast((block >> 24) & 0xFF)
    salt_block[salt_len + 1] = @intCast((block >> 16) & 0xFF)
    salt_block[salt_len + 2] = @intCast((block >> 8) & 0xFF)
    salt_block[salt_len + 3] = @intCast(block & 0xFF)

    hmac_sha256(password, password_len, @ptrFromInt(@intFromPtr(&salt_block)), salt_len + 4, @ptrFromInt(@intFromPtr(&u)))

    // Copy U1 to T
    j = 0
    while j < 32 {
      t[j] = u[j]
      j = j + 1
    }

    // Iterations
    var iter: u32 = 1
    while iter < iterations {
      var prev_u: [u8; 32]
      j = 0
      while j < 32 {
        prev_u[j] = u[j]
        j = j + 1
      }

      hmac_sha256(password, password_len, @ptrFromInt(@intFromPtr(&prev_u)), 32, @ptrFromInt(@intFromPtr(&u)))

      // T = T XOR Ui
      j = 0
      while j < 32 {
        t[j] = t[j] ^ u[j]
        j = j + 1
      }

      iter = iter + 1
    }

    // Copy to output
    var copy_len: u32 = 32
    if remaining < 32 {
      copy_len = remaining
    }

    j = 0
    while j < copy_len {
      @ptrFromInt(@intFromPtr(dk) + dk_offset + j).* = t[j]
      j = j + 1
    }

    dk_offset = dk_offset + copy_len
    remaining = remaining - copy_len
    block = block + 1
  }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

// Convert hash to hex string (64 chars + null)
export fn sha256_to_hex(digest: *u8, hex: *u8) {
  const HEX_CHARS: *u8 = "0123456789abcdef"

  var i: u32 = 0
  while i < 32 {
    var byte: u8 = @ptrFromInt(@intFromPtr(digest) + i).*
    var hex_ptr: *u8 = @ptrFromInt(@intFromPtr(hex) + (i * 2))
    hex_ptr.* = @ptrFromInt(@intFromPtr(HEX_CHARS) + ((byte >> 4) & 0x0F)).*
    @ptrFromInt(@intFromPtr(hex) + (i * 2) + 1).* = @ptrFromInt(@intFromPtr(HEX_CHARS) + (byte & 0x0F)).*
    i = i + 1
  }
  @ptrFromInt(@intFromPtr(hex) + 64).* = 0  // Null terminator
}

// Compare two digests (constant-time)
export fn sha256_compare(a: *u8, b: *u8): u32 {
  var result: u8 = 0
  var i: u32 = 0
  while i < 32 {
    result = result | (@ptrFromInt(@intFromPtr(a) + i).* ^ @ptrFromInt(@intFromPtr(b) + i).*)
    i = i + 1
  }
  if result == 0 {
    return 1  // Equal
  }
  return 0  // Not equal
}

// ============================================================================
// STATISTICS
// ============================================================================

export fn sha256_get_stats(computed: *u64, processed: *u64) {
  computed.* = hashes_computed
  processed.* = bytes_processed
}
