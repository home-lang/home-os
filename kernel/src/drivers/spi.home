// home-os SPI Driver
// Serial Peripheral Interface

import "../core/foundation.home" as foundation

const SPI_BASE: u16 = 0x0D00

const SPI_CR1: u16 = 0x00
const SPI_CR2: u16 = 0x04
const SPI_SR: u16 = 0x08
const SPI_DR: u16 = 0x0C

const SPI_SR_TXE: u8 = 0x02
const SPI_SR_RXNE: u8 = 0x01

var spi_initialized: u32 = 0

export fn spi_init() {
  if spi_initialized == 1 { return }
  
  // Configure SPI
  foundation.outb(SPI_BASE + SPI_CR1, 0x04)  // Master mode
  foundation.outb(SPI_BASE + SPI_CR1, 0x40)  // Enable SPI
  
  spi_initialized = 1
  foundation.serial_write_string("[SPI] Initialized\n")
}

fn spi_transfer_byte(data: u8) -> u8 {
  // Wait for TX empty
  while (foundation.inb(SPI_BASE + SPI_SR) & SPI_SR_TXE) == 0 {}
  
  foundation.outb(SPI_BASE + SPI_DR, data)
  
  // Wait for RX not empty
  while (foundation.inb(SPI_BASE + SPI_SR) & SPI_SR_RXNE) == 0 {}
  
  return foundation.inb(SPI_BASE + SPI_DR)
}

export fn spi_transfer(tx_data: u64, rx_data: u64, length: u32) -> u32 {
  if spi_initialized == 0 { return 1 }
  
  var i: u32 = 0
  while i < length {
    var tx_byte: u8 = 0xFF
    if tx_data != 0 {
      tx_byte = @intToPtr(tx_data + i, u8)
    }
    
    var rx_byte: u8 = spi_transfer_byte(tx_byte)
    
    if rx_data != 0 {
      @ptrToInt(rx_data + i, u8) = rx_byte
    }
    
    i = i + 1
  }
  
  return 0
}

export fn spi_write(data: u64, length: u32) -> u32 {
  return spi_transfer(data, 0, length)
}

export fn spi_read(buffer: u64, length: u32) -> u32 {
  return spi_transfer(0, buffer, length)
}
