// home-os SPI (Serial Peripheral Interface) Driver
// Full-featured SPI controller with multiple bus and DMA support

import "../core/foundation.home" as foundation

// SPI controller types
const SPI_CTRL_BCM2835: u8 = 0     // Raspberry Pi
const SPI_CTRL_INTEL_PCH: u8 = 1   // Intel PCH SPI
const SPI_CTRL_DESIGNWARE: u8 = 2  // DesignWare SPI
const SPI_CTRL_BITBANG: u8 = 3     // Bit-banged GPIO

// SPI modes (CPOL, CPHA combinations)
const SPI_MODE_0: u8 = 0  // CPOL=0, CPHA=0
const SPI_MODE_1: u8 = 1  // CPOL=0, CPHA=1
const SPI_MODE_2: u8 = 2  // CPOL=1, CPHA=0
const SPI_MODE_3: u8 = 3  // CPOL=1, CPHA=1

// Bit order
const SPI_MSB_FIRST: u8 = 0
const SPI_LSB_FIRST: u8 = 1

// Chip select polarity
const SPI_CS_ACTIVE_LOW: u8 = 0
const SPI_CS_ACTIVE_HIGH: u8 = 1

// Transfer flags
const SPI_FLAG_NO_CS: u8 = 0x01       // Don't toggle CS
const SPI_FLAG_CS_HIGH: u8 = 0x02     // CS stays high
const SPI_FLAG_HALF_DUPLEX: u8 = 0x04 // Half-duplex mode
const SPI_FLAG_3WIRE: u8 = 0x08       // 3-wire mode
const SPI_FLAG_TX_DUAL: u8 = 0x10     // Dual TX
const SPI_FLAG_TX_QUAD: u8 = 0x20     // Quad TX
const SPI_FLAG_RX_DUAL: u8 = 0x40     // Dual RX
const SPI_FLAG_RX_QUAD: u8 = 0x80     // Quad RX

// BCM2835 SPI registers
const BCM_SPI_CS: u32 = 0x00     // Control and Status
const BCM_SPI_FIFO: u32 = 0x04   // TX and RX FIFOs
const BCM_SPI_CLK: u32 = 0x08    // Clock Divider
const BCM_SPI_DLEN: u32 = 0x0C   // Data Length
const BCM_SPI_LTOH: u32 = 0x10   // LOSSI mode TOH
const BCM_SPI_DC: u32 = 0x14     // DMA DREQ Controls

// BCM SPI CS register bits
const BCM_SPI_CS_LEN_LONG: u32 = 0x02000000  // Enable Long data word
const BCM_SPI_CS_DMA_LEN: u32 = 0x01000000   // Enable DMA mode
const BCM_SPI_CS_CSPOL2: u32 = 0x00800000    // CS2 Polarity
const BCM_SPI_CS_CSPOL1: u32 = 0x00400000    // CS1 Polarity
const BCM_SPI_CS_CSPOL0: u32 = 0x00200000    // CS0 Polarity
const BCM_SPI_CS_RXF: u32 = 0x00100000       // RX FIFO Full
const BCM_SPI_CS_RXR: u32 = 0x00080000       // RX FIFO needs Reading
const BCM_SPI_CS_TXD: u32 = 0x00040000       // TX FIFO can accept Data
const BCM_SPI_CS_RXD: u32 = 0x00020000       // RX FIFO contains Data
const BCM_SPI_CS_DONE: u32 = 0x00010000      // Transfer Done
const BCM_SPI_CS_LEN: u32 = 0x00002000       // LEN LoSSI enable
const BCM_SPI_CS_REN: u32 = 0x00001000       // Read Enable
const BCM_SPI_CS_ADCS: u32 = 0x00000800      // Automatically Deassert CS
const BCM_SPI_CS_INTR: u32 = 0x00000400      // Interrupt on RXR
const BCM_SPI_CS_INTD: u32 = 0x00000200      // Interrupt on Done
const BCM_SPI_CS_DMAEN: u32 = 0x00000100     // DMA Enable
const BCM_SPI_CS_TA: u32 = 0x00000080        // Transfer Active
const BCM_SPI_CS_CSPOL: u32 = 0x00000040     // CS Polarity
const BCM_SPI_CS_CLEAR: u32 = 0x00000030     // Clear FIFO
const BCM_SPI_CS_CPOL: u32 = 0x00000008      // Clock Polarity
const BCM_SPI_CS_CPHA: u32 = 0x00000004      // Clock Phase
const BCM_SPI_CS_CS: u32 = 0x00000003        // Chip Select

// Constants
const MAX_SPI_CONTROLLERS: u32 = 4
const MAX_SPI_DEVICES: u32 = 16
const SPI_FIFO_SIZE: u32 = 64
const SPI_TIMEOUT_MS: u64 = 1000
const SPI_MAX_SPEED: u32 = 125000000  // 125 MHz

// SPI transfer descriptor
struct SpiTransfer {
    tx_buf: u64,
    rx_buf: u64,
    len: u32,
    speed_hz: u32,
    delay_usecs: u16,
    bits_per_word: u8,
    cs_change: u8,
    flags: u8
}

// SPI controller
struct SpiController {
    controller_type: u8,
    base_addr: u64,
    irq: u8,
    num_cs: u8,
    max_speed: u32,
    min_speed: u32,
    active: u8
}

// SPI device
struct SpiDevice {
    controller: u8,
    cs: u8,
    mode: u8,
    bit_order: u8,
    bits_per_word: u8,
    speed_hz: u32,
    cs_polarity: u8,
    active: u8
}

// Statistics
struct SpiStats {
    transfers: u64,
    bytes_sent: u64,
    bytes_received: u64,
    errors: u32,
    timeouts: u32
}

// Global state
var spi_controllers: [SpiController; 4]
var spi_controller_count: u32 = 0
var spi_devices: [SpiDevice; 16]
var spi_device_count: u32 = 0
var spi_stats: SpiStats
var spi_initialized: u32 = 0

// Initialize SPI subsystem
export fn spi_init(): u32 {
    if spi_initialized == 1 {
        return 1
    }

    // Clear controllers
    var i: u32 = 0
    while i < MAX_SPI_CONTROLLERS {
        spi_controllers[i].active = 0
        i = i + 1
    }

    // Clear devices
    i = 0
    while i < MAX_SPI_DEVICES {
        spi_devices[i].active = 0
        i = i + 1
    }

    // Clear stats
    spi_stats.transfers = 0
    spi_stats.bytes_sent = 0
    spi_stats.bytes_received = 0
    spi_stats.errors = 0
    spi_stats.timeouts = 0

    spi_controller_count = 0
    spi_device_count = 0

    spi_initialized = 1
    foundation.serial_write_string("[SPI] Subsystem initialized\n")
    return 1
}

// Register an SPI controller
export fn spi_register_controller(ctrl_type: u8, base_addr: u64, irq: u8, num_cs: u8): u32 {
    if spi_controller_count >= MAX_SPI_CONTROLLERS {
        return 0xFFFFFFFF
    }

    var idx: u32 = spi_controller_count
    spi_controllers[idx].controller_type = ctrl_type
    spi_controllers[idx].base_addr = base_addr
    spi_controllers[idx].irq = irq
    spi_controllers[idx].num_cs = num_cs
    spi_controllers[idx].max_speed = SPI_MAX_SPEED
    spi_controllers[idx].min_speed = 100000
    spi_controllers[idx].active = 1

    // Initialize controller hardware
    if ctrl_type == SPI_CTRL_BCM2835 {
        spi_bcm_init(idx)
    }

    spi_controller_count = spi_controller_count + 1

    foundation.serial_write_string("[SPI] Controller ")
    foundation.serial_write_hex(idx)
    foundation.serial_write_string(" registered at 0x")
    foundation.serial_write_hex(base_addr)
    foundation.serial_write_string("\n")

    return idx
}

// Register BCM2835 controller
export fn spi_register_bcm2835(base_addr: u64): u32 {
    return spi_register_controller(SPI_CTRL_BCM2835, base_addr, 0, 3)  // 3 CS lines
}

// Initialize BCM2835 SPI
fn spi_bcm_init(idx: u32) {
    var base: u64 = spi_controllers[idx].base_addr

    // Clear FIFOs and reset
    spi_write_reg32(base + BCM_SPI_CS, BCM_SPI_CS_CLEAR)

    // Set default clock divider (250MHz / 256 = ~1MHz)
    spi_write_reg32(base + BCM_SPI_CLK, 256)
}

// Register a device on the bus
export fn spi_register_device(controller: u32, cs: u8, mode: u8, speed_hz: u32): u32 {
    if controller >= spi_controller_count {
        return 0xFFFFFFFF
    }

    if cs >= spi_controllers[controller].num_cs {
        return 0xFFFFFFFF
    }

    // Find empty slot
    var i: u32 = 0
    while i < MAX_SPI_DEVICES {
        if spi_devices[i].active == 0 {
            spi_devices[i].controller = controller
            spi_devices[i].cs = cs
            spi_devices[i].mode = mode
            spi_devices[i].bit_order = SPI_MSB_FIRST
            spi_devices[i].bits_per_word = 8
            spi_devices[i].speed_hz = speed_hz
            spi_devices[i].cs_polarity = SPI_CS_ACTIVE_LOW
            spi_devices[i].active = 1
            spi_device_count = spi_device_count + 1
            return i
        }
        i = i + 1
    }

    return 0xFFFFFFFF
}

// Unregister a device
export fn spi_unregister_device(handle: u32) {
    if handle >= MAX_SPI_DEVICES { return }
    if spi_devices[handle].active == 0 { return }

    spi_devices[handle].active = 0
    spi_device_count = spi_device_count - 1
}

// Set device mode
export fn spi_set_mode(handle: u32, mode: u8) {
    if handle >= MAX_SPI_DEVICES { return }
    if spi_devices[handle].active == 0 { return }

    spi_devices[handle].mode = mode
}

// Set device speed
export fn spi_set_speed(handle: u32, speed_hz: u32) {
    if handle >= MAX_SPI_DEVICES { return }
    if spi_devices[handle].active == 0 { return }

    spi_devices[handle].speed_hz = speed_hz
}

// Set bits per word
export fn spi_set_bits_per_word(handle: u32, bits: u8) {
    if handle >= MAX_SPI_DEVICES { return }
    if spi_devices[handle].active == 0 { return }

    spi_devices[handle].bits_per_word = bits
}

// Set bit order
export fn spi_set_bit_order(handle: u32, order: u8) {
    if handle >= MAX_SPI_DEVICES { return }
    if spi_devices[handle].active == 0 { return }

    spi_devices[handle].bit_order = order
}

// Full-duplex transfer
export fn spi_transfer(handle: u32, tx_data: u64, rx_data: u64, length: u32): u32 {
    if handle >= MAX_SPI_DEVICES { return 0 }
    if spi_devices[handle].active == 0 { return 0 }

    var controller: u8 = spi_devices[handle].controller
    var result: u32 = 0

    if spi_controllers[controller].controller_type == SPI_CTRL_BCM2835 {
        result = spi_bcm_transfer(handle, tx_data, rx_data, length)
    }

    if result > 0 {
        spi_stats.transfers = spi_stats.transfers + 1
        if tx_data != 0 {
            spi_stats.bytes_sent = spi_stats.bytes_sent + result
        }
        if rx_data != 0 {
            spi_stats.bytes_received = spi_stats.bytes_received + result
        }
    }

    return result
}

// BCM2835 transfer
fn spi_bcm_transfer(handle: u32, tx_data: u64, rx_data: u64, length: u32): u32 {
    var controller: u8 = spi_devices[handle].controller
    var base: u64 = spi_controllers[controller].base_addr
    var device: SpiDevice = spi_devices[handle]

    // Calculate clock divider
    // BCM2835 SPI clock = Core clock / CDIV
    // Core clock = 250MHz, we want device.speed_hz
    var cdiv: u32 = 250000000 / device.speed_hz
    if cdiv < 2 { cdiv = 2 }
    if cdiv > 65535 { cdiv = 65535 }
    // Round to even
    cdiv = (cdiv + 1) & 0xFFFFFFFE

    spi_write_reg32(base + BCM_SPI_CLK, cdiv)

    // Configure CS register
    var cs_reg: u32 = 0

    // Set chip select
    cs_reg = cs_reg | (device.cs & BCM_SPI_CS_CS)

    // Set mode (CPOL, CPHA)
    if (device.mode & 0x02) != 0 {
        cs_reg = cs_reg | BCM_SPI_CS_CPOL
    }
    if (device.mode & 0x01) != 0 {
        cs_reg = cs_reg | BCM_SPI_CS_CPHA
    }

    // Set CS polarity
    if device.cs_polarity == SPI_CS_ACTIVE_HIGH {
        if device.cs == 0 { cs_reg = cs_reg | BCM_SPI_CS_CSPOL0 }
        else if device.cs == 1 { cs_reg = cs_reg | BCM_SPI_CS_CSPOL1 }
        else if device.cs == 2 { cs_reg = cs_reg | BCM_SPI_CS_CSPOL2 }
        cs_reg = cs_reg | BCM_SPI_CS_CSPOL
    }

    // Clear FIFOs
    spi_write_reg32(base + BCM_SPI_CS, cs_reg | BCM_SPI_CS_CLEAR)

    // Start transfer
    spi_write_reg32(base + BCM_SPI_CS, cs_reg | BCM_SPI_CS_TA)

    var sent: u32 = 0
    var received: u32 = 0
    var start: u64 = foundation.timer_get_ticks()
    var timeout: u64 = SPI_TIMEOUT_MS

    while sent < length || received < length {
        // Check timeout
        if foundation.timer_get_ticks() - start > timeout {
            spi_stats.timeouts = spi_stats.timeouts + 1
            // End transfer
            spi_write_reg32(base + BCM_SPI_CS, cs_reg)
            return 0
        }

        var status: u32 = spi_read_reg32(base + BCM_SPI_CS)

        // Write data if TX FIFO has space
        while ((status & BCM_SPI_CS_TXD) != 0) && (sent < length) {
            var tx_byte: u8 = 0xFF
            if tx_data != 0 {
                tx_byte = @intToPtr(tx_data + sent, u8)
            }
            spi_write_reg32(base + BCM_SPI_FIFO, tx_byte)
            sent = sent + 1
            status = spi_read_reg32(base + BCM_SPI_CS)
        }

        // Read data if RX FIFO has data
        while ((status & BCM_SPI_CS_RXD) != 0) && (received < length) {
            var rx_byte: u8 = spi_read_reg32(base + BCM_SPI_FIFO) & 0xFF
            if rx_data != 0 {
                @ptrToInt(rx_data + received, u8) = rx_byte
            }
            received = received + 1
            status = spi_read_reg32(base + BCM_SPI_CS)
        }
    }

    // Wait for transfer to complete
    while 1 == 1 {
        if foundation.timer_get_ticks() - start > timeout {
            spi_stats.timeouts = spi_stats.timeouts + 1
            break
        }

        var status: u32 = spi_read_reg32(base + BCM_SPI_CS)
        if (status & BCM_SPI_CS_DONE) != 0 {
            break
        }
    }

    // Drain remaining RX data
    while (spi_read_reg32(base + BCM_SPI_CS) & BCM_SPI_CS_RXD) != 0 {
        if received >= length { break }
        var rx_byte: u8 = spi_read_reg32(base + BCM_SPI_FIFO) & 0xFF
        if rx_data != 0 {
            @ptrToInt(rx_data + received, u8) = rx_byte
        }
        received = received + 1
    }

    // End transfer
    spi_write_reg32(base + BCM_SPI_CS, cs_reg)

    return received
}

// Write only (no read)
export fn spi_write(handle: u32, data: u64, length: u32): u32 {
    return spi_transfer(handle, data, 0, length)
}

// Read only (write 0xFF)
export fn spi_read(handle: u32, buffer: u64, length: u32): u32 {
    return spi_transfer(handle, 0, buffer, length)
}

// Write then read (half-duplex)
export fn spi_write_then_read(handle: u32, tx_data: u64, tx_len: u32, rx_data: u64, rx_len: u32): u32 {
    if handle >= MAX_SPI_DEVICES { return 0 }
    if spi_devices[handle].active == 0 { return 0 }

    // Write phase
    if spi_transfer(handle, tx_data, 0, tx_len) == 0 {
        return 0
    }

    // Read phase
    return spi_transfer(handle, 0, rx_data, rx_len)
}

// Write byte
export fn spi_write_byte(handle: u32, data: u8): u32 {
    var byte: [u8; 1]
    byte[0] = data
    return spi_transfer(handle, @ptrFromInt(byte), 0, 1)
}

// Read byte
export fn spi_read_byte(handle: u32): u8 {
    var byte: [u8; 1]
    if spi_transfer(handle, 0, @ptrFromInt(byte), 1) == 0 {
        return 0xFF
    }
    return byte[0]
}

// Transfer byte (full-duplex)
export fn spi_transfer_byte(handle: u32, data: u8): u8 {
    var tx: [u8; 1]
    var rx: [u8; 1]
    tx[0] = data
    if spi_transfer(handle, @ptrFromInt(tx), @ptrFromInt(rx), 1) == 0 {
        return 0xFF
    }
    return rx[0]
}

// Write word (16-bit)
export fn spi_write_word(handle: u32, data: u16): u32 {
    var bytes: [u8; 2]
    if spi_devices[handle].bit_order == SPI_MSB_FIRST {
        bytes[0] = (data >> 8) & 0xFF
        bytes[1] = data & 0xFF
    } else {
        bytes[0] = data & 0xFF
        bytes[1] = (data >> 8) & 0xFF
    }
    return spi_transfer(handle, @ptrFromInt(bytes), 0, 2)
}

// Read word (16-bit)
export fn spi_read_word(handle: u32): u16 {
    var bytes: [u8; 2]
    if spi_transfer(handle, 0, @ptrFromInt(bytes), 2) == 0 {
        return 0xFFFF
    }
    if spi_devices[handle].bit_order == SPI_MSB_FIRST {
        return (bytes[0] << 8) | bytes[1]
    } else {
        return (bytes[1] << 8) | bytes[0]
    }
}

// Write register (common pattern: address + data)
export fn spi_write_reg(handle: u32, reg: u8, data: u8): u32 {
    var bytes: [u8; 2]
    bytes[0] = reg
    bytes[1] = data
    return spi_transfer(handle, @ptrFromInt(bytes), 0, 2)
}

// Read register (common pattern: address + read)
export fn spi_read_reg(handle: u32, reg: u8): u8 {
    var tx: [u8; 2]
    var rx: [u8; 2]
    tx[0] = reg | 0x80  // Read flag (common convention)
    tx[1] = 0xFF
    if spi_transfer(handle, @ptrFromInt(tx), @ptrFromInt(rx), 2) == 0 {
        return 0xFF
    }
    return rx[1]
}

// Multi-transfer (for complex transactions)
export fn spi_multi_transfer(handle: u32, transfers: u64, num_transfers: u32): u32 {
    if handle >= MAX_SPI_DEVICES { return 0 }
    if spi_devices[handle].active == 0 { return 0 }

    var i: u32 = 0
    while i < num_transfers {
        var xfer: SpiTransfer = @intToPtr(transfers + (i * 32), SpiTransfer)

        var result: u32 = spi_transfer(handle, xfer.tx_buf, xfer.rx_buf, xfer.len)
        if result == 0 {
            return i
        }

        // Delay between transfers if requested
        if xfer.delay_usecs > 0 {
            spi_delay_us(xfer.delay_usecs)
        }

        i = i + 1
    }

    return num_transfers
}

// Helper: Read register
fn spi_read_reg32(addr: u64): u32 {
    return @intToPtr(addr, u32)
}

// Helper: Write register
fn spi_write_reg32(addr: u64, value: u32) {
    @ptrToInt(addr, u32) = value
}

// Helper: Microsecond delay
fn spi_delay_us(us: u16) {
    var start: u64 = foundation.timer_get_ticks()
    var target: u64 = start + us
    while foundation.timer_get_ticks() < target {
        // Busy wait
    }
}

// Get statistics
export fn spi_get_stats(): u64 {
    return @ptrFromInt(spi_stats)
}

// Shutdown SPI
export fn spi_shutdown() {
    if spi_initialized == 0 { return }

    // Disable all controllers
    var i: u32 = 0
    while i < spi_controller_count {
        if spi_controllers[i].controller_type == SPI_CTRL_BCM2835 {
            var base: u64 = spi_controllers[i].base_addr
            spi_write_reg32(base + BCM_SPI_CS, BCM_SPI_CS_CLEAR)
        }
        spi_controllers[i].active = 0
        i = i + 1
    }

    spi_initialized = 0
    foundation.serial_write_string("[SPI] Shutdown complete\n")
}
