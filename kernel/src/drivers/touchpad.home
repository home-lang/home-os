// home-os Touchpad Driver
// PS/2 and I2C touchpad support with multi-touch gestures

import "../core/foundation.home" as foundation

// ============================================================================
// PS/2 CONTROLLER PORTS
// ============================================================================

const PS2_DATA_PORT: u16 = 0x60
const PS2_STATUS_PORT: u16 = 0x64
const PS2_COMMAND_PORT: u16 = 0x64

// PS/2 Status register bits
const PS2_STATUS_OUTPUT_FULL: u8 = 0x01
const PS2_STATUS_INPUT_FULL: u8 = 0x02
const PS2_STATUS_SYSTEM_FLAG: u8 = 0x04
const PS2_STATUS_COMMAND: u8 = 0x08
const PS2_STATUS_TIMEOUT: u8 = 0x40
const PS2_STATUS_PARITY_ERROR: u8 = 0x80

// PS/2 Controller commands
const PS2_CMD_READ_CONFIG: u8 = 0x20
const PS2_CMD_WRITE_CONFIG: u8 = 0x60
const PS2_CMD_DISABLE_PORT2: u8 = 0xA7
const PS2_CMD_ENABLE_PORT2: u8 = 0xA8
const PS2_CMD_TEST_PORT2: u8 = 0xA9
const PS2_CMD_SELF_TEST: u8 = 0xAA
const PS2_CMD_TEST_PORT1: u8 = 0xAB
const PS2_CMD_DISABLE_PORT1: u8 = 0xAD
const PS2_CMD_ENABLE_PORT1: u8 = 0xAE
const PS2_CMD_WRITE_PORT2: u8 = 0xD4

// Mouse commands
const MOUSE_CMD_SET_SCALING_1_1: u8 = 0xE6
const MOUSE_CMD_SET_SCALING_2_1: u8 = 0xE7
const MOUSE_CMD_SET_RESOLUTION: u8 = 0xE8
const MOUSE_CMD_STATUS_REQUEST: u8 = 0xE9
const MOUSE_CMD_SET_STREAM_MODE: u8 = 0xEA
const MOUSE_CMD_READ_DATA: u8 = 0xEB
const MOUSE_CMD_RESET_WRAP: u8 = 0xEC
const MOUSE_CMD_SET_WRAP_MODE: u8 = 0xEE
const MOUSE_CMD_SET_REMOTE_MODE: u8 = 0xF0
const MOUSE_CMD_GET_ID: u8 = 0xF2
const MOUSE_CMD_SET_SAMPLE_RATE: u8 = 0xF3
const MOUSE_CMD_ENABLE_DATA: u8 = 0xF4
const MOUSE_CMD_DISABLE_DATA: u8 = 0xF5
const MOUSE_CMD_SET_DEFAULTS: u8 = 0xF6
const MOUSE_CMD_RESEND: u8 = 0xFE
const MOUSE_CMD_RESET: u8 = 0xFF

// Mouse responses
const MOUSE_ACK: u8 = 0xFA
const MOUSE_RESEND: u8 = 0xFE
const MOUSE_ERROR: u8 = 0xFC
const MOUSE_RESET_OK: u8 = 0xAA

// ============================================================================
// SYNAPTICS TOUCHPAD REGISTERS
// ============================================================================

const SYNAPTICS_MODEL_ID: u8 = 0x00
const SYNAPTICS_CAPABILITIES: u8 = 0x02
const SYNAPTICS_MODEL_SUB: u8 = 0x03
const SYNAPTICS_EXT_CAPS: u8 = 0x0C
const SYNAPTICS_MAX_COORDS: u8 = 0x0D
const SYNAPTICS_DELUXE_LED: u8 = 0x0E
const SYNAPTICS_CONT_CAPS: u8 = 0x0F

// Synaptics modes
const SYNAPTICS_MODE_ABSOLUTE: u8 = 0x80
const SYNAPTICS_MODE_HIGH_RATE: u8 = 0x40
const SYNAPTICS_MODE_SLEEP: u8 = 0x08
const SYNAPTICS_MODE_GESTURE: u8 = 0x04
const SYNAPTICS_MODE_WMODE: u8 = 0x01

// ============================================================================
// TOUCHPAD MODES AND STATES
// ============================================================================

const TOUCHPAD_MODE_RELATIVE: u32 = 0
const TOUCHPAD_MODE_ABSOLUTE: u32 = 1

const TOUCHPAD_TYPE_UNKNOWN: u32 = 0
const TOUCHPAD_TYPE_PS2_BASIC: u32 = 1
const TOUCHPAD_TYPE_SYNAPTICS: u32 = 2
const TOUCHPAD_TYPE_ALPS: u32 = 3
const TOUCHPAD_TYPE_ELAN: u32 = 4

// Button masks
const BUTTON_LEFT: u8 = 0x01
const BUTTON_RIGHT: u8 = 0x02
const BUTTON_MIDDLE: u8 = 0x04

// Gesture types
const GESTURE_NONE: u32 = 0
const GESTURE_TAP: u32 = 1
const GESTURE_DOUBLE_TAP: u32 = 2
const GESTURE_DRAG: u32 = 3
const GESTURE_SCROLL_UP: u32 = 4
const GESTURE_SCROLL_DOWN: u32 = 5
const GESTURE_SCROLL_LEFT: u32 = 6
const GESTURE_SCROLL_RIGHT: u32 = 7
const GESTURE_PINCH_IN: u32 = 8
const GESTURE_PINCH_OUT: u32 = 9
const GESTURE_ROTATE_CW: u32 = 10
const GESTURE_ROTATE_CCW: u32 = 11
const GESTURE_THREE_FINGER_SWIPE: u32 = 12

// ============================================================================
// DRIVER STATE
// ============================================================================

var touchpad_type: u32 = TOUCHPAD_TYPE_UNKNOWN
var touchpad_mode: u32 = TOUCHPAD_MODE_RELATIVE
var touchpad_initialized: u32 = 0
var touchpad_enabled: u32 = 0

// Current position (absolute mode)
var touchpad_x: u32 = 0
var touchpad_y: u32 = 0
var touchpad_z: u32 = 0  // Pressure

// Movement delta (relative mode)
var touchpad_dx: i32 = 0
var touchpad_dy: i32 = 0

// Button state
var touchpad_buttons: u8 = 0
var touchpad_prev_buttons: u8 = 0

// Touch count for multi-touch
var touch_count: u32 = 0

// Touchpad dimensions
var touchpad_min_x: u32 = 0
var touchpad_max_x: u32 = 6143
var touchpad_min_y: u32 = 0
var touchpad_max_y: u32 = 6143

// Gesture recognition state
var gestures_enabled: u32 = 0
var gesture_state: u32 = 0
var tap_start_time: u64 = 0
var tap_start_x: u32 = 0
var tap_start_y: u32 = 0
var last_gesture: u32 = GESTURE_NONE

// Packet state
var packet_buffer: [6]u8
var packet_index: u32 = 0
var packet_size: u32 = 3  // Basic PS/2 = 3, Synaptics = 6

// ============================================================================
// PORT I/O HELPERS
// ============================================================================

fn outb(port: u16, value: u8) {
  asm volatile ("outb %[value], %[port]"
    :
    : [value] "a" (value), [port] "Nd" (port)
  )
}

fn inb(port: u16): u8 {
  var result: u8 = 0
  asm volatile ("inb %[port], %[result]"
    : [result] "=a" (result)
    : [port] "Nd" (port)
  )
  return result
}

fn io_wait() {
  // Small delay using port 0x80 (unused)
  outb(0x80, 0)
}

// ============================================================================
// PS/2 CONTROLLER HELPERS
// ============================================================================

fn ps2_wait_input(): u32 {
  var timeout: u32 = 100000
  while timeout > 0 {
    if (inb(PS2_STATUS_PORT) & PS2_STATUS_INPUT_FULL) == 0 {
      return 0
    }
    timeout = timeout - 1
  }
  return 1  // Timeout
}

fn ps2_wait_output(): u32 {
  var timeout: u32 = 100000
  while timeout > 0 {
    if (inb(PS2_STATUS_PORT) & PS2_STATUS_OUTPUT_FULL) != 0 {
      return 0
    }
    timeout = timeout - 1
  }
  return 1  // Timeout
}

fn ps2_send_command(cmd: u8) {
  ps2_wait_input()
  outb(PS2_COMMAND_PORT, cmd)
}

fn ps2_send_data(data: u8) {
  ps2_wait_input()
  outb(PS2_DATA_PORT, data)
}

fn ps2_read_data(): u8 {
  ps2_wait_output()
  return inb(PS2_DATA_PORT)
}

fn ps2_flush_buffer() {
  var timeout: u32 = 100
  while timeout > 0 {
    if (inb(PS2_STATUS_PORT) & PS2_STATUS_OUTPUT_FULL) == 0 {
      break
    }
    inb(PS2_DATA_PORT)
    timeout = timeout - 1
  }
}

// Send command to mouse (through port 2)
fn mouse_send_command(cmd: u8): u8 {
  ps2_send_command(PS2_CMD_WRITE_PORT2)
  ps2_send_data(cmd)
  return ps2_read_data()  // Should be ACK
}

fn mouse_send_command_arg(cmd: u8, arg: u8): u8 {
  mouse_send_command(cmd)
  ps2_send_command(PS2_CMD_WRITE_PORT2)
  ps2_send_data(arg)
  return ps2_read_data()  // Should be ACK
}

// ============================================================================
// SYNAPTICS TOUCHPAD DETECTION AND INIT
// ============================================================================

fn synaptics_special_sequence(rate1: u8, rate2: u8, rate3: u8): u32 {
  // Special knock sequence to identify Synaptics
  mouse_send_command_arg(MOUSE_CMD_SET_SAMPLE_RATE, rate1)
  mouse_send_command_arg(MOUSE_CMD_SET_SAMPLE_RATE, rate2)
  mouse_send_command_arg(MOUSE_CMD_SET_SAMPLE_RATE, rate3)

  // Read device ID
  mouse_send_command(MOUSE_CMD_GET_ID)
  var id: u8 = ps2_read_data()
  return id
}

fn synaptics_detect(): u32 {
  // Try Synaptics identification sequence
  var id: u32 = synaptics_special_sequence(200, 200, 200)

  if id == 0x47 {
    return 1  // Synaptics touchpad detected
  }
  return 0
}

fn synaptics_query(reg: u8): u32 {
  // Query Synaptics register using special sequence
  mouse_send_command_arg(MOUSE_CMD_SET_SAMPLE_RATE, 0x80 | reg)
  mouse_send_command_arg(MOUSE_CMD_SET_SAMPLE_RATE, 0x00)
  mouse_send_command_arg(MOUSE_CMD_SET_SAMPLE_RATE, 0x00)

  mouse_send_command(MOUSE_CMD_STATUS_REQUEST)

  var byte1: u8 = ps2_read_data()
  var byte2: u8 = ps2_read_data()
  var byte3: u8 = ps2_read_data()

  return (byte1 << 16) | (byte2 << 8) | byte3
}

fn synaptics_set_mode(mode: u8): u32 {
  // Set Synaptics mode
  mouse_send_command_arg(MOUSE_CMD_SET_SAMPLE_RATE, 0x14)  // Rate 20
  mouse_send_command_arg(MOUSE_CMD_SET_SAMPLE_RATE, mode)

  // Enable streaming
  mouse_send_command(MOUSE_CMD_ENABLE_DATA)

  return 0
}

fn synaptics_init(): u32 {
  // Read model ID
  var model_id: u32 = synaptics_query(SYNAPTICS_MODEL_ID)
  foundation.serial_write_string("[Touchpad] Synaptics model: ")
  foundation.serial_write_hex(model_id)
  foundation.serial_write_string("\n")

  // Read capabilities
  var caps: u32 = synaptics_query(SYNAPTICS_CAPABILITIES)
  foundation.serial_write_string("[Touchpad] Capabilities: ")
  foundation.serial_write_hex(caps)
  foundation.serial_write_string("\n")

  // Read max coordinates
  var max_coords: u32 = synaptics_query(SYNAPTICS_MAX_COORDS)
  touchpad_max_x = (max_coords >> 8) & 0xFF00 | ((max_coords >> 16) & 0x0F)
  touchpad_max_y = (max_coords & 0xFF00) | ((max_coords >> 8) & 0x0F)

  // Set absolute mode with gestures
  var mode: u8 = SYNAPTICS_MODE_ABSOLUTE | SYNAPTICS_MODE_HIGH_RATE
  if gestures_enabled != 0 {
    mode = mode | SYNAPTICS_MODE_GESTURE
  }
  synaptics_set_mode(mode)

  touchpad_mode = TOUCHPAD_MODE_ABSOLUTE
  packet_size = 6

  return 0
}

// ============================================================================
// ALPS TOUCHPAD DETECTION AND INIT
// ============================================================================

fn alps_detect(): u32 {
  // ALPS uses E6 report
  mouse_send_command(MOUSE_CMD_SET_SCALING_2_1)
  mouse_send_command(MOUSE_CMD_SET_SCALING_2_1)
  mouse_send_command(MOUSE_CMD_SET_SCALING_2_1)

  mouse_send_command(MOUSE_CMD_STATUS_REQUEST)

  var byte1: u8 = ps2_read_data()
  var byte2: u8 = ps2_read_data()
  var byte3: u8 = ps2_read_data()

  // Check for ALPS signature
  if byte1 == 0x73 and byte2 == 0x02 and byte3 == 0x64 {
    return 1  // ALPS V2
  }
  if byte1 == 0x73 and byte2 == 0x03 and byte3 == 0x50 {
    return 1  // ALPS V3
  }

  return 0
}

// ============================================================================
// BASIC PS/2 MOUSE INIT
// ============================================================================

fn basic_mouse_init(): u32 {
  // Reset mouse
  mouse_send_command(MOUSE_CMD_RESET)
  ps2_read_data()  // Read self-test result
  ps2_read_data()  // Read device ID

  // Set defaults
  mouse_send_command(MOUSE_CMD_SET_DEFAULTS)

  // Try to enable scroll wheel (IntelliMouse)
  var id: u32 = synaptics_special_sequence(200, 100, 80)
  if id == 0x03 {
    // Scroll wheel enabled, try for 5-button mouse
    id = synaptics_special_sequence(200, 200, 80)
    if id == 0x04 {
      packet_size = 4  // 5-button mouse
    } else {
      packet_size = 4  // Scroll wheel mouse
    }
  } else {
    packet_size = 3  // Basic 3-button mouse
  }

  // Set sample rate and resolution
  mouse_send_command_arg(MOUSE_CMD_SET_SAMPLE_RATE, 100)
  mouse_send_command_arg(MOUSE_CMD_SET_RESOLUTION, 3)  // 8 counts/mm

  // Enable data reporting
  mouse_send_command(MOUSE_CMD_ENABLE_DATA)

  return 0
}

// ============================================================================
// PACKET PARSING
// ============================================================================

fn parse_basic_packet() {
  // Parse basic PS/2 mouse packet
  var byte0: u8 = packet_buffer[0]
  var byte1: u8 = packet_buffer[1]
  var byte2: u8 = packet_buffer[2]

  // Validate packet (bit 3 must be set)
  if (byte0 & 0x08) == 0 {
    return  // Invalid packet
  }

  // Extract buttons
  touchpad_buttons = byte0 & 0x07

  // Extract movement with sign extension
  var dx: i32 = byte1
  var dy: i32 = byte2

  if (byte0 & 0x10) != 0 {
    dx = dx - 256
  }
  if (byte0 & 0x20) != 0 {
    dy = dy - 256
  }

  // PS/2 Y is inverted
  dy = -dy

  touchpad_dx = dx
  touchpad_dy = dy

  // Update position in relative mode
  if touchpad_mode == TOUCHPAD_MODE_RELATIVE {
    var new_x: i32 = touchpad_x + dx
    var new_y: i32 = touchpad_y + dy

    if new_x < 0 { new_x = 0 }
    if new_y < 0 { new_y = 0 }
    if new_x > touchpad_max_x { new_x = touchpad_max_x }
    if new_y > touchpad_max_y { new_y = touchpad_max_y }

    touchpad_x = new_x
    touchpad_y = new_y
  }

  // Handle scroll wheel if present
  if packet_size >= 4 {
    var byte3: i8 = packet_buffer[3]
    // byte3 contains scroll wheel delta (signed)
    if byte3 != 0 {
      if byte3 > 0 {
        last_gesture = GESTURE_SCROLL_UP
      } else {
        last_gesture = GESTURE_SCROLL_DOWN
      }
    }
  }
}

fn parse_synaptics_packet() {
  // Parse 6-byte Synaptics absolute packet
  var byte0: u8 = packet_buffer[0]
  var byte1: u8 = packet_buffer[1]
  var byte2: u8 = packet_buffer[2]
  var byte3: u8 = packet_buffer[3]
  var byte4: u8 = packet_buffer[4]
  var byte5: u8 = packet_buffer[5]

  // Validate packet markers
  if (byte0 & 0xC0) != 0x80 or (byte3 & 0xC0) != 0xC0 {
    return  // Invalid packet
  }

  // Extract W value (touch width/finger count)
  var w: u32 = ((byte0 & 0x30) >> 2) | ((byte0 & 0x04) >> 1) | ((byte3 & 0x04) >> 2)

  // Extract position
  var x: u32 = ((byte3 & 0x10) << 8) | ((byte1 & 0x0F) << 8) | byte4
  var y: u32 = ((byte3 & 0x20) << 7) | ((byte1 & 0xF0) << 4) | byte5

  // Extract pressure (Z)
  var z: u32 = byte2

  // Extract buttons
  touchpad_prev_buttons = touchpad_buttons
  touchpad_buttons = 0
  if (byte0 & 0x01) != 0 { touchpad_buttons = touchpad_buttons | BUTTON_LEFT }
  if (byte0 & 0x02) != 0 { touchpad_buttons = touchpad_buttons | BUTTON_RIGHT }

  // Update position
  touchpad_x = x
  touchpad_y = y
  touchpad_z = z

  // Determine touch count from W value
  if z == 0 {
    touch_count = 0
  } else if w == 0 {
    touch_count = 2  // Two fingers
  } else if w == 1 {
    touch_count = 3  // Three fingers
  } else {
    touch_count = 1  // One finger
  }

  // Gesture recognition
  if gestures_enabled != 0 {
    recognize_gesture()
  }
}

// ============================================================================
// GESTURE RECOGNITION
// ============================================================================

fn recognize_gesture() {
  // Simple gesture recognition based on touch state

  // Tap detection
  if touchpad_z > 30 and touch_count == 1 {
    if gesture_state == 0 {
      // Starting a potential tap
      gesture_state = 1
      tap_start_x = touchpad_x
      tap_start_y = touchpad_y
    }
  } else if gesture_state == 1 and touchpad_z < 10 {
    // Finger lifted - check if it was a tap
    var dx: i32 = touchpad_x - tap_start_x
    var dy: i32 = touchpad_y - tap_start_y

    if dx < 0 { dx = -dx }
    if dy < 0 { dy = -dy }

    if dx < 100 and dy < 100 {
      // Small movement = tap
      last_gesture = GESTURE_TAP
      // Simulate left click
      touchpad_buttons = touchpad_buttons | BUTTON_LEFT
    }

    gesture_state = 0
  }

  // Two-finger scroll detection
  if touch_count == 2 {
    // Calculate movement delta
    if gesture_state == 2 {
      var dy: i32 = touchpad_y - tap_start_y
      var dx: i32 = touchpad_x - tap_start_x

      if dy > 50 {
        last_gesture = GESTURE_SCROLL_DOWN
        tap_start_y = touchpad_y
      } else if dy < -50 {
        last_gesture = GESTURE_SCROLL_UP
        tap_start_y = touchpad_y
      }

      if dx > 50 {
        last_gesture = GESTURE_SCROLL_RIGHT
        tap_start_x = touchpad_x
      } else if dx < -50 {
        last_gesture = GESTURE_SCROLL_LEFT
        tap_start_x = touchpad_x
      }
    } else {
      // Starting two-finger gesture
      gesture_state = 2
      tap_start_x = touchpad_x
      tap_start_y = touchpad_y
    }
  } else if gesture_state == 2 {
    gesture_state = 0
  }

  // Three-finger swipe
  if touch_count == 3 {
    if gesture_state != 3 {
      gesture_state = 3
      tap_start_x = touchpad_x
      tap_start_y = touchpad_y
    } else {
      var dx: i32 = touchpad_x - tap_start_x
      var dy: i32 = touchpad_y - tap_start_y

      if dx < 0 { dx = -dx }
      if dy < 0 { dy = -dy }

      if dx > 200 or dy > 200 {
        last_gesture = GESTURE_THREE_FINGER_SWIPE
        gesture_state = 0
      }
    }
  } else if gesture_state == 3 {
    gesture_state = 0
  }
}

// ============================================================================
// INTERRUPT HANDLER
// ============================================================================

export fn touchpad_irq_handler() {
  // Read byte from PS/2 data port
  var data: u8 = inb(PS2_DATA_PORT)

  // Add to packet buffer
  packet_buffer[packet_index] = data
  packet_index = packet_index + 1

  // Check if packet is complete
  if packet_index >= packet_size {
    // Parse packet based on touchpad type
    if touchpad_type == TOUCHPAD_TYPE_SYNAPTICS {
      parse_synaptics_packet()
    } else {
      parse_basic_packet()
    }

    packet_index = 0
  }
}

// ============================================================================
// PUBLIC API
// ============================================================================

export fn touchpad_init() {
  if touchpad_initialized == 1 { return }

  // Flush any pending data
  ps2_flush_buffer()

  // Enable second PS/2 port
  ps2_send_command(PS2_CMD_ENABLE_PORT2)

  // Read and modify controller configuration
  ps2_send_command(PS2_CMD_READ_CONFIG)
  var config: u8 = ps2_read_data()

  // Enable second port interrupt and clock
  config = config | 0x02  // Enable IRQ12
  config = config & ~0x20  // Enable second port clock

  ps2_send_command(PS2_CMD_WRITE_CONFIG)
  ps2_send_data(config)

  // Try to detect advanced touchpad
  if synaptics_detect() != 0 {
    foundation.serial_write_string("[Touchpad] Synaptics detected\n")
    touchpad_type = TOUCHPAD_TYPE_SYNAPTICS
    synaptics_init()
  } else if alps_detect() != 0 {
    foundation.serial_write_string("[Touchpad] ALPS detected\n")
    touchpad_type = TOUCHPAD_TYPE_ALPS
    basic_mouse_init()  // Use basic protocol for now
  } else {
    foundation.serial_write_string("[Touchpad] Basic PS/2 mouse\n")
    touchpad_type = TOUCHPAD_TYPE_PS2_BASIC
    basic_mouse_init()
  }

  touchpad_initialized = 1
  touchpad_enabled = 1
  foundation.serial_write_string("[Touchpad] Initialized\n")
}

export fn touchpad_enable() {
  if touchpad_initialized == 0 { return }

  mouse_send_command(MOUSE_CMD_ENABLE_DATA)
  touchpad_enabled = 1
}

export fn touchpad_disable() {
  if touchpad_initialized == 0 { return }

  mouse_send_command(MOUSE_CMD_DISABLE_DATA)
  touchpad_enabled = 0
}

export fn touchpad_set_mode(mode: u32) {
  touchpad_mode = mode

  if touchpad_type == TOUCHPAD_TYPE_SYNAPTICS {
    var synaptics_mode: u8 = SYNAPTICS_MODE_HIGH_RATE
    if mode == TOUCHPAD_MODE_ABSOLUTE {
      synaptics_mode = synaptics_mode | SYNAPTICS_MODE_ABSOLUTE
    }
    if gestures_enabled != 0 {
      synaptics_mode = synaptics_mode | SYNAPTICS_MODE_GESTURE
    }
    synaptics_set_mode(synaptics_mode)
  }
}

export fn touchpad_get_x(): u32 {
  return touchpad_x
}

export fn touchpad_get_y(): u32 {
  return touchpad_y
}

export fn touchpad_get_pressure(): u32 {
  return touchpad_z
}

export fn touchpad_get_dx(): i32 {
  var dx: i32 = touchpad_dx
  touchpad_dx = 0
  return dx
}

export fn touchpad_get_dy(): i32 {
  var dy: i32 = touchpad_dy
  touchpad_dy = 0
  return dy
}

export fn touchpad_get_buttons(): u8 {
  return touchpad_buttons
}

export fn touchpad_get_touch_count(): u32 {
  return touch_count
}

export fn touchpad_enable_gestures() {
  gestures_enabled = 1

  if touchpad_type == TOUCHPAD_TYPE_SYNAPTICS {
    var mode: u8 = SYNAPTICS_MODE_ABSOLUTE | SYNAPTICS_MODE_HIGH_RATE | SYNAPTICS_MODE_GESTURE
    synaptics_set_mode(mode)
  }

  foundation.serial_write_string("[Touchpad] Gestures enabled\n")
}

export fn touchpad_disable_gestures() {
  gestures_enabled = 0
  last_gesture = GESTURE_NONE
  gesture_state = 0

  if touchpad_type == TOUCHPAD_TYPE_SYNAPTICS {
    var mode: u8 = SYNAPTICS_MODE_ABSOLUTE | SYNAPTICS_MODE_HIGH_RATE
    synaptics_set_mode(mode)
  }
}

export fn touchpad_get_last_gesture(): u32 {
  var gesture: u32 = last_gesture
  last_gesture = GESTURE_NONE
  return gesture
}

export fn touchpad_set_sensitivity(sensitivity: u8) {
  // Set resolution (0-3, higher = more sensitive)
  var res: u8 = sensitivity
  if res > 3 { res = 3 }
  mouse_send_command_arg(MOUSE_CMD_SET_RESOLUTION, res)
}

export fn touchpad_get_bounds(min_x: *u32, max_x: *u32, min_y: *u32, max_y: *u32) {
  @ptrToInt(min_x, u32) = touchpad_min_x
  @ptrToInt(max_x, u32) = touchpad_max_x
  @ptrToInt(min_y, u32) = touchpad_min_y
  @ptrToInt(max_y, u32) = touchpad_max_y
}

export fn touchpad_is_enabled(): u32 {
  return touchpad_enabled
}

export fn touchpad_get_type(): u32 {
  return touchpad_type
}
