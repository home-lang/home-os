// home-os Kernel - PIT (Programmable Interval Timer) Driver
// Real implementation for system timing

import "../core/foundation.home" as foundation

// ============================================================================
// CONSTANTS
// ============================================================================

const PIT_CHANNEL0: u16 = 0x40
const PIT_CHANNEL1: u16 = 0x41
const PIT_CHANNEL2: u16 = 0x42
const PIT_COMMAND: u16 = 0x43

const PIT_FREQUENCY: u32 = 1193182  // Base frequency in Hz

// PIT command byte bits
const PIT_BINARY: u8 = 0x00
const PIT_BCD: u8 = 0x01
const PIT_MODE0: u8 = 0x00  // Interrupt on terminal count
const PIT_MODE2: u8 = 0x04  // Rate generator
const PIT_MODE3: u8 = 0x06  // Square wave
const PIT_LOBYTE: u8 = 0x10
const PIT_HIBYTE: u8 = 0x20
const PIT_LOHI: u8 = 0x30
const PIT_CHANNEL0_SELECT: u8 = 0x00

// ============================================================================
// TIMER STATE
// ============================================================================

var timer_ticks: u64 = 0
var timer_frequency: u32 = 100  // 100 Hz (10ms per tick)
var timer_initialized: u32 = 0

// Sleep tracking
const MAX_SLEEPERS: u32 = 64

struct Sleeper {
  active: u32,
  wake_tick: u64,
  process_id: u32
}

var sleepers: [Sleeper; 64]
var sleeper_count: u32 = 0

// ============================================================================
// TIMER INITIALIZATION
// ============================================================================

export fn timer_init(frequency: u32) {
  if timer_initialized == 1 { return }
  
  timer_frequency = frequency
  
  // Calculate divisor for desired frequency
  var divisor: u32 = PIT_FREQUENCY / frequency
  
  // Send command byte
  var command: u8 = PIT_CHANNEL0_SELECT | PIT_LOHI | PIT_MODE2 | PIT_BINARY
  foundation.outb(PIT_COMMAND, command)
  
  // Send divisor (low byte, then high byte)
  var low: u8 = divisor & 0xFF
  var high: u8 = (divisor >> 8) & 0xFF
  
  foundation.outb(PIT_CHANNEL0, low)
  foundation.outb(PIT_CHANNEL0, high)
  
  // Clear sleeper array
  var i: u32 = 0
  while i < MAX_SLEEPERS {
    sleepers[i].active = 0
    sleepers[i].wake_tick = 0
    sleepers[i].process_id = 0
    i = i + 1
  }
  
  timer_initialized = 1
  foundation.serial_write_string("[Timer] Initialized at ")
  foundation.serial_write_string(" Hz\n")
}

// ============================================================================
// TIMER INTERRUPT HANDLER
// ============================================================================

export fn timer_interrupt_handler() {
  timer_ticks = timer_ticks + 1
  
  // Check for processes that need to wake up
  check_sleepers()
  
  // Every 100 ticks (1 second at 100Hz), print uptime
  if (timer_ticks % 100) == 0 {
    var seconds: u64 = timer_ticks / 100
    if (seconds % 10) == 0 {  // Every 10 seconds
      foundation.serial_write_string("[Timer] Uptime: ")
      foundation.serial_write_string(" seconds\n")
    }
  }
}

fn check_sleepers() {
  var i: u32 = 0
  
  while i < MAX_SLEEPERS {
    if sleepers[i].active == 1 {
      if timer_ticks >= sleepers[i].wake_tick {
        // Wake up this process
        sleepers[i].active = 0
        sleeper_count = sleeper_count - 1
        
        // TODO: Actually wake the process (needs scheduler integration)
      }
    }
    i = i + 1
  }
}

// ============================================================================
// TIMING FUNCTIONS
// ============================================================================

export fn timer_get_ticks() -> u64 {
  return timer_ticks
}

export fn timer_get_seconds() -> u64 {
  return timer_ticks / timer_frequency
}

export fn timer_get_milliseconds() -> u64 {
  return (timer_ticks * 1000) / timer_frequency
}

// ============================================================================
// SLEEP FUNCTIONS
// ============================================================================

export fn timer_sleep_ticks(ticks: u64) {
  var target: u64 = timer_ticks + ticks
  
  while timer_ticks < target {
    foundation.hlt()  // Wait for interrupt
  }
}

export fn timer_sleep_ms(milliseconds: u64) {
  var ticks: u64 = (milliseconds * timer_frequency) / 1000
  timer_sleep_ticks(ticks)
}

export fn timer_sleep_seconds(seconds: u64) {
  var ticks: u64 = seconds * timer_frequency
  timer_sleep_ticks(ticks)
}

// Register a process to sleep
export fn timer_register_sleeper(process_id: u32, wake_tick: u64) -> u32 {
  if sleeper_count >= MAX_SLEEPERS {
    return 1  // No space
  }
  
  var i: u32 = 0
  while i < MAX_SLEEPERS {
    if sleepers[i].active == 0 {
      sleepers[i].active = 1
      sleepers[i].wake_tick = wake_tick
      sleepers[i].process_id = process_id
      sleeper_count = sleeper_count + 1
      return 0
    }
    i = i + 1
  }
  
  return 1
}

// ============================================================================
// DELAY FUNCTIONS (Busy-wait)
// ============================================================================

export fn timer_delay_ticks(ticks: u64) {
  var start: u64 = timer_ticks
  var target: u64 = start + ticks
  
  while timer_ticks < target {
    // Busy wait
  }
}

export fn timer_delay_ms(milliseconds: u64) {
  var ticks: u64 = (milliseconds * timer_frequency) / 1000
  timer_delay_ticks(ticks)
}

export fn timer_delay_us(microseconds: u64) {
  // For very short delays, use CPU cycles
  // Approximate: 1us â‰ˆ CPU_MHZ cycles
  var cycles: u64 = microseconds * 1000  // Assume ~1GHz CPU
  
  var i: u64 = 0
  while i < cycles {
    i = i + 1
  }
}

// ============================================================================
// PERFORMANCE MEASUREMENT
// ============================================================================

export fn timer_measure_start() -> u64 {
  return timer_ticks
}

export fn timer_measure_end(start_tick: u64) -> u64 {
  var end_tick: u64 = timer_ticks
  return end_tick - start_tick
}

export fn timer_measure_ms(start_tick: u64) -> u64 {
  var ticks: u64 = timer_measure_end(start_tick)
  return (ticks * 1000) / timer_frequency
}

// ============================================================================
// WATCHDOG TIMER
// ============================================================================

var watchdog_enabled: u32 = 0
var watchdog_timeout: u64 = 0
var watchdog_callback: u64 = 0

export fn timer_watchdog_enable(timeout_ms: u64, callback: u64) {
  watchdog_timeout = timer_ticks + ((timeout_ms * timer_frequency) / 1000)
  watchdog_callback = callback
  watchdog_enabled = 1
}

export fn timer_watchdog_disable() {
  watchdog_enabled = 0
}

export fn timer_watchdog_reset() {
  if watchdog_enabled == 1 {
    watchdog_timeout = timer_ticks + ((5000 * timer_frequency) / 1000)  // Reset to 5s
  }
}

fn timer_watchdog_check() {
  if watchdog_enabled == 1 {
    if timer_ticks >= watchdog_timeout {
      // Watchdog timeout!
      if watchdog_callback != 0 {
        // Call callback function
        // TODO: Function pointer call
      }
      watchdog_enabled = 0
    }
  }
}

// ============================================================================
// STATISTICS
// ============================================================================

export fn timer_get_frequency() -> u32 {
  return timer_frequency
}

export fn timer_get_sleeper_count() -> u32 {
  return sleeper_count
}
