// home-os NVMe Driver
// Non-Volatile Memory Express (PCIe SSDs)

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

const NVME_QUEUE_SIZE: u32 = 64

struct NvmeCommand {
  opcode: u8,
  flags: u8,
  cid: u16,
  nsid: u32,
  cdw2: u32,
  cdw3: u32,
  metadata: u64,
  prp1: u64,
  prp2: u64,
  cdw10: u32,
  cdw11: u32,
  cdw12: u32,
  cdw13: u32,
  cdw14: u32,
  cdw15: u32
}

var nvme_initialized: u32 = 0
var nvme_admin_queue: u64 = 0
var nvme_io_queue: u64 = 0

export fn nvme_init() {
  if nvme_initialized == 1 { return }
  
  nvme_admin_queue = memory.kmalloc(NVME_QUEUE_SIZE * 64)
  nvme_io_queue = memory.kmalloc(NVME_QUEUE_SIZE * 64)
  
  if nvme_admin_queue == 0 or nvme_io_queue == 0 {
    foundation.serial_write_string("[NVMe] Failed to allocate queues\n")
    return
  }
  
  nvme_initialized = 1
  foundation.serial_write_string("[NVMe] Initialized\n")
}

export fn nvme_read(lba: u64, count: u32, buffer: u64) -> u32 {
  if nvme_initialized == 0 { return 1 }
  
  var cmd: NvmeCommand
  cmd.opcode = 0x02  // Read
  cmd.nsid = 1
  cmd.prp1 = buffer
  cmd.cdw10 = lba & 0xFFFFFFFF
  cmd.cdw11 = (lba >> 32) & 0xFFFFFFFF
  cmd.cdw12 = count - 1
  
  // Submit command (stub)
  return 0
}

export fn nvme_write(lba: u64, count: u32, buffer: u64) -> u32 {
  if nvme_initialized == 0 { return 1 }
  
  var cmd: NvmeCommand
  cmd.opcode = 0x01  // Write
  cmd.nsid = 1
  cmd.prp1 = buffer
  cmd.cdw10 = lba & 0xFFFFFFFF
  cmd.cdw11 = (lba >> 32) & 0xFFFFFFFF
  cmd.cdw12 = count - 1
  
  // Submit command (stub)
  return 0
}
