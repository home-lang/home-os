// home-os SD/MMC Driver with DMA Support
// Generic SD/MMC/SDIO controller driver for Raspberry Pi and other platforms
// Supports DMA, high-speed modes, and multi-block transfers

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "./dma.home" as dma

// SD/MMC Commands
const CMD0_GO_IDLE_STATE: u32 = 0
const CMD1_SEND_OP_COND: u32 = 1
const CMD2_ALL_SEND_CID: u32 = 2
const CMD3_SEND_RELATIVE_ADDR: u32 = 3
const CMD6_SWITCH_FUNC: u32 = 6
const CMD7_SELECT_CARD: u32 = 7
const CMD8_SEND_IF_COND: u32 = 8
const CMD9_SEND_CSD: u32 = 9
const CMD12_STOP_TRANSMISSION: u32 = 12
const CMD13_SEND_STATUS: u32 = 13
const CMD17_READ_SINGLE_BLOCK: u32 = 17
const CMD18_READ_MULTIPLE_BLOCK: u32 = 18
const CMD24_WRITE_BLOCK: u32 = 24
const CMD25_WRITE_MULTIPLE_BLOCK: u32 = 25
const CMD55_APP_CMD: u32 = 55
const ACMD41_SD_SEND_OP_COND: u32 = 41

// Card types
const CARD_TYPE_UNKNOWN: u32 = 0
const CARD_TYPE_SD: u32 = 1
const CARD_TYPE_SDHC: u32 = 2
const CARD_TYPE_MMC: u32 = 3
const CARD_TYPE_EMMC: u32 = 4

// Transfer modes
const TRANSFER_MODE_PIO: u32 = 0
const TRANSFER_MODE_DMA: u32 = 1

// Bus widths
const BUS_WIDTH_1BIT: u32 = 0
const BUS_WIDTH_4BIT: u32 = 2
const BUS_WIDTH_8BIT: u32 = 3

// Clock speeds (Hz)
const CLOCK_INIT: u32 = 400000        // 400 KHz for initialization
const CLOCK_DEFAULT: u32 = 25000000   // 25 MHz default speed
const CLOCK_HIGH_SPEED: u32 = 50000000 // 50 MHz high speed
const CLOCK_SDR50: u32 = 100000000    // 100 MHz SDR50
const CLOCK_SDR104: u32 = 208000000   // 208 MHz SDR104

// Controller state
const STATE_IDLE: u32 = 0
const STATE_INITIALIZING: u32 = 1
const STATE_READY: u32 = 2
const STATE_TRANSFERRING: u32 = 3
const STATE_ERROR: u32 = 4

// DMA buffer size
const DMA_BUFFER_SIZE: u32 = 65536  // 64 KB

// SD/MMC controller structure
struct SdmmcController {
  base_addr: u64              // MMIO base address
  card_type: u32              // Detected card type
  state: u32                  // Controller state
  rca: u32                    // Relative card address
  capacity_blocks: u64        // Card capacity in blocks
  block_size: u32             // Block size (usually 512)
  bus_width: u32              // Current bus width
  clock_speed: u32            // Current clock speed
  transfer_mode: u32          // PIO or DMA
  dma_channel: u32            // DMA channel ID
  dma_buffer: u64             // DMA buffer address
  high_speed: u32             // High-speed mode enabled
  initialized: u32            // Initialization complete
}

const MAX_CONTROLLERS: u32 = 4

var controllers: [MAX_CONTROLLERS]SdmmcController
var controller_count: u32 = 0

// Statistics
var total_reads: u64 = 0
var total_writes: u64 = 0
var total_errors: u32 = 0
var dma_transfers: u64 = 0
var pio_transfers: u64 = 0

// Initialize SD/MMC subsystem
export fn sdmmc_init() {
  controller_count = 0
  total_reads = 0
  total_writes = 0
  total_errors = 0
  dma_transfers = 0
  pio_transfers = 0

  foundation.serial_write_string("[SD/MMC] Subsystem initialized\n")
}

// Register a controller
export fn sdmmc_register_controller(base_addr: u64, use_dma: u32): u32 {
  if controller_count >= MAX_CONTROLLERS {
    foundation.serial_write_string("[SD/MMC] Maximum controllers reached\n")
    return 0xFFFFFFFF
  }

  let ctrl: *SdmmcController = &controllers[controller_count]

  ctrl.base_addr = base_addr
  ctrl.card_type = CARD_TYPE_UNKNOWN
  ctrl.state = STATE_IDLE
  ctrl.rca = 0
  ctrl.capacity_blocks = 0
  ctrl.block_size = 512
  ctrl.bus_width = BUS_WIDTH_1BIT
  ctrl.clock_speed = CLOCK_INIT
  ctrl.transfer_mode = if use_dma == 1 { TRANSFER_MODE_DMA } else { TRANSFER_MODE_PIO }
  ctrl.dma_channel = 0xFFFFFFFF
  ctrl.dma_buffer = 0
  ctrl.high_speed = 0
  ctrl.initialized = 0

  // Allocate DMA buffer if using DMA
  if use_dma == 1 {
    ctrl.dma_buffer = memory.kmalloc(DMA_BUFFER_SIZE)
    if ctrl.dma_buffer == 0 {
      foundation.serial_write_string("[SD/MMC] Failed to allocate DMA buffer\n")
      return 0xFFFFFFFF
    }

    // Request DMA channel
    ctrl.dma_channel = dma.dma_request_channel()
    if ctrl.dma_channel == 0xFFFFFFFF {
      foundation.serial_write_string("[SD/MMC] Failed to allocate DMA channel\n")
      memory.kfree(ctrl.dma_buffer)
      return 0xFFFFFFFF
    }
  }

  let id: u32 = controller_count
  controller_count = controller_count + 1

  foundation.serial_write_string("[SD/MMC] Registered controller ")
  foundation.serial_write_u64(id)
  foundation.serial_write_string(" at 0x")
  foundation.serial_write_u64(base_addr)

  if use_dma == 1 {
    foundation.serial_write_string(" (DMA mode)")
  } else {
    foundation.serial_write_string(" (PIO mode)")
  }

  foundation.serial_write_string("\n")

  return id
}

// Send command to card
fn sdmmc_send_command(ctrl: *SdmmcController, cmd: u32, arg: u32): u32 {
  // This would write to actual hardware registers
  // Simplified implementation for now

  foundation.serial_write_string("[SD/MMC] CMD")
  foundation.serial_write_u64(cmd)
  foundation.serial_write_string(" arg=0x")
  foundation.serial_write_u64(arg)
  foundation.serial_write_string("\n")

  // Simulate command execution
  return 0  // Success
}

// Wait for command complete
fn sdmmc_wait_command_complete(ctrl: *SdmmcController): u32 {
  // Would poll hardware status register
  // Simplified: assume immediate completion
  return 0
}

// Set clock speed
fn sdmmc_set_clock(ctrl: *SdmmcController, speed: u32) {
  ctrl.clock_speed = speed

  foundation.serial_write_string("[SD/MMC] Clock set to ")
  foundation.serial_write_u64(speed / 1000000)
  foundation.serial_write_string(" MHz\n")
}

// Set bus width
fn sdmmc_set_bus_width(ctrl: *SdmmcController, width: u32) {
  ctrl.bus_width = width

  foundation.serial_write_string("[SD/MMC] Bus width set to ")

  if width == BUS_WIDTH_1BIT {
    foundation.serial_write_string("1-bit")
  } else if width == BUS_WIDTH_4BIT {
    foundation.serial_write_string("4-bit")
  } else if width == BUS_WIDTH_8BIT {
    foundation.serial_write_string("8-bit")
  }

  foundation.serial_write_string("\n")
}

// Initialize card
export fn sdmmc_init_card(controller_id: u32): u32 {
  if controller_id >= controller_count { return 1 }

  let ctrl: *SdmmcController = &controllers[controller_id]

  foundation.serial_write_string("[SD/MMC] Initializing card on controller ")
  foundation.serial_write_u64(controller_id)
  foundation.serial_write_string("\n")

  ctrl.state = STATE_INITIALIZING

  // Set initial clock speed
  sdmmc_set_clock(ctrl, CLOCK_INIT)

  // CMD0: GO_IDLE_STATE
  if sdmmc_send_command(ctrl, CMD0_GO_IDLE_STATE, 0) != 0 {
    foundation.serial_write_string("[SD/MMC] CMD0 failed\n")
    ctrl.state = STATE_ERROR
    return 1
  }

  // CMD8: SEND_IF_COND (for SD v2.0+)
  let cmd8_result: u32 = sdmmc_send_command(ctrl, CMD8_SEND_IF_COND, 0x1AA)

  // Try SD card initialization
  var retry: u32 = 0
  loop {
    if retry >= 100 { break }

    // CMD55: APP_CMD
    if sdmmc_send_command(ctrl, CMD55_APP_CMD, 0) != 0 {
      retry = retry + 1
      continue
    }

    // ACMD41: SD_SEND_OP_COND
    let ocr: u32 = 0x40300000  // 3.2-3.3V, SDHC support
    if sdmmc_send_command(ctrl, ACMD41_SD_SEND_OP_COND, ocr) == 0 {
      ctrl.card_type = if cmd8_result == 0 { CARD_TYPE_SDHC } else { CARD_TYPE_SD }
      break
    }

    retry = retry + 1
  }

  // If SD failed, try MMC
  if ctrl.card_type == CARD_TYPE_UNKNOWN {
    retry = 0
    loop {
      if retry >= 100 { break }

      if sdmmc_send_command(ctrl, CMD1_SEND_OP_COND, 0x40FF8000) == 0 {
        ctrl.card_type = CARD_TYPE_MMC
        break
      }

      retry = retry + 1
    }
  }

  if ctrl.card_type == CARD_TYPE_UNKNOWN {
    foundation.serial_write_string("[SD/MMC] Card detection failed\n")
    ctrl.state = STATE_ERROR
    return 1
  }

  // CMD2: ALL_SEND_CID
  if sdmmc_send_command(ctrl, CMD2_ALL_SEND_CID, 0) != 0 {
    foundation.serial_write_string("[SD/MMC] CMD2 failed\n")
    ctrl.state = STATE_ERROR
    return 1
  }

  // CMD3: SEND_RELATIVE_ADDR
  if sdmmc_send_command(ctrl, CMD3_SEND_RELATIVE_ADDR, 0) != 0 {
    foundation.serial_write_string("[SD/MMC] CMD3 failed\n")
    ctrl.state = STATE_ERROR
    return 1
  }

  // Simulate RCA assignment
  ctrl.rca = 0x0001

  // CMD9: SEND_CSD
  if sdmmc_send_command(ctrl, CMD9_SEND_CSD, ctrl.rca << 16) != 0 {
    foundation.serial_write_string("[SD/MMC] CMD9 failed\n")
    ctrl.state = STATE_ERROR
    return 1
  }

  // Simulate capacity detection
  ctrl.capacity_blocks = 15564800  // ~8GB card

  // CMD7: SELECT_CARD
  if sdmmc_send_command(ctrl, CMD7_SELECT_CARD, ctrl.rca << 16) != 0 {
    foundation.serial_write_string("[SD/MMC] CMD7 failed\n")
    ctrl.state = STATE_ERROR
    return 1
  }

  // Increase clock speed
  sdmmc_set_clock(ctrl, CLOCK_DEFAULT)

  // Try to set 4-bit bus width for SD cards
  if ctrl.card_type == CARD_TYPE_SD || ctrl.card_type == CARD_TYPE_SDHC {
    if sdmmc_send_command(ctrl, CMD55_APP_CMD, ctrl.rca << 16) == 0 {
      if sdmmc_send_command(ctrl, 6, 0x02) == 0 {  // ACMD6: SET_BUS_WIDTH
        sdmmc_set_bus_width(ctrl, BUS_WIDTH_4BIT)
      }
    }
  }

  // Try high-speed mode
  if sdmmc_send_command(ctrl, CMD6_SWITCH_FUNC, 0x80FFFFF1) == 0 {
    sdmmc_set_clock(ctrl, CLOCK_HIGH_SPEED)
    ctrl.high_speed = 1
  }

  ctrl.state = STATE_READY
  ctrl.initialized = 1

  foundation.serial_write_string("[SD/MMC] Card initialized: ")

  if ctrl.card_type == CARD_TYPE_SD {
    foundation.serial_write_string("SD")
  } else if ctrl.card_type == CARD_TYPE_SDHC {
    foundation.serial_write_string("SDHC")
  } else if ctrl.card_type == CARD_TYPE_MMC {
    foundation.serial_write_string("MMC")
  }

  foundation.serial_write_string(", capacity: ")
  foundation.serial_write_u64(ctrl.capacity_blocks * 512 / 1024 / 1024)
  foundation.serial_write_string(" MB\n")

  return 0
}

// Read blocks using DMA
fn sdmmc_read_dma(ctrl: *SdmmcController, block: u64, count: u32, buffer: u64): u32 {
  if ctrl.dma_channel == 0xFFFFFFFF { return 1 }

  foundation.serial_write_string("[SD/MMC] DMA read: block ")
  foundation.serial_write_u64(block)
  foundation.serial_write_string(", count ")
  foundation.serial_write_u64(count)
  foundation.serial_write_string("\n")

  // Setup DMA transfer
  let transfer_size: u32 = count * ctrl.block_size

  // Use multiple block read if count > 1
  let cmd: u32 = if count == 1 { CMD17_READ_SINGLE_BLOCK } else { CMD18_READ_MULTIPLE_BLOCK }

  // Send read command
  if sdmmc_send_command(ctrl, cmd, block) != 0 {
    foundation.serial_write_string("[SD/MMC] Read command failed\n")
    return 1
  }

  // Start DMA transfer (would configure actual DMA controller)
  // For now, simulate by copying to DMA buffer

  // Stop transmission for multi-block
  if count > 1 {
    sdmmc_send_command(ctrl, CMD12_STOP_TRANSMISSION, 0)
  }

  // Copy from DMA buffer to destination
  memory.memcpy(buffer, ctrl.dma_buffer, transfer_size)

  dma_transfers = dma_transfers + 1
  total_reads = total_reads + count

  return 0
}

// Read blocks using PIO
fn sdmmc_read_pio(ctrl: *SdmmcController, block: u64, count: u32, buffer: u64): u32 {
  foundation.serial_write_string("[SD/MMC] PIO read: block ")
  foundation.serial_write_u64(block)
  foundation.serial_write_string(", count ")
  foundation.serial_write_u64(count)
  foundation.serial_write_string("\n")

  var i: u32 = 0
  loop {
    if i >= count { break }

    let cmd: u32 = CMD17_READ_SINGLE_BLOCK
    let current_block: u64 = block + i

    if sdmmc_send_command(ctrl, cmd, current_block) != 0 {
      foundation.serial_write_string("[SD/MMC] Read failed at block ")
      foundation.serial_write_u64(current_block)
      foundation.serial_write_string("\n")
      return 1
    }

    // Would read data from FIFO here
    // For now, simulate success

    i = i + 1
  }

  pio_transfers = pio_transfers + 1
  total_reads = total_reads + count

  return 0
}

// Public read interface
export fn sdmmc_read_blocks(controller_id: u32, block: u64, count: u32, buffer: u64): u32 {
  if controller_id >= controller_count { return 1 }

  let ctrl: *SdmmcController = &controllers[controller_id]

  if ctrl.initialized == 0 {
    foundation.serial_write_string("[SD/MMC] Controller not initialized\n")
    return 1
  }

  if ctrl.state != STATE_READY {
    foundation.serial_write_string("[SD/MMC] Controller not ready\n")
    return 1
  }

  ctrl.state = STATE_TRANSFERRING

  let result: u32 = if ctrl.transfer_mode == TRANSFER_MODE_DMA {
    sdmmc_read_dma(ctrl, block, count, buffer)
  } else {
    sdmmc_read_pio(ctrl, block, count, buffer)
  }

  ctrl.state = STATE_READY

  if result != 0 {
    total_errors = total_errors + 1
  }

  return result
}

// Write blocks using DMA
fn sdmmc_write_dma(ctrl: *SdmmcController, block: u64, count: u32, buffer: u64): u32 {
  if ctrl.dma_channel == 0xFFFFFFFF { return 1 }

  foundation.serial_write_string("[SD/MMC] DMA write: block ")
  foundation.serial_write_u64(block)
  foundation.serial_write_string(", count ")
  foundation.serial_write_u64(count)
  foundation.serial_write_string("\n")

  let transfer_size: u32 = count * ctrl.block_size

  // Copy to DMA buffer
  memory.memcpy(ctrl.dma_buffer, buffer, transfer_size)

  let cmd: u32 = if count == 1 { CMD24_WRITE_BLOCK } else { CMD25_WRITE_MULTIPLE_BLOCK }

  if sdmmc_send_command(ctrl, cmd, block) != 0 {
    foundation.serial_write_string("[SD/MMC] Write command failed\n")
    return 1
  }

  // Start DMA transfer

  if count > 1 {
    sdmmc_send_command(ctrl, CMD12_STOP_TRANSMISSION, 0)
  }

  dma_transfers = dma_transfers + 1
  total_writes = total_writes + count

  return 0
}

// Write blocks using PIO
fn sdmmc_write_pio(ctrl: *SdmmcController, block: u64, count: u32, buffer: u64): u32 {
  var i: u32 = 0
  loop {
    if i >= count { break }

    let cmd: u32 = CMD24_WRITE_BLOCK
    let current_block: u64 = block + i

    if sdmmc_send_command(ctrl, cmd, current_block) != 0 {
      return 1
    }

    i = i + 1
  }

  pio_transfers = pio_transfers + 1
  total_writes = total_writes + count

  return 0
}

// Public write interface
export fn sdmmc_write_blocks(controller_id: u32, block: u64, count: u32, buffer: u64): u32 {
  if controller_id >= controller_count { return 1 }

  let ctrl: *SdmmcController = &controllers[controller_id]

  if ctrl.initialized == 0 || ctrl.state != STATE_READY {
    return 1
  }

  ctrl.state = STATE_TRANSFERRING

  let result: u32 = if ctrl.transfer_mode == TRANSFER_MODE_DMA {
    sdmmc_write_dma(ctrl, block, count, buffer)
  } else {
    sdmmc_write_pio(ctrl, block, count, buffer)
  }

  ctrl.state = STATE_READY

  if result != 0 {
    total_errors = total_errors + 1
  }

  return result
}

// Get card info
export fn sdmmc_get_capacity(controller_id: u32): u64 {
  if controller_id >= controller_count { return 0 }
  return controllers[controller_id].capacity_blocks * 512
}

// Print statistics
export fn sdmmc_print_stats() {
  foundation.serial_write_string("\n[SD/MMC] Statistics:\n")
  foundation.serial_write_string("  Total reads: ")
  foundation.serial_write_u64(total_reads)
  foundation.serial_write_string(" blocks\n")

  foundation.serial_write_string("  Total writes: ")
  foundation.serial_write_u64(total_writes)
  foundation.serial_write_string(" blocks\n")

  foundation.serial_write_string("  DMA transfers: ")
  foundation.serial_write_u64(dma_transfers)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  PIO transfers: ")
  foundation.serial_write_u64(pio_transfers)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Errors: ")
  foundation.serial_write_u64(total_errors)
  foundation.serial_write_string("\n")
}
