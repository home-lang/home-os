// home-os GPIO Driver
// General Purpose Input/Output

import "../core/foundation.home" as foundation

const GPIO_BASE: u64 = 0xFE200000

const GPIO_MODE_INPUT: u32 = 0
const GPIO_MODE_OUTPUT: u32 = 1
const GPIO_MODE_ALT0: u32 = 4
const GPIO_MODE_ALT1: u32 = 5

const MAX_GPIO_PINS: u32 = 54

var gpio_initialized: u32 = 0

export fn gpio_init() {
  if gpio_initialized == 1 { return }
  
  gpio_initialized = 1
  foundation.serial_write_string("[GPIO] Initialized\n")
}

export fn gpio_set_mode(pin: u32, mode: u32) {
  if gpio_initialized == 0 { return }
  if pin >= MAX_GPIO_PINS { return }
  
  var reg: u32 = pin / 10
  var shift: u32 = (pin % 10) * 3
  
  var addr: u64 = GPIO_BASE + (reg * 4)
  var value: u32 = @intToPtr(addr, u32)
  
  value = value & ~(0x7 << shift)
  value = value | (mode << shift)
  
  @ptrToInt(addr, u32) = value
}

export fn gpio_write(pin: u32, value: u32) {
  if gpio_initialized == 0 { return }
  if pin >= MAX_GPIO_PINS { return }
  
  var reg: u32 = pin / 32
  var bit: u32 = pin % 32
  
  var addr: u64
  if value != 0 {
    addr = GPIO_BASE + 0x1C + (reg * 4)  // SET register
  } else {
    addr = GPIO_BASE + 0x28 + (reg * 4)  // CLR register
  }
  
  @ptrToInt(addr, u32) = 1 << bit
}

export fn gpio_read(pin: u32) -> u32 {
  if gpio_initialized == 0 { return 0 }
  if pin >= MAX_GPIO_PINS { return 0 }
  
  var reg: u32 = pin / 32
  var bit: u32 = pin % 32
  
  var addr: u64 = GPIO_BASE + 0x34 + (reg * 4)  // LEV register
  var value: u32 = @intToPtr(addr, u32)
  
  return (value >> bit) & 1
}

export fn gpio_set_pull(pin: u32, pull: u32) {
  if gpio_initialized == 0 { return }
  if pin >= MAX_GPIO_PINS { return }
  
  // Set pull up/down (stub)
}
