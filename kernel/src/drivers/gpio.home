// home-os GPIO (General Purpose Input/Output) Driver
// Full-featured GPIO with interrupts, PWM, debouncing

import "../core/foundation.home" as foundation

// GPIO controller types
const GPIO_CTRL_BCM2835: u8 = 0     // Raspberry Pi
const GPIO_CTRL_BCM2711: u8 = 1     // Raspberry Pi 4
const GPIO_CTRL_INTEL_PCH: u8 = 2   // Intel PCH
const GPIO_CTRL_AMD_FCH: u8 = 3     // AMD FCH
const GPIO_CTRL_MMIO: u8 = 4        // Generic MMIO

// GPIO modes
const GPIO_MODE_INPUT: u8 = 0
const GPIO_MODE_OUTPUT: u8 = 1
const GPIO_MODE_ALT0: u8 = 2
const GPIO_MODE_ALT1: u8 = 3
const GPIO_MODE_ALT2: u8 = 4
const GPIO_MODE_ALT3: u8 = 5
const GPIO_MODE_ALT4: u8 = 6
const GPIO_MODE_ALT5: u8 = 7

// Pull resistor settings
const GPIO_PULL_NONE: u8 = 0
const GPIO_PULL_UP: u8 = 1
const GPIO_PULL_DOWN: u8 = 2

// Interrupt edge detection
const GPIO_INT_NONE: u8 = 0
const GPIO_INT_RISING: u8 = 1
const GPIO_INT_FALLING: u8 = 2
const GPIO_INT_BOTH: u8 = 3
const GPIO_INT_LEVEL_HIGH: u8 = 4
const GPIO_INT_LEVEL_LOW: u8 = 5

// Drive strength (mA)
const GPIO_DRIVE_2MA: u8 = 0
const GPIO_DRIVE_4MA: u8 = 1
const GPIO_DRIVE_8MA: u8 = 2
const GPIO_DRIVE_12MA: u8 = 3

// Slew rate
const GPIO_SLEW_SLOW: u8 = 0
const GPIO_SLEW_FAST: u8 = 1

// BCM2835/2711 register offsets
const BCM_GPFSEL0: u32 = 0x00      // Function Select
const BCM_GPSET0: u32 = 0x1C       // Pin Output Set
const BCM_GPCLR0: u32 = 0x28       // Pin Output Clear
const BCM_GPLEV0: u32 = 0x34       // Pin Level
const BCM_GPEDS0: u32 = 0x40       // Event Detect Status
const BCM_GPREN0: u32 = 0x4C       // Rising Edge Detect Enable
const BCM_GPFEN0: u32 = 0x58       // Falling Edge Detect Enable
const BCM_GPHEN0: u32 = 0x64       // High Detect Enable
const BCM_GPLEN0: u32 = 0x70       // Low Detect Enable
const BCM_GPAREN0: u32 = 0x7C      // Async Rising Edge Detect
const BCM_GPAFEN0: u32 = 0x88      // Async Falling Edge Detect
const BCM_GPIO_PUP_PDN0: u32 = 0xE4 // Pull-up/down control (BCM2711)

// Constants
const MAX_GPIO_CONTROLLERS: u32 = 4
const MAX_GPIO_PINS: u32 = 64
const MAX_GPIO_CALLBACKS: u32 = 64
const DEBOUNCE_DEFAULT_MS: u32 = 50

// GPIO pin configuration
struct GpioPin {
    controller: u8,
    pin: u8,
    mode: u8,
    pull: u8,
    drive: u8,
    slew: u8,
    int_mode: u8,
    debounce_ms: u32,
    last_state: u8,
    last_change: u64,
    callback: u64,
    user_data: u64,
    active: u8
}

// GPIO controller
struct GpioController {
    controller_type: u8,
    base_addr: u64,
    num_pins: u32,
    irq: u8,
    active: u8
}

// PWM configuration
struct GpioPwm {
    controller: u8,
    pin: u8,
    frequency: u32,
    duty_cycle: u16,     // 0-10000 (0-100.00%)
    enabled: u8,
    active: u8
}

// Statistics
struct GpioStats {
    interrupts: u64,
    reads: u64,
    writes: u64,
    debounced: u64
}

// Global state
var gpio_controllers: [GpioController; 4]
var gpio_controller_count: u32 = 0
var gpio_pins: [GpioPin; 64]
var gpio_pin_count: u32 = 0
var gpio_pwm: [GpioPwm; 16]
var gpio_pwm_count: u32 = 0
var gpio_stats: GpioStats
var gpio_initialized: u32 = 0

// Initialize GPIO subsystem
export fn gpio_init(): u32 {
    if gpio_initialized == 1 {
        return 1
    }

    // Clear controllers
    var i: u32 = 0
    while i < MAX_GPIO_CONTROLLERS {
        gpio_controllers[i].active = 0
        i = i + 1
    }

    // Clear pins
    i = 0
    while i < MAX_GPIO_PINS {
        gpio_pins[i].active = 0
        i = i + 1
    }

    // Clear PWM
    i = 0
    while i < 16 {
        gpio_pwm[i].active = 0
        i = i + 1
    }

    // Clear stats
    gpio_stats.interrupts = 0
    gpio_stats.reads = 0
    gpio_stats.writes = 0
    gpio_stats.debounced = 0

    gpio_controller_count = 0
    gpio_pin_count = 0
    gpio_pwm_count = 0

    gpio_initialized = 1
    foundation.serial_write_string("[GPIO] Subsystem initialized\n")
    return 1
}

// Register a GPIO controller
export fn gpio_register_controller(ctrl_type: u8, base_addr: u64, num_pins: u32, irq: u8): u32 {
    if gpio_controller_count >= MAX_GPIO_CONTROLLERS {
        return 0xFFFFFFFF
    }

    var idx: u32 = gpio_controller_count
    gpio_controllers[idx].controller_type = ctrl_type
    gpio_controllers[idx].base_addr = base_addr
    gpio_controllers[idx].num_pins = num_pins
    gpio_controllers[idx].irq = irq
    gpio_controllers[idx].active = 1

    gpio_controller_count = gpio_controller_count + 1

    foundation.serial_write_string("[GPIO] Controller registered at 0x")
    foundation.serial_write_hex(base_addr)
    foundation.serial_write_string("\n")

    return idx
}

// Register BCM2835 controller (Raspberry Pi 1/2/3/Zero)
export fn gpio_register_bcm2835(base_addr: u64): u32 {
    return gpio_register_controller(GPIO_CTRL_BCM2835, base_addr, 54, 0)
}

// Register BCM2711 controller (Raspberry Pi 4)
export fn gpio_register_bcm2711(base_addr: u64): u32 {
    return gpio_register_controller(GPIO_CTRL_BCM2711, base_addr, 58, 0)
}

// Request a GPIO pin
export fn gpio_request(controller: u32, pin: u32): u32 {
    if controller >= gpio_controller_count {
        return 0xFFFFFFFF
    }

    if pin >= gpio_controllers[controller].num_pins {
        return 0xFFFFFFFF
    }

    // Find empty slot
    var i: u32 = 0
    while i < MAX_GPIO_PINS {
        if gpio_pins[i].active == 0 {
            gpio_pins[i].controller = controller
            gpio_pins[i].pin = pin
            gpio_pins[i].mode = GPIO_MODE_INPUT
            gpio_pins[i].pull = GPIO_PULL_NONE
            gpio_pins[i].drive = GPIO_DRIVE_4MA
            gpio_pins[i].slew = GPIO_SLEW_SLOW
            gpio_pins[i].int_mode = GPIO_INT_NONE
            gpio_pins[i].debounce_ms = 0
            gpio_pins[i].last_state = 0
            gpio_pins[i].last_change = 0
            gpio_pins[i].callback = 0
            gpio_pins[i].user_data = 0
            gpio_pins[i].active = 1
            gpio_pin_count = gpio_pin_count + 1
            return i
        }
        i = i + 1
    }

    return 0xFFFFFFFF
}

// Release a GPIO pin
export fn gpio_free(handle: u32) {
    if handle >= MAX_GPIO_PINS { return }
    if gpio_pins[handle].active == 0 { return }

    // Disable interrupts
    gpio_disable_interrupt(handle)

    gpio_pins[handle].active = 0
    gpio_pin_count = gpio_pin_count - 1
}

// Set pin mode
export fn gpio_set_mode(handle: u32, mode: u8) {
    if handle >= MAX_GPIO_PINS { return }
    if gpio_pins[handle].active == 0 { return }

    var ctrl: u8 = gpio_pins[handle].controller
    var pin: u8 = gpio_pins[handle].pin
    var base: u64 = gpio_controllers[ctrl].base_addr

    if gpio_controllers[ctrl].controller_type == GPIO_CTRL_BCM2835 ||
       gpio_controllers[ctrl].controller_type == GPIO_CTRL_BCM2711 {
        // BCM GPIO function select
        var reg: u32 = pin / 10
        var shift: u32 = (pin % 10) * 3
        var addr: u64 = base + BCM_GPFSEL0 + (reg * 4)

        var value: u32 = gpio_read_reg32(addr)
        value = value & ~(0x7 << shift)

        // Map mode to BCM function
        var bcm_mode: u32 = 0
        if mode == GPIO_MODE_INPUT { bcm_mode = 0 }
        else if mode == GPIO_MODE_OUTPUT { bcm_mode = 1 }
        else if mode >= GPIO_MODE_ALT0 { bcm_mode = mode - 2 + 4 }

        value = value | (bcm_mode << shift)
        gpio_write_reg32(addr, value)
    }

    gpio_pins[handle].mode = mode
}

// Set pull resistor
export fn gpio_set_pull(handle: u32, pull: u8) {
    if handle >= MAX_GPIO_PINS { return }
    if gpio_pins[handle].active == 0 { return }

    var ctrl: u8 = gpio_pins[handle].controller
    var pin: u8 = gpio_pins[handle].pin
    var base: u64 = gpio_controllers[ctrl].base_addr

    if gpio_controllers[ctrl].controller_type == GPIO_CTRL_BCM2711 {
        // BCM2711 uses new pull control registers
        var reg: u32 = pin / 16
        var shift: u32 = (pin % 16) * 2
        var addr: u64 = base + BCM_GPIO_PUP_PDN0 + (reg * 4)

        var value: u32 = gpio_read_reg32(addr)
        value = value & ~(0x3 << shift)

        var pull_val: u32 = 0
        if pull == GPIO_PULL_UP { pull_val = 1 }
        else if pull == GPIO_PULL_DOWN { pull_val = 2 }

        value = value | (pull_val << shift)
        gpio_write_reg32(addr, value)
    } else if gpio_controllers[ctrl].controller_type == GPIO_CTRL_BCM2835 {
        // BCM2835 uses GPPUD registers (different method)
        var gppud: u64 = base + 0x94
        var gppudclk: u64 = base + 0x98 + ((pin / 32) * 4)

        // Set pull control
        var pull_val: u32 = 0
        if pull == GPIO_PULL_UP { pull_val = 2 }
        else if pull == GPIO_PULL_DOWN { pull_val = 1 }

        gpio_write_reg32(gppud, pull_val)
        gpio_delay_us(5)

        // Clock the control signal
        gpio_write_reg32(gppudclk, 1 << (pin % 32))
        gpio_delay_us(5)

        // Clear
        gpio_write_reg32(gppud, 0)
        gpio_write_reg32(gppudclk, 0)
    }

    gpio_pins[handle].pull = pull
}

// Set drive strength
export fn gpio_set_drive(handle: u32, drive: u8) {
    if handle >= MAX_GPIO_PINS { return }
    if gpio_pins[handle].active == 0 { return }

    gpio_pins[handle].drive = drive
    // Implementation depends on controller
}

// Set slew rate
export fn gpio_set_slew(handle: u32, slew: u8) {
    if handle >= MAX_GPIO_PINS { return }
    if gpio_pins[handle].active == 0 { return }

    gpio_pins[handle].slew = slew
    // Implementation depends on controller
}

// Write to output pin
export fn gpio_write(handle: u32, value: u8) {
    if handle >= MAX_GPIO_PINS { return }
    if gpio_pins[handle].active == 0 { return }

    var ctrl: u8 = gpio_pins[handle].controller
    var pin: u8 = gpio_pins[handle].pin
    var base: u64 = gpio_controllers[ctrl].base_addr

    if gpio_controllers[ctrl].controller_type == GPIO_CTRL_BCM2835 ||
       gpio_controllers[ctrl].controller_type == GPIO_CTRL_BCM2711 {
        var reg: u32 = pin / 32
        var bit: u32 = pin % 32

        var addr: u64
        if value != 0 {
            addr = base + BCM_GPSET0 + (reg * 4)
        } else {
            addr = base + BCM_GPCLR0 + (reg * 4)
        }

        gpio_write_reg32(addr, 1 << bit)
    }

    gpio_stats.writes = gpio_stats.writes + 1
}

// Read from input pin
export fn gpio_read(handle: u32): u8 {
    if handle >= MAX_GPIO_PINS { return 0 }
    if gpio_pins[handle].active == 0 { return 0 }

    var ctrl: u8 = gpio_pins[handle].controller
    var pin: u8 = gpio_pins[handle].pin
    var base: u64 = gpio_controllers[ctrl].base_addr
    var value: u8 = 0

    if gpio_controllers[ctrl].controller_type == GPIO_CTRL_BCM2835 ||
       gpio_controllers[ctrl].controller_type == GPIO_CTRL_BCM2711 {
        var reg: u32 = pin / 32
        var bit: u32 = pin % 32

        var addr: u64 = base + BCM_GPLEV0 + (reg * 4)
        var reg_val: u32 = gpio_read_reg32(addr)

        value = (reg_val >> bit) & 1
    }

    gpio_stats.reads = gpio_stats.reads + 1
    return value
}

// Toggle output pin
export fn gpio_toggle(handle: u32) {
    var current: u8 = gpio_read(handle)
    gpio_write(handle, if current == 0 { 1 } else { 0 })
}

// Enable interrupt on pin
export fn gpio_enable_interrupt(handle: u32, mode: u8, callback: u64, user_data: u64) {
    if handle >= MAX_GPIO_PINS { return }
    if gpio_pins[handle].active == 0 { return }

    var ctrl: u8 = gpio_pins[handle].controller
    var pin: u8 = gpio_pins[handle].pin
    var base: u64 = gpio_controllers[ctrl].base_addr

    if gpio_controllers[ctrl].controller_type == GPIO_CTRL_BCM2835 ||
       gpio_controllers[ctrl].controller_type == GPIO_CTRL_BCM2711 {
        var reg: u32 = pin / 32
        var bit: u32 = pin % 32
        var mask: u32 = 1 << bit

        // Clear existing settings
        gpio_write_reg32(base + BCM_GPREN0 + (reg * 4),
            gpio_read_reg32(base + BCM_GPREN0 + (reg * 4)) & ~mask)
        gpio_write_reg32(base + BCM_GPFEN0 + (reg * 4),
            gpio_read_reg32(base + BCM_GPFEN0 + (reg * 4)) & ~mask)
        gpio_write_reg32(base + BCM_GPHEN0 + (reg * 4),
            gpio_read_reg32(base + BCM_GPHEN0 + (reg * 4)) & ~mask)
        gpio_write_reg32(base + BCM_GPLEN0 + (reg * 4),
            gpio_read_reg32(base + BCM_GPLEN0 + (reg * 4)) & ~mask)

        // Enable based on mode
        if mode == GPIO_INT_RISING || mode == GPIO_INT_BOTH {
            gpio_write_reg32(base + BCM_GPREN0 + (reg * 4),
                gpio_read_reg32(base + BCM_GPREN0 + (reg * 4)) | mask)
        }
        if mode == GPIO_INT_FALLING || mode == GPIO_INT_BOTH {
            gpio_write_reg32(base + BCM_GPFEN0 + (reg * 4),
                gpio_read_reg32(base + BCM_GPFEN0 + (reg * 4)) | mask)
        }
        if mode == GPIO_INT_LEVEL_HIGH {
            gpio_write_reg32(base + BCM_GPHEN0 + (reg * 4),
                gpio_read_reg32(base + BCM_GPHEN0 + (reg * 4)) | mask)
        }
        if mode == GPIO_INT_LEVEL_LOW {
            gpio_write_reg32(base + BCM_GPLEN0 + (reg * 4),
                gpio_read_reg32(base + BCM_GPLEN0 + (reg * 4)) | mask)
        }
    }

    gpio_pins[handle].int_mode = mode
    gpio_pins[handle].callback = callback
    gpio_pins[handle].user_data = user_data
    gpio_pins[handle].last_state = gpio_read(handle)
}

// Disable interrupt on pin
export fn gpio_disable_interrupt(handle: u32) {
    if handle >= MAX_GPIO_PINS { return }
    if gpio_pins[handle].active == 0 { return }

    var ctrl: u8 = gpio_pins[handle].controller
    var pin: u8 = gpio_pins[handle].pin
    var base: u64 = gpio_controllers[ctrl].base_addr

    if gpio_controllers[ctrl].controller_type == GPIO_CTRL_BCM2835 ||
       gpio_controllers[ctrl].controller_type == GPIO_CTRL_BCM2711 {
        var reg: u32 = pin / 32
        var bit: u32 = pin % 32
        var mask: u32 = ~(1 << bit)

        gpio_write_reg32(base + BCM_GPREN0 + (reg * 4),
            gpio_read_reg32(base + BCM_GPREN0 + (reg * 4)) & mask)
        gpio_write_reg32(base + BCM_GPFEN0 + (reg * 4),
            gpio_read_reg32(base + BCM_GPFEN0 + (reg * 4)) & mask)
        gpio_write_reg32(base + BCM_GPHEN0 + (reg * 4),
            gpio_read_reg32(base + BCM_GPHEN0 + (reg * 4)) & mask)
        gpio_write_reg32(base + BCM_GPLEN0 + (reg * 4),
            gpio_read_reg32(base + BCM_GPLEN0 + (reg * 4)) & mask)
    }

    gpio_pins[handle].int_mode = GPIO_INT_NONE
    gpio_pins[handle].callback = 0
}

// Enable debouncing on pin
export fn gpio_set_debounce(handle: u32, debounce_ms: u32) {
    if handle >= MAX_GPIO_PINS { return }
    if gpio_pins[handle].active == 0 { return }

    gpio_pins[handle].debounce_ms = debounce_ms
}

// Handle GPIO interrupt
export fn gpio_irq_handler(controller: u32) {
    if controller >= gpio_controller_count { return }

    var base: u64 = gpio_controllers[controller].base_addr
    var now: u64 = foundation.timer_get_ticks()

    if gpio_controllers[controller].controller_type == GPIO_CTRL_BCM2835 ||
       gpio_controllers[controller].controller_type == GPIO_CTRL_BCM2711 {
        // Check event detect status
        var eds0: u32 = gpio_read_reg32(base + BCM_GPEDS0)
        var eds1: u32 = gpio_read_reg32(base + BCM_GPEDS0 + 4)

        // Process each pin
        var i: u32 = 0
        while i < MAX_GPIO_PINS {
            if gpio_pins[i].active == 1 {
                if gpio_pins[i].controller == controller {
                    var pin: u8 = gpio_pins[i].pin
                    var reg: u32 = pin / 32
                    var bit: u32 = pin % 32

                    var eds: u32 = if reg == 0 { eds0 } else { eds1 }

                    if (eds & (1 << bit)) != 0 {
                        gpio_stats.interrupts = gpio_stats.interrupts + 1

                        // Apply debouncing
                        if gpio_pins[i].debounce_ms > 0 {
                            if now - gpio_pins[i].last_change < gpio_pins[i].debounce_ms {
                                gpio_stats.debounced = gpio_stats.debounced + 1
                            } else {
                                gpio_pins[i].last_change = now
                                gpio_call_callback(i)
                            }
                        } else {
                            gpio_call_callback(i)
                        }

                        // Clear event
                        var clear_addr: u64 = base + BCM_GPEDS0 + (reg * 4)
                        gpio_write_reg32(clear_addr, 1 << bit)
                    }
                }
            }
            i = i + 1
        }
    }
}

// Call callback for pin
fn gpio_call_callback(handle: u32) {
    if gpio_pins[handle].callback != 0 {
        var new_state: u8 = gpio_read(handle)
        gpio_pins[handle].last_state = new_state
        // Would call callback function here
    }
}

// PWM: Configure PWM on pin
export fn gpio_pwm_configure(handle: u32, frequency: u32): u32 {
    if handle >= MAX_GPIO_PINS { return 0xFFFFFFFF }
    if gpio_pins[handle].active == 0 { return 0xFFFFFFFF }

    // Find empty PWM slot
    var i: u32 = 0
    while i < 16 {
        if gpio_pwm[i].active == 0 {
            gpio_pwm[i].controller = gpio_pins[handle].controller
            gpio_pwm[i].pin = gpio_pins[handle].pin
            gpio_pwm[i].frequency = frequency
            gpio_pwm[i].duty_cycle = 5000  // 50%
            gpio_pwm[i].enabled = 0
            gpio_pwm[i].active = 1
            gpio_pwm_count = gpio_pwm_count + 1

            // Set pin to PWM mode (ALT0 for BCM)
            gpio_set_mode(handle, GPIO_MODE_ALT0)

            return i
        }
        i = i + 1
    }

    return 0xFFFFFFFF
}

// PWM: Set duty cycle (0-10000 = 0.00% - 100.00%)
export fn gpio_pwm_set_duty(pwm_handle: u32, duty: u16) {
    if pwm_handle >= 16 { return }
    if gpio_pwm[pwm_handle].active == 0 { return }

    if duty > 10000 { duty = 10000 }
    gpio_pwm[pwm_handle].duty_cycle = duty

    // Update hardware PWM (implementation depends on controller)
}

// PWM: Set frequency
export fn gpio_pwm_set_frequency(pwm_handle: u32, frequency: u32) {
    if pwm_handle >= 16 { return }
    if gpio_pwm[pwm_handle].active == 0 { return }

    gpio_pwm[pwm_handle].frequency = frequency
    // Update hardware PWM
}

// PWM: Enable
export fn gpio_pwm_enable(pwm_handle: u32) {
    if pwm_handle >= 16 { return }
    if gpio_pwm[pwm_handle].active == 0 { return }

    gpio_pwm[pwm_handle].enabled = 1
    // Enable hardware PWM
}

// PWM: Disable
export fn gpio_pwm_disable(pwm_handle: u32) {
    if pwm_handle >= 16 { return }
    if gpio_pwm[pwm_handle].active == 0 { return }

    gpio_pwm[pwm_handle].enabled = 0
    // Disable hardware PWM
}

// PWM: Free
export fn gpio_pwm_free(pwm_handle: u32) {
    if pwm_handle >= 16 { return }
    if gpio_pwm[pwm_handle].active == 0 { return }

    gpio_pwm_disable(pwm_handle)
    gpio_pwm[pwm_handle].active = 0
    gpio_pwm_count = gpio_pwm_count - 1
}

// Batch operations: Read multiple pins
export fn gpio_read_multiple(handles: u64, values: u64, count: u32) {
    var i: u32 = 0
    while i < count {
        var handle: u32 = @intToPtr(handles + (i * 4), u32)
        @ptrToInt(values + i, u8) = gpio_read(handle)
        i = i + 1
    }
}

// Batch operations: Write multiple pins
export fn gpio_write_multiple(handles: u64, values: u64, count: u32) {
    var i: u32 = 0
    while i < count {
        var handle: u32 = @intToPtr(handles + (i * 4), u32)
        var value: u8 = @intToPtr(values + i, u8)
        gpio_write(handle, value)
        i = i + 1
    }
}

// Helper: Read 32-bit register
fn gpio_read_reg32(addr: u64): u32 {
    return @intToPtr(addr, u32)
}

// Helper: Write 32-bit register
fn gpio_write_reg32(addr: u64, value: u32) {
    @ptrToInt(addr, u32) = value
}

// Helper: Microsecond delay
fn gpio_delay_us(us: u32) {
    var start: u64 = foundation.timer_get_ticks()
    var target: u64 = start + us
    while foundation.timer_get_ticks() < target {
        // Busy wait
    }
}

// Get statistics
export fn gpio_get_stats(): u64 {
    return @ptrFromInt(gpio_stats)
}

// Shutdown GPIO
export fn gpio_shutdown() {
    if gpio_initialized == 0 { return }

    // Free all pins
    var i: u32 = 0
    while i < MAX_GPIO_PINS {
        if gpio_pins[i].active == 1 {
            gpio_free(i)
        }
        i = i + 1
    }

    // Free all PWM
    i = 0
    while i < 16 {
        if gpio_pwm[i].active == 1 {
            gpio_pwm_free(i)
        }
        i = i + 1
    }

    gpio_initialized = 0
    foundation.serial_write_string("[GPIO] Shutdown complete\n")
}
