// home-os AHCI Driver
// Advanced Host Controller Interface (SATA)

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "pci.home" as pci

// ============================================================================
// AHCI CONSTANTS
// ============================================================================

const AHCI_CLASS: u8 = 0x01
const AHCI_SUBCLASS: u8 = 0x06
const AHCI_PROG_IF: u8 = 0x01

// HBA Memory Register Offsets
const HBA_CAP: u32 = 0x00       // Host Capabilities
const HBA_GHC: u32 = 0x04       // Global Host Control
const HBA_IS: u32 = 0x08        // Interrupt Status
const HBA_PI: u32 = 0x0C        // Ports Implemented
const HBA_VS: u32 = 0x10        // Version
const HBA_PORT_BASE: u32 = 0x100

// Port Register Offsets (from port base)
const PORT_CLB: u32 = 0x00      // Command List Base Address
const PORT_CLBU: u32 = 0x04     // Command List Base Address Upper
const PORT_FB: u32 = 0x08       // FIS Base Address
const PORT_FBU: u32 = 0x0C      // FIS Base Address Upper
const PORT_IS: u32 = 0x10       // Interrupt Status
const PORT_IE: u32 = 0x14       // Interrupt Enable
const PORT_CMD: u32 = 0x18      // Command and Status
const PORT_TFD: u32 = 0x20      // Task File Data
const PORT_SIG: u32 = 0x24      // Signature
const PORT_SSTS: u32 = 0x28     // SATA Status
const PORT_SCTL: u32 = 0x2C     // SATA Control
const PORT_SERR: u32 = 0x30     // SATA Error
const PORT_SACT: u32 = 0x34     // SATA Active
const PORT_CI: u32 = 0x38       // Command Issue

// Port Command Bits
const HBA_PORT_CMD_ST: u32 = 0x0001   // Start
const HBA_PORT_CMD_SUD: u32 = 0x0002  // Spin-Up Device
const HBA_PORT_CMD_POD: u32 = 0x0004  // Power On Device
const HBA_PORT_CMD_FRE: u32 = 0x0010  // FIS Receive Enable
const HBA_PORT_CMD_FR: u32 = 0x4000   // FIS Receive Running
const HBA_PORT_CMD_CR: u32 = 0x8000   // Command List Running

// Device Signatures
const SATA_SIG_ATA: u32 = 0x00000101   // SATA drive
const SATA_SIG_ATAPI: u32 = 0xEB140101 // SATAPI drive
const SATA_SIG_SEMB: u32 = 0xC33C0101  // Enclosure management bridge
const SATA_SIG_PM: u32 = 0x96690101    // Port multiplier

// SATA Status
const HBA_PORT_IPM_ACTIVE: u32 = 0x100
const HBA_PORT_DET_PRESENT: u32 = 0x3

// FIS Types
const FIS_TYPE_REG_H2D: u8 = 0x27    // Host to Device
const FIS_TYPE_REG_D2H: u8 = 0x34    // Device to Host
const FIS_TYPE_DMA_ACT: u8 = 0x39    // DMA Activate
const FIS_TYPE_DMA_SETUP: u8 = 0x41  // DMA Setup
const FIS_TYPE_DATA: u8 = 0x46       // Data
const FIS_TYPE_BIST: u8 = 0x58       // BIST Activate
const FIS_TYPE_PIO_SETUP: u8 = 0x5F  // PIO Setup
const FIS_TYPE_DEV_BITS: u8 = 0xA1   // Set Device Bits

// ATA Commands
const ATA_CMD_READ_DMA_EX: u8 = 0x25
const ATA_CMD_WRITE_DMA_EX: u8 = 0x35
const ATA_CMD_IDENTIFY: u8 = 0xEC
const ATA_CMD_FLUSH: u8 = 0xE7

// ============================================================================
// AHCI STRUCTURES
// ============================================================================

struct HbaPort {
  clb: u32,           // Command list base address (lower)
  clbu: u32,          // Command list base address (upper)
  fb: u32,            // FIS base address (lower)
  fbu: u32,           // FIS base address (upper)
  is: u32,            // Interrupt status
  ie: u32,            // Interrupt enable
  cmd: u32,           // Command and status
  reserved0: u32,
  tfd: u32,           // Task file data
  sig: u32,           // Signature
  ssts: u32,          // SATA status
  sctl: u32,          // SATA control
  serr: u32,          // SATA error
  sact: u32,          // SATA active
  ci: u32,            // Command issue
  sntf: u32,          // SATA notification
  fbs: u32            // FIS-based switching
}

struct HbaCommandHeader {
  dw0: u32,           // Command FIS length, ATAPI, Write, Prefetch
  prdtl: u32,         // PRDT length (entries)
  prdbc: u32,         // PRD byte count transferred
  ctba: u32,          // Command table base address (lower)
  ctbau: u32,         // Command table base address (upper)
  reserved: [u32; 4]
}

struct HbaPrdtEntry {
  dba: u32,           // Data base address (lower)
  dbau: u32,          // Data base address (upper)
  reserved: u32,
  dbc: u32            // Byte count, bit 31 = interrupt on completion
}

struct HbaCommandTable {
  cfis: [u8; 64],     // Command FIS
  acmd: [u8; 16],     // ATAPI command
  reserved: [u8; 48],
  prdt: [HbaPrdtEntry; 8]  // PRDT entries
}

struct FisRegH2D {
  fis_type: u8,
  pmport_c: u8,       // PM port | C bit
  command: u8,
  features: u8,
  lba0: u8,
  lba1: u8,
  lba2: u8,
  device: u8,
  lba3: u8,
  lba4: u8,
  lba5: u8,
  features_exp: u8,
  count_low: u8,
  count_high: u8,
  icc: u8,
  control: u8,
  reserved: [u8; 4]
}

struct AhciPort {
  port_num: u32,
  port_type: u32,     // 0=None, 1=SATA, 2=SATAPI
  clb: u64,           // Command list base
  fb: u64,            // FIS base
  ctba: [u64; 32],    // Command tables
  sector_count: u64,
  active: u32
}

// ============================================================================
// GLOBAL STATE
// ============================================================================

var ahci_base: u64 = 0
var ahci_initialized: u32 = 0
var ahci_port_count: u32 = 0
var ahci_ports: [AhciPort; 32]

// ============================================================================
// LOW-LEVEL ACCESS
// ============================================================================

fn ahci_read32(offset: u32): u32 {
  return @intToPtr(ahci_base + offset, u32)
}

fn ahci_write32(offset: u32, value: u32) {
  @ptrToInt(ahci_base + offset, u32) = value
}

fn port_read32(port: u32, offset: u32): u32 {
  return ahci_read32(HBA_PORT_BASE + port * 0x80 + offset)
}

fn port_write32(port: u32, offset: u32, value: u32) {
  ahci_write32(HBA_PORT_BASE + port * 0x80 + offset, value)
}

// ============================================================================
// PORT MANAGEMENT
// ============================================================================

fn ahci_stop_cmd(port: u32) {
  var cmd: u32 = port_read32(port, PORT_CMD)

  // Clear ST (Start) bit
  cmd = cmd & ~HBA_PORT_CMD_ST

  // Clear FRE (FIS Receive Enable) bit
  cmd = cmd & ~HBA_PORT_CMD_FRE

  port_write32(port, PORT_CMD, cmd)

  // Wait for FR and CR to clear
  var timeout: u32 = 1000
  while timeout > 0 {
    cmd = port_read32(port, PORT_CMD)
    if (cmd & HBA_PORT_CMD_FR) == 0 and (cmd & HBA_PORT_CMD_CR) == 0 {
      break
    }
    timeout = timeout - 1
  }
}

fn ahci_start_cmd(port: u32) {
  // Wait for CR to clear
  var timeout: u32 = 1000
  while timeout > 0 {
    var cmd: u32 = port_read32(port, PORT_CMD)
    if (cmd & HBA_PORT_CMD_CR) == 0 { break }
    timeout = timeout - 1
  }

  // Set FRE and ST
  var cmd: u32 = port_read32(port, PORT_CMD)
  cmd = cmd | HBA_PORT_CMD_FRE
  port_write32(port, PORT_CMD, cmd)

  cmd = cmd | HBA_PORT_CMD_ST
  port_write32(port, PORT_CMD, cmd)
}

fn ahci_port_rebase(port: u32) {
  ahci_stop_cmd(port)

  // Allocate command list (1KB, 1024-byte aligned)
  var clb: u64 = memory.pmm_alloc_pages(1)
  memory.memset(clb, 0, 4096)

  port_write32(port, PORT_CLB, clb & 0xFFFFFFFF)
  port_write32(port, PORT_CLBU, (clb >> 32) & 0xFFFFFFFF)
  ahci_ports[port].clb = clb

  // Allocate FIS (256 bytes, 256-byte aligned)
  var fb: u64 = memory.pmm_alloc_pages(1)
  memory.memset(fb, 0, 4096)

  port_write32(port, PORT_FB, fb & 0xFFFFFFFF)
  port_write32(port, PORT_FBU, (fb >> 32) & 0xFFFFFFFF)
  ahci_ports[port].fb = fb

  // Setup command tables (one per command slot)
  var cmd_header: u64 = clb
  var i: u32 = 0
  while i < 32 {
    // Allocate command table (256 bytes minimum)
    var ctba: u64 = memory.pmm_alloc_pages(1)
    memory.memset(ctba, 0, 4096)

    // Set command header
    var header: *HbaCommandHeader = @ptrFromInt(cmd_header + i * 32)
    header.prdtl = 8  // 8 PRDT entries per command
    header.ctba = ctba & 0xFFFFFFFF
    header.ctbau = (ctba >> 32) & 0xFFFFFFFF

    ahci_ports[port].ctba[i] = ctba
    i = i + 1
  }

  // Clear interrupt status
  port_write32(port, PORT_IS, 0xFFFFFFFF)

  // Enable interrupts
  port_write32(port, PORT_IE, 0xFFFFFFFF)

  ahci_start_cmd(port)
}

fn ahci_check_port_type(port: u32): u32 {
  var ssts: u32 = port_read32(port, PORT_SSTS)

  var ipm: u32 = (ssts >> 8) & 0x0F
  var det: u32 = ssts & 0x0F

  if det != HBA_PORT_DET_PRESENT { return 0 }
  if ipm != 1 { return 0 }  // Not active

  var sig: u32 = port_read32(port, PORT_SIG)

  if sig == SATA_SIG_ATAPI { return 2 }  // SATAPI
  if sig == SATA_SIG_ATA { return 1 }    // SATA

  return 0
}

// ============================================================================
// COMMAND EXECUTION
// ============================================================================

fn ahci_find_cmdslot(port: u32): i32 {
  var slots: u32 = port_read32(port, PORT_SACT) | port_read32(port, PORT_CI)

  var i: i32 = 0
  while i < 32 {
    if (slots & (1 << i)) == 0 {
      return i
    }
    i = i + 1
  }

  return -1  // No free slot
}

fn ahci_issue_command(port: u32, slot: u32, lba: u64, count: u32, buffer: u64, write: u32): u32 {
  // Clear interrupt status
  port_write32(port, PORT_IS, 0xFFFFFFFF)

  // Get command header
  var cmd_header: *HbaCommandHeader = @ptrFromInt(ahci_ports[port].clb + slot * 32)

  // Setup command header
  var cfl: u32 = 5  // FIS length in DWORDs (20 bytes / 4)
  if write != 0 {
    cmd_header.dw0 = cfl | (1 << 6)  // Write bit
  } else {
    cmd_header.dw0 = cfl
  }
  cmd_header.prdtl = 1  // 1 PRDT entry

  // Get command table
  var cmd_tbl: *HbaCommandTable = @ptrFromInt(ahci_ports[port].ctba[slot])
  memory.memset(@ptrFromInt(cmd_tbl), 0, 256)

  // Setup PRDT
  cmd_tbl.prdt[0].dba = buffer & 0xFFFFFFFF
  cmd_tbl.prdt[0].dbau = (buffer >> 32) & 0xFFFFFFFF
  cmd_tbl.prdt[0].dbc = (count * 512) - 1  // Byte count minus 1

  // Setup command FIS
  var fis: *FisRegH2D = @ptrFromInt(@ptrFromInt(cmd_tbl))
  fis.fis_type = FIS_TYPE_REG_H2D
  fis.pmport_c = 0x80  // Command bit set

  if write != 0 {
    fis.command = ATA_CMD_WRITE_DMA_EX
  } else {
    fis.command = ATA_CMD_READ_DMA_EX
  }

  fis.lba0 = (lba & 0xFF) as u8
  fis.lba1 = ((lba >> 8) & 0xFF) as u8
  fis.lba2 = ((lba >> 16) & 0xFF) as u8
  fis.device = 0x40  // LBA mode

  fis.lba3 = ((lba >> 24) & 0xFF) as u8
  fis.lba4 = ((lba >> 32) & 0xFF) as u8
  fis.lba5 = ((lba >> 40) & 0xFF) as u8

  fis.count_low = (count & 0xFF) as u8
  fis.count_high = ((count >> 8) & 0xFF) as u8

  // Issue command
  port_write32(port, PORT_CI, 1 << slot)

  // Wait for completion
  var timeout: u32 = 100000
  while timeout > 0 {
    var ci: u32 = port_read32(port, PORT_CI)
    if (ci & (1 << slot)) == 0 { break }

    var is: u32 = port_read32(port, PORT_IS)
    if (is & 0x40000000) != 0 {  // Task file error
      foundation.serial_write_string("[AHCI] Task file error\n")
      return 1
    }

    timeout = timeout - 1
  }

  if timeout == 0 {
    foundation.serial_write_string("[AHCI] Command timeout\n")
    return 1
  }

  return 0
}

// ============================================================================
// INITIALIZATION
// ============================================================================

export fn ahci_init() {
  if ahci_initialized == 1 { return }

  foundation.serial_write_string("[AHCI] Scanning for controllers...\n")

  // Find AHCI controller via PCI (class 01h, subclass 06h)
  var i: u32 = 0
  var found: u32 = 0
  while i < pci.pci_get_device_count() {
    var dev: u64 = pci.pci_get_device(i)
    if dev != 0 {
      var class_code: u8 = pci.pci_read_config8(dev, 0x0B)
      var subclass: u8 = pci.pci_read_config8(dev, 0x0A)

      if class_code == AHCI_CLASS and subclass == AHCI_SUBCLASS {
        // Found AHCI controller - read BAR5
        ahci_base = pci.pci_read_bar(dev, 5) & ~0xF

        // Enable bus mastering and memory space
        var cmd: u16 = pci.pci_read_config16(dev, 0x04)
        pci.pci_write_config16(dev, 0x04, cmd | 0x06)

        found = 1
        foundation.serial_write_string("[AHCI] Found controller at ABAR: 0x")
        foundation.serial_write_hex(@truncate(ahci_base, u32))
        foundation.serial_write_string("\n")
        break
      }
    }
    i = i + 1
  }

  if found == 0 {
    foundation.serial_write_string("[AHCI] No controller found\n")
    return
  }

  // Enable AHCI mode
  var ghc: u32 = ahci_read32(HBA_GHC)
  ahci_write32(HBA_GHC, ghc | 0x80000000)  // Set AE (AHCI Enable)

  // Get ports implemented
  var pi: u32 = ahci_read32(HBA_PI)
  var cap: u32 = ahci_read32(HBA_CAP)
  var num_ports: u32 = (cap & 0x1F) + 1

  foundation.serial_write_string("[AHCI] Ports implemented: 0x")
  foundation.serial_write_hex(pi)
  foundation.serial_write_string("\n")

  // Probe ports
  i = 0
  while i < num_ports {
    if (pi & (1 << i)) != 0 {
      var port_type: u32 = ahci_check_port_type(i)
      ahci_ports[i].port_num = i
      ahci_ports[i].port_type = port_type

      if port_type == 1 {
        foundation.serial_write_string("[AHCI] Port ")
        foundation.serial_write_u32(i)
        foundation.serial_write_string(": SATA drive\n")

        ahci_port_rebase(i)
        ahci_ports[i].active = 1
        ahci_port_count = ahci_port_count + 1
      } else if port_type == 2 {
        foundation.serial_write_string("[AHCI] Port ")
        foundation.serial_write_u32(i)
        foundation.serial_write_string(": SATAPI drive\n")

        ahci_port_rebase(i)
        ahci_ports[i].active = 1
        ahci_port_count = ahci_port_count + 1
      }
    }
    i = i + 1
  }

  if ahci_port_count == 0 {
    foundation.serial_write_string("[AHCI] No drives found\n")
    return
  }

  ahci_initialized = 1
  foundation.serial_write_string("[AHCI] Initialization complete (")
  foundation.serial_write_u32(ahci_port_count)
  foundation.serial_write_string(" drives)\n")
}

// ============================================================================
// I/O OPERATIONS
// ============================================================================

export fn ahci_read_sector(port: u32, lba: u64, buffer: u64): u32 {
  return ahci_read_sectors(port, lba, 1, buffer)
}

export fn ahci_read_sectors(port: u32, lba: u64, count: u32, buffer: u64): u32 {
  if ahci_initialized == 0 { return 1 }
  if port >= 32 { return 1 }
  if ahci_ports[port].active == 0 { return 1 }

  var slot: i32 = ahci_find_cmdslot(port)
  if slot < 0 { return 1 }

  return ahci_issue_command(port, slot as u32, lba, count, buffer, 0)
}

export fn ahci_write_sector(port: u32, lba: u64, buffer: u64): u32 {
  return ahci_write_sectors(port, lba, 1, buffer)
}

export fn ahci_write_sectors(port: u32, lba: u64, count: u32, buffer: u64): u32 {
  if ahci_initialized == 0 { return 1 }
  if port >= 32 { return 1 }
  if ahci_ports[port].active == 0 { return 1 }

  var slot: i32 = ahci_find_cmdslot(port)
  if slot < 0 { return 1 }

  return ahci_issue_command(port, slot as u32, lba, count, buffer, 1)
}

export fn ahci_flush(port: u32): u32 {
  if ahci_initialized == 0 { return 1 }
  if port >= 32 { return 1 }
  if ahci_ports[port].active == 0 { return 1 }

  var slot: i32 = ahci_find_cmdslot(port)
  if slot < 0 { return 1 }

  // Get command table
  var cmd_tbl: *HbaCommandTable = @ptrFromInt(ahci_ports[port].ctba[slot as u32])
  memory.memset(@ptrFromInt(cmd_tbl), 0, 256)

  // Setup flush FIS
  var fis: *FisRegH2D = @ptrFromInt(@ptrFromInt(cmd_tbl))
  fis.fis_type = FIS_TYPE_REG_H2D
  fis.pmport_c = 0x80
  fis.command = ATA_CMD_FLUSH

  // Get command header
  var cmd_header: *HbaCommandHeader = @ptrFromInt(ahci_ports[port].clb + slot as u32 * 32)
  cmd_header.dw0 = 5  // FIS length
  cmd_header.prdtl = 0

  // Issue command
  port_write32(port, PORT_CI, 1 << slot as u32)

  // Wait for completion
  var timeout: u32 = 100000
  while timeout > 0 {
    var ci: u32 = port_read32(port, PORT_CI)
    if (ci & (1 << slot as u32)) == 0 { break }
    timeout = timeout - 1
  }

  return if timeout == 0 { 1 } else { 0 }
}

export fn ahci_get_port_count(): u32 {
  return ahci_port_count
}

export fn ahci_is_port_active(port: u32): u32 {
  if port >= 32 { return 0 }
  return ahci_ports[port].active
}

export fn ahci_is_initialized(): u32 {
  return ahci_initialized
}
