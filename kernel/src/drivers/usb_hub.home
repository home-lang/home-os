// HomeOS USB Hub Driver
// Full USB hub support with port management and device enumeration

import "../core/foundation.home" as foundation
import "usb.home" as usb

// ============================================
// Hub Constants
// ============================================

const USB_HUB_MAX_HUBS: u32 = 16
const USB_HUB_MAX_PORTS: u32 = 15  // USB spec allows up to 255, but 15 is practical
const USB_HUB_MAX_DEPTH: u32 = 5   // USB spec maximum hub depth

// Hub Class Request Codes
const USB_HUB_REQ_GET_STATUS: u8 = 0x00
const USB_HUB_REQ_CLEAR_FEATURE: u8 = 0x01
const USB_HUB_REQ_SET_FEATURE: u8 = 0x03
const USB_HUB_REQ_GET_DESCRIPTOR: u8 = 0x06
const USB_HUB_REQ_SET_DESCRIPTOR: u8 = 0x07
const USB_HUB_REQ_CLEAR_TT_BUFFER: u8 = 0x08
const USB_HUB_REQ_RESET_TT: u8 = 0x09
const USB_HUB_REQ_GET_TT_STATE: u8 = 0x0A
const USB_HUB_REQ_STOP_TT: u8 = 0x0B

// Hub Class Feature Selectors
const USB_HUB_FEAT_C_HUB_LOCAL_POWER: u16 = 0
const USB_HUB_FEAT_C_HUB_OVER_CURRENT: u16 = 1

// Port Feature Selectors
const USB_PORT_FEAT_CONNECTION: u16 = 0
const USB_PORT_FEAT_ENABLE: u16 = 1
const USB_PORT_FEAT_SUSPEND: u16 = 2
const USB_PORT_FEAT_OVER_CURRENT: u16 = 3
const USB_PORT_FEAT_RESET: u16 = 4
const USB_PORT_FEAT_LINK_STATE: u16 = 5
const USB_PORT_FEAT_POWER: u16 = 8
const USB_PORT_FEAT_LOWSPEED: u16 = 9
const USB_PORT_FEAT_C_CONNECTION: u16 = 16
const USB_PORT_FEAT_C_ENABLE: u16 = 17
const USB_PORT_FEAT_C_SUSPEND: u16 = 18
const USB_PORT_FEAT_C_OVER_CURRENT: u16 = 19
const USB_PORT_FEAT_C_RESET: u16 = 20
const USB_PORT_FEAT_TEST: u16 = 21
const USB_PORT_FEAT_INDICATOR: u16 = 22
const USB_PORT_FEAT_C_PORT_LINK_STATE: u16 = 25
const USB_PORT_FEAT_C_PORT_CONFIG_ERROR: u16 = 26
const USB_PORT_FEAT_REMOTE_WAKE_MASK: u16 = 27
const USB_PORT_FEAT_BH_PORT_RESET: u16 = 28
const USB_PORT_FEAT_C_BH_PORT_RESET: u16 = 29
const USB_PORT_FEAT_FORCE_LINKPM_ACCEPT: u16 = 30

// Port Status Bits
const USB_PORT_STAT_CONNECTION: u16 = 0x0001
const USB_PORT_STAT_ENABLE: u16 = 0x0002
const USB_PORT_STAT_SUSPEND: u16 = 0x0004
const USB_PORT_STAT_OVER_CURRENT: u16 = 0x0008
const USB_PORT_STAT_RESET: u16 = 0x0010
const USB_PORT_STAT_L1: u16 = 0x0020
const USB_PORT_STAT_POWER: u16 = 0x0100
const USB_PORT_STAT_LOW_SPEED: u16 = 0x0200
const USB_PORT_STAT_HIGH_SPEED: u16 = 0x0400
const USB_PORT_STAT_TEST: u16 = 0x0800
const USB_PORT_STAT_INDICATOR: u16 = 0x1000

// Port Change Status Bits
const USB_PORT_STAT_C_CONNECTION: u16 = 0x0001
const USB_PORT_STAT_C_ENABLE: u16 = 0x0002
const USB_PORT_STAT_C_SUSPEND: u16 = 0x0004
const USB_PORT_STAT_C_OVER_CURRENT: u16 = 0x0008
const USB_PORT_STAT_C_RESET: u16 = 0x0010
const USB_PORT_STAT_C_BH_RESET: u16 = 0x0020
const USB_PORT_STAT_C_LINK_STATE: u16 = 0x0040
const USB_PORT_STAT_C_CONFIG_ERROR: u16 = 0x0080

// Hub Status Bits
const USB_HUB_STAT_LOCAL_POWER: u16 = 0x0001
const USB_HUB_STAT_OVER_CURRENT: u16 = 0x0002

// Hub Descriptor Types
const USB_DT_HUB: u8 = 0x29
const USB_DT_SS_HUB: u8 = 0x2A

// Hub Characteristics
const USB_HUB_CHAR_LPSM: u16 = 0x0003  // Logical Power Switching Mode
const USB_HUB_CHAR_COMPOUND: u16 = 0x0004
const USB_HUB_CHAR_OCPM: u16 = 0x0018  // Over-Current Protection Mode
const USB_HUB_CHAR_TTTT: u16 = 0x0060  // TT Think Time
const USB_HUB_CHAR_PORTIND: u16 = 0x0080

// Power switching modes
const USB_HUB_LPSM_GANGED: u16 = 0x0000
const USB_HUB_LPSM_INDIVIDUAL: u16 = 0x0001

// Over-current protection modes
const USB_HUB_OCPM_GLOBAL: u16 = 0x0000
const USB_HUB_OCPM_INDIVIDUAL: u16 = 0x0008
const USB_HUB_OCPM_NONE: u16 = 0x0010

// Device speeds
const USB_SPEED_LOW: u8 = 1
const USB_SPEED_FULL: u8 = 2
const USB_SPEED_HIGH: u8 = 3
const USB_SPEED_SUPER: u8 = 4
const USB_SPEED_SUPER_PLUS: u8 = 5

// Port indicator colors
const USB_PORT_INDICATOR_OFF: u8 = 0
const USB_PORT_INDICATOR_AMBER: u8 = 1
const USB_PORT_INDICATOR_GREEN: u8 = 2
const USB_PORT_INDICATOR_AUTO: u8 = 3

// ============================================
// Hub Structures
// ============================================

// USB Hub Descriptor (USB 2.0)
struct UsbHubDescriptor {
    length: u8
    descriptor_type: u8
    num_ports: u8
    characteristics: u16
    power_on_to_power_good: u8   // In 2ms intervals
    hub_controller_current: u8
    device_removable: [u8; 4]    // Bitmap, 1 bit per port
    port_pwr_ctrl_mask: [u8; 4]  // Bitmap
}

// USB SuperSpeed Hub Descriptor
struct UsbSSHubDescriptor {
    length: u8
    descriptor_type: u8
    num_ports: u8
    characteristics: u16
    power_on_to_power_good: u8
    hub_controller_current: u8
    hub_hdr_dec_lat: u8         // Hub header decode latency
    hub_delay: u16              // Hub delay in ns
    device_removable: u16       // Bitmap
}

// Port Status and Change
struct UsbPortStatus {
    status: u16
    change: u16
}

// Hub Status and Change
struct UsbHubStatus {
    status: u16
    change: u16
}

// Port state enumeration
enum PortState {
    Disconnected
    Powered
    Disabled
    Resetting
    Enabled
    Suspended
    Error
}

// Hub port information
struct HubPort {
    state: PortState
    speed: u8
    device_address: u8
    status: UsbPortStatus
    is_removable: bool
    has_power_control: bool
    reset_count: u8
    error_count: u8
    child_hub_id: i32          // -1 if no child hub
    connect_time: u64
}

// Transaction Translator info for high-speed hubs
struct TransactionTranslator {
    hub_address: u8
    port_number: u8
    think_time: u8             // 0=8, 1=16, 2=24, 3=32 FS bit times
    multi_tt: bool             // Multi-TT hub
}

// USB Hub structure
struct UsbHub {
    // USB device info
    device_address: u8
    endpoint_in: u8            // Interrupt endpoint for status changes
    parent_hub_id: i32         // -1 for root hub
    parent_port: u8
    depth: u8

    // Hub descriptor info
    descriptor: UsbHubDescriptor
    num_ports: u8
    power_good_delay: u16      // In milliseconds
    hub_current: u8
    characteristics: u16

    // Port info
    ports: [HubPort; USB_HUB_MAX_PORTS]

    // Transaction translator
    tt: TransactionTranslator
    has_tt: bool
    multi_tt: bool

    // Status
    is_active: bool
    is_powered: bool
    over_current: bool
    local_power_good: bool

    // SuperSpeed hub info
    is_superspeed: bool
    ss_descriptor: UsbSSHubDescriptor

    // Polling state
    pending_status_change: bool
    status_change_bitmap: u32

    // Statistics
    total_connects: u32
    total_disconnects: u32
    total_resets: u32
    total_errors: u32
}

// Hub enumeration callback
type HubDeviceCallback = fn(hub_id: u32, port: u8, speed: u8, address: u8): void

// ============================================
// Global State
// ============================================

var hubs: [UsbHub; USB_HUB_MAX_HUBS]
var hub_count: u32 = 0
var hub_initialized: bool = false
var device_callback: HubDeviceCallback = null
var next_device_address: u8 = 1

// Root hub tracking
var root_hubs: [u32; 4]       // Hub IDs for root hubs
var root_hub_count: u32 = 0

// ============================================
// Initialization
// ============================================

export fn usb_hub_init(): i32 {
    if hub_initialized {
        return 0
    }

    // Initialize hub array
    var i: u32 = 0
    while i < USB_HUB_MAX_HUBS {
        hubs[i].is_active = false
        hubs[i].device_address = 0
        hubs[i].parent_hub_id = -1
        hubs[i].depth = 0
        hubs[i].num_ports = 0

        // Initialize ports
        var p: u32 = 0
        while p < USB_HUB_MAX_PORTS {
            hubs[i].ports[p].state = PortState.Disconnected
            hubs[i].ports[p].speed = 0
            hubs[i].ports[p].device_address = 0
            hubs[i].ports[p].child_hub_id = -1
            hubs[i].ports[p].reset_count = 0
            hubs[i].ports[p].error_count = 0
            p = p + 1
        }

        i = i + 1
    }

    hub_count = 0
    root_hub_count = 0
    next_device_address = 1
    device_callback = null
    hub_initialized = true

    foundation.serial_write_string("[USB Hub] Hub driver initialized\n")
    return 0
}

export fn usb_hub_set_device_callback(callback: HubDeviceCallback): void {
    device_callback = callback
}

// ============================================
// Hub Registration
// ============================================

// Register a root hub (EHCI/XHCI controller)
export fn usb_hub_register_root_hub(num_ports: u8): i32 {
    if hub_count >= USB_HUB_MAX_HUBS {
        foundation.serial_write_string("[USB Hub] Error: Maximum hubs reached\n")
        return -1
    }

    if root_hub_count >= 4 {
        foundation.serial_write_string("[USB Hub] Error: Maximum root hubs reached\n")
        return -1
    }

    let hub_id = hub_count
    hub_count = hub_count + 1

    var hub = &hubs[hub_id]
    hub.is_active = true
    hub.device_address = 0  // Root hub has no address
    hub.parent_hub_id = -1
    hub.parent_port = 0
    hub.depth = 0

    // Set up descriptor
    hub.descriptor.num_ports = num_ports
    hub.descriptor.characteristics = USB_HUB_LPSM_INDIVIDUAL | USB_HUB_OCPM_INDIVIDUAL
    hub.descriptor.power_on_to_power_good = 10  // 20ms
    hub.num_ports = num_ports
    hub.power_good_delay = 20

    // Initialize port states
    var p: u8 = 0
    while p < num_ports {
        hub.ports[p].state = PortState.Powered
        hub.ports[p].is_removable = true
        hub.ports[p].has_power_control = true
        p = p + 1
    }

    hub.is_powered = true
    hub.over_current = false
    hub.local_power_good = true
    hub.is_superspeed = false
    hub.has_tt = false

    root_hubs[root_hub_count] = hub_id
    root_hub_count = root_hub_count + 1

    foundation.serial_write_string("[USB Hub] Registered root hub with ")
    foundation.serial_write_int(num_ports as u32)
    foundation.serial_write_string(" ports (hub ID ")
    foundation.serial_write_int(hub_id)
    foundation.serial_write_string(")\n")

    return hub_id as i32
}

// Register an external hub device
export fn usb_hub_register(device_address: u8, parent_hub_id: i32, parent_port: u8): i32 {
    if hub_count >= USB_HUB_MAX_HUBS {
        foundation.serial_write_string("[USB Hub] Error: Maximum hubs reached\n")
        return -1
    }

    // Check depth limit
    var depth: u8 = 0
    if parent_hub_id >= 0 {
        if parent_hub_id as u32 >= hub_count {
            return -1
        }
        depth = hubs[parent_hub_id as u32].depth + 1
        if depth > USB_HUB_MAX_DEPTH as u8 {
            foundation.serial_write_string("[USB Hub] Error: Maximum hub depth exceeded\n")
            return -1
        }
    }

    let hub_id = hub_count
    hub_count = hub_count + 1

    var hub = &hubs[hub_id]
    hub.is_active = true
    hub.device_address = device_address
    hub.parent_hub_id = parent_hub_id
    hub.parent_port = parent_port
    hub.depth = depth

    // Get hub descriptor
    let result = usb_hub_get_descriptor(hub)
    if result < 0 {
        hub.is_active = false
        hub_count = hub_count - 1
        return -1
    }

    // Calculate power good delay
    hub.power_good_delay = hub.descriptor.power_on_to_power_good as u16 * 2

    // Determine TT support for high-speed hubs
    hub.has_tt = (hub.characteristics & USB_HUB_CHAR_TTTT) != 0
    hub.multi_tt = (hub.characteristics & 0x0003) == 0x0002

    if hub.has_tt {
        hub.tt.hub_address = device_address
        hub.tt.think_time = ((hub.characteristics >> 5) & 0x03) as u8
        hub.tt.multi_tt = hub.multi_tt
    }

    // Power on all ports
    var p: u8 = 0
    while p < hub.num_ports {
        usb_hub_port_power(hub_id, p, true)
        p = p + 1
    }

    // Wait for power good
    usb_hub_delay(hub.power_good_delay as u32)

    // Update parent's child hub reference
    if parent_hub_id >= 0 {
        hubs[parent_hub_id as u32].ports[parent_port].child_hub_id = hub_id as i32
    }

    foundation.serial_write_string("[USB Hub] Registered external hub at address ")
    foundation.serial_write_int(device_address as u32)
    foundation.serial_write_string(" with ")
    foundation.serial_write_int(hub.num_ports as u32)
    foundation.serial_write_string(" ports (depth ")
    foundation.serial_write_int(depth as u32)
    foundation.serial_write_string(")\n")

    return hub_id as i32
}

// ============================================
// Hub Descriptor Operations
// ============================================

fn usb_hub_get_descriptor(hub: *UsbHub): i32 {
    var desc_buffer: [16]u8

    // Build GET_DESCRIPTOR request for hub descriptor
    let request_type: u8 = 0xA0  // Device to host, class, device
    let request: u8 = USB_HUB_REQ_GET_DESCRIPTOR
    let value: u16 = (USB_DT_HUB as u16) << 8
    let index: u16 = 0
    let length: u16 = 16

    // Send control transfer (would use USB driver)
    let result = usb_control_transfer(
        hub.device_address,
        request_type,
        request,
        value,
        index,
        &desc_buffer,
        length
    )

    if result < 0 {
        // Try SuperSpeed hub descriptor
        let ss_value: u16 = (USB_DT_SS_HUB as u16) << 8
        let ss_result = usb_control_transfer(
            hub.device_address,
            request_type,
            request,
            ss_value,
            index,
            &desc_buffer,
            length
        )

        if ss_result < 0 {
            return -1
        }

        hub.is_superspeed = true
        hub.ss_descriptor.length = desc_buffer[0]
        hub.ss_descriptor.descriptor_type = desc_buffer[1]
        hub.ss_descriptor.num_ports = desc_buffer[2]
        hub.ss_descriptor.characteristics = (desc_buffer[4] as u16) << 8 | desc_buffer[3] as u16
        hub.ss_descriptor.power_on_to_power_good = desc_buffer[5]
        hub.ss_descriptor.hub_controller_current = desc_buffer[6]
        hub.ss_descriptor.hub_hdr_dec_lat = desc_buffer[7]
        hub.ss_descriptor.hub_delay = (desc_buffer[9] as u16) << 8 | desc_buffer[8] as u16

        hub.num_ports = hub.ss_descriptor.num_ports
        hub.characteristics = hub.ss_descriptor.characteristics
    } else {
        hub.is_superspeed = false
        hub.descriptor.length = desc_buffer[0]
        hub.descriptor.descriptor_type = desc_buffer[1]
        hub.descriptor.num_ports = desc_buffer[2]
        hub.descriptor.characteristics = (desc_buffer[4] as u16) << 8 | desc_buffer[3] as u16
        hub.descriptor.power_on_to_power_good = desc_buffer[5]
        hub.descriptor.hub_controller_current = desc_buffer[6]

        // Device removable bitmap
        var i: u32 = 0
        while i < 4 and (7 + i) < desc_buffer[0] as u32 {
            hub.descriptor.device_removable[i] = desc_buffer[7 + i]
            i = i + 1
        }

        hub.num_ports = hub.descriptor.num_ports
        hub.characteristics = hub.descriptor.characteristics

        // Parse device removable bitmap
        var p: u8 = 0
        while p < hub.num_ports {
            let byte_idx = (p + 1) / 8
            let bit_idx = (p + 1) % 8
            hub.ports[p].is_removable = (hub.descriptor.device_removable[byte_idx] & (1 << bit_idx)) == 0
            p = p + 1
        }
    }

    // Limit ports
    if hub.num_ports > USB_HUB_MAX_PORTS as u8 {
        hub.num_ports = USB_HUB_MAX_PORTS as u8
    }

    return 0
}

// ============================================
// Hub Status Operations
// ============================================

export fn usb_hub_get_status(hub_id: u32): UsbHubStatus {
    var status: UsbHubStatus
    status.status = 0
    status.change = 0

    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return status
    }

    var hub = &hubs[hub_id]

    var status_buffer: [4]u8
    let result = usb_control_transfer(
        hub.device_address,
        0xA0,  // Device to host, class, device
        USB_HUB_REQ_GET_STATUS,
        0,
        0,
        &status_buffer,
        4
    )

    if result >= 0 {
        status.status = (status_buffer[1] as u16) << 8 | status_buffer[0] as u16
        status.change = (status_buffer[3] as u16) << 8 | status_buffer[2] as u16

        hub.local_power_good = (status.status & USB_HUB_STAT_LOCAL_POWER) == 0
        hub.over_current = (status.status & USB_HUB_STAT_OVER_CURRENT) != 0
    }

    return status
}

export fn usb_hub_clear_hub_feature(hub_id: u32, feature: u16): i32 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return -1
    }

    return usb_control_transfer(
        hubs[hub_id].device_address,
        0x20,  // Host to device, class, device
        USB_HUB_REQ_CLEAR_FEATURE,
        feature,
        0,
        null,
        0
    )
}

// ============================================
// Port Operations
// ============================================

export fn usb_hub_get_port_status(hub_id: u32, port: u8): UsbPortStatus {
    var status: UsbPortStatus
    status.status = 0
    status.change = 0

    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return status
    }
    if port >= hubs[hub_id].num_ports {
        return status
    }

    var hub = &hubs[hub_id]

    var status_buffer: [4]u8
    let result = usb_control_transfer(
        hub.device_address,
        0xA3,  // Device to host, class, other (port)
        USB_HUB_REQ_GET_STATUS,
        0,
        (port + 1) as u16,  // Ports are 1-indexed in USB
        &status_buffer,
        4
    )

    if result >= 0 {
        status.status = (status_buffer[1] as u16) << 8 | status_buffer[0] as u16
        status.change = (status_buffer[3] as u16) << 8 | status_buffer[2] as u16
        hub.ports[port].status = status
    }

    return status
}

export fn usb_hub_set_port_feature(hub_id: u32, port: u8, feature: u16): i32 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return -1
    }
    if port >= hubs[hub_id].num_ports {
        return -1
    }

    return usb_control_transfer(
        hubs[hub_id].device_address,
        0x23,  // Host to device, class, other (port)
        USB_HUB_REQ_SET_FEATURE,
        feature,
        (port + 1) as u16,
        null,
        0
    )
}

export fn usb_hub_clear_port_feature(hub_id: u32, port: u8, feature: u16): i32 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return -1
    }
    if port >= hubs[hub_id].num_ports {
        return -1
    }

    return usb_control_transfer(
        hubs[hub_id].device_address,
        0x23,  // Host to device, class, other (port)
        USB_HUB_REQ_CLEAR_FEATURE,
        feature,
        (port + 1) as u16,
        null,
        0
    )
}

// Port power control
export fn usb_hub_port_power(hub_id: u32, port: u8, power_on: bool): i32 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return -1
    }
    if port >= hubs[hub_id].num_ports {
        return -1
    }

    var hub = &hubs[hub_id]

    if power_on {
        let result = usb_hub_set_port_feature(hub_id, port, USB_PORT_FEAT_POWER)
        if result >= 0 {
            hub.ports[port].state = PortState.Powered
        }
        return result
    } else {
        let result = usb_hub_clear_port_feature(hub_id, port, USB_PORT_FEAT_POWER)
        if result >= 0 {
            hub.ports[port].state = PortState.Disconnected
        }
        return result
    }
}

// Port reset
export fn usb_hub_port_reset(hub_id: u32, port: u8): i32 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return -1
    }
    if port >= hubs[hub_id].num_ports {
        return -1
    }

    var hub = &hubs[hub_id]
    hub.ports[port].state = PortState.Resetting
    hub.ports[port].reset_count = hub.ports[port].reset_count + 1
    hub.total_resets = hub.total_resets + 1

    // Issue reset
    let result = usb_hub_set_port_feature(hub_id, port, USB_PORT_FEAT_RESET)
    if result < 0 {
        hub.ports[port].state = PortState.Error
        hub.ports[port].error_count = hub.ports[port].error_count + 1
        return result
    }

    // Wait for reset to complete (typically 10-50ms)
    usb_hub_delay(50)

    // Check reset status
    let status = usb_hub_get_port_status(hub_id, port)

    if (status.change & USB_PORT_STAT_C_RESET) != 0 {
        // Clear reset change
        usb_hub_clear_port_feature(hub_id, port, USB_PORT_FEAT_C_RESET)

        if (status.status & USB_PORT_STAT_ENABLE) != 0 {
            hub.ports[port].state = PortState.Enabled

            // Determine speed
            if (status.status & USB_PORT_STAT_HIGH_SPEED) != 0 {
                hub.ports[port].speed = USB_SPEED_HIGH
            } else if (status.status & USB_PORT_STAT_LOW_SPEED) != 0 {
                hub.ports[port].speed = USB_SPEED_LOW
            } else {
                hub.ports[port].speed = USB_SPEED_FULL
            }

            foundation.serial_write_string("[USB Hub] Port ")
            foundation.serial_write_int(port as u32)
            foundation.serial_write_string(" reset complete, speed=")
            foundation.serial_write_int(hub.ports[port].speed as u32)
            foundation.serial_write_string("\n")

            return 0
        }
    }

    hub.ports[port].state = PortState.Error
    hub.ports[port].error_count = hub.ports[port].error_count + 1
    return -1
}

// Port suspend
export fn usb_hub_port_suspend(hub_id: u32, port: u8): i32 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return -1
    }
    if port >= hubs[hub_id].num_ports {
        return -1
    }

    let result = usb_hub_set_port_feature(hub_id, port, USB_PORT_FEAT_SUSPEND)
    if result >= 0 {
        hubs[hub_id].ports[port].state = PortState.Suspended
    }
    return result
}

// Port resume
export fn usb_hub_port_resume(hub_id: u32, port: u8): i32 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return -1
    }
    if port >= hubs[hub_id].num_ports {
        return -1
    }

    let result = usb_hub_clear_port_feature(hub_id, port, USB_PORT_FEAT_SUSPEND)
    if result >= 0 {
        // Wait for resume signaling (20ms minimum)
        usb_hub_delay(25)

        // Clear suspend change
        usb_hub_clear_port_feature(hub_id, port, USB_PORT_FEAT_C_SUSPEND)

        hubs[hub_id].ports[port].state = PortState.Enabled
    }
    return result
}

// Port indicator control
export fn usb_hub_port_indicator(hub_id: u32, port: u8, color: u8): i32 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return -1
    }
    if port >= hubs[hub_id].num_ports {
        return -1
    }

    // Check if hub supports port indicators
    if (hubs[hub_id].characteristics & USB_HUB_CHAR_PORTIND) == 0 {
        return -1
    }

    let selector = (color as u16) << 8 | USB_PORT_FEAT_INDICATOR
    return usb_hub_set_port_feature(hub_id, port, selector)
}

// ============================================
// Device Enumeration
// ============================================

export fn usb_hub_enumerate_ports(hub_id: u32): i32 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return -1
    }

    var hub = &hubs[hub_id]
    var devices_found: i32 = 0

    foundation.serial_write_string("[USB Hub] Enumerating hub ")
    foundation.serial_write_int(hub_id)
    foundation.serial_write_string(" ports...\n")

    var port: u8 = 0
    while port < hub.num_ports {
        let status = usb_hub_get_port_status(hub_id, port)

        // Check for connection
        if (status.status & USB_PORT_STAT_CONNECTION) != 0 {
            // Device present
            if hub.ports[port].state == PortState.Disconnected or
               hub.ports[port].state == PortState.Powered {
                // New device - need to reset and enumerate
                let result = usb_hub_enumerate_device(hub_id, port)
                if result >= 0 {
                    devices_found = devices_found + 1
                }
            }
        } else if hub.ports[port].state != PortState.Disconnected {
            // Device was removed
            usb_hub_handle_disconnect(hub_id, port)
        }

        // Clear any change status bits
        if (status.change & USB_PORT_STAT_C_CONNECTION) != 0 {
            usb_hub_clear_port_feature(hub_id, port, USB_PORT_FEAT_C_CONNECTION)
        }
        if (status.change & USB_PORT_STAT_C_ENABLE) != 0 {
            usb_hub_clear_port_feature(hub_id, port, USB_PORT_FEAT_C_ENABLE)
        }
        if (status.change & USB_PORT_STAT_C_OVER_CURRENT) != 0 {
            usb_hub_clear_port_feature(hub_id, port, USB_PORT_FEAT_C_OVER_CURRENT)
        }

        port = port + 1
    }

    return devices_found
}

fn usb_hub_enumerate_device(hub_id: u32, port: u8): i32 {
    var hub = &hubs[hub_id]

    foundation.serial_write_string("[USB Hub] Enumerating device on hub ")
    foundation.serial_write_int(hub_id)
    foundation.serial_write_string(" port ")
    foundation.serial_write_int(port as u32)
    foundation.serial_write_string("\n")

    // Wait for debounce (100ms)
    usb_hub_delay(100)

    // Check still connected
    let status = usb_hub_get_port_status(hub_id, port)
    if (status.status & USB_PORT_STAT_CONNECTION) == 0 {
        foundation.serial_write_string("[USB Hub] Device disconnected during debounce\n")
        return -1
    }

    // Reset port
    let reset_result = usb_hub_port_reset(hub_id, port)
    if reset_result < 0 {
        foundation.serial_write_string("[USB Hub] Port reset failed\n")
        return -1
    }

    // Assign address
    let address = next_device_address
    next_device_address = next_device_address + 1
    if next_device_address > 127 {
        next_device_address = 1
    }

    // Set address via USB control transfer
    let addr_result = usb_set_address(address)
    if addr_result < 0 {
        foundation.serial_write_string("[USB Hub] Failed to set device address\n")
        return -1
    }

    // Wait for address to take effect
    usb_hub_delay(2)

    hub.ports[port].device_address = address
    hub.ports[port].connect_time = usb_hub_get_time()
    hub.total_connects = hub.total_connects + 1

    foundation.serial_write_string("[USB Hub] Device assigned address ")
    foundation.serial_write_int(address as u32)
    foundation.serial_write_string("\n")

    // Get device descriptor to check if it's a hub
    let is_hub = usb_device_is_hub(address)
    if is_hub {
        // Register as sub-hub
        let sub_hub_id = usb_hub_register(address, hub_id as i32, port)
        if sub_hub_id >= 0 {
            hub.ports[port].child_hub_id = sub_hub_id
            // Recursively enumerate sub-hub
            usb_hub_enumerate_ports(sub_hub_id as u32)
        }
    }

    // Notify callback
    if device_callback != null {
        device_callback(hub_id, port, hub.ports[port].speed, address)
    }

    return address as i32
}

fn usb_hub_handle_disconnect(hub_id: u32, port: u8): void {
    var hub = &hubs[hub_id]

    foundation.serial_write_string("[USB Hub] Device disconnected from hub ")
    foundation.serial_write_int(hub_id)
    foundation.serial_write_string(" port ")
    foundation.serial_write_int(port as u32)
    foundation.serial_write_string("\n")

    // If there was a child hub, deactivate it
    if hub.ports[port].child_hub_id >= 0 {
        usb_hub_deactivate(hub.ports[port].child_hub_id as u32)
    }

    // Reset port state
    hub.ports[port].state = PortState.Disconnected
    hub.ports[port].device_address = 0
    hub.ports[port].child_hub_id = -1
    hub.total_disconnects = hub.total_disconnects + 1
}

fn usb_hub_deactivate(hub_id: u32): void {
    if hub_id >= hub_count {
        return
    }

    var hub = &hubs[hub_id]

    // Recursively deactivate child hubs
    var port: u8 = 0
    while port < hub.num_ports {
        if hub.ports[port].child_hub_id >= 0 {
            usb_hub_deactivate(hub.ports[port].child_hub_id as u32)
        }
        port = port + 1
    }

    hub.is_active = false

    foundation.serial_write_string("[USB Hub] Hub ")
    foundation.serial_write_int(hub_id)
    foundation.serial_write_string(" deactivated\n")
}

// ============================================
// Status Change Handling
// ============================================

// Called from USB interrupt handler when hub status change occurs
export fn usb_hub_handle_status_change(hub_id: u32, status_bitmap: u32): void {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return
    }

    var hub = &hubs[hub_id]
    hub.pending_status_change = true
    hub.status_change_bitmap = status_bitmap

    // Bit 0 = hub status change
    // Bits 1-N = port 1-N status change

    if (status_bitmap & 1) != 0 {
        // Hub status changed
        let status = usb_hub_get_status(hub_id)

        if (status.change & USB_HUB_STAT_LOCAL_POWER) != 0 {
            usb_hub_clear_hub_feature(hub_id, USB_HUB_FEAT_C_HUB_LOCAL_POWER)
            foundation.serial_write_string("[USB Hub] Local power change\n")
        }

        if (status.change & USB_HUB_STAT_OVER_CURRENT) != 0 {
            usb_hub_clear_hub_feature(hub_id, USB_HUB_FEAT_C_HUB_OVER_CURRENT)
            foundation.serial_write_string("[USB Hub] Over-current condition!\n")
        }
    }

    // Check each port for changes
    var port: u8 = 0
    while port < hub.num_ports {
        if (status_bitmap & (1 << (port + 1))) != 0 {
            usb_hub_handle_port_change(hub_id, port)
        }
        port = port + 1
    }

    hub.pending_status_change = false
}

fn usb_hub_handle_port_change(hub_id: u32, port: u8): void {
    var hub = &hubs[hub_id]
    let status = usb_hub_get_port_status(hub_id, port)

    // Connection change
    if (status.change & USB_PORT_STAT_C_CONNECTION) != 0 {
        usb_hub_clear_port_feature(hub_id, port, USB_PORT_FEAT_C_CONNECTION)

        if (status.status & USB_PORT_STAT_CONNECTION) != 0 {
            // New connection
            foundation.serial_write_string("[USB Hub] Device connected on port ")
            foundation.serial_write_int(port as u32)
            foundation.serial_write_string("\n")
            usb_hub_enumerate_device(hub_id, port)
        } else {
            // Disconnection
            usb_hub_handle_disconnect(hub_id, port)
        }
    }

    // Enable change (usually indicates error)
    if (status.change & USB_PORT_STAT_C_ENABLE) != 0 {
        usb_hub_clear_port_feature(hub_id, port, USB_PORT_FEAT_C_ENABLE)

        if (status.status & USB_PORT_STAT_ENABLE) == 0 and
           (status.status & USB_PORT_STAT_CONNECTION) != 0 {
            // Port disabled but device still connected - try re-reset
            foundation.serial_write_string("[USB Hub] Port ")
            foundation.serial_write_int(port as u32)
            foundation.serial_write_string(" disabled unexpectedly, attempting reset\n")

            if hub.ports[port].reset_count < 3 {
                usb_hub_port_reset(hub_id, port)
            } else {
                hub.ports[port].state = PortState.Error
                hub.total_errors = hub.total_errors + 1
            }
        }
    }

    // Over-current change
    if (status.change & USB_PORT_STAT_C_OVER_CURRENT) != 0 {
        usb_hub_clear_port_feature(hub_id, port, USB_PORT_FEAT_C_OVER_CURRENT)

        if (status.status & USB_PORT_STAT_OVER_CURRENT) != 0 {
            foundation.serial_write_string("[USB Hub] Over-current on port ")
            foundation.serial_write_int(port as u32)
            foundation.serial_write_string("!\n")
            hub.ports[port].state = PortState.Error
            hub.total_errors = hub.total_errors + 1
        } else {
            // Over-current cleared, try to re-power
            usb_hub_port_power(hub_id, port, true)
        }
    }

    // Suspend change
    if (status.change & USB_PORT_STAT_C_SUSPEND) != 0 {
        usb_hub_clear_port_feature(hub_id, port, USB_PORT_FEAT_C_SUSPEND)

        if (status.status & USB_PORT_STAT_SUSPEND) == 0 {
            // Device woke up
            hub.ports[port].state = PortState.Enabled
        }
    }

    // Reset change
    if (status.change & USB_PORT_STAT_C_RESET) != 0 {
        usb_hub_clear_port_feature(hub_id, port, USB_PORT_FEAT_C_RESET)
    }
}

// ============================================
// Transaction Translator Operations
// ============================================

export fn usb_hub_clear_tt_buffer(hub_id: u32, port: u8, dev_addr: u8, endpoint: u8, ep_type: u8): i32 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return -1
    }

    var hub = &hubs[hub_id]
    if not hub.has_tt {
        return -1
    }

    // Build TT buffer value
    let value: u16 = (endpoint as u16) |
                     ((dev_addr as u16) << 4) |
                     ((ep_type as u16) << 11)

    let index: u16 = if hub.multi_tt { (port + 1) as u16 } else { 1 }

    return usb_control_transfer(
        hub.device_address,
        0x23,  // Host to device, class, other
        USB_HUB_REQ_CLEAR_TT_BUFFER,
        value,
        index,
        null,
        0
    )
}

export fn usb_hub_reset_tt(hub_id: u32, port: u8): i32 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return -1
    }

    if not hubs[hub_id].has_tt {
        return -1
    }

    let index: u16 = if hubs[hub_id].multi_tt { (port + 1) as u16 } else { 1 }

    return usb_control_transfer(
        hubs[hub_id].device_address,
        0x23,
        USB_HUB_REQ_RESET_TT,
        0,
        index,
        null,
        0
    )
}

// ============================================
// Query Functions
// ============================================

export fn usb_hub_get_count(): u32 {
    return hub_count
}

export fn usb_hub_get_root_hub_count(): u32 {
    return root_hub_count
}

export fn usb_hub_is_active(hub_id: u32): bool {
    if hub_id >= hub_count {
        return false
    }
    return hubs[hub_id].is_active
}

export fn usb_hub_get_port_count(hub_id: u32): u8 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return 0
    }
    return hubs[hub_id].num_ports
}

export fn usb_hub_get_port_state(hub_id: u32, port: u8): PortState {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return PortState.Disconnected
    }
    if port >= hubs[hub_id].num_ports {
        return PortState.Disconnected
    }
    return hubs[hub_id].ports[port].state
}

export fn usb_hub_get_port_speed(hub_id: u32, port: u8): u8 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return 0
    }
    if port >= hubs[hub_id].num_ports {
        return 0
    }
    return hubs[hub_id].ports[port].speed
}

export fn usb_hub_get_port_device(hub_id: u32, port: u8): u8 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return 0
    }
    if port >= hubs[hub_id].num_ports {
        return 0
    }
    return hubs[hub_id].ports[port].device_address
}

export fn usb_hub_get_depth(hub_id: u32): u8 {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return 0
    }
    return hubs[hub_id].depth
}

export fn usb_hub_is_superspeed(hub_id: u32): bool {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return false
    }
    return hubs[hub_id].is_superspeed
}

export fn usb_hub_has_tt(hub_id: u32): bool {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return false
    }
    return hubs[hub_id].has_tt
}

export fn usb_hub_get_tt_info(hub_id: u32): TransactionTranslator {
    var tt: TransactionTranslator
    tt.hub_address = 0
    tt.port_number = 0
    tt.think_time = 0
    tt.multi_tt = false

    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return tt
    }

    if hubs[hub_id].has_tt {
        return hubs[hub_id].tt
    }

    return tt
}

// Get TT for a device behind high-speed hubs
export fn usb_hub_find_tt_for_device(hub_id: u32, port: u8): TransactionTranslator {
    var tt: TransactionTranslator
    tt.hub_address = 0
    tt.port_number = 0
    tt.think_time = 0
    tt.multi_tt = false

    if hub_id >= hub_count or not hubs[hub_id].is_active {
        return tt
    }

    var hub = &hubs[hub_id]

    // If this hub has a TT, use it
    if hub.has_tt {
        tt.hub_address = hub.device_address
        tt.port_number = if hub.multi_tt { port } else { 0 }
        tt.think_time = hub.tt.think_time
        tt.multi_tt = hub.multi_tt
        return tt
    }

    // Otherwise, traverse up to find parent with TT
    if hub.parent_hub_id >= 0 {
        return usb_hub_find_tt_for_device(hub.parent_hub_id as u32, hub.parent_port)
    }

    return tt
}

// ============================================
// Statistics
// ============================================

export fn usb_hub_get_stats(hub_id: u32, connects: *u32, disconnects: *u32, resets: *u32, errors: *u32): void {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        *connects = 0
        *disconnects = 0
        *resets = 0
        *errors = 0
        return
    }

    *connects = hubs[hub_id].total_connects
    *disconnects = hubs[hub_id].total_disconnects
    *resets = hubs[hub_id].total_resets
    *errors = hubs[hub_id].total_errors
}

export fn usb_hub_print_info(hub_id: u32): void {
    if hub_id >= hub_count or not hubs[hub_id].is_active {
        foundation.serial_write_string("[USB Hub] Invalid hub ID\n")
        return
    }

    var hub = &hubs[hub_id]

    foundation.serial_write_string("USB Hub ")
    foundation.serial_write_int(hub_id)
    foundation.serial_write_string(":\n")

    foundation.serial_write_string("  Address: ")
    foundation.serial_write_int(hub.device_address as u32)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  Ports: ")
    foundation.serial_write_int(hub.num_ports as u32)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  Depth: ")
    foundation.serial_write_int(hub.depth as u32)
    foundation.serial_write_string("\n")

    if hub.is_superspeed {
        foundation.serial_write_string("  Type: SuperSpeed\n")
    } else if hub.has_tt {
        if hub.multi_tt {
            foundation.serial_write_string("  Type: High-Speed Multi-TT\n")
        } else {
            foundation.serial_write_string("  Type: High-Speed Single-TT\n")
        }
    } else {
        foundation.serial_write_string("  Type: Full-Speed\n")
    }

    foundation.serial_write_string("  Power good delay: ")
    foundation.serial_write_int(hub.power_good_delay as u32)
    foundation.serial_write_string("ms\n")

    foundation.serial_write_string("  Connected devices: ")
    var connected: u32 = 0
    var p: u8 = 0
    while p < hub.num_ports {
        if hub.ports[p].state == PortState.Enabled {
            connected = connected + 1
        }
        p = p + 1
    }
    foundation.serial_write_int(connected)
    foundation.serial_write_string("\n")
}

// ============================================
// Helper Functions
// ============================================

fn usb_hub_delay(ms: u32): void {
    // Would use kernel timer
    var i: u32 = 0
    while i < ms * 1000 {
        i = i + 1
    }
}

fn usb_hub_get_time(): u64 {
    // Would use kernel timer
    return 0
}

// Stubs for USB layer functions (would be in usb.home)
fn usb_control_transfer(address: u8, request_type: u8, request: u8, value: u16, index: u16, data: *u8, length: u16): i32 {
    // Would call actual USB driver
    return 0
}

fn usb_set_address(address: u8): i32 {
    // Would call actual USB driver
    return 0
}

fn usb_device_is_hub(address: u8): bool {
    // Would check device descriptor class
    return false
}
