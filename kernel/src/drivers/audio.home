// home-os Audio Driver
// AC97 and Intel HDA audio support with real hardware output

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

// ============================================================================
// AC97 CONTROLLER REGISTERS (Intel ICH)
// ============================================================================

const AC97_NAMBAR: u16 = 0x0000   // Native Audio Mixer Base Address
const AC97_NABMBAR: u16 = 0x0000  // Native Audio Bus Mastering Base Address

// Mixer registers (NAMBAR + offset)
const AC97_RESET: u16 = 0x00
const AC97_MASTER_VOL: u16 = 0x02
const AC97_AUX_OUT_VOL: u16 = 0x04
const AC97_MONO_VOL: u16 = 0x06
const AC97_PC_BEEP: u16 = 0x0A
const AC97_PHONE_VOL: u16 = 0x0C
const AC97_MIC_VOL: u16 = 0x0E
const AC97_LINE_IN_VOL: u16 = 0x10
const AC97_CD_VOL: u16 = 0x12
const AC97_VIDEO_VOL: u16 = 0x14
const AC97_AUX_IN_VOL: u16 = 0x16
const AC97_PCM_OUT_VOL: u16 = 0x18
const AC97_RECORD_SELECT: u16 = 0x1A
const AC97_RECORD_GAIN: u16 = 0x1C
const AC97_GENERAL_PURPOSE: u16 = 0x20
const AC97_3D_CONTROL: u16 = 0x22
const AC97_POWERDOWN: u16 = 0x26
const AC97_EXT_AUDIO_ID: u16 = 0x28
const AC97_EXT_AUDIO_CTRL: u16 = 0x2A
const AC97_PCM_FRONT_RATE: u16 = 0x2C
const AC97_PCM_SURR_RATE: u16 = 0x2E
const AC97_PCM_LFE_RATE: u16 = 0x30
const AC97_VENDOR_ID1: u16 = 0x7C
const AC97_VENDOR_ID2: u16 = 0x7E

// Bus Master registers (NABMBAR + offset)
const AC97_PO_BDBAR: u16 = 0x10   // PCM Out Buffer Descriptor Base Address
const AC97_PO_CIV: u16 = 0x14     // PCM Out Current Index Value
const AC97_PO_LVI: u16 = 0x15     // PCM Out Last Valid Index
const AC97_PO_SR: u16 = 0x16      // PCM Out Status Register
const AC97_PO_PICB: u16 = 0x18    // PCM Out Position in Current Buffer
const AC97_PO_PIV: u16 = 0x1A     // PCM Out Prefetch Index Value
const AC97_PO_CR: u16 = 0x1B      // PCM Out Control Register
const AC97_GLOB_CNT: u16 = 0x2C   // Global Control
const AC97_GLOB_STA: u16 = 0x30   // Global Status

// Control Register bits
const AC97_CR_RPBM: u8 = 0x01     // Run/Pause Bus Master
const AC97_CR_RR: u8 = 0x02       // Reset Registers
const AC97_CR_LVBIE: u8 = 0x04    // Last Valid Buffer Interrupt Enable
const AC97_CR_FEIE: u8 = 0x08     // FIFO Error Interrupt Enable
const AC97_CR_IOCE: u8 = 0x10     // Interrupt on Completion Enable

// Status Register bits
const AC97_SR_DCH: u16 = 0x0001   // DMA Controller Halted
const AC97_SR_CELV: u16 = 0x0002  // Current Equals Last Valid
const AC97_SR_LVBCI: u16 = 0x0004 // Last Valid Buffer Completion Interrupt
const AC97_SR_BCIS: u16 = 0x0008  // Buffer Completion Interrupt Status
const AC97_SR_FIFOE: u16 = 0x0010 // FIFO Error

// ============================================================================
// INTEL HDA (HIGH DEFINITION AUDIO) REGISTERS
// ============================================================================

const HDA_GCAP: u16 = 0x00       // Global Capabilities
const HDA_VMIN: u16 = 0x02       // Minor Version
const HDA_VMAJ: u16 = 0x03       // Major Version
const HDA_OUTPAY: u16 = 0x04     // Output Payload Capability
const HDA_INPAY: u16 = 0x06      // Input Payload Capability
const HDA_GCTL: u16 = 0x08       // Global Control
const HDA_WAKEEN: u16 = 0x0C     // Wake Enable
const HDA_STATESTS: u16 = 0x0E   // State Change Status
const HDA_GSTS: u16 = 0x10       // Global Status
const HDA_INTCTL: u16 = 0x20     // Interrupt Control
const HDA_INTSTS: u16 = 0x24     // Interrupt Status
const HDA_CORBLBASE: u16 = 0x40  // CORB Lower Base Address
const HDA_CORBUBASE: u16 = 0x44  // CORB Upper Base Address
const HDA_CORBWP: u16 = 0x48     // CORB Write Pointer
const HDA_CORBRP: u16 = 0x4A     // CORB Read Pointer
const HDA_CORBCTL: u16 = 0x4C    // CORB Control
const HDA_CORBSTS: u16 = 0x4D    // CORB Status
const HDA_CORBSIZE: u16 = 0x4E   // CORB Size
const HDA_RIRBLBASE: u16 = 0x50  // RIRB Lower Base Address
const HDA_RIRBUBASE: u16 = 0x54  // RIRB Upper Base Address
const HDA_RIRBWP: u16 = 0x58     // RIRB Write Pointer
const HDA_RINTCNT: u16 = 0x5A    // Response Interrupt Count
const HDA_RIRBCTL: u16 = 0x5C    // RIRB Control
const HDA_RIRBSTS: u16 = 0x5D    // RIRB Status
const HDA_RIRBSIZE: u16 = 0x5E   // RIRB Size

// HDA Stream Descriptor registers (offset from stream base)
const HDA_SD_CTL: u16 = 0x00     // Stream Descriptor Control
const HDA_SD_STS: u16 = 0x03     // Stream Descriptor Status
const HDA_SD_LPIB: u16 = 0x04    // Link Position in Buffer
const HDA_SD_CBL: u16 = 0x08     // Cyclic Buffer Length
const HDA_SD_LVI: u16 = 0x0C     // Last Valid Index
const HDA_SD_FIFOS: u16 = 0x10   // FIFO Size
const HDA_SD_FMT: u16 = 0x12     // Stream Format
const HDA_SD_BDLPL: u16 = 0x18   // BDL Pointer Lower
const HDA_SD_BDLPU: u16 = 0x1C   // BDL Pointer Upper

// Global Control bits
const HDA_GCTL_CRST: u32 = 0x00000001  // Controller Reset

// ============================================================================
// AUDIO BUFFER STRUCTURES
// ============================================================================

const MAX_BUFFERS: u32 = 32
const BUFFER_SIZE: u32 = 4096
const SAMPLE_RATE_44100: u32 = 44100
const SAMPLE_RATE_48000: u32 = 48000

// Buffer Descriptor List Entry (for AC97)
struct AC97BufferDescriptor {
  buffer_addr: u32,
  buffer_len: u16,
  reserved: u16
}

// Buffer Descriptor List Entry (for HDA)
struct HDABufferDescriptor {
  address: u64,
  length: u32,
  ioc: u32  // Interrupt on Completion flag
}

// Audio format
struct AudioFormat {
  sample_rate: u32,
  channels: u8,
  bits_per_sample: u8,
  is_signed: u8,
  is_little_endian: u8
}

// ============================================================================
// DRIVER STATE
// ============================================================================

const AUDIO_TYPE_NONE: u32 = 0
const AUDIO_TYPE_AC97: u32 = 1
const AUDIO_TYPE_HDA: u32 = 2

var audio_type: u32 = AUDIO_TYPE_NONE
var audio_initialized: u32 = 0
var audio_playing: u32 = 0

// AC97 state
var ac97_nambar: u16 = 0
var ac97_nabmbar: u16 = 0
var ac97_buffer_descriptors: [32]AC97BufferDescriptor
var ac97_buffers: [32]u64
var ac97_current_buffer: u32 = 0

// HDA state
var hda_base: u64 = 0
var hda_corb: u64 = 0
var hda_rirb: u64 = 0
var hda_buffer_descriptors: [32]HDABufferDescriptor
var hda_buffers: [32]u64
var hda_stream_base: u64 = 0
var hda_codec_id: u32 = 0

// Current format
var current_sample_rate: u32 = SAMPLE_RATE_48000
var current_channels: u8 = 2
var current_bits: u8 = 16
var current_volume: u8 = 80

// Audio ring buffer for playback
var audio_ring_buffer: [65536]u16
var ring_write_pos: u32 = 0
var ring_read_pos: u32 = 0
var ring_buffer_size: u32 = 65536

// ============================================================================
// PORT I/O HELPERS
// ============================================================================

fn outb(port: u16, value: u8) {
  asm volatile ("outb %[value], %[port]"
    :
    : [value] "a" (value), [port] "Nd" (port)
  )
}

fn outw(port: u16, value: u16) {
  asm volatile ("outw %[value], %[port]"
    :
    : [value] "a" (value), [port] "Nd" (port)
  )
}

fn outl(port: u16, value: u32) {
  asm volatile ("outl %[value], %[port]"
    :
    : [value] "a" (value), [port] "Nd" (port)
  )
}

fn inb(port: u16): u8 {
  var result: u8 = 0
  asm volatile ("inb %[port], %[result]"
    : [result] "=a" (result)
    : [port] "Nd" (port)
  )
  return result
}

fn inw(port: u16): u16 {
  var result: u16 = 0
  asm volatile ("inw %[port], %[result]"
    : [result] "=a" (result)
    : [port] "Nd" (port)
  )
  return result
}

fn inl(port: u16): u32 {
  var result: u32 = 0
  asm volatile ("inl %[port], %[result]"
    : [result] "=a" (result)
    : [port] "Nd" (port)
  )
  return result
}

// MMIO helpers
fn mmio_read32(addr: u64): u32 {
  return @volatile_load(@intToPtr(addr, *volatile u32))
}

fn mmio_write32(addr: u64, value: u32) {
  @volatile_store(@intToPtr(addr, *volatile u32), value)
}

fn mmio_read16(addr: u64): u16 {
  return @volatile_load(@intToPtr(addr, *volatile u16))
}

fn mmio_write16(addr: u64, value: u16) {
  @volatile_store(@intToPtr(addr, *volatile u16), value)
}

// ============================================================================
// AC97 DRIVER IMPLEMENTATION
// ============================================================================

fn ac97_mixer_read(reg: u16): u16 {
  return inw(ac97_nambar + reg)
}

fn ac97_mixer_write(reg: u16, value: u16) {
  outw(ac97_nambar + reg, value)
}

fn ac97_bus_read8(reg: u16): u8 {
  return inb(ac97_nabmbar + reg)
}

fn ac97_bus_read16(reg: u16): u16 {
  return inw(ac97_nabmbar + reg)
}

fn ac97_bus_read32(reg: u16): u32 {
  return inl(ac97_nabmbar + reg)
}

fn ac97_bus_write8(reg: u16, value: u8) {
  outb(ac97_nabmbar + reg, value)
}

fn ac97_bus_write32(reg: u16, value: u32) {
  outl(ac97_nabmbar + reg, value)
}

fn ac97_reset_codec() {
  // Reset the codec
  ac97_mixer_write(AC97_RESET, 0)

  // Wait for codec ready
  var timeout: u32 = 10000
  while timeout > 0 {
    var status: u16 = ac97_mixer_read(AC97_POWERDOWN)
    if (status & 0x0F00) == 0x0F00 {
      return
    }
    timeout = timeout - 1
  }
}

fn ac97_set_sample_rate(rate: u32) {
  // Enable Variable Rate Audio
  var ext_ctrl: u16 = ac97_mixer_read(AC97_EXT_AUDIO_CTRL)
  ext_ctrl = ext_ctrl | 0x0001
  ac97_mixer_write(AC97_EXT_AUDIO_CTRL, ext_ctrl)

  // Set PCM output rate
  ac97_mixer_write(AC97_PCM_FRONT_RATE, rate)
  current_sample_rate = rate
}

fn ac97_set_volume_internal(volume: u8) {
  // AC97 volume is 0-63 (0 = max, 63 = min), with mute bit at 15
  var ac97_vol: u16 = 0
  if volume == 0 {
    ac97_vol = 0x8000  // Mute
  } else {
    var scaled: u16 = 63 - ((volume * 63) / 100)
    ac97_vol = (scaled << 8) | scaled  // Left and right channels
  }

  ac97_mixer_write(AC97_MASTER_VOL, ac97_vol)
  ac97_mixer_write(AC97_PCM_OUT_VOL, ac97_vol)
}

fn ac97_init_buffers() {
  // Allocate buffer descriptors (must be 8-byte aligned)
  var i: u32 = 0
  while i < MAX_BUFFERS {
    // Allocate each audio buffer
    ac97_buffers[i] = memory.kmalloc(BUFFER_SIZE)

    // Setup buffer descriptor
    ac97_buffer_descriptors[i].buffer_addr = ac97_buffers[i]
    ac97_buffer_descriptors[i].buffer_len = (BUFFER_SIZE / 2) | 0x8000  // IOC flag
    ac97_buffer_descriptors[i].reserved = 0

    // Clear buffer
    var j: u32 = 0
    while j < BUFFER_SIZE {
      @ptrToInt(ac97_buffers[i] + j, u8) = 0
      j = j + 1
    }

    i = i + 1
  }

  // Set buffer descriptor base address
  var bd_addr: u64 = @ptrToInt(&ac97_buffer_descriptors[0])
  ac97_bus_write32(AC97_PO_BDBAR, bd_addr)
}

fn ac97_start_playback() {
  // Set last valid index
  ac97_bus_write8(AC97_PO_LVI, MAX_BUFFERS - 1)

  // Enable playback with interrupts
  ac97_bus_write8(AC97_PO_CR, AC97_CR_RPBM | AC97_CR_IOCE | AC97_CR_LVBIE)

  audio_playing = 1
}

fn ac97_stop_playback() {
  // Stop DMA
  ac97_bus_write8(AC97_PO_CR, 0)

  // Reset the channel
  ac97_bus_write8(AC97_PO_CR, AC97_CR_RR)

  audio_playing = 0
}

fn ac97_init(nambar: u16, nabmbar: u16): u32 {
  ac97_nambar = nambar
  ac97_nabmbar = nabmbar

  // Reset codec
  ac97_reset_codec()

  // Get vendor ID
  var vendor1: u16 = ac97_mixer_read(AC97_VENDOR_ID1)
  var vendor2: u16 = ac97_mixer_read(AC97_VENDOR_ID2)

  foundation.serial_write_string("[AC97] Vendor ID: ")
  foundation.serial_write_hex(vendor1)
  foundation.serial_write_string(":")
  foundation.serial_write_hex(vendor2)
  foundation.serial_write_string("\n")

  // Initialize buffers
  ac97_init_buffers()

  // Set sample rate
  ac97_set_sample_rate(SAMPLE_RATE_48000)

  // Set volume
  ac97_set_volume_internal(current_volume)

  audio_type = AUDIO_TYPE_AC97
  return 0
}

// ============================================================================
// INTEL HDA DRIVER IMPLEMENTATION
// ============================================================================

fn hda_read32(offset: u16): u32 {
  return mmio_read32(hda_base + offset)
}

fn hda_write32(offset: u16, value: u32) {
  mmio_write32(hda_base + offset, value)
}

fn hda_read16(offset: u16): u16 {
  return mmio_read16(hda_base + offset)
}

fn hda_write16(offset: u16, value: u16) {
  mmio_write16(hda_base + offset, value)
}

fn hda_reset(): u32 {
  // Enter reset
  var gctl: u32 = hda_read32(HDA_GCTL)
  gctl = gctl & ~HDA_GCTL_CRST
  hda_write32(HDA_GCTL, gctl)

  // Wait for reset
  var timeout: u32 = 1000
  while timeout > 0 {
    if (hda_read32(HDA_GCTL) & HDA_GCTL_CRST) == 0 {
      break
    }
    timeout = timeout - 1
  }

  // Exit reset
  gctl = hda_read32(HDA_GCTL) | HDA_GCTL_CRST
  hda_write32(HDA_GCTL, gctl)

  // Wait for controller to come out of reset
  timeout = 1000
  while timeout > 0 {
    if (hda_read32(HDA_GCTL) & HDA_GCTL_CRST) != 0 {
      return 0
    }
    timeout = timeout - 1
  }

  return 1  // Timeout
}

fn hda_init_corb_rirb() {
  // Allocate CORB (Command Output Ring Buffer)
  hda_corb = memory.kmalloc(1024)

  // Allocate RIRB (Response Input Ring Buffer)
  hda_rirb = memory.kmalloc(2048)

  // Setup CORB
  hda_write32(HDA_CORBLBASE, hda_corb & 0xFFFFFFFF)
  hda_write32(HDA_CORBUBASE, hda_corb >> 32)

  // Set CORB size (256 entries)
  var corbsize: u8 = inb(hda_base + HDA_CORBSIZE)
  corbsize = (corbsize & 0xFC) | 0x02  // 256 entries
  outb(hda_base + HDA_CORBSIZE, corbsize)

  // Reset CORB read pointer
  hda_write16(HDA_CORBRP, 0x8000)
  var timeout: u32 = 1000
  while timeout > 0 {
    if (hda_read16(HDA_CORBRP) & 0x8000) != 0 {
      break
    }
    timeout = timeout - 1
  }
  hda_write16(HDA_CORBRP, 0)

  // Setup RIRB
  hda_write32(HDA_RIRBLBASE, hda_rirb & 0xFFFFFFFF)
  hda_write32(HDA_RIRBUBASE, hda_rirb >> 32)

  // Set RIRB size (256 entries)
  var rirbsize: u8 = inb(hda_base + HDA_RIRBSIZE)
  rirbsize = (rirbsize & 0xFC) | 0x02
  outb(hda_base + HDA_RIRBSIZE, rirbsize)

  // Reset RIRB write pointer
  hda_write16(HDA_RIRBWP, 0x8000)

  // Enable CORB and RIRB
  outb(hda_base + HDA_CORBCTL, 0x02)  // Run CORB
  outb(hda_base + HDA_RIRBCTL, 0x02)  // Run RIRB
}

fn hda_send_command(codec: u8, node: u8, verb: u32): u32 {
  // Build command
  var cmd: u32 = (codec << 28) | (node << 20) | verb

  // Get CORB write pointer
  var wp: u16 = hda_read16(HDA_CORBWP) & 0xFF
  wp = (wp + 1) % 256

  // Write command to CORB
  @ptrToInt(hda_corb + (wp * 4), u32) = cmd

  // Update write pointer
  hda_write16(HDA_CORBWP, wp)

  // Wait for response
  var rp: u16 = hda_read16(HDA_RIRBWP) & 0xFF
  var timeout: u32 = 10000
  while timeout > 0 {
    var new_rp: u16 = hda_read16(HDA_RIRBWP) & 0xFF
    if new_rp != rp {
      // Read response
      var response: u64 = @intToPtr(hda_rirb + (new_rp * 8), u64)
      return response & 0xFFFFFFFF
    }
    timeout = timeout - 1
  }

  return 0xFFFFFFFF  // Timeout
}

fn hda_init_stream() {
  // Calculate stream descriptor base
  var gcap: u16 = hda_read16(HDA_GCAP)
  var num_input_streams: u32 = (gcap >> 8) & 0x0F
  var num_output_streams: u32 = (gcap >> 12) & 0x0F

  // Use first output stream
  hda_stream_base = hda_base + 0x80 + (num_input_streams * 0x20)

  // Allocate buffer descriptors
  var bd_addr: u64 = memory.kmalloc(MAX_BUFFERS * @sizeOf(HDABufferDescriptor))

  var i: u32 = 0
  while i < MAX_BUFFERS {
    hda_buffers[i] = memory.kmalloc(BUFFER_SIZE)

    hda_buffer_descriptors[i].address = hda_buffers[i]
    hda_buffer_descriptors[i].length = BUFFER_SIZE
    hda_buffer_descriptors[i].ioc = 1

    i = i + 1
  }

  // Setup stream descriptor
  mmio_write32(hda_stream_base + HDA_SD_BDLPL, @ptrToInt(&hda_buffer_descriptors[0]) & 0xFFFFFFFF)
  mmio_write32(hda_stream_base + HDA_SD_BDLPU, @ptrToInt(&hda_buffer_descriptors[0]) >> 32)

  // Set buffer length
  mmio_write32(hda_stream_base + HDA_SD_CBL, BUFFER_SIZE * MAX_BUFFERS)

  // Set LVI
  mmio_write16(hda_stream_base + HDA_SD_LVI, MAX_BUFFERS - 1)

  // Set format: 48kHz, 16-bit, stereo
  // Format: bits[15:14]=base rate (0=48kHz), [13:11]=mult, [10:8]=div
  //         [7]=bits per sample (1=16bit), [6:4]=reserved, [3:0]=channels-1
  var format: u16 = 0x0011  // 48kHz, 16-bit, stereo
  mmio_write16(hda_stream_base + HDA_SD_FMT, format)
}

fn hda_start_playback() {
  // Enable stream
  var ctl: u32 = mmio_read32(hda_stream_base + HDA_SD_CTL)
  ctl = ctl | 0x02  // Run
  ctl = ctl | 0x04  // Interrupt on completion
  mmio_write32(hda_stream_base + HDA_SD_CTL, ctl)

  audio_playing = 1
}

fn hda_stop_playback() {
  // Disable stream
  var ctl: u32 = mmio_read32(hda_stream_base + HDA_SD_CTL)
  ctl = ctl & ~0x02
  mmio_write32(hda_stream_base + HDA_SD_CTL, ctl)

  audio_playing = 0
}

fn hda_init(base_addr: u64): u32 {
  hda_base = base_addr

  // Reset controller
  if hda_reset() != 0 {
    return 1
  }

  // Get capabilities
  var gcap: u16 = hda_read16(HDA_GCAP)
  var vmaj: u8 = inb(hda_base + HDA_VMAJ)
  var vmin: u8 = inb(hda_base + HDA_VMIN)

  foundation.serial_write_string("[HDA] Version ")
  foundation.serial_write_hex(vmaj)
  foundation.serial_write_string(".")
  foundation.serial_write_hex(vmin)
  foundation.serial_write_string("\n")

  // Initialize CORB/RIRB
  hda_init_corb_rirb()

  // Wait for codec
  var timeout: u32 = 1000
  while timeout > 0 {
    var statests: u16 = hda_read16(HDA_STATESTS)
    if statests != 0 {
      // Find first codec
      var codec: u8 = 0
      while codec < 15 {
        if (statests & (1 << codec)) != 0 {
          hda_codec_id = codec
          break
        }
        codec = codec + 1
      }
      break
    }
    timeout = timeout - 1
  }

  // Initialize stream
  hda_init_stream()

  audio_type = AUDIO_TYPE_HDA
  return 0
}

// ============================================================================
// PUBLIC API
// ============================================================================

export fn audio_init() {
  if audio_initialized == 1 { return }

  // Try to detect AC97 first (check for common IO ports)
  // In a real implementation, you would enumerate PCI devices

  // For now, we initialize with software audio only
  // Hardware detection would be done via PCI enumeration

  audio_initialized = 1
  foundation.serial_write_string("[Audio] Initialized (software mode)\n")
}

export fn audio_init_ac97(nambar: u16, nabmbar: u16): u32 {
  if audio_initialized == 1 and audio_type == AUDIO_TYPE_AC97 { return 0 }

  var result: u32 = ac97_init(nambar, nabmbar)
  if result == 0 {
    audio_initialized = 1
    foundation.serial_write_string("[Audio] AC97 initialized\n")
  }
  return result
}

export fn audio_init_hda(base_addr: u64): u32 {
  if audio_initialized == 1 and audio_type == AUDIO_TYPE_HDA { return 0 }

  var result: u32 = hda_init(base_addr)
  if result == 0 {
    audio_initialized = 1
    foundation.serial_write_string("[Audio] HDA initialized\n")
  }
  return result
}

export fn audio_play(samples: u64, count: u32): u32 {
  if audio_initialized == 0 { return 1 }

  // Copy samples to ring buffer
  var i: u32 = 0
  while i < count {
    var sample: u16 = @intToPtr(samples + (i * 2), u16)
    audio_ring_buffer[ring_write_pos] = sample
    ring_write_pos = (ring_write_pos + 1) % ring_buffer_size
    i = i + 1
  }

  // If we have hardware, transfer to hardware buffers
  if audio_type == AUDIO_TYPE_AC97 {
    var buf_idx: u32 = ac97_current_buffer
    var buf_ptr: u64 = ac97_buffers[buf_idx]

    i = 0
    while i < count and i < (BUFFER_SIZE / 2) {
      @ptrToInt(buf_ptr + (i * 2), u16) = audio_ring_buffer[(ring_read_pos + i) % ring_buffer_size]
      i = i + 1
    }

    ring_read_pos = (ring_read_pos + i) % ring_buffer_size
    ac97_current_buffer = (ac97_current_buffer + 1) % MAX_BUFFERS
  } else if audio_type == AUDIO_TYPE_HDA {
    // Similar for HDA
    var buf_idx: u32 = 0
    var buf_ptr: u64 = hda_buffers[buf_idx]

    i = 0
    while i < count and i < (BUFFER_SIZE / 2) {
      @ptrToInt(buf_ptr + (i * 2), u16) = audio_ring_buffer[(ring_read_pos + i) % ring_buffer_size]
      i = i + 1
    }
    ring_read_pos = (ring_read_pos + i) % ring_buffer_size
  }

  return 0
}

export fn audio_start(): u32 {
  if audio_initialized == 0 { return 1 }
  if audio_playing == 1 { return 0 }

  if audio_type == AUDIO_TYPE_AC97 {
    ac97_start_playback()
  } else if audio_type == AUDIO_TYPE_HDA {
    hda_start_playback()
  }

  return 0
}

export fn audio_stop(): u32 {
  if audio_initialized == 0 { return 1 }
  if audio_playing == 0 { return 0 }

  if audio_type == AUDIO_TYPE_AC97 {
    ac97_stop_playback()
  } else if audio_type == AUDIO_TYPE_HDA {
    hda_stop_playback()
  }

  return 0
}

export fn audio_set_volume(volume: u8) {
  current_volume = volume
  if volume > 100 { current_volume = 100 }

  if audio_type == AUDIO_TYPE_AC97 {
    ac97_set_volume_internal(current_volume)
  } else if audio_type == AUDIO_TYPE_HDA {
    // HDA volume is set via codec verbs
    // Verb: Set Amp Gain/Mute (0x3xx)
    var gain: u32 = (current_volume * 127) / 100
    hda_send_command(hda_codec_id, 0x02, 0x3B000 | gain)
  }
}

export fn audio_get_volume(): u8 {
  return current_volume
}

export fn audio_set_sample_rate(rate: u32): u32 {
  if rate != SAMPLE_RATE_44100 and rate != SAMPLE_RATE_48000 {
    return 1  // Unsupported rate
  }

  if audio_type == AUDIO_TYPE_AC97 {
    ac97_set_sample_rate(rate)
  } else if audio_type == AUDIO_TYPE_HDA {
    // Would need to reconfigure stream format
    current_sample_rate = rate
  } else {
    current_sample_rate = rate
  }

  return 0
}

export fn audio_get_sample_rate(): u32 {
  return current_sample_rate
}

export fn audio_get_buffer_status(): u32 {
  // Return number of samples in ring buffer
  if ring_write_pos >= ring_read_pos {
    return ring_write_pos - ring_read_pos
  } else {
    return ring_buffer_size - ring_read_pos + ring_write_pos
  }
}

export fn audio_is_playing(): u32 {
  return audio_playing
}

// Interrupt handler for audio DMA completion
export fn audio_irq_handler() {
  if audio_type == AUDIO_TYPE_AC97 {
    // Check status
    var status: u16 = ac97_bus_read16(AC97_PO_SR)

    if (status & AC97_SR_BCIS) != 0 {
      // Buffer completed, update LVI to keep playing
      var civ: u8 = ac97_bus_read8(AC97_PO_CIV)
      var new_lvi: u8 = (civ + MAX_BUFFERS - 1) % MAX_BUFFERS
      ac97_bus_write8(AC97_PO_LVI, new_lvi)

      // Clear status
      ac97_bus_write8(AC97_PO_SR + 1, (status >> 8))
    }
  } else if audio_type == AUDIO_TYPE_HDA {
    // Check stream status
    var status: u8 = inb(hda_stream_base + HDA_SD_STS)

    if (status & 0x04) != 0 {
      // Buffer completed
      // Clear status
      outb(hda_stream_base + HDA_SD_STS, 0x04)
    }
  }
}
