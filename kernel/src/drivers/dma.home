// home-os DMA Controller
// Direct Memory Access

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

const DMA_CHANNELS: u32 = 8

const DMA_MODE_READ: u8 = 0x44
const DMA_MODE_WRITE: u8 = 0x48

struct DmaChannel {
  in_use: u32,
  buffer: u64,
  size: u32
}

var dma_channels: [DmaChannel; 8]

export fn dma_init() {
  var i: u32 = 0
  while i < DMA_CHANNELS {
    dma_channels[i].in_use = 0
    i = i + 1
  }
  foundation.serial_write_string("[DMA] Initialized\n")
}

export fn dma_allocate_channel(): u32 {
  var i: u32 = 0
  while i < DMA_CHANNELS {
    if dma_channels[i].in_use == 0 {
      dma_channels[i].in_use = 1
      return i
    }
    i = i + 1
  }
  return 0xFFFFFFFF
}

export fn dma_free_channel(channel: u32) {
  if channel < DMA_CHANNELS {
    dma_channels[channel].in_use = 0
  }
}

export fn dma_setup_transfer(channel: u32, buffer: u64, size: u32, mode: u8) {
  if channel >= DMA_CHANNELS { return }
  
  dma_channels[channel].buffer = buffer
  dma_channels[channel].size = size
  
  var page: u8 = (buffer >> 16) & 0xFF
  var offset: u16 = buffer & 0xFFFF
  var count: u16 = size - 1
  
  // Mask channel
  foundation.outb(0x0A, 0x04 | channel)
  
  // Clear flip-flop
  foundation.outb(0x0C, 0)
  
  // Set mode
  foundation.outb(0x0B, mode | channel)
  
  // Set address
  foundation.outb(0x00 + (channel * 2), offset & 0xFF)
  foundation.outb(0x00 + (channel * 2), (offset >> 8) & 0xFF)
  
  // Set count
  foundation.outb(0x01 + (channel * 2), count & 0xFF)
  foundation.outb(0x01 + (channel * 2), (count >> 8) & 0xFF)
  
  // Set page
  foundation.outb(0x87, page)
  
  // Unmask channel
  foundation.outb(0x0A, channel)
}

export fn dma_start_transfer(channel: u32) {
  if channel >= DMA_CHANNELS { return }
  foundation.outb(0x0A, channel)
}
