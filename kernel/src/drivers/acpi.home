// home-os ACPI Driver
// Advanced Configuration and Power Interface

import "../core/foundation.home" as foundation

struct ACPISDTHeader {
  signature: [u8; 4],
  length: u32,
  revision: u8,
  checksum: u8,
  oem_id: [u8; 6],
  oem_table_id: [u8; 8],
  oem_revision: u32,
  creator_id: u32,
  creator_revision: u32
}

struct RSDP {
  signature: [u8; 8],
  checksum: u8,
  oem_id: [u8; 6],
  revision: u8,
  rsdt_address: u32
}

var acpi_initialized: u32 = 0
var rsdt_address: u64 = 0

fn acpi_find_rsdp() -> u64 {
  // Search EBDA
  var ebda: u64 = 0x000E0000
  var i: u64 = 0
  
  while i < 0x20000 {
    var sig: u64 = @intToPtr(ebda + i, u64)
    if sig == 0x2052545020445352 {  // "RSD PTR "
      return ebda + i
    }
    i = i + 16
  }
  
  return 0
}

export fn acpi_init() {
  if acpi_initialized == 1 { return }
  
  var rsdp_addr: u64 = acpi_find_rsdp()
  if rsdp_addr == 0 {
    foundation.serial_write_string("[ACPI] RSDP not found\n")
    return
  }
  
  var rsdp: RSDP = @intToPtr(rsdp_addr, RSDP)
  rsdt_address = rsdp.rsdt_address
  
  acpi_initialized = 1
  foundation.serial_write_string("[ACPI] Initialized\n")
}

export fn acpi_shutdown() {
  foundation.serial_write_string("[ACPI] Shutdown requested\n")
  foundation.outb(0xB004, 0x2000)  // QEMU
  foundation.outb(0x604, 0x2000)   // Bochs
  foundation.outb(0x4004, 0x3400)  // VirtualBox
}

export fn acpi_reboot() {
  foundation.serial_write_string("[ACPI] Reboot requested\n")
  foundation.outb(0x64, 0xFE)  // PS/2 controller reset
}
