// home-os Bluetooth HCI (Host Controller Interface)
// Bluetooth controller abstraction layer

import "../../core/types"
import "../../sync/spinlock"
import "../../mm/memory"

// =============================================================================
// HCI Constants
// =============================================================================

const HCI_MAX_NAME_LENGTH: usize = 248
const HCI_MAX_EVENT_SIZE: usize = 260
const HCI_MAX_FRAME_SIZE: usize = 1028
const HCI_MAX_ACL_SIZE: usize = 1024
const HCI_MAX_SCO_SIZE: usize = 255

// =============================================================================
// HCI Packet Types
// =============================================================================

const HCI_COMMAND_PKT: u8 = 0x01
const HCI_ACLDATA_PKT: u8 = 0x02
const HCI_SCODATA_PKT: u8 = 0x03
const HCI_EVENT_PKT: u8 = 0x04
const HCI_ISODATA_PKT: u8 = 0x05
const HCI_VENDOR_PKT: u8 = 0xFF

// =============================================================================
// HCI Command OpCodes (OGF << 10 | OCF)
// =============================================================================

// Link Control Commands (OGF 0x01)
const HCI_OP_INQUIRY: u16 = 0x0401
const HCI_OP_INQUIRY_CANCEL: u16 = 0x0402
const HCI_OP_PERIODIC_INQUIRY: u16 = 0x0403
const HCI_OP_EXIT_PERIODIC_INQUIRY: u16 = 0x0404
const HCI_OP_CREATE_CONN: u16 = 0x0405
const HCI_OP_DISCONNECT: u16 = 0x0406
const HCI_OP_CREATE_CONN_CANCEL: u16 = 0x0408
const HCI_OP_ACCEPT_CONN_REQ: u16 = 0x0409
const HCI_OP_REJECT_CONN_REQ: u16 = 0x040A
const HCI_OP_LINK_KEY_REPLY: u16 = 0x040B
const HCI_OP_LINK_KEY_NEG_REPLY: u16 = 0x040C
const HCI_OP_PIN_CODE_REPLY: u16 = 0x040D
const HCI_OP_PIN_CODE_NEG_REPLY: u16 = 0x040E
const HCI_OP_AUTH_REQUESTED: u16 = 0x0411
const HCI_OP_SET_CONN_ENCRYPT: u16 = 0x0413
const HCI_OP_REMOTE_NAME_REQ: u16 = 0x0419
const HCI_OP_REMOTE_NAME_REQ_CANCEL: u16 = 0x041A
const HCI_OP_READ_REMOTE_FEATURES: u16 = 0x041B
const HCI_OP_READ_REMOTE_EXT_FEATURES: u16 = 0x041C
const HCI_OP_READ_REMOTE_VERSION: u16 = 0x041D

// Link Policy Commands (OGF 0x02)
const HCI_OP_HOLD_MODE: u16 = 0x0801
const HCI_OP_SNIFF_MODE: u16 = 0x0803
const HCI_OP_EXIT_SNIFF_MODE: u16 = 0x0804
const HCI_OP_ROLE_DISCOVERY: u16 = 0x0809
const HCI_OP_SWITCH_ROLE: u16 = 0x080B
const HCI_OP_READ_LINK_POLICY: u16 = 0x080C
const HCI_OP_WRITE_LINK_POLICY: u16 = 0x080D
const HCI_OP_SNIFF_SUBRATING: u16 = 0x0811

// Controller & Baseband Commands (OGF 0x03)
const HCI_OP_SET_EVENT_MASK: u16 = 0x0C01
const HCI_OP_RESET: u16 = 0x0C03
const HCI_OP_SET_EVENT_FLT: u16 = 0x0C05
const HCI_OP_WRITE_LOCAL_NAME: u16 = 0x0C13
const HCI_OP_READ_LOCAL_NAME: u16 = 0x0C14
const HCI_OP_READ_CONN_ACCEPT_TIMEOUT: u16 = 0x0C15
const HCI_OP_WRITE_CONN_ACCEPT_TIMEOUT: u16 = 0x0C16
const HCI_OP_READ_PAGE_TIMEOUT: u16 = 0x0C17
const HCI_OP_WRITE_PAGE_TIMEOUT: u16 = 0x0C18
const HCI_OP_READ_SCAN_ENABLE: u16 = 0x0C19
const HCI_OP_WRITE_SCAN_ENABLE: u16 = 0x0C1A
const HCI_OP_READ_CLASS_OF_DEV: u16 = 0x0C23
const HCI_OP_WRITE_CLASS_OF_DEV: u16 = 0x0C24
const HCI_OP_READ_VOICE_SETTING: u16 = 0x0C25
const HCI_OP_WRITE_VOICE_SETTING: u16 = 0x0C26
const HCI_OP_HOST_BUFFER_SIZE: u16 = 0x0C33
const HCI_OP_READ_SSP_MODE: u16 = 0x0C55
const HCI_OP_WRITE_SSP_MODE: u16 = 0x0C56
const HCI_OP_READ_LE_HOST_SUPPORTED: u16 = 0x0C6C
const HCI_OP_WRITE_LE_HOST_SUPPORTED: u16 = 0x0C6D

// Informational Parameters (OGF 0x04)
const HCI_OP_READ_LOCAL_VERSION: u16 = 0x1001
const HCI_OP_READ_LOCAL_COMMANDS: u16 = 0x1002
const HCI_OP_READ_LOCAL_FEATURES: u16 = 0x1003
const HCI_OP_READ_LOCAL_EXT_FEATURES: u16 = 0x1004
const HCI_OP_READ_BUFFER_SIZE: u16 = 0x1005
const HCI_OP_READ_BD_ADDR: u16 = 0x1009

// Status Parameters (OGF 0x05)
const HCI_OP_READ_RSSI: u16 = 0x1405

// LE Controller Commands (OGF 0x08)
const HCI_OP_LE_SET_EVENT_MASK: u16 = 0x2001
const HCI_OP_LE_READ_BUFFER_SIZE: u16 = 0x2002
const HCI_OP_LE_READ_LOCAL_FEATURES: u16 = 0x2003
const HCI_OP_LE_SET_RANDOM_ADDR: u16 = 0x2005
const HCI_OP_LE_SET_ADV_PARAM: u16 = 0x2006
const HCI_OP_LE_READ_ADV_TX_POWER: u16 = 0x2007
const HCI_OP_LE_SET_ADV_DATA: u16 = 0x2008
const HCI_OP_LE_SET_SCAN_RSP_DATA: u16 = 0x2009
const HCI_OP_LE_SET_ADV_ENABLE: u16 = 0x200A
const HCI_OP_LE_SET_SCAN_PARAM: u16 = 0x200B
const HCI_OP_LE_SET_SCAN_ENABLE: u16 = 0x200C
const HCI_OP_LE_CREATE_CONN: u16 = 0x200D
const HCI_OP_LE_CREATE_CONN_CANCEL: u16 = 0x200E
const HCI_OP_LE_READ_WHITE_LIST_SIZE: u16 = 0x200F
const HCI_OP_LE_CLEAR_WHITE_LIST: u16 = 0x2010
const HCI_OP_LE_ADD_TO_WHITE_LIST: u16 = 0x2011
const HCI_OP_LE_REMOVE_FROM_WHITE_LIST: u16 = 0x2012
const HCI_OP_LE_CONN_UPDATE: u16 = 0x2013
const HCI_OP_LE_START_ENC: u16 = 0x2019
const HCI_OP_LE_LTK_REPLY: u16 = 0x201A
const HCI_OP_LE_LTK_NEG_REPLY: u16 = 0x201B
const HCI_OP_LE_READ_SUPPORTED_STATES: u16 = 0x201C

// =============================================================================
// HCI Events
// =============================================================================

const HCI_EV_INQUIRY_COMPLETE: u8 = 0x01
const HCI_EV_INQUIRY_RESULT: u8 = 0x02
const HCI_EV_CONN_COMPLETE: u8 = 0x03
const HCI_EV_CONN_REQUEST: u8 = 0x04
const HCI_EV_DISCONN_COMPLETE: u8 = 0x05
const HCI_EV_AUTH_COMPLETE: u8 = 0x06
const HCI_EV_REMOTE_NAME: u8 = 0x07
const HCI_EV_ENCRYPT_CHANGE: u8 = 0x08
const HCI_EV_CHANGE_LINK_KEY_COMPLETE: u8 = 0x09
const HCI_EV_REMOTE_FEATURES: u8 = 0x0B
const HCI_EV_REMOTE_VERSION: u8 = 0x0C
const HCI_EV_QOS_SETUP_COMPLETE: u8 = 0x0D
const HCI_EV_CMD_COMPLETE: u8 = 0x0E
const HCI_EV_CMD_STATUS: u8 = 0x0F
const HCI_EV_HARDWARE_ERROR: u8 = 0x10
const HCI_EV_ROLE_CHANGE: u8 = 0x12
const HCI_EV_NUM_COMP_PKTS: u8 = 0x13
const HCI_EV_MODE_CHANGE: u8 = 0x14
const HCI_EV_PIN_CODE_REQ: u8 = 0x16
const HCI_EV_LINK_KEY_REQ: u8 = 0x17
const HCI_EV_LINK_KEY_NOTIFY: u8 = 0x18
const HCI_EV_CLOCK_OFFSET: u8 = 0x1C
const HCI_EV_PKT_TYPE_CHANGE: u8 = 0x1D
const HCI_EV_INQUIRY_RESULT_WITH_RSSI: u8 = 0x22
const HCI_EV_REMOTE_EXT_FEATURES: u8 = 0x23
const HCI_EV_SYNC_CONN_COMPLETE: u8 = 0x2C
const HCI_EV_SYNC_CONN_CHANGED: u8 = 0x2D
const HCI_EV_SNIFF_SUBRATING: u8 = 0x2E
const HCI_EV_EXTENDED_INQUIRY_RESULT: u8 = 0x2F
const HCI_EV_ENCRYPTION_KEY_REFRESH: u8 = 0x30
const HCI_EV_IO_CAPA_REQUEST: u8 = 0x31
const HCI_EV_IO_CAPA_REPLY: u8 = 0x32
const HCI_EV_USER_CONFIRM_REQUEST: u8 = 0x33
const HCI_EV_USER_PASSKEY_REQUEST: u8 = 0x34
const HCI_EV_SSP_COMPLETE: u8 = 0x36
const HCI_EV_LE_META: u8 = 0x3E
const HCI_EV_VENDOR: u8 = 0xFF

// LE Meta Event Sub-events
const HCI_EV_LE_CONN_COMPLETE: u8 = 0x01
const HCI_EV_LE_ADVERTISING_REPORT: u8 = 0x02
const HCI_EV_LE_CONN_UPDATE_COMPLETE: u8 = 0x03
const HCI_EV_LE_READ_REMOTE_FEATURES: u8 = 0x04
const HCI_EV_LE_LTK_REQUEST: u8 = 0x05
const HCI_EV_LE_ENHANCED_CONN_COMPLETE: u8 = 0x0A
const HCI_EV_LE_DIRECT_ADV_REPORT: u8 = 0x0B
const HCI_EV_LE_EXT_ADV_REPORT: u8 = 0x0D

// =============================================================================
// HCI Status Codes
// =============================================================================

const HCI_SUCCESS: u8 = 0x00
const HCI_ERR_UNKNOWN_COMMAND: u8 = 0x01
const HCI_ERR_UNKNOWN_CONN_ID: u8 = 0x02
const HCI_ERR_HARDWARE_FAILURE: u8 = 0x03
const HCI_ERR_PAGE_TIMEOUT: u8 = 0x04
const HCI_ERR_AUTH_FAILURE: u8 = 0x05
const HCI_ERR_PIN_OR_KEY_MISSING: u8 = 0x06
const HCI_ERR_MEMORY_EXCEEDED: u8 = 0x07
const HCI_ERR_CONNECTION_TIMEOUT: u8 = 0x08
const HCI_ERR_MAX_NUMBER_OF_CONN: u8 = 0x09
const HCI_ERR_HOST_BUSY_PAIRING: u8 = 0x38
const HCI_ERR_CONN_REJECTED: u8 = 0x1F
const HCI_ERR_REMOTE_USER_TERM: u8 = 0x13
const HCI_ERR_LOCAL_HOST_TERM: u8 = 0x16
const HCI_ERR_UNSUPPORTED_FEATURE: u8 = 0x11
const HCI_ERR_INVALID_PARAMS: u8 = 0x12

// =============================================================================
// Bluetooth Address
// =============================================================================

#[repr(C, packed)]
struct BDAddr {
    b: [u8; 6],
}

impl BDAddr {
    fn new(): BDAddr {
        BDAddr { b: [0u8; 6] }
    }

    fn from_bytes(bytes: &[u8; 6]): BDAddr {
        BDAddr { b: *bytes }
    }

    fn is_zero(self: &Self): bool {
        self.b[0] == 0 && self.b[1] == 0 && self.b[2] == 0 &&
        self.b[3] == 0 && self.b[4] == 0 && self.b[5] == 0
    }
}

// =============================================================================
// HCI Structures
// =============================================================================

#[repr(C, packed)]
struct HCICommandHeader {
    opcode: u16,
    plen: u8,
}

#[repr(C, packed)]
struct HCIEventHeader {
    evt: u8,
    plen: u8,
}

#[repr(C, packed)]
struct HCIACLHeader {
    handle: u16,     // Handle (12 bits) + PB flag (2 bits) + BC flag (2 bits)
    dlen: u16,
}

// =============================================================================
// HCI Device State
// =============================================================================

enum HCIState {
    Down,
    Init,
    Running,
    Closing,
}

enum HCIBusType {
    USB,
    UART,
    SDIO,
    Virtual,
}

// =============================================================================
// HCI Connection
// =============================================================================

const MAX_CONNECTIONS: usize = 16

enum ConnectionType {
    ACL,
    SCO,
    ESCO,
    LE,
}

enum ConnectionState {
    Disconnected,
    Connecting,
    Connected,
    Disconnecting,
}

struct HCIConnection {
    handle: u16,
    conn_type: ConnectionType,
    state: ConnectionState,
    bdaddr: BDAddr,
    link_type: u8,
    encrypt: bool,
    auth: bool,
    role: u8,          // 0 = master, 1 = slave

    // LE specific
    le: bool,
    le_conn_interval: u16,
    le_conn_latency: u16,
    le_supervision_timeout: u16,

    // Packet counters
    sent_acl_pkts: u32,
    sent_sco_pkts: u32,
}

// =============================================================================
// HCI Device
// =============================================================================

const MAX_HCI_DEVICES: usize = 4

struct HCIDeviceInfo {
    // Basic info
    bd_addr: BDAddr,
    name: [u8; HCI_MAX_NAME_LENGTH],
    name_len: usize,

    // Capabilities
    hci_ver: u8,
    hci_rev: u16,
    lmp_ver: u8,
    lmp_subver: u16,
    manufacturer: u16,

    // Features
    features: [u8; 8],
    le_features: [u8; 8],
    commands: [u8; 64],

    // Buffer sizes
    acl_mtu: u16,
    acl_pkts: u16,
    sco_mtu: u16,
    sco_pkts: u16,
    le_mtu: u16,
    le_pkts: u16,
}

struct HCIDevice {
    id: u32,
    bus: HCIBusType,
    state: HCIState,
    info: HCIDeviceInfo,

    // Connections
    connections: [Option<HCIConnection>; MAX_CONNECTIONS],
    conn_count: usize,

    // Command queue
    cmd_pending: bool,
    last_cmd: u16,

    // Packet counts
    acl_cnt: u32,
    sco_cnt: u32,
    le_cnt: u32,

    // Statistics
    rx_bytes: u64,
    tx_bytes: u64,
    rx_errors: u64,
    tx_errors: u64,

    // Driver callbacks
    open: Option<fn(dev: *mut HCIDevice) -> i32>,
    close: Option<fn(dev: *mut HCIDevice) -> i32>,
    send: Option<fn(dev: *mut HCIDevice, data: &[u8]) -> i32>,
    flush: Option<fn(dev: *mut HCIDevice) -> i32>,

    // Driver data
    driver_data: u64,

    lock: Spinlock,
}

// =============================================================================
// HCI State
// =============================================================================

struct HCIState {
    devices: [Option<HCIDevice>; MAX_HCI_DEVICES],
    device_count: usize,
    lock: Spinlock,
}

static mut HCI: HCIState = HCIState {
    devices: [None; MAX_HCI_DEVICES],
    device_count: 0,
    lock: Spinlock::new(),
}

// =============================================================================
// Initialization
// =============================================================================

export fn hci_init(): i32 {
    unsafe { HCI.lock.init() }
    return 0
}

// =============================================================================
// Device Registration
// =============================================================================

export fn hci_register_device(
    bus: HCIBusType,
    open: Option<fn(*mut HCIDevice) -> i32>,
    close: Option<fn(*mut HCIDevice) -> i32>,
    send: Option<fn(*mut HCIDevice, &[u8]) -> i32>,
): i32 {
    unsafe {
        HCI.lock.lock()

        if HCI.device_count >= MAX_HCI_DEVICES {
            HCI.lock.unlock()
            return -1
        }

        let id = HCI.device_count as u32

        HCI.devices[HCI.device_count] = Some(HCIDevice {
            id: id,
            bus: bus,
            state: HCIState::Down,
            info: HCIDeviceInfo {
                bd_addr: BDAddr::new(),
                name: [0u8; HCI_MAX_NAME_LENGTH],
                name_len: 0,
                hci_ver: 0,
                hci_rev: 0,
                lmp_ver: 0,
                lmp_subver: 0,
                manufacturer: 0,
                features: [0u8; 8],
                le_features: [0u8; 8],
                commands: [0u8; 64],
                acl_mtu: 0,
                acl_pkts: 0,
                sco_mtu: 0,
                sco_pkts: 0,
                le_mtu: 0,
                le_pkts: 0,
            },
            connections: [None; MAX_CONNECTIONS],
            conn_count: 0,
            cmd_pending: false,
            last_cmd: 0,
            acl_cnt: 0,
            sco_cnt: 0,
            le_cnt: 0,
            rx_bytes: 0,
            tx_bytes: 0,
            rx_errors: 0,
            tx_errors: 0,
            open: open,
            close: close,
            send: send,
            flush: None,
            driver_data: 0,
            lock: Spinlock::new(),
        })

        HCI.device_count += 1
        HCI.lock.unlock()

        return id as i32
    }
}

// =============================================================================
// Device Control
// =============================================================================

export fn hci_dev_open(dev_id: u32): i32 {
    unsafe {
        if dev_id as usize >= HCI.device_count { return -1 }

        if let Some(ref mut dev) = HCI.devices[dev_id as usize] {
            if dev.state != HCIState::Down {
                return -1  // Already open
            }

            // Call driver open
            if let Some(open) = dev.open {
                let result = open(dev as *mut HCIDevice)
                if result != 0 { return result }
            }

            dev.state = HCIState::Init

            // Initialize the controller
            hci_init_controller(dev)

            dev.state = HCIState::Running
            return 0
        }
        return -1
    }
}

export fn hci_dev_close(dev_id: u32): i32 {
    unsafe {
        if dev_id as usize >= HCI.device_count { return -1 }

        if let Some(ref mut dev) = HCI.devices[dev_id as usize] {
            if dev.state == HCIState::Down {
                return 0  // Already closed
            }

            dev.state = HCIState::Closing

            // Disconnect all connections
            for i in 0..MAX_CONNECTIONS {
                if let Some(ref conn) = dev.connections[i] {
                    hci_disconnect(dev_id, conn.handle, 0x13)  // Remote user terminated
                }
            }

            // Call driver close
            if let Some(close) = dev.close {
                close(dev as *mut HCIDevice)
            }

            dev.state = HCIState::Down
            return 0
        }
        return -1
    }
}

fn hci_init_controller(dev: &mut HCIDevice) {
    // Reset controller
    hci_send_cmd_sync(dev, HCI_OP_RESET, &[])

    // Read local version
    hci_send_cmd_sync(dev, HCI_OP_READ_LOCAL_VERSION, &[])

    // Read BD address
    hci_send_cmd_sync(dev, HCI_OP_READ_BD_ADDR, &[])

    // Read buffer sizes
    hci_send_cmd_sync(dev, HCI_OP_READ_BUFFER_SIZE, &[])

    // Read local features
    hci_send_cmd_sync(dev, HCI_OP_READ_LOCAL_FEATURES, &[])

    // Read local commands
    hci_send_cmd_sync(dev, HCI_OP_READ_LOCAL_COMMANDS, &[])

    // Set event mask
    let event_mask: [u8; 8] = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F]
    hci_send_cmd_sync(dev, HCI_OP_SET_EVENT_MASK, &event_mask)

    // Enable SSP if supported
    let ssp_mode: [u8; 1] = [0x01]
    hci_send_cmd_sync(dev, HCI_OP_WRITE_SSP_MODE, &ssp_mode)

    // Check for LE support and initialize
    if (dev.info.features[4] & 0x40) != 0 {
        // LE supported
        hci_send_cmd_sync(dev, HCI_OP_LE_READ_BUFFER_SIZE, &[])
        hci_send_cmd_sync(dev, HCI_OP_LE_READ_LOCAL_FEATURES, &[])

        // Set LE event mask
        let le_event_mask: [u8; 8] = [0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00]
        hci_send_cmd_sync(dev, HCI_OP_LE_SET_EVENT_MASK, &le_event_mask)

        // Enable LE + BR/EDR host support
        let le_host: [u8; 2] = [0x01, 0x00]
        hci_send_cmd_sync(dev, HCI_OP_WRITE_LE_HOST_SUPPORTED, &le_host)
    }
}

// =============================================================================
// Command Sending
// =============================================================================

fn hci_send_cmd(dev: &mut HCIDevice, opcode: u16, params: &[u8]): i32 {
    let mut buf: [u8; 259] = [0u8; 259]

    buf[0] = HCI_COMMAND_PKT
    buf[1] = (opcode & 0xFF) as u8
    buf[2] = (opcode >> 8) as u8
    buf[3] = params.len() as u8

    for i in 0..params.len() {
        buf[4 + i] = params[i]
    }

    let len = 4 + params.len()

    if let Some(send) = dev.send {
        dev.cmd_pending = true
        dev.last_cmd = opcode
        dev.tx_bytes += len as u64
        return send(dev as *mut HCIDevice, &buf[..len])
    }

    return -1
}

fn hci_send_cmd_sync(dev: &mut HCIDevice, opcode: u16, params: &[u8]): i32 {
    let result = hci_send_cmd(dev, opcode, params)
    if result != 0 { return result }

    // Wait for command complete (simplified - would use proper sync)
    for _ in 0..1000 {
        if !dev.cmd_pending {
            return 0
        }
        // Small delay
        for _ in 0..10000 { asm!("pause") }
    }

    return -1  // Timeout
}

// =============================================================================
// Event Processing
// =============================================================================

export fn hci_recv_event(dev_id: u32, data: &[u8]): i32 {
    unsafe {
        if dev_id as usize >= HCI.device_count { return -1 }
        if data.len() < 2 { return -1 }

        if let Some(ref mut dev) = HCI.devices[dev_id as usize] {
            dev.rx_bytes += data.len() as u64

            let event = data[0]
            let plen = data[1] as usize

            if data.len() < 2 + plen { return -1 }

            let params = &data[2..2 + plen]

            match event {
                HCI_EV_CMD_COMPLETE => {
                    hci_cmd_complete(dev, params)
                },
                HCI_EV_CMD_STATUS => {
                    hci_cmd_status(dev, params)
                },
                HCI_EV_CONN_COMPLETE => {
                    hci_conn_complete(dev, params)
                },
                HCI_EV_DISCONN_COMPLETE => {
                    hci_disconn_complete(dev, params)
                },
                HCI_EV_CONN_REQUEST => {
                    hci_conn_request(dev, params)
                },
                HCI_EV_LE_META => {
                    hci_le_meta_event(dev, params)
                },
                HCI_EV_NUM_COMP_PKTS => {
                    hci_num_comp_pkts(dev, params)
                },
                _ => {
                    // Unhandled event
                }
            }

            return 0
        }
        return -1
    }
}

fn hci_cmd_complete(dev: &mut HCIDevice, params: &[u8]) {
    if params.len() < 3 { return }

    let _num_cmds = params[0]
    let opcode = (params[1] as u16) | ((params[2] as u16) << 8)
    let status = if params.len() > 3 { params[3] } else { 0 }

    if opcode == dev.last_cmd {
        dev.cmd_pending = false
    }

    if status != HCI_SUCCESS { return }

    match opcode {
        HCI_OP_READ_LOCAL_VERSION => {
            if params.len() >= 12 {
                dev.info.hci_ver = params[4]
                dev.info.hci_rev = (params[5] as u16) | ((params[6] as u16) << 8)
                dev.info.lmp_ver = params[7]
                dev.info.manufacturer = (params[8] as u16) | ((params[9] as u16) << 8)
                dev.info.lmp_subver = (params[10] as u16) | ((params[11] as u16) << 8)
            }
        },
        HCI_OP_READ_BD_ADDR => {
            if params.len() >= 10 {
                for i in 0..6 {
                    dev.info.bd_addr.b[i] = params[4 + i]
                }
            }
        },
        HCI_OP_READ_BUFFER_SIZE => {
            if params.len() >= 11 {
                dev.info.acl_mtu = (params[4] as u16) | ((params[5] as u16) << 8)
                dev.info.sco_mtu = params[6] as u16
                dev.info.acl_pkts = (params[7] as u16) | ((params[8] as u16) << 8)
                dev.info.sco_pkts = (params[9] as u16) | ((params[10] as u16) << 8)
                dev.acl_cnt = dev.info.acl_pkts as u32
                dev.sco_cnt = dev.info.sco_pkts as u32
            }
        },
        HCI_OP_READ_LOCAL_FEATURES => {
            if params.len() >= 12 {
                for i in 0..8 {
                    dev.info.features[i] = params[4 + i]
                }
            }
        },
        HCI_OP_LE_READ_BUFFER_SIZE => {
            if params.len() >= 7 {
                dev.info.le_mtu = (params[4] as u16) | ((params[5] as u16) << 8)
                dev.info.le_pkts = params[6] as u16
                dev.le_cnt = dev.info.le_pkts as u32
            }
        },
        _ => {}
    }
}

fn hci_cmd_status(dev: &mut HCIDevice, params: &[u8]) {
    if params.len() < 4 { return }

    let status = params[0]
    let _num_cmds = params[1]
    let opcode = (params[2] as u16) | ((params[3] as u16) << 8)

    if opcode == dev.last_cmd && status != 0 {
        dev.cmd_pending = false
    }
}

fn hci_conn_complete(dev: &mut HCIDevice, params: &[u8]) {
    if params.len() < 11 { return }

    let status = params[0]
    let handle = (params[1] as u16) | ((params[2] as u16) << 8)
    let link_type = params[9]
    let encrypt = params[10] != 0

    if status != HCI_SUCCESS { return }

    // Find free connection slot
    for i in 0..MAX_CONNECTIONS {
        if dev.connections[i].is_none() {
            let mut bdaddr = BDAddr::new()
            for j in 0..6 {
                bdaddr.b[j] = params[3 + j]
            }

            dev.connections[i] = Some(HCIConnection {
                handle: handle,
                conn_type: if link_type == 0 { ConnectionType::SCO } else { ConnectionType::ACL },
                state: ConnectionState::Connected,
                bdaddr: bdaddr,
                link_type: link_type,
                encrypt: encrypt,
                auth: false,
                role: 0,
                le: false,
                le_conn_interval: 0,
                le_conn_latency: 0,
                le_supervision_timeout: 0,
                sent_acl_pkts: 0,
                sent_sco_pkts: 0,
            })
            dev.conn_count += 1
            break
        }
    }
}

fn hci_disconn_complete(dev: &mut HCIDevice, params: &[u8]) {
    if params.len() < 4 { return }

    let status = params[0]
    let handle = (params[1] as u16) | ((params[2] as u16) << 8)
    let _reason = params[3]

    if status != HCI_SUCCESS { return }

    // Find and remove connection
    for i in 0..MAX_CONNECTIONS {
        if let Some(ref conn) = dev.connections[i] {
            if conn.handle == handle {
                dev.connections[i] = None
                dev.conn_count -= 1
                break
            }
        }
    }
}

fn hci_conn_request(dev: &mut HCIDevice, params: &[u8]) {
    if params.len() < 10 { return }

    // Auto-accept connections for now
    let mut accept_params: [u8; 7] = [0u8; 7]
    for i in 0..6 {
        accept_params[i] = params[i]  // BD_ADDR
    }
    accept_params[6] = 0x01  // Role: slave

    hci_send_cmd(dev, HCI_OP_ACCEPT_CONN_REQ, &accept_params)
}

fn hci_le_meta_event(dev: &mut HCIDevice, params: &[u8]) {
    if params.len() < 1 { return }

    let subevent = params[0]
    let subparams = &params[1..]

    match subevent {
        HCI_EV_LE_CONN_COMPLETE => {
            if subparams.len() >= 18 {
                let status = subparams[0]
                let handle = (subparams[1] as u16) | ((subparams[2] as u16) << 8)
                let role = subparams[3]
                let interval = (subparams[9] as u16) | ((subparams[10] as u16) << 8)
                let latency = (subparams[11] as u16) | ((subparams[12] as u16) << 8)
                let timeout = (subparams[13] as u16) | ((subparams[14] as u16) << 8)

                if status == HCI_SUCCESS {
                    for i in 0..MAX_CONNECTIONS {
                        if dev.connections[i].is_none() {
                            let mut bdaddr = BDAddr::new()
                            for j in 0..6 {
                                bdaddr.b[j] = subparams[4 + j]
                            }

                            dev.connections[i] = Some(HCIConnection {
                                handle: handle,
                                conn_type: ConnectionType::LE,
                                state: ConnectionState::Connected,
                                bdaddr: bdaddr,
                                link_type: 0,
                                encrypt: false,
                                auth: false,
                                role: role,
                                le: true,
                                le_conn_interval: interval,
                                le_conn_latency: latency,
                                le_supervision_timeout: timeout,
                                sent_acl_pkts: 0,
                                sent_sco_pkts: 0,
                            })
                            dev.conn_count += 1
                            break
                        }
                    }
                }
            }
        },
        HCI_EV_LE_ADVERTISING_REPORT => {
            // Handle advertising reports for scanning
        },
        _ => {}
    }
}

fn hci_num_comp_pkts(dev: &mut HCIDevice, params: &[u8]) {
    if params.len() < 1 { return }

    let num_handles = params[0] as usize

    for i in 0..num_handles {
        if params.len() < 1 + (i + 1) * 4 { break }

        let offset = 1 + i * 4
        let handle = (params[offset] as u16) | ((params[offset + 1] as u16) << 8)
        let count = (params[offset + 2] as u16) | ((params[offset + 3] as u16) << 8)

        // Find connection and update packet counts
        for j in 0..MAX_CONNECTIONS {
            if let Some(ref conn) = dev.connections[j] {
                if conn.handle == handle {
                    if conn.le {
                        dev.le_cnt += count as u32
                    } else {
                        dev.acl_cnt += count as u32
                    }
                    break
                }
            }
        }
    }
}

// =============================================================================
// Connection Management
// =============================================================================

export fn hci_disconnect(dev_id: u32, handle: u16, reason: u8): i32 {
    unsafe {
        if dev_id as usize >= HCI.device_count { return -1 }

        if let Some(ref mut dev) = HCI.devices[dev_id as usize] {
            let params: [u8; 3] = [
                (handle & 0xFF) as u8,
                (handle >> 8) as u8,
                reason,
            ]
            return hci_send_cmd(dev, HCI_OP_DISCONNECT, &params)
        }
        return -1
    }
}

// =============================================================================
// ACL Data
// =============================================================================

export fn hci_send_acl(dev_id: u32, handle: u16, data: &[u8]): i32 {
    unsafe {
        if dev_id as usize >= HCI.device_count { return -1 }

        if let Some(ref mut dev) = HCI.devices[dev_id as usize] {
            if dev.acl_cnt == 0 { return -1 }  // No buffers

            let mut buf: [u8; HCI_MAX_FRAME_SIZE] = [0u8; HCI_MAX_FRAME_SIZE]

            buf[0] = HCI_ACLDATA_PKT
            buf[1] = (handle & 0xFF) as u8
            buf[2] = ((handle >> 8) & 0x0F) as u8 | 0x20  // PB=10 (first auto-flush)
            buf[3] = (data.len() & 0xFF) as u8
            buf[4] = (data.len() >> 8) as u8

            let len = data.len().min(HCI_MAX_ACL_SIZE)
            for i in 0..len {
                buf[5 + i] = data[i]
            }

            if let Some(send) = dev.send {
                dev.acl_cnt -= 1
                dev.tx_bytes += (5 + len) as u64
                return send(dev as *mut HCIDevice, &buf[..5 + len])
            }
        }
        return -1
    }
}

// =============================================================================
// Query Functions
// =============================================================================

export fn hci_get_device_count(): usize {
    unsafe { HCI.device_count }
}

export fn hci_get_bd_addr(dev_id: u32): BDAddr {
    unsafe {
        if dev_id as usize >= HCI.device_count { return BDAddr::new() }
        match &HCI.devices[dev_id as usize] {
            Some(dev) => dev.info.bd_addr,
            None => BDAddr::new(),
        }
    }
}

export fn hci_get_connection_count(dev_id: u32): usize {
    unsafe {
        if dev_id as usize >= HCI.device_count { return 0 }
        match &HCI.devices[dev_id as usize] {
            Some(dev) => dev.conn_count,
            None => 0,
        }
    }
}
