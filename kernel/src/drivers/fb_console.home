// home-os Framebuffer Console with Font Rendering
// VT100-compatible terminal emulator with PSF font support
// Provides graphical text console output

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "framebuffer.home" as framebuffer

// Console configuration
const CONSOLE_WIDTH: u32 = 80        // Characters
const CONSOLE_HEIGHT: u32 = 25       // Characters
const FONT_WIDTH: u32 = 8            // Pixels
const FONT_HEIGHT: u32 = 16          // Pixels
const TAB_SIZE: u32 = 8

// Colors (32-bit RGBA)
const COLOR_BLACK: u32 = 0xFF000000
const COLOR_RED: u32 = 0xFFAA0000
const COLOR_GREEN: u32 = 0xFF00AA00
const COLOR_YELLOW: u32 = 0xFFAAAA00
const COLOR_BLUE: u32 = 0xFF0000AA
const COLOR_MAGENTA: u32 = 0xFFAA00AA
const COLOR_CYAN: u32 = 0xFF00AAAA
const COLOR_WHITE: u32 = 0xFFAAAAAA
const COLOR_BRIGHT_BLACK: u32 = 0xFF555555
const COLOR_BRIGHT_RED: u32 = 0xFFFF5555
const COLOR_BRIGHT_GREEN: u32 = 0xFF55FF55
const COLOR_BRIGHT_YELLOW: u32 = 0xFFFFFF55
const COLOR_BRIGHT_BLUE: u32 = 0xFF5555FF
const COLOR_BRIGHT_MAGENTA: u32 = 0xFFFF55FF
const COLOR_BRIGHT_CYAN: u32 = 0xFF55FFFF
const COLOR_BRIGHT_WHITE: u32 = 0xFFFFFFFF

// VT100 escape sequence states
const VT_STATE_NORMAL: u32 = 0
const VT_STATE_ESC: u32 = 1
const VT_STATE_CSI: u32 = 2

// Character cell
struct ConsoleCell {
  char: u32
  fg_color: u32
  bg_color: u32
  attributes: u32  // Bold, underline, etc.
}

// Console state
struct ConsoleState {
  cursor_x: u32
  cursor_y: u32
  fg_color: u32
  bg_color: u32
  attributes: u32

  vt_state: u32           // VT100 parser state
  esc_params: [8]u32      // Escape sequence parameters
  esc_param_count: u32

  buffer: *ConsoleCell    // Character buffer
  scroll_top: u32
  scroll_bottom: u32

  cursor_visible: u32
  cursor_blink: u32

  initialized: u32
}

var console: ConsoleState
var initialized: u32 = 0

// Built-in 8x16 font (simplified - would include full bitmap)
// Each character is 16 bytes (16 rows of 8 pixels)
var font_data: [256 * 16]u8

// Initialize font data (simplified)
fn init_font() {
  // Would load actual PSF font or include bitmap font
  // For now, just clear
  var i: u32 = 0
  loop {
    if i >= 256 * 16 { break }
    font_data[i] = 0
    i = i + 1
  }

  // Set up a simple pattern for ASCII 'A' (0x41)
  font_data[0x41 * 16 + 0] = 0b00111100
  font_data[0x41 * 16 + 1] = 0b01100110
  font_data[0x41 * 16 + 2] = 0b11000011
  font_data[0x41 * 16 + 3] = 0b11000011
  font_data[0x41 * 16 + 4] = 0b11111111
  font_data[0x41 * 16 + 5] = 0b11000011
  font_data[0x41 * 16 + 6] = 0b11000011
  font_data[0x41 * 16 + 7] = 0b11000011
}

// Get color from index
fn get_color(index: u32, bright: u32): u32 {
  if bright == 0 {
    if index == 0 { return COLOR_BLACK }
    else if index == 1 { return COLOR_RED }
    else if index == 2 { return COLOR_GREEN }
    else if index == 3 { return COLOR_YELLOW }
    else if index == 4 { return COLOR_BLUE }
    else if index == 5 { return COLOR_MAGENTA }
    else if index == 6 { return COLOR_CYAN }
    else { return COLOR_WHITE }
  } else {
    if index == 0 { return COLOR_BRIGHT_BLACK }
    else if index == 1 { return COLOR_BRIGHT_RED }
    else if index == 2 { return COLOR_BRIGHT_GREEN }
    else if index == 3 { return COLOR_BRIGHT_YELLOW }
    else if index == 4 { return COLOR_BRIGHT_BLUE }
    else if index == 5 { return COLOR_BRIGHT_MAGENTA }
    else if index == 6 { return COLOR_BRIGHT_CYAN }
    else { return COLOR_BRIGHT_WHITE }
  }
}

// Initialize framebuffer console
export fn fb_console_init(): u32 {
  if initialized == 1 {
    foundation.serial_write_string("[FB_CONSOLE] Already initialized\n")
    return 0
  }

  foundation.serial_write_string("[FB_CONSOLE] Initializing framebuffer console...\n")

  // Allocate character buffer
  let buffer_size: u64 = (CONSOLE_WIDTH * CONSOLE_HEIGHT * 16) as u64  // Size of ConsoleCell
  console.buffer = memory.kmalloc(buffer_size) as *ConsoleCell

  if console.buffer == 0 {
    foundation.serial_write_string("[FB_CONSOLE] Failed to allocate buffer\n")
    return 1
  }

  // Initialize console state
  console.cursor_x = 0
  console.cursor_y = 0
  console.fg_color = COLOR_WHITE
  console.bg_color = COLOR_BLACK
  console.attributes = 0
  console.vt_state = VT_STATE_NORMAL
  console.esc_param_count = 0
  console.scroll_top = 0
  console.scroll_bottom = CONSOLE_HEIGHT - 1
  console.cursor_visible = 1
  console.cursor_blink = 0

  // Clear buffer
  var i: u32 = 0
  loop {
    if i >= CONSOLE_WIDTH * CONSOLE_HEIGHT { break }

    let cell_ptr: u64 = console.buffer as u64 + (i * 16) as u64
    memory.write_u32(cell_ptr, ' ' as u32)
    memory.write_u32(cell_ptr + 4, console.fg_color)
    memory.write_u32(cell_ptr + 8, console.bg_color)
    memory.write_u32(cell_ptr + 12, 0)

    i = i + 1
  }

  // Initialize font
  init_font()

  console.initialized = 1
  initialized = 1

  // Clear screen
  fb_console_clear()

  foundation.serial_write_string("[FB_CONSOLE] Console initialized ")
  foundation.serial_write_u64(CONSOLE_WIDTH)
  foundation.serial_write_string("x")
  foundation.serial_write_u64(CONSOLE_HEIGHT)
  foundation.serial_write_string(" chars\n")

  return 0
}

// Draw a character at position
fn draw_char(x: u32, y: u32, char: u32, fg: u32, bg: u32) {
  if char >= 256 { return }

  let pixel_x: u32 = x * FONT_WIDTH
  let pixel_y: u32 = y * FONT_HEIGHT

  var row: u32 = 0
  loop {
    if row >= FONT_HEIGHT { break }

    let font_byte: u8 = font_data[(char * 16 + row) as u32]

    var col: u32 = 0
    loop {
      if col >= FONT_WIDTH { break }

      let bit: u32 = (font_byte >> (7 - col)) & 1
      let color: u32 = if bit == 1 { fg } else { bg }

      framebuffer.fb_draw_pixel(pixel_x + col, pixel_y + row, color)

      col = col + 1
    }

    row = row + 1
  }
}

// Scroll console up one line
fn scroll_up() {
  // Move buffer contents up
  var y: u32 = console.scroll_top
  loop {
    if y >= console.scroll_bottom { break }

    var x: u32 = 0
    loop {
      if x >= CONSOLE_WIDTH { break }

      let src_idx: u32 = (y + 1) * CONSOLE_WIDTH + x
      let dst_idx: u32 = y * CONSOLE_WIDTH + x

      let src_ptr: u64 = console.buffer as u64 + (src_idx * 16) as u64
      let dst_ptr: u64 = console.buffer as u64 + (dst_idx * 16) as u64

      memory.write_u32(dst_ptr, memory.read_u32(src_ptr))
      memory.write_u32(dst_ptr + 4, memory.read_u32(src_ptr + 4))
      memory.write_u32(dst_ptr + 8, memory.read_u32(src_ptr + 8))
      memory.write_u32(dst_ptr + 12, memory.read_u32(src_ptr + 12))

      x = x + 1
    }

    y = y + 1
  }

  // Clear bottom line
  var x: u32 = 0
  loop {
    if x >= CONSOLE_WIDTH { break }

    let idx: u32 = console.scroll_bottom * CONSOLE_WIDTH + x
    let ptr: u64 = console.buffer as u64 + (idx * 16) as u64

    memory.write_u32(ptr, ' ' as u32)
    memory.write_u32(ptr + 4, console.fg_color)
    memory.write_u32(ptr + 8, console.bg_color)
    memory.write_u32(ptr + 12, 0)

    x = x + 1
  }

  // Redraw entire screen
  fb_console_refresh()
}

// Put character at current cursor position
fn put_char_at_cursor(ch: u32) {
  let idx: u32 = console.cursor_y * CONSOLE_WIDTH + console.cursor_x
  let ptr: u64 = console.buffer as u64 + (idx * 16) as u64

  memory.write_u32(ptr, ch)
  memory.write_u32(ptr + 4, console.fg_color)
  memory.write_u32(ptr + 8, console.bg_color)
  memory.write_u32(ptr + 12, console.attributes)

  draw_char(console.cursor_x, console.cursor_y, ch, console.fg_color, console.bg_color)
}

// Handle VT100 CSI sequence
fn handle_csi_sequence(final_char: u8) {
  if final_char == ('H' as u8) || final_char == ('f' as u8) {
    // Cursor position
    let row: u32 = if console.esc_param_count > 0 { console.esc_params[0] - 1 } else { 0 }
    let col: u32 = if console.esc_param_count > 1 { console.esc_params[1] - 1 } else { 0 }

    console.cursor_y = if row < CONSOLE_HEIGHT { row } else { CONSOLE_HEIGHT - 1 }
    console.cursor_x = if col < CONSOLE_WIDTH { col } else { CONSOLE_WIDTH - 1 }

  } else if final_char == ('A' as u8) {
    // Cursor up
    let n: u32 = if console.esc_param_count > 0 { console.esc_params[0] } else { 1 }
    if console.cursor_y >= n {
      console.cursor_y = console.cursor_y - n
    }

  } else if final_char == ('B' as u8) {
    // Cursor down
    let n: u32 = if console.esc_param_count > 0 { console.esc_params[0] } else { 1 }
    console.cursor_y = console.cursor_y + n
    if console.cursor_y >= CONSOLE_HEIGHT {
      console.cursor_y = CONSOLE_HEIGHT - 1
    }

  } else if final_char == ('C' as u8) {
    // Cursor forward
    let n: u32 = if console.esc_param_count > 0 { console.esc_params[0] } else { 1 }
    console.cursor_x = console.cursor_x + n
    if console.cursor_x >= CONSOLE_WIDTH {
      console.cursor_x = CONSOLE_WIDTH - 1
    }

  } else if final_char == ('D' as u8) {
    // Cursor back
    let n: u32 = if console.esc_param_count > 0 { console.esc_params[0] } else { 1 }
    if console.cursor_x >= n {
      console.cursor_x = console.cursor_x - n
    }

  } else if final_char == ('J' as u8) {
    // Erase display
    let mode: u32 = if console.esc_param_count > 0 { console.esc_params[0] } else { 0 }

    if mode == 2 {
      fb_console_clear()
    }

  } else if final_char == ('m' as u8) {
    // Set graphics mode
    if console.esc_param_count == 0 {
      // Reset
      console.fg_color = COLOR_WHITE
      console.bg_color = COLOR_BLACK
      console.attributes = 0
    } else {
      var i: u32 = 0
      loop {
        if i >= console.esc_param_count { break }

        let param: u32 = console.esc_params[i]

        if param == 0 {
          console.fg_color = COLOR_WHITE
          console.bg_color = COLOR_BLACK
          console.attributes = 0
        } else if param >= 30 && param <= 37 {
          console.fg_color = get_color(param - 30, 0)
        } else if param >= 40 && param <= 47 {
          console.bg_color = get_color(param - 40, 0)
        } else if param >= 90 && param <= 97 {
          console.fg_color = get_color(param - 90, 1)
        } else if param >= 100 && param <= 107 {
          console.bg_color = get_color(param - 100, 1)
        }

        i = i + 1
      }
    }
  }
}

// Write a character to console
export fn fb_console_putchar(ch: u8) {
  if initialized == 0 { return }

  // Handle VT100 escape sequences
  if console.vt_state == VT_STATE_ESC {
    if ch == ('[' as u8) {
      console.vt_state = VT_STATE_CSI
      console.esc_param_count = 0
      var i: u32 = 0
      loop {
        if i >= 8 { break }
        console.esc_params[i] = 0
        i = i + 1
      }
      return
    } else {
      console.vt_state = VT_STATE_NORMAL
    }
  } else if console.vt_state == VT_STATE_CSI {
    if ch >= ('0' as u8) && ch <= ('9' as u8) {
      if console.esc_param_count == 0 {
        console.esc_param_count = 1
      }
      console.esc_params[console.esc_param_count - 1] =
        console.esc_params[console.esc_param_count - 1] * 10 + (ch - ('0' as u8)) as u32
      return
    } else if ch == (';' as u8) {
      if console.esc_param_count < 8 {
        console.esc_param_count = console.esc_param_count + 1
      }
      return
    } else {
      handle_csi_sequence(ch)
      console.vt_state = VT_STATE_NORMAL
      return
    }
  }

  // Handle special characters
  if ch == 0x1B {  // ESC
    console.vt_state = VT_STATE_ESC
    return
  } else if ch == ('\n' as u8) {
    console.cursor_x = 0
    console.cursor_y = console.cursor_y + 1

    if console.cursor_y >= CONSOLE_HEIGHT {
      console.cursor_y = CONSOLE_HEIGHT - 1
      scroll_up()
    }
    return
  } else if ch == ('\r' as u8) {
    console.cursor_x = 0
    return
  } else if ch == ('\t' as u8) {
    console.cursor_x = (console.cursor_x + TAB_SIZE) & ~(TAB_SIZE - 1)
    if console.cursor_x >= CONSOLE_WIDTH {
      console.cursor_x = 0
      console.cursor_y = console.cursor_y + 1
    }
    return
  } else if ch == ('\b' as u8) {
    if console.cursor_x > 0 {
      console.cursor_x = console.cursor_x - 1
    }
    return
  }

  // Normal character
  put_char_at_cursor(ch as u32)

  console.cursor_x = console.cursor_x + 1
  if console.cursor_x >= CONSOLE_WIDTH {
    console.cursor_x = 0
    console.cursor_y = console.cursor_y + 1

    if console.cursor_y >= CONSOLE_HEIGHT {
      console.cursor_y = CONSOLE_HEIGHT - 1
      scroll_up()
    }
  }
}

// Write string to console
export fn fb_console_write(str: *u8) {
  var i: u32 = 0
  loop {
    let ch: u8 = memory.read_u8(str as u64 + i as u64)
    if ch == 0 { break }

    fb_console_putchar(ch)
    i = i + 1
  }
}

// Clear console
export fn fb_console_clear() {
  if initialized == 0 { return }

  // Clear buffer
  var i: u32 = 0
  loop {
    if i >= CONSOLE_WIDTH * CONSOLE_HEIGHT { break }

    let ptr: u64 = console.buffer as u64 + (i * 16) as u64
    memory.write_u32(ptr, ' ' as u32)
    memory.write_u32(ptr + 4, console.fg_color)
    memory.write_u32(ptr + 8, console.bg_color)
    memory.write_u32(ptr + 12, 0)

    i = i + 1
  }

  // Clear framebuffer
  framebuffer.fb_clear(console.bg_color)

  console.cursor_x = 0
  console.cursor_y = 0
}

// Refresh entire display
export fn fb_console_refresh() {
  var y: u32 = 0
  loop {
    if y >= CONSOLE_HEIGHT { break }

    var x: u32 = 0
    loop {
      if x >= CONSOLE_WIDTH { break }

      let idx: u32 = y * CONSOLE_WIDTH + x
      let ptr: u64 = console.buffer as u64 + (idx * 16) as u64

      let char: u32 = memory.read_u32(ptr)
      let fg: u32 = memory.read_u32(ptr + 4)
      let bg: u32 = memory.read_u32(ptr + 8)

      draw_char(x, y, char, fg, bg)

      x = x + 1
    }

    y = y + 1
  }
}

// Set cursor visibility
export fn fb_console_set_cursor_visible(visible: u32) {
  console.cursor_visible = visible
}

// Get cursor position
export fn fb_console_get_cursor_x(): u32 {
  return console.cursor_x
}

export fn fb_console_get_cursor_y(): u32 {
  return console.cursor_y
}

// ============================================================================
// Enhanced Console Features - Polish and Performance
// ============================================================================

// Status line support
var status_line_enabled: u32 = 0
var status_line_text: [80]u8
var status_line_dirty: u32 = 0

// Performance tracking
var total_chars_rendered: u64 = 0
var total_scrolls: u64 = 0
var total_clears: u64 = 0

// Double-buffering support
var use_double_buffer: u32 = 0
var dirty_region_x1: u32 = 0
var dirty_region_y1: u32 = 0
var dirty_region_x2: u32 = 0
var dirty_region_y2: u32 = 0
var has_dirty_region: u32 = 0

// Cursor rendering
var cursor_char_underneath: u32 = ' '
var cursor_fg_underneath: u32 = COLOR_WHITE
var cursor_bg_underneath: u32 = COLOR_BLACK
var cursor_drawn: u32 = 0
var cursor_blink_timer: u32 = 0

// ============================================================================
// Status Line
// ============================================================================

export fn fb_console_enable_status_line(enable: u32) {
  status_line_enabled = enable

  if enable == 1 {
    // Reserve bottom line for status
    console.scroll_bottom = CONSOLE_HEIGHT - 2
  } else {
    console.scroll_bottom = CONSOLE_HEIGHT - 1
  }

  status_line_dirty = 1
}

export fn fb_console_set_status(text: u64) {
  var i: u32 = 0
  while i < 79 {
    var c: u8 = @ptrLoad(text + i, u8)
    if c == 0 { break }
    status_line_text[i] = c
    i = i + 1
  }
  status_line_text[i] = 0

  status_line_dirty = 1

  if status_line_enabled == 1 {
    fb_console_render_status_line()
  }
}

fn fb_console_render_status_line() {
  if status_line_enabled == 0 { return }

  var y: u32 = CONSOLE_HEIGHT - 1
  var status_fg: u32 = COLOR_BLACK
  var status_bg: u32 = COLOR_WHITE

  // Draw status bar background
  var x: u32 = 0
  while x < CONSOLE_WIDTH {
    var c: u8 = if x < 79 { status_line_text[x] } else { ' ' }
    if c == 0 { c = ' ' }

    draw_char(x, y, c, status_fg, status_bg)
    x = x + 1
  }

  status_line_dirty = 0
}

// ============================================================================
// Dirty Region Tracking for Partial Updates
// ============================================================================

fn mark_dirty(x: u32, y: u32) {
  if has_dirty_region == 0 {
    dirty_region_x1 = x
    dirty_region_y1 = y
    dirty_region_x2 = x + 1
    dirty_region_y2 = y + 1
    has_dirty_region = 1
  } else {
    if x < dirty_region_x1 { dirty_region_x1 = x }
    if y < dirty_region_y1 { dirty_region_y1 = y }
    if x + 1 > dirty_region_x2 { dirty_region_x2 = x + 1 }
    if y + 1 > dirty_region_y2 { dirty_region_y2 = y + 1 }
  }
}

fn mark_all_dirty() {
  dirty_region_x1 = 0
  dirty_region_y1 = 0
  dirty_region_x2 = CONSOLE_WIDTH
  dirty_region_y2 = CONSOLE_HEIGHT
  has_dirty_region = 1
}

fn clear_dirty() {
  has_dirty_region = 0
}

// Refresh only dirty regions
export fn fb_console_partial_refresh() {
  if has_dirty_region == 0 { return }

  var y: u32 = dirty_region_y1
  while y < dirty_region_y2 {
    if y >= CONSOLE_HEIGHT { break }

    var x: u32 = dirty_region_x1
    while x < dirty_region_x2 {
      if x >= CONSOLE_WIDTH { break }

      var idx: u32 = y * CONSOLE_WIDTH + x
      var ptr: u64 = console.buffer as u64 + (idx * 16) as u64

      var char: u32 = memory.read_u32(ptr)
      var fg: u32 = memory.read_u32(ptr + 4)
      var bg: u32 = memory.read_u32(ptr + 8)

      draw_char(x, y, char, fg, bg)

      x = x + 1
    }

    y = y + 1
  }

  clear_dirty()
}

// ============================================================================
// Cursor Rendering
// ============================================================================

fn hide_cursor() {
  if cursor_drawn == 0 { return }

  // Restore character underneath cursor
  draw_char(console.cursor_x, console.cursor_y,
            cursor_char_underneath, cursor_fg_underneath, cursor_bg_underneath)

  cursor_drawn = 0
}

fn show_cursor() {
  if console.cursor_visible == 0 { return }
  if cursor_drawn == 1 { return }

  // Save character underneath
  var idx: u32 = console.cursor_y * CONSOLE_WIDTH + console.cursor_x
  var ptr: u64 = console.buffer as u64 + (idx * 16) as u64

  cursor_char_underneath = memory.read_u32(ptr)
  cursor_fg_underneath = memory.read_u32(ptr + 4)
  cursor_bg_underneath = memory.read_u32(ptr + 8)

  // Draw cursor (inverted colors)
  draw_char(console.cursor_x, console.cursor_y,
            cursor_char_underneath, cursor_bg_underneath, cursor_fg_underneath)

  cursor_drawn = 1
}

export fn fb_console_blink_cursor() {
  cursor_blink_timer = cursor_blink_timer + 1

  if cursor_blink_timer >= 30 {  // ~500ms at 60Hz
    cursor_blink_timer = 0

    if cursor_drawn == 1 {
      hide_cursor()
    } else {
      show_cursor()
    }
  }
}

export fn fb_console_update_cursor() {
  hide_cursor()
  show_cursor()
}

// ============================================================================
// Optimized Scrolling
// ============================================================================

// Fast scroll using hardware if available, otherwise block copy
fn fast_scroll_up() {
  total_scrolls = total_scrolls + 1

  // Try hardware scroll if available
  var hw_scrolled: u32 = framebuffer.fb_hardware_scroll(0, FONT_HEIGHT)

  if hw_scrolled == 1 {
    // Hardware scroll succeeded, just clear bottom line
    var y: u32 = console.scroll_bottom
    var x: u32 = 0
    while x < CONSOLE_WIDTH {
      var idx: u32 = y * CONSOLE_WIDTH + x
      var ptr: u64 = console.buffer as u64 + (idx * 16) as u64

      memory.write_u32(ptr, ' ' as u32)
      memory.write_u32(ptr + 4, console.fg_color)
      memory.write_u32(ptr + 8, console.bg_color)
      memory.write_u32(ptr + 12, 0)

      x = x + 1
    }

    // Clear the bottom line visually
    framebuffer.fb_fill_rect(0, console.scroll_bottom * FONT_HEIGHT,
                             CONSOLE_WIDTH * FONT_WIDTH, FONT_HEIGHT,
                             console.bg_color)
  } else {
    // Fall back to software scroll
    scroll_up()
  }
}

// ============================================================================
// Enhanced Font Support
// ============================================================================

// Initialize more complete font data
fn init_full_font() {
  // Initialize basic ASCII printable characters
  // Each character is 16 bytes (16 rows of 8 pixels)

  // Space (0x20)
  var i: u32 = 0
  while i < 16 {
    font_data[0x20 * 16 + i] = 0x00
    i = i + 1
  }

  // ! (0x21)
  font_data[0x21 * 16 + 2] = 0b00011000
  font_data[0x21 * 16 + 3] = 0b00011000
  font_data[0x21 * 16 + 4] = 0b00011000
  font_data[0x21 * 16 + 5] = 0b00011000
  font_data[0x21 * 16 + 6] = 0b00011000
  font_data[0x21 * 16 + 8] = 0b00011000
  font_data[0x21 * 16 + 9] = 0b00011000

  // Common characters patterns
  // Numbers 0-9
  font_data[0x30 * 16 + 2] = 0b00111100  // 0
  font_data[0x30 * 16 + 3] = 0b01100110
  font_data[0x30 * 16 + 4] = 0b01101110
  font_data[0x30 * 16 + 5] = 0b01110110
  font_data[0x30 * 16 + 6] = 0b01100110
  font_data[0x30 * 16 + 7] = 0b00111100

  font_data[0x31 * 16 + 2] = 0b00011000  // 1
  font_data[0x31 * 16 + 3] = 0b00111000
  font_data[0x31 * 16 + 4] = 0b00011000
  font_data[0x31 * 16 + 5] = 0b00011000
  font_data[0x31 * 16 + 6] = 0b00011000
  font_data[0x31 * 16 + 7] = 0b01111110

  // A-Z (already have A)
  // Add more letter patterns...

  foundation.serial_write_string("[FB_CONSOLE] Font initialized with basic glyphs\n")
}

// ============================================================================
// Console Statistics
// ============================================================================

export fn fb_console_get_stats(chars_out: u64, scrolls_out: u64, clears_out: u64) {
  @ptrStore(chars_out, u64, total_chars_rendered)
  @ptrStore(scrolls_out, u64, total_scrolls)
  @ptrStore(clears_out, u64, total_clears)
}

export fn fb_console_print_stats() {
  foundation.serial_write_string("[FB_CONSOLE] Statistics:\n")
  foundation.serial_write_string("  Characters rendered: ")
  foundation.serial_write_u64(total_chars_rendered)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("  Scrolls: ")
  foundation.serial_write_u64(total_scrolls)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("  Clears: ")
  foundation.serial_write_u64(total_clears)
  foundation.serial_write_string("\n")
}

// ============================================================================
// Console Modes
// ============================================================================

const MODE_NORMAL: u32 = 0
const MODE_RAW: u32 = 1        // No escape sequence processing
const MODE_LINE: u32 = 2       // Line-buffered input

var console_mode: u32 = MODE_NORMAL

export fn fb_console_set_mode(mode: u32) {
  console_mode = mode
}

export fn fb_console_get_mode(): u32 {
  return console_mode
}

// ============================================================================
// Screen Buffer Management
// ============================================================================

// Save/restore screen for applications
var saved_buffer: [80 * 25 * 16]u8
var saved_cursor_x: u32 = 0
var saved_cursor_y: u32 = 0
var buffer_saved: u32 = 0

export fn fb_console_save_screen() {
  if initialized == 0 { return }

  var i: u32 = 0
  while i < CONSOLE_WIDTH * CONSOLE_HEIGHT * 16 {
    saved_buffer[i] = @ptrLoad(console.buffer as u64 + i, u8)
    i = i + 1
  }

  saved_cursor_x = console.cursor_x
  saved_cursor_y = console.cursor_y
  buffer_saved = 1

  foundation.serial_write_string("[FB_CONSOLE] Screen saved\n")
}

export fn fb_console_restore_screen() {
  if initialized == 0 { return }
  if buffer_saved == 0 { return }

  var i: u32 = 0
  while i < CONSOLE_WIDTH * CONSOLE_HEIGHT * 16 {
    @ptrStore(console.buffer as u64 + i, u8, saved_buffer[i])
    i = i + 1
  }

  console.cursor_x = saved_cursor_x
  console.cursor_y = saved_cursor_y

  fb_console_refresh()

  foundation.serial_write_string("[FB_CONSOLE] Screen restored\n")
}

// ============================================================================
// Color Themes
// ============================================================================

const THEME_DARK: u32 = 0
const THEME_LIGHT: u32 = 1
const THEME_SOLARIZED: u32 = 2
const THEME_MONOKAI: u32 = 3

var current_theme: u32 = THEME_DARK

export fn fb_console_set_theme(theme: u32) {
  current_theme = theme

  if theme == THEME_DARK {
    console.fg_color = COLOR_WHITE
    console.bg_color = COLOR_BLACK
  } else if theme == THEME_LIGHT {
    console.fg_color = COLOR_BLACK
    console.bg_color = COLOR_WHITE
  } else if theme == THEME_SOLARIZED {
    console.fg_color = 0xFF839496  // Solarized base0
    console.bg_color = 0xFF002B36  // Solarized base03
  } else if theme == THEME_MONOKAI {
    console.fg_color = 0xFFF8F8F2  // Monokai foreground
    console.bg_color = 0xFF272822  // Monokai background
  }

  fb_console_clear()

  foundation.serial_write_string("[FB_CONSOLE] Theme changed to ")
  foundation.serial_write_u64(theme)
  foundation.serial_write_string("\n")
}

export fn fb_console_get_theme(): u32 {
  return current_theme
}

// ============================================================================
// Low-CPU Headless Mode
// ============================================================================

var headless_mode: u32 = 0

export fn fb_console_set_headless(enable: u32) {
  headless_mode = enable

  if enable == 1 {
    foundation.serial_write_string("[FB_CONSOLE] Headless mode enabled (no FB updates)\n")
  } else {
    foundation.serial_write_string("[FB_CONSOLE] Headless mode disabled\n")
    fb_console_refresh()
  }
}

export fn fb_console_is_headless(): u32 {
  return headless_mode
}
