// HomeOS Touchscreen Driver
// Multi-touch capacitive touchscreen support

const basics = @import("basics")
const i2c = @import("drivers/i2c")
const input = @import("drivers/input/core")

// ============================================
// Touchscreen Types
// ============================================

const TS_TYPE_I2C: u8 = 0
const TS_TYPE_USB: u8 = 1
const TS_TYPE_SPI: u8 = 2

// ============================================
// Touch Event Types
// ============================================

const TOUCH_DOWN: u8 = 0
const TOUCH_UP: u8 = 1
const TOUCH_MOVE: u8 = 2
const TOUCH_CANCEL: u8 = 3

// ============================================
// Touch Point
// ============================================

const MAX_TS_TOUCH_POINTS: u32 = 10

struct TSPoint {
    id: u8
    event: u8
    x: u16
    y: u16
    pressure: u16
    area: u16
    orientation: i8
}

// ============================================
// Touchscreen Calibration
// ============================================

struct TouchscreenCalibration {
    // 3x3 transformation matrix (fixed point, 16.16)
    a: [3]i32
    b: [3]i32
    c: [3]i32

    // Pressure calibration
    pressure_min: u16
    pressure_max: u16

    // Valid flag
    calibrated: bool
}

// ============================================
// Touchscreen State
// ============================================

struct TouchscreenState {
    // Hardware info
    ts_type: u8
    vendor_id: u16
    product_id: u16
    firmware_version: u32

    // Physical dimensions (in 0.1mm)
    physical_width: u16
    physical_height: u16

    // Resolution
    x_res: u16
    y_res: u16

    // Current touches
    touches: [MAX_TS_TOUCH_POINTS]TSPoint
    num_touches: u8
    prev_touches: [MAX_TS_TOUCH_POINTS]TSPoint
    prev_num_touches: u8

    // Calibration
    calibration: TouchscreenCalibration

    // Configuration
    flip_x: bool
    flip_y: bool
    swap_xy: bool

    // Input device
    input_dev: *input.InputDevice

    // I2C info
    i2c_bus: u8
    i2c_addr: u8
    irq: u8

    // Statistics
    total_touches: u64
    total_events: u64
}

// ============================================
// Global State
// ============================================

const MAX_TOUCHSCREENS: u32 = 4
var touchscreens: [MAX_TOUCHSCREENS]TouchscreenState = undefined
var num_touchscreens: u32 = 0

// ============================================
// Initialization
// ============================================

export fn touchscreen_init(): void {
    basics.print("[TOUCHSCREEN] Initializing touchscreen driver\n")

    var i: u32 = 0
    while i < MAX_TOUCHSCREENS {
        touchscreens[i].input_dev = null
        touchscreens[i].calibration.calibrated = false
        touchscreens[i].flip_x = false
        touchscreens[i].flip_y = false
        touchscreens[i].swap_xy = false
        i = i + 1
    }

    // Probe for known touchscreen controllers
    probe_goodix()
    probe_ft5x06()
    probe_atmel_mxt()

    basics.print("[TOUCHSCREEN] Driver initialized, found ")
    basics.print_u32(num_touchscreens)
    basics.print(" touchscreen(s)\n")
}

// ============================================
// Goodix GT911/GT928/GT9xx Family
// ============================================

const GOODIX_ADDR1: u8 = 0x5D
const GOODIX_ADDR2: u8 = 0x14

fn probe_goodix(): void {
    const addresses = [_]u8{ GOODIX_ADDR1, GOODIX_ADDR2 }

    var i: u32 = 0
    while i < addresses.len {
        if i2c.probe_device(0, addresses[i]) {
            // Read product ID
            var product_id: [4]u8 = undefined
            if i2c.read_register(0, addresses[i], 0x8140, &product_id, 4) == 0 {
                // Check for valid Goodix ID (starts with 9)
                if product_id[0] == '9' {
                    init_goodix(addresses[i])
                    return
                }
            }
        }
        i = i + 1
    }
}

fn init_goodix(addr: u8): void {
    if num_touchscreens >= MAX_TOUCHSCREENS {
        return
    }

    let ts = &touchscreens[num_touchscreens]

    ts.ts_type = TS_TYPE_I2C
    ts.i2c_bus = 0
    ts.i2c_addr = addr
    ts.vendor_id = 0x0416  // Goodix

    // Read configuration
    var config: [186]u8 = undefined
    i2c.read_register(0, addr, 0x8047, &config, 186)

    ts.x_res = (config[2] as u16 << 8) | config[1] as u16
    ts.y_res = (config[4] as u16 << 8) | config[3] as u16

    if ts.x_res == 0 { ts.x_res = 1024 }
    if ts.y_res == 0 { ts.y_res = 600 }

    // Initialize touches
    var i: u32 = 0
    while i < MAX_TS_TOUCH_POINTS {
        ts.touches[i].event = TOUCH_UP
        ts.prev_touches[i].event = TOUCH_UP
        i = i + 1
    }

    // Register input device
    ts.input_dev = input.register_device(input.INPUT_TYPE_TOUCHSCREEN, "Goodix Touch")
    if ts.input_dev == null {
        return
    }

    setup_input_device(ts)

    // Enable interrupt mode
    i2c.write_register(0, addr, 0x8040, 0)

    num_touchscreens = num_touchscreens + 1
    basics.print("[TOUCHSCREEN] Goodix controller found at 0x")
    basics.print_hex8(addr)
    basics.print("\n")
}

// ============================================
// FocalTech FT5x06/FT6x06 Family
// ============================================

const FT5X06_ADDR: u8 = 0x38

fn probe_ft5x06(): void {
    if i2c.probe_device(0, FT5X06_ADDR) {
        var chip_id: u8 = 0
        if i2c.read_register(0, FT5X06_ADDR, 0xA3, &chip_id, 1) == 0 {
            // Valid FT5x06 chip IDs
            if chip_id == 0x55 or chip_id == 0x08 or chip_id == 0x0A {
                init_ft5x06(chip_id)
            }
        }
    }
}

fn init_ft5x06(chip_id: u8): void {
    if num_touchscreens >= MAX_TOUCHSCREENS {
        return
    }

    let ts = &touchscreens[num_touchscreens]

    ts.ts_type = TS_TYPE_I2C
    ts.i2c_bus = 0
    ts.i2c_addr = FT5X06_ADDR
    ts.vendor_id = 0x2808  // FocalTech
    ts.product_id = chip_id as u16

    // Read firmware version
    var fw_ver: u8 = 0
    i2c.read_register(0, FT5X06_ADDR, 0xA6, &fw_ver, 1)
    ts.firmware_version = fw_ver as u32

    // Default resolution (device specific)
    ts.x_res = 800
    ts.y_res = 480

    // Initialize touches
    var i: u32 = 0
    while i < MAX_TS_TOUCH_POINTS {
        ts.touches[i].event = TOUCH_UP
        ts.prev_touches[i].event = TOUCH_UP
        i = i + 1
    }

    // Register input device
    ts.input_dev = input.register_device(input.INPUT_TYPE_TOUCHSCREEN, "FT5x06 Touch")
    if ts.input_dev == null {
        return
    }

    setup_input_device(ts)

    // Set device mode to normal
    i2c.write_register(0, FT5X06_ADDR, 0x00, 0x00)

    num_touchscreens = num_touchscreens + 1
    basics.print("[TOUCHSCREEN] FocalTech FT5x06 found\n")
}

// ============================================
// Atmel maXTouch Family
// ============================================

const MXT_ADDR1: u8 = 0x4A
const MXT_ADDR2: u8 = 0x4B

fn probe_atmel_mxt(): void {
    const addresses = [_]u8{ MXT_ADDR1, MXT_ADDR2 }

    var i: u32 = 0
    while i < addresses.len {
        if i2c.probe_device(0, addresses[i]) {
            var info: [7]u8 = undefined
            if i2c.read_register(0, addresses[i], 0x00, &info, 7) == 0 {
                // Check family ID
                if info[0] == 0xA4 or info[0] == 0x82 {
                    init_atmel_mxt(addresses[i], &info)
                    return
                }
            }
        }
        i = i + 1
    }
}

fn init_atmel_mxt(addr: u8, info: *[7]u8): void {
    if num_touchscreens >= MAX_TOUCHSCREENS {
        return
    }

    let ts = &touchscreens[num_touchscreens]

    ts.ts_type = TS_TYPE_I2C
    ts.i2c_bus = 0
    ts.i2c_addr = addr
    ts.vendor_id = 0x03EB  // Atmel
    ts.product_id = (info[2] as u16 << 8) | info[1] as u16
    ts.firmware_version = (info[3] as u32 << 8) | info[4] as u32

    // Default resolution
    ts.x_res = 1024
    ts.y_res = 768

    // Initialize touches
    var i: u32 = 0
    while i < MAX_TS_TOUCH_POINTS {
        ts.touches[i].event = TOUCH_UP
        ts.prev_touches[i].event = TOUCH_UP
        i = i + 1
    }

    // Register input device
    ts.input_dev = input.register_device(input.INPUT_TYPE_TOUCHSCREEN, "Atmel maXTouch")
    if ts.input_dev == null {
        return
    }

    setup_input_device(ts)

    num_touchscreens = num_touchscreens + 1
    basics.print("[TOUCHSCREEN] Atmel maXTouch found\n")
}

// ============================================
// Common Setup
// ============================================

fn setup_input_device(ts: *TouchscreenState): void {
    // Capabilities
    input.set_capability(ts.input_dev, input.EV_KEY, input.BTN_TOUCH)
    input.set_capability(ts.input_dev, input.EV_ABS, input.ABS_X)
    input.set_capability(ts.input_dev, input.EV_ABS, input.ABS_Y)
    input.set_capability(ts.input_dev, input.EV_ABS, input.ABS_PRESSURE)
    input.set_capability(ts.input_dev, input.EV_ABS, input.ABS_MT_SLOT)
    input.set_capability(ts.input_dev, input.EV_ABS, input.ABS_MT_POSITION_X)
    input.set_capability(ts.input_dev, input.EV_ABS, input.ABS_MT_POSITION_Y)
    input.set_capability(ts.input_dev, input.EV_ABS, input.ABS_MT_TRACKING_ID)
    input.set_capability(ts.input_dev, input.EV_ABS, input.ABS_MT_TOUCH_MAJOR)
    input.set_capability(ts.input_dev, input.EV_ABS, input.ABS_MT_PRESSURE)

    // Axis info
    input.set_abs_info(ts.input_dev, input.ABS_X, 0, ts.x_res as i32 - 1, 0, 0)
    input.set_abs_info(ts.input_dev, input.ABS_Y, 0, ts.y_res as i32 - 1, 0, 0)
    input.set_abs_info(ts.input_dev, input.ABS_PRESSURE, 0, 255, 0, 0)
    input.set_abs_info(ts.input_dev, input.ABS_MT_SLOT, 0, MAX_TS_TOUCH_POINTS as i32 - 1, 0, 0)
    input.set_abs_info(ts.input_dev, input.ABS_MT_POSITION_X, 0, ts.x_res as i32 - 1, 0, 0)
    input.set_abs_info(ts.input_dev, input.ABS_MT_POSITION_Y, 0, ts.y_res as i32 - 1, 0, 0)
    input.set_abs_info(ts.input_dev, input.ABS_MT_TRACKING_ID, 0, 65535, 0, 0)
    input.set_abs_info(ts.input_dev, input.ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0)
    input.set_abs_info(ts.input_dev, input.ABS_MT_PRESSURE, 0, 255, 0, 0)
}

// ============================================
// Polling
// ============================================

export fn touchscreen_poll(): void {
    var i: u32 = 0
    while i < num_touchscreens {
        let ts = &touchscreens[i]

        if ts.vendor_id == 0x0416 {  // Goodix
            poll_goodix(ts)
        } else if ts.vendor_id == 0x2808 {  // FocalTech
            poll_ft5x06(ts)
        } else if ts.vendor_id == 0x03EB {  // Atmel
            poll_atmel_mxt(ts)
        }

        i = i + 1
    }
}

fn poll_goodix(ts: *TouchscreenState): void {
    var status: u8 = 0
    i2c.read_register(0, ts.i2c_addr, 0x814E, &status, 1)

    if (status & 0x80) == 0 {
        return  // No new data
    }

    // Save previous state
    ts.prev_num_touches = ts.num_touches
    var i: u32 = 0
    while i < MAX_TS_TOUCH_POINTS {
        ts.prev_touches[i] = ts.touches[i]
        i = i + 1
    }

    ts.num_touches = status & 0x0F
    if ts.num_touches > MAX_TS_TOUCH_POINTS as u8 {
        ts.num_touches = MAX_TS_TOUCH_POINTS as u8
    }

    // Read touch data
    var touch_data: [80]u8 = undefined
    i2c.read_register(0, ts.i2c_addr, 0x8150, &touch_data, ts.num_touches as u32 * 8)

    i = 0
    while i < ts.num_touches as u32 {
        let offset = i * 8
        let touch = &ts.touches[i]

        touch.id = touch_data[offset] & 0x0F
        touch.x = (touch_data[offset + 2] as u16 << 8) | touch_data[offset + 1] as u16
        touch.y = (touch_data[offset + 4] as u16 << 8) | touch_data[offset + 3] as u16
        touch.area = (touch_data[offset + 6] as u16 << 8) | touch_data[offset + 5] as u16
        touch.pressure = 128  // Goodix doesn't report pressure

        // Determine event type
        if find_prev_touch(ts, touch.id) == null {
            touch.event = TOUCH_DOWN
            ts.total_touches = ts.total_touches + 1
        } else {
            touch.event = TOUCH_MOVE
        }

        i = i + 1
    }

    // Mark lifted touches
    i = 0
    while i < ts.prev_num_touches as u32 {
        let prev_id = ts.prev_touches[i].id
        if not touch_active(ts, prev_id) {
            // This touch was lifted
            var j: u32 = 0
            while j < MAX_TS_TOUCH_POINTS {
                if not ts.touches[j].event == TOUCH_DOWN and not ts.touches[j].event == TOUCH_MOVE {
                    ts.touches[j].id = prev_id
                    ts.touches[j].event = TOUCH_UP
                    ts.touches[j].x = ts.prev_touches[i].x
                    ts.touches[j].y = ts.prev_touches[i].y
                    break
                }
                j = j + 1
            }
        }
        i = i + 1
    }

    // Clear status
    i2c.write_register(0, ts.i2c_addr, 0x814E, 0)

    // Report events
    report_touch_events(ts)
}

fn poll_ft5x06(ts: *TouchscreenState): void {
    var data: [31]u8 = undefined

    if i2c.read_register(0, ts.i2c_addr, 0x00, &data, 31) != 0 {
        return
    }

    // Save previous state
    ts.prev_num_touches = ts.num_touches
    var i: u32 = 0
    while i < MAX_TS_TOUCH_POINTS {
        ts.prev_touches[i] = ts.touches[i]
        i = i + 1
    }

    ts.num_touches = data[2] & 0x0F
    if ts.num_touches > 5 {
        ts.num_touches = 5  // FT5x06 supports max 5 touches
    }

    i = 0
    while i < ts.num_touches as u32 {
        let offset = 3 + i * 6
        let touch = &ts.touches[i]

        touch.event = (data[offset] >> 6) & 0x03
        touch.id = (data[offset + 2] >> 4) & 0x0F
        touch.x = ((data[offset] & 0x0F) as u16 << 8) | data[offset + 1] as u16
        touch.y = ((data[offset + 2] & 0x0F) as u16 << 8) | data[offset + 3] as u16
        touch.pressure = data[offset + 4] as u16
        touch.area = data[offset + 5] as u16

        if touch.event == 0 {
            touch.event = TOUCH_DOWN
            ts.total_touches = ts.total_touches + 1
        } else if touch.event == 2 {
            touch.event = TOUCH_MOVE
        } else {
            touch.event = TOUCH_UP
        }

        i = i + 1
    }

    report_touch_events(ts)
}

fn poll_atmel_mxt(ts: *TouchscreenState): void {
    // Atmel uses message-based protocol
    var msg: [8]u8 = undefined

    // Read message count
    var count: u8 = 0
    if i2c.read_register(0, ts.i2c_addr, 0x0100, &count, 1) != 0 {
        return
    }

    if count == 0 {
        return
    }

    // Save previous state
    ts.prev_num_touches = ts.num_touches
    var i: u32 = 0
    while i < MAX_TS_TOUCH_POINTS {
        ts.prev_touches[i] = ts.touches[i]
        i = i + 1
    }

    // Process messages
    var touch_idx: u8 = 0
    i = 0
    while i < count as u32 and i < 10 {
        if i2c.read_register(0, ts.i2c_addr, 0x0101, &msg, 8) != 0 {
            break
        }

        let report_id = msg[0]
        if report_id >= 2 and report_id < 12 {  // Touch reports
            let touch = &ts.touches[touch_idx]

            touch.id = report_id - 2
            touch.event = if (msg[1] & 0x20) != 0 { TOUCH_DOWN } else if (msg[1] & 0x40) != 0 { TOUCH_UP } else { TOUCH_MOVE }
            touch.x = (msg[3] as u16 << 4) | ((msg[5] >> 4) as u16)
            touch.y = (msg[4] as u16 << 4) | (msg[5] & 0x0F) as u16
            touch.area = msg[6] as u16
            touch.pressure = msg[7] as u16

            if touch.event == TOUCH_DOWN {
                ts.total_touches = ts.total_touches + 1
            }

            touch_idx = touch_idx + 1
        }

        i = i + 1
    }

    ts.num_touches = touch_idx
    report_touch_events(ts)
}

// ============================================
// Event Reporting
// ============================================

fn report_touch_events(ts: *TouchscreenState): void {
    var any_touch: bool = false

    var i: u32 = 0
    while i < MAX_TS_TOUCH_POINTS {
        let touch = &ts.touches[i]

        if touch.event == TOUCH_DOWN or touch.event == TOUCH_MOVE or touch.event == TOUCH_UP {
            // Apply calibration
            var x = touch.x
            var y = touch.y
            apply_calibration(ts, &x, &y)

            // Apply transformations
            if ts.swap_xy {
                let tmp = x
                x = y
                y = tmp
            }
            if ts.flip_x {
                x = ts.x_res - 1 - x
            }
            if ts.flip_y {
                y = ts.y_res - 1 - y
            }

            input.report_abs(ts.input_dev, input.ABS_MT_SLOT, touch.id as i32)

            if touch.event == TOUCH_UP {
                input.report_abs(ts.input_dev, input.ABS_MT_TRACKING_ID, -1)
            } else {
                input.report_abs(ts.input_dev, input.ABS_MT_TRACKING_ID, touch.id as i32)
                input.report_abs(ts.input_dev, input.ABS_MT_POSITION_X, x as i32)
                input.report_abs(ts.input_dev, input.ABS_MT_POSITION_Y, y as i32)
                input.report_abs(ts.input_dev, input.ABS_MT_PRESSURE, touch.pressure as i32)
                input.report_abs(ts.input_dev, input.ABS_MT_TOUCH_MAJOR, touch.area as i32)
                any_touch = true
            }

            ts.total_events = ts.total_events + 1
        }

        i = i + 1
    }

    // Report primary touch
    if any_touch {
        i = 0
        while i < MAX_TS_TOUCH_POINTS {
            if ts.touches[i].event == TOUCH_DOWN or ts.touches[i].event == TOUCH_MOVE {
                var x = ts.touches[i].x
                var y = ts.touches[i].y
                apply_calibration(ts, &x, &y)

                if ts.swap_xy {
                    let tmp = x
                    x = y
                    y = tmp
                }
                if ts.flip_x { x = ts.x_res - 1 - x }
                if ts.flip_y { y = ts.y_res - 1 - y }

                input.report_abs(ts.input_dev, input.ABS_X, x as i32)
                input.report_abs(ts.input_dev, input.ABS_Y, y as i32)
                input.report_abs(ts.input_dev, input.ABS_PRESSURE, ts.touches[i].pressure as i32)
                break
            }
            i = i + 1
        }
        input.report_key(ts.input_dev, input.BTN_TOUCH, true)
    } else {
        input.report_key(ts.input_dev, input.BTN_TOUCH, false)
        input.report_abs(ts.input_dev, input.ABS_PRESSURE, 0)
    }

    input.report_sync(ts.input_dev)
}

fn find_prev_touch(ts: *TouchscreenState, id: u8): *TSPoint {
    var i: u32 = 0
    while i < ts.prev_num_touches as u32 {
        if ts.prev_touches[i].id == id {
            return &ts.prev_touches[i]
        }
        i = i + 1
    }
    return null
}

fn touch_active(ts: *TouchscreenState, id: u8): bool {
    var i: u32 = 0
    while i < ts.num_touches as u32 {
        if ts.touches[i].id == id and (ts.touches[i].event == TOUCH_DOWN or ts.touches[i].event == TOUCH_MOVE) {
            return true
        }
        i = i + 1
    }
    return false
}

// ============================================
// Calibration
// ============================================

fn apply_calibration(ts: *TouchscreenState, x: *u16, y: *u16): void {
    if not ts.calibration.calibrated {
        return
    }

    let cal = &ts.calibration
    let xi = *x as i32
    let yi = *y as i32

    // Apply 3x3 transformation
    let nx = (cal.a[0] * xi + cal.a[1] * yi + cal.a[2]) >> 16
    let ny = (cal.b[0] * xi + cal.b[1] * yi + cal.b[2]) >> 16

    *x = if nx < 0 { 0 } else if nx >= ts.x_res as i32 { ts.x_res - 1 } else { nx as u16 }
    *y = if ny < 0 { 0 } else if ny >= ts.y_res as i32 { ts.y_res - 1 } else { ny as u16 }
}

export fn touchscreen_calibrate(ts_id: u32, points: *[3][2]u16, targets: *[3][2]u16): bool {
    if ts_id >= num_touchscreens {
        return false
    }

    let ts = &touchscreens[ts_id]
    let cal = &ts.calibration

    // Calculate calibration matrix using 3-point algorithm
    let x0 = points[0][0] as i32
    let y0 = points[0][1] as i32
    let x1 = points[1][0] as i32
    let y1 = points[1][1] as i32
    let x2 = points[2][0] as i32
    let y2 = points[2][1] as i32

    let tx0 = targets[0][0] as i32
    let ty0 = targets[0][1] as i32
    let tx1 = targets[1][0] as i32
    let ty1 = targets[1][1] as i32
    let tx2 = targets[2][0] as i32
    let ty2 = targets[2][1] as i32

    let div = (x0 - x2) * (y1 - y2) - (x1 - x2) * (y0 - y2)
    if div == 0 {
        return false
    }

    // Fixed point 16.16
    cal.a[0] = ((tx0 - tx2) * (y1 - y2) - (tx1 - tx2) * (y0 - y2)) * 65536 / div
    cal.a[1] = ((tx1 - tx2) * (x0 - x2) - (tx0 - tx2) * (x1 - x2)) * 65536 / div
    cal.a[2] = (tx0 * (x1 * y2 - x2 * y1) - tx1 * (x0 * y2 - x2 * y0) + tx2 * (x0 * y1 - x1 * y0)) * 65536 / div

    cal.b[0] = ((ty0 - ty2) * (y1 - y2) - (ty1 - ty2) * (y0 - y2)) * 65536 / div
    cal.b[1] = ((ty1 - ty2) * (x0 - x2) - (ty0 - ty2) * (x1 - x2)) * 65536 / div
    cal.b[2] = (ty0 * (x1 * y2 - x2 * y1) - ty1 * (x0 * y2 - x2 * y0) + ty2 * (x0 * y1 - x1 * y0)) * 65536 / div

    cal.calibrated = true
    return true
}

// ============================================
// Configuration
// ============================================

export fn touchscreen_set_flip(ts_id: u32, flip_x: bool, flip_y: bool): bool {
    if ts_id >= num_touchscreens {
        return false
    }
    touchscreens[ts_id].flip_x = flip_x
    touchscreens[ts_id].flip_y = flip_y
    return true
}

export fn touchscreen_set_swap_xy(ts_id: u32, swap: bool): bool {
    if ts_id >= num_touchscreens {
        return false
    }
    touchscreens[ts_id].swap_xy = swap
    return true
}

export fn touchscreen_get_count(): u32 {
    return num_touchscreens
}

export fn touchscreen_get_resolution(ts_id: u32, x: *u16, y: *u16): bool {
    if ts_id >= num_touchscreens {
        return false
    }
    *x = touchscreens[ts_id].x_res
    *y = touchscreens[ts_id].y_res
    return true
}
