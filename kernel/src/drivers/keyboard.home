// home-os Kernel - PS/2 Keyboard Driver
// Real implementation for keyboard input

import "../core/foundation.home" as foundation

// ============================================================================
// CONSTANTS
// ============================================================================

const KEYBOARD_DATA_PORT: u16 = 0x60
const KEYBOARD_STATUS_PORT: u16 = 0x64
const KEYBOARD_COMMAND_PORT: u16 = 0x64

const KEYBOARD_BUFFER_SIZE: u32 = 256

// Keyboard commands
const CMD_SET_LED: u8 = 0xED
const CMD_ECHO: u8 = 0xEE
const CMD_SCANCODE: u8 = 0xF0
const CMD_IDENTIFY: u8 = 0xF2
const CMD_TYPEMATIC: u8 = 0xF3
const CMD_ENABLE: u8 = 0xF4
const CMD_DISABLE: u8 = 0xF5
const CMD_RESET: u8 = 0xFF

// Special keys
const KEY_ESC: u8 = 1
const KEY_BACKSPACE: u8 = 14
const KEY_TAB: u8 = 15
const KEY_ENTER: u8 = 28
const KEY_CTRL: u8 = 29
const KEY_LSHIFT: u8 = 42
const KEY_RSHIFT: u8 = 54
const KEY_ALT: u8 = 56
const KEY_CAPS: u8 = 58

// ============================================================================
// SCANCODE TO ASCII MAPPING
// ============================================================================

const SCANCODE_TO_ASCII: [u8; 128] = [
  0,    27,  '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', '\b',
  '\t', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\n',
  0,    'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', '`',
  0,    '\\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 0,
  '*',  0,   ' ', 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,    0,   0,   0,   0,   0,   0,   0
]

const SCANCODE_TO_ASCII_SHIFT: [u8; 128] = [
  0,    27,  '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', '\b',
  '\t', 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', '\n',
  0,    'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '"', '~',
  0,    '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '<', '>', '?', 0,
  '*',  0,   ' ', 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,    0,   0,   0,   0,   0,   0,   0
]

// ============================================================================
// KEYBOARD STATE
// ============================================================================

var keyboard_buffer: [u8; 256]
var buffer_read_pos: u32 = 0
var buffer_write_pos: u32 = 0
var buffer_count: u32 = 0

var shift_pressed: u32 = 0
var ctrl_pressed: u32 = 0
var alt_pressed: u32 = 0
var caps_lock: u32 = 0

var keyboard_initialized: u32 = 0

// ============================================================================
// KEYBOARD CONTROLLER
// ============================================================================

fn keyboard_wait_input() {
  var timeout: u32 = 100000
  while timeout > 0 {
    var status: u8 = foundation.inb(KEYBOARD_STATUS_PORT)
    if (status & 0x02) == 0 {
      return
    }
    timeout = timeout - 1
  }
}

fn keyboard_wait_output() {
  var timeout: u32 = 100000
  while timeout > 0 {
    var status: u8 = foundation.inb(KEYBOARD_STATUS_PORT)
    if (status & 0x01) != 0 {
      return
    }
    timeout = timeout - 1
  }
}

fn keyboard_send_command(cmd: u8) {
  keyboard_wait_input()
  foundation.outb(KEYBOARD_COMMAND_PORT, cmd)
}

fn keyboard_send_data(data: u8) {
  keyboard_wait_input()
  foundation.outb(KEYBOARD_DATA_PORT, data)
}

fn keyboard_read_data() -> u8 {
  keyboard_wait_output()
  return foundation.inb(KEYBOARD_DATA_PORT)
}

// ============================================================================
// KEYBOARD INITIALIZATION
// ============================================================================

export fn keyboard_init() {
  if keyboard_initialized == 1 { return }
  
  // Disable keyboard
  keyboard_send_command(0xAD)
  
  // Flush output buffer
  foundation.inb(KEYBOARD_DATA_PORT)
  
  // Set controller configuration
  keyboard_send_command(0x20)
  var config: u8 = keyboard_read_data()
  config = config | 0x01  // Enable interrupt
  config = config & ~0x10 // Enable keyboard clock
  keyboard_send_command(0x60)
  keyboard_send_data(config)
  
  // Enable keyboard
  keyboard_send_command(0xAE)
  
  // Reset keyboard
  keyboard_send_data(CMD_RESET)
  var response: u8 = keyboard_read_data()
  
  if response == 0xFA {
    // ACK received, wait for self-test result
    response = keyboard_read_data()
    if response == 0xAA {
      foundation.serial_write_string("[Keyboard] Self-test passed\n")
    }
  }
  
  // Enable scanning
  keyboard_send_data(CMD_ENABLE)
  keyboard_read_data()  // Read ACK
  
  // Clear buffer
  buffer_read_pos = 0
  buffer_write_pos = 0
  buffer_count = 0
  
  keyboard_initialized = 1
  foundation.serial_write_string("[Keyboard] Initialized\n")
}

// ============================================================================
// SCANCODE PROCESSING
// ============================================================================

fn keyboard_process_scancode(scancode: u8) {
  // Check for key release (bit 7 set)
  if (scancode & 0x80) != 0 {
    var key: u8 = scancode & 0x7F
    
    // Handle modifier keys
    if key == KEY_LSHIFT or key == KEY_RSHIFT {
      shift_pressed = 0
    } else if key == KEY_CTRL {
      ctrl_pressed = 0
    } else if key == KEY_ALT {
      alt_pressed = 0
    }
    
    return
  }
  
  // Key press
  var key: u8 = scancode
  
  // Handle modifier keys
  if key == KEY_LSHIFT or key == KEY_RSHIFT {
    shift_pressed = 1
    return
  } else if key == KEY_CTRL {
    ctrl_pressed = 1
    return
  } else if key == KEY_ALT {
    alt_pressed = 1
    return
  } else if key == KEY_CAPS {
    caps_lock = caps_lock ^ 1  // Toggle
    return
  }
  
  // Convert scancode to ASCII
  var ascii: u8 = 0
  
  if shift_pressed == 1 {
    ascii = SCANCODE_TO_ASCII_SHIFT[key]
  } else {
    ascii = SCANCODE_TO_ASCII[key]
    
    // Handle caps lock for letters
    if caps_lock == 1 {
      if ascii >= 'a' and ascii <= 'z' {
        ascii = ascii - 32  // Convert to uppercase
      }
    }
  }
  
  // Add to buffer if valid
  if ascii != 0 {
    keyboard_buffer_add(ascii)
  }
}

// ============================================================================
// KEYBOARD BUFFER
// ============================================================================

fn keyboard_buffer_add(ch: u8) {
  if buffer_count >= KEYBOARD_BUFFER_SIZE {
    return  // Buffer full
  }
  
  keyboard_buffer[buffer_write_pos] = ch
  buffer_write_pos = (buffer_write_pos + 1) % KEYBOARD_BUFFER_SIZE
  buffer_count = buffer_count + 1
}

export fn keyboard_getchar() -> u8 {
  if buffer_count == 0 {
    return 0  // No character available
  }
  
  var ch: u8 = keyboard_buffer[buffer_read_pos]
  buffer_read_pos = (buffer_read_pos + 1) % KEYBOARD_BUFFER_SIZE
  buffer_count = buffer_count - 1
  
  return ch
}

export fn keyboard_has_char() -> u32 {
  return buffer_count > 0
}

export fn keyboard_getline(buffer: u64, max_len: u32) -> u32 {
  var len: u32 = 0
  
  while len < max_len - 1 {
    // Wait for character
    while keyboard_has_char() == 0 {}
    
    var ch: u8 = keyboard_getchar()
    
    if ch == '\n' {
      break
    } else if ch == '\b' {
      // Backspace
      if len > 0 {
        len = len - 1
        foundation.serial_write_char('\b')
        foundation.serial_write_char(' ')
        foundation.serial_write_char('\b')
        foundation.vga_write_char('\b')
        foundation.vga_write_char(' ')
        foundation.vga_write_char('\b')
      }
    } else {
      @ptrToInt(buffer + len, u8) = ch
      len = len + 1
      
      // Echo character
      foundation.serial_write_char(ch)
      foundation.vga_write_char(ch)
    }
  }
  
  // Null terminate
  @ptrToInt(buffer + len, u8) = 0
  
  // Echo newline
  foundation.serial_write_char('\n')
  foundation.vga_write_char('\n')
  
  return len
}

// ============================================================================
// INTERRUPT HANDLER
// ============================================================================

export fn keyboard_interrupt_handler() {
  var scancode: u8 = foundation.inb(KEYBOARD_DATA_PORT)
  keyboard_process_scancode(scancode)
}

// ============================================================================
// LED CONTROL
// ============================================================================

export fn keyboard_set_leds(scroll_lock: u32, num_lock: u32, caps_lock_led: u32) {
  var led_byte: u8 = 0
  
  if scroll_lock != 0 { led_byte = led_byte | 0x01 }
  if num_lock != 0 { led_byte = led_byte | 0x02 }
  if caps_lock_led != 0 { led_byte = led_byte | 0x04 }
  
  keyboard_send_data(CMD_SET_LED)
  keyboard_read_data()  // Read ACK
  keyboard_send_data(led_byte)
  keyboard_read_data()  // Read ACK
}
