// home-os PCIe Extended Capabilities
// Advanced PCIe features including AER, SRIOV, TLP Processing, and more

import "../core/foundation.home" as foundation
import "pci.home" as pci

// Extended Capability IDs (PCIe Extended Config Space at 0x100+)
const PCIE_EXT_CAP_AER: u16 = 0x0001        // Advanced Error Reporting
const PCIE_EXT_CAP_VC: u16 = 0x0002         // Virtual Channel
const PCIE_EXT_CAP_DSN: u16 = 0x0003        // Device Serial Number
const PCIE_EXT_CAP_PWR: u16 = 0x0004        // Power Budgeting
const PCIE_EXT_CAP_RCLD: u16 = 0x0005       // Root Complex Link Declaration
const PCIE_EXT_CAP_RCILC: u16 = 0x0006      // Root Complex Internal Link Control
const PCIE_EXT_CAP_RCEC: u16 = 0x0007       // Root Complex Event Collector
const PCIE_EXT_CAP_MFVC: u16 = 0x0008       // Multi-Function Virtual Channel
const PCIE_EXT_CAP_VC9: u16 = 0x0009        // Virtual Channel (9)
const PCIE_EXT_CAP_RCRB: u16 = 0x000A       // Root Complex Register Block
const PCIE_EXT_CAP_VNDR: u16 = 0x000B       // Vendor Specific Extended Capability
const PCIE_EXT_CAP_CAC: u16 = 0x000C        // Configuration Access Correlation
const PCIE_EXT_CAP_ACS: u16 = 0x000D        // Access Control Services
const PCIE_EXT_CAP_ARI: u16 = 0x000E        // Alternative Routing-ID Interpretation
const PCIE_EXT_CAP_ATS: u16 = 0x000F        // Address Translation Services
const PCIE_EXT_CAP_SRIOV: u16 = 0x0010      // Single Root I/O Virtualization
const PCIE_EXT_CAP_MRIOV: u16 = 0x0011      // Multi-Root I/O Virtualization
const PCIE_EXT_CAP_MCAST: u16 = 0x0012      // Multicast
const PCIE_EXT_CAP_PRI: u16 = 0x0013        // Page Request Interface
const PCIE_EXT_CAP_RESBAR: u16 = 0x0015     // Resizable BAR
const PCIE_EXT_CAP_DPA: u16 = 0x0016        // Dynamic Power Allocation
const PCIE_EXT_CAP_TPH: u16 = 0x0017        // TPH Requester
const PCIE_EXT_CAP_LTR: u16 = 0x0018        // Latency Tolerance Reporting
const PCIE_EXT_CAP_SEC: u16 = 0x0019        // Secondary PCI Express
const PCIE_EXT_CAP_PMUX: u16 = 0x001A       // Protocol Multiplexing
const PCIE_EXT_CAP_PASID: u16 = 0x001B      // Process Address Space ID
const PCIE_EXT_CAP_LNR: u16 = 0x001C        // LN Requester
const PCIE_EXT_CAP_DPC: u16 = 0x001D        // Downstream Port Containment
const PCIE_EXT_CAP_L1SS: u16 = 0x001E       // L1 PM Substates
const PCIE_EXT_CAP_PTM: u16 = 0x001F        // Precision Time Measurement
const PCIE_EXT_CAP_MPCIE: u16 = 0x0020      // M-PCIe
const PCIE_EXT_CAP_FRSQ: u16 = 0x0021       // FRS Queueing
const PCIE_EXT_CAP_RTR: u16 = 0x0022        // Readiness Time Reporting
const PCIE_EXT_CAP_DVS: u16 = 0x0023        // Designated Vendor-Specific
const PCIE_EXT_CAP_VFRESBAR: u16 = 0x0024   // VF Resizable BAR
const PCIE_EXT_CAP_DLNK: u16 = 0x0025       // Data Link Feature
const PCIE_EXT_CAP_PL16: u16 = 0x0026       // Physical Layer 16.0 GT/s
const PCIE_EXT_CAP_LMR: u16 = 0x0027        // Lane Margining at Receiver
const PCIE_EXT_CAP_HIER_ID: u16 = 0x0028    // Hierarchy ID
const PCIE_EXT_CAP_NPEM: u16 = 0x0029       // Native PCIe Enclosure Management
const PCIE_EXT_CAP_PL32: u16 = 0x002A       // Physical Layer 32.0 GT/s

// AER register offsets
const AER_UNCORR_STATUS: u32 = 0x04
const AER_UNCORR_MASK: u32 = 0x08
const AER_UNCORR_SEV: u32 = 0x0C
const AER_CORR_STATUS: u32 = 0x10
const AER_CORR_MASK: u32 = 0x14
const AER_CAP_CTRL: u32 = 0x18
const AER_HEADER_LOG: u32 = 0x1C
const AER_ROOT_ERR_CMD: u32 = 0x2C
const AER_ROOT_ERR_STATUS: u32 = 0x30
const AER_ERR_SRC_ID: u32 = 0x34
const AER_TLP_PREFIX_LOG: u32 = 0x38

// AER uncorrectable error bits
const AER_UNC_DLP: u32 = 0x00000010         // Data Link Protocol Error
const AER_UNC_SURP_DN: u32 = 0x00000020     // Surprise Down
const AER_UNC_POISON_TLP: u32 = 0x00001000  // Poisoned TLP
const AER_UNC_FC_PROT: u32 = 0x00002000     // Flow Control Protocol Error
const AER_UNC_COMP_TIME: u32 = 0x00004000   // Completion Timeout
const AER_UNC_COMP_ABORT: u32 = 0x00008000  // Completer Abort
const AER_UNC_UNX_COMP: u32 = 0x00010000    // Unexpected Completion
const AER_UNC_RX_OVER: u32 = 0x00020000     // Receiver Overflow
const AER_UNC_MALF_TLP: u32 = 0x00040000    // Malformed TLP
const AER_UNC_ECRC: u32 = 0x00080000        // ECRC Error
const AER_UNC_UNSUP: u32 = 0x00100000       // Unsupported Request
const AER_UNC_ACS_VIOL: u32 = 0x00200000    // ACS Violation
const AER_UNC_INT: u32 = 0x00400000         // Internal Error
const AER_UNC_MC_BLK: u32 = 0x00800000      // MC Blocked TLP
const AER_UNC_ATOMOP_EGRESS: u32 = 0x01000000
const AER_UNC_TLP_PREFIX: u32 = 0x02000000

// AER correctable error bits
const AER_COR_RCVR: u32 = 0x00000001        // Receiver Error
const AER_COR_BAD_TLP: u32 = 0x00000040     // Bad TLP
const AER_COR_BAD_DLLP: u32 = 0x00000080    // Bad DLLP
const AER_COR_REP_ROLL: u32 = 0x00000100    // REPLAY_NUM Rollover
const AER_COR_REP_TMR: u32 = 0x00001000     // Replay Timer Timeout
const AER_COR_ADV_NFAT: u32 = 0x00002000    // Advisory Non-Fatal
const AER_COR_INT: u32 = 0x00004000         // Corrected Internal Error
const AER_COR_HDR_LOG_OVER: u32 = 0x00008000

// SR-IOV register offsets
const SRIOV_CAP: u32 = 0x04
const SRIOV_CTRL: u32 = 0x08
const SRIOV_STATUS: u32 = 0x0A
const SRIOV_INITIAL_VFS: u32 = 0x0C
const SRIOV_TOTAL_VFS: u32 = 0x0E
const SRIOV_NUM_VFS: u32 = 0x10
const SRIOV_FUNC_DEP_LINK: u32 = 0x12
const SRIOV_VF_OFFSET: u32 = 0x14
const SRIOV_VF_STRIDE: u32 = 0x16
const SRIOV_VF_DEVICE_ID: u32 = 0x1A
const SRIOV_SUP_PGSIZE: u32 = 0x1C
const SRIOV_SYS_PGSIZE: u32 = 0x20
const SRIOV_VF_BAR: u32 = 0x24

// SR-IOV control bits
const SRIOV_CTRL_VFE: u16 = 0x0001          // VF Enable
const SRIOV_CTRL_VF_MI: u16 = 0x0002        // VF Migration Interrupt Enable
const SRIOV_CTRL_MS: u16 = 0x0008           // VF MSE
const SRIOV_CTRL_ARI: u16 = 0x0010          // ARI Capable Hierarchy

// LTR register offsets
const LTR_MAX_SNOOP: u32 = 0x04
const LTR_MAX_NOSNOOP: u32 = 0x06

// PTM register offsets
const PTM_CAP: u32 = 0x04
const PTM_CTRL: u32 = 0x08

// DPC register offsets
const DPC_CAP: u32 = 0x04
const DPC_CTRL: u32 = 0x06
const DPC_STATUS: u32 = 0x08
const DPC_ERR_SRC_ID: u32 = 0x0A

// Device info
struct PcieDevice {
    bus: u32,
    device: u32,
    function: u32,
    base_addr: u64,             // ECAM base for this device
    caps_found: u32,            // Bitmap of found capabilities

    // AER info
    aer_cap: u32,               // AER capability offset
    aer_enabled: u32,

    // SR-IOV info
    sriov_cap: u32,
    total_vfs: u16,
    num_vfs: u16,
    vf_offset: u16,
    vf_stride: u16,

    // Serial number
    serial_number: u64,

    // LTR info
    ltr_cap: u32,
    ltr_enabled: u32,

    // PTM info
    ptm_cap: u32,
    ptm_enabled: u32,

    // L1SS info
    l1ss_cap: u32,
    l1ss_enabled: u32
}

// Extended config space access via ECAM
fn ecam_read32(ecam_base: u64, bus: u32, dev: u32, func: u32, offset: u32): u32 {
    var addr: u64 = ecam_base + (@intCast(bus, u64) << 20) + (@intCast(dev, u64) << 15) +
                    (@intCast(func, u64) << 12) + @intCast(offset, u64)
    return @volatile_load(@intToPtr(addr, *volatile u32))
}

fn ecam_write32(ecam_base: u64, bus: u32, dev: u32, func: u32, offset: u32, value: u32) {
    var addr: u64 = ecam_base + (@intCast(bus, u64) << 20) + (@intCast(dev, u64) << 15) +
                    (@intCast(func, u64) << 12) + @intCast(offset, u64)
    @volatile_store(@intToPtr(addr, *volatile u32), value)
}

fn ecam_read16(ecam_base: u64, bus: u32, dev: u32, func: u32, offset: u32): u16 {
    var val32: u32 = ecam_read32(ecam_base, bus, dev, func, offset & ~3)
    return @truncate(val32 >> ((offset & 2) * 8), u16)
}

fn ecam_write16(ecam_base: u64, bus: u32, dev: u32, func: u32, offset: u32, value: u16) {
    var val32: u32 = ecam_read32(ecam_base, bus, dev, func, offset & ~3)
    var shift: u32 = (offset & 2) * 8
    val32 = (val32 & ~(0xFFFF << shift)) | (@intCast(value, u32) << shift)
    ecam_write32(ecam_base, bus, dev, func, offset & ~3, val32)
}

// Global ECAM base (set by ACPI MCFG)
var ecam_base: u64 = 0

// Max devices to track
const MAX_PCIE_DEVICES: u32 = 64
var pcie_devices: [MAX_PCIE_DEVICES]PcieDevice = undefined
var pcie_device_count: u32 = 0

// Find extended capability
export fn pcie_find_ext_capability(bus: u32, dev: u32, func: u32, cap_id: u16): u32 {
    if ecam_base == 0 {
        return 0
    }

    var offset: u32 = 0x100  // Extended capabilities start at 0x100

    while offset != 0 and offset < 0x1000 {
        var header: u32 = ecam_read32(ecam_base, bus, dev, func, offset)
        var id: u16 = @truncate(header, u16)
        var next: u32 = (header >> 20) & 0xFFC

        if id == 0xFFFF {
            break  // No capabilities
        }

        if id == cap_id {
            return offset
        }

        offset = next
    }

    return 0
}

// Find and cache all capabilities for a device
fn scan_device_capabilities(dev: *PcieDevice) {
    dev.caps_found = 0

    // Find AER
    dev.aer_cap = pcie_find_ext_capability(dev.bus, dev.device, dev.function, PCIE_EXT_CAP_AER)
    if dev.aer_cap != 0 {
        dev.caps_found = dev.caps_found | (1 << 0)
    }

    // Find SR-IOV
    dev.sriov_cap = pcie_find_ext_capability(dev.bus, dev.device, dev.function, PCIE_EXT_CAP_SRIOV)
    if dev.sriov_cap != 0 {
        dev.caps_found = dev.caps_found | (1 << 1)

        dev.total_vfs = ecam_read16(ecam_base, dev.bus, dev.device, dev.function, dev.sriov_cap + SRIOV_TOTAL_VFS)
        dev.vf_offset = ecam_read16(ecam_base, dev.bus, dev.device, dev.function, dev.sriov_cap + SRIOV_VF_OFFSET)
        dev.vf_stride = ecam_read16(ecam_base, dev.bus, dev.device, dev.function, dev.sriov_cap + SRIOV_VF_STRIDE)
    }

    // Find DSN (Device Serial Number)
    var dsn_cap: u32 = pcie_find_ext_capability(dev.bus, dev.device, dev.function, PCIE_EXT_CAP_DSN)
    if dsn_cap != 0 {
        dev.caps_found = dev.caps_found | (1 << 2)
        var low: u32 = ecam_read32(ecam_base, dev.bus, dev.device, dev.function, dsn_cap + 4)
        var high: u32 = ecam_read32(ecam_base, dev.bus, dev.device, dev.function, dsn_cap + 8)
        dev.serial_number = (@intCast(high, u64) << 32) | @intCast(low, u64)
    }

    // Find LTR
    dev.ltr_cap = pcie_find_ext_capability(dev.bus, dev.device, dev.function, PCIE_EXT_CAP_LTR)
    if dev.ltr_cap != 0 {
        dev.caps_found = dev.caps_found | (1 << 3)
    }

    // Find PTM
    dev.ptm_cap = pcie_find_ext_capability(dev.bus, dev.device, dev.function, PCIE_EXT_CAP_PTM)
    if dev.ptm_cap != 0 {
        dev.caps_found = dev.caps_found | (1 << 4)
    }

    // Find L1SS
    dev.l1ss_cap = pcie_find_ext_capability(dev.bus, dev.device, dev.function, PCIE_EXT_CAP_L1SS)
    if dev.l1ss_cap != 0 {
        dev.caps_found = dev.caps_found | (1 << 5)
    }
}

// Initialize PCIe extended capabilities subsystem
export fn pcie_extended_init() {
    foundation.serial_write_string("[PCIe] Initializing extended capabilities...\n")

    pcie_device_count = 0

    // Get ECAM base from ACPI (simplified - would parse MCFG table)
    ecam_base = 0xE0000000  // Common default for x86

    foundation.serial_write_string("[PCIe] ECAM base: ")
    foundation.serial_write_hex64(ecam_base)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("[PCIe] Extended capabilities initialized\n")
}

// Register a device for extended capability tracking
export fn pcie_register_device(bus: u32, dev: u32, func: u32): u32 {
    if pcie_device_count >= MAX_PCIE_DEVICES {
        return 0xFFFFFFFF
    }

    var device: *PcieDevice = &pcie_devices[pcie_device_count]
    device.bus = bus
    device.device = dev
    device.function = func
    device.base_addr = ecam_base
    device.aer_enabled = 0
    device.num_vfs = 0
    device.ltr_enabled = 0
    device.ptm_enabled = 0
    device.l1ss_enabled = 0

    // Scan for capabilities
    scan_device_capabilities(device)

    var idx: u32 = pcie_device_count
    pcie_device_count = pcie_device_count + 1

    foundation.serial_write_string("[PCIe] Registered device ")
    foundation.serial_write_dec(bus)
    foundation.serial_write_string(":")
    foundation.serial_write_dec(dev)
    foundation.serial_write_string(".")
    foundation.serial_write_dec(func)
    foundation.serial_write_string(" caps=")
    foundation.serial_write_hex(device.caps_found)
    foundation.serial_write_string("\n")

    return idx
}

// Enable Advanced Error Reporting
export fn pcie_enable_aer(device_idx: u32): u32 {
    if device_idx >= pcie_device_count {
        return 1
    }

    var dev: *PcieDevice = &pcie_devices[device_idx]
    if dev.aer_cap == 0 {
        return 1  // AER not supported
    }

    foundation.serial_write_string("[PCIe] Enabling AER for device ")
    foundation.serial_write_dec(dev.bus)
    foundation.serial_write_string(":")
    foundation.serial_write_dec(dev.device)
    foundation.serial_write_string(".")
    foundation.serial_write_dec(dev.function)
    foundation.serial_write_string("\n")

    // Clear any pending errors
    ecam_write32(ecam_base, dev.bus, dev.device, dev.function, dev.aer_cap + AER_UNCORR_STATUS, 0xFFFFFFFF)
    ecam_write32(ecam_base, dev.bus, dev.device, dev.function, dev.aer_cap + AER_CORR_STATUS, 0xFFFFFFFF)

    // Unmask all correctable errors
    ecam_write32(ecam_base, dev.bus, dev.device, dev.function, dev.aer_cap + AER_CORR_MASK, 0)

    // Unmask all uncorrectable errors
    ecam_write32(ecam_base, dev.bus, dev.device, dev.function, dev.aer_cap + AER_UNCORR_MASK, 0)

    // Set severity for uncorrectable errors
    var severity: u32 = AER_UNC_DLP | AER_UNC_SURP_DN | AER_UNC_MALF_TLP  // Fatal
    ecam_write32(ecam_base, dev.bus, dev.device, dev.function, dev.aer_cap + AER_UNCORR_SEV, severity)

    // Enable ECRC generation and checking if supported
    var cap_ctrl: u32 = ecam_read32(ecam_base, dev.bus, dev.device, dev.function, dev.aer_cap + AER_CAP_CTRL)
    if (cap_ctrl & 0x00000020) != 0 {  // ECRC Generation Capable
        cap_ctrl = cap_ctrl | 0x00000040  // ECRC Generation Enable
    }
    if (cap_ctrl & 0x00000080) != 0 {  // ECRC Check Capable
        cap_ctrl = cap_ctrl | 0x00000100  // ECRC Check Enable
    }
    ecam_write32(ecam_base, dev.bus, dev.device, dev.function, dev.aer_cap + AER_CAP_CTRL, cap_ctrl)

    dev.aer_enabled = 1
    return 0
}

// Read AER error status
export fn pcie_read_aer_status(device_idx: u32, uncorr: *u32, corr: *u32): u32 {
    if device_idx >= pcie_device_count {
        return 1
    }

    var dev: *PcieDevice = &pcie_devices[device_idx]
    if dev.aer_cap == 0 {
        return 1
    }

    @ptrDeref(uncorr) = ecam_read32(ecam_base, dev.bus, dev.device, dev.function, dev.aer_cap + AER_UNCORR_STATUS)
    @ptrDeref(corr) = ecam_read32(ecam_base, dev.bus, dev.device, dev.function, dev.aer_cap + AER_CORR_STATUS)

    return 0
}

// Clear AER errors
export fn pcie_clear_aer_errors(device_idx: u32) {
    if device_idx >= pcie_device_count {
        return
    }

    var dev: *PcieDevice = &pcie_devices[device_idx]
    if dev.aer_cap == 0 {
        return
    }

    ecam_write32(ecam_base, dev.bus, dev.device, dev.function, dev.aer_cap + AER_UNCORR_STATUS, 0xFFFFFFFF)
    ecam_write32(ecam_base, dev.bus, dev.device, dev.function, dev.aer_cap + AER_CORR_STATUS, 0xFFFFFFFF)
}

// Get device serial number
export fn pcie_read_serial_number(device_idx: u32): u64 {
    if device_idx >= pcie_device_count {
        return 0
    }

    return pcie_devices[device_idx].serial_number
}

// Enable SR-IOV
export fn pcie_enable_sriov(device_idx: u32, num_vfs: u16): u32 {
    if device_idx >= pcie_device_count {
        return 1
    }

    var dev: *PcieDevice = &pcie_devices[device_idx]
    if dev.sriov_cap == 0 {
        return 1
    }

    if num_vfs > dev.total_vfs {
        num_vfs = dev.total_vfs
    }

    foundation.serial_write_string("[PCIe] Enabling SR-IOV with ")
    foundation.serial_write_dec(@intCast(num_vfs, u32))
    foundation.serial_write_string(" VFs\n")

    // Set number of VFs
    ecam_write16(ecam_base, dev.bus, dev.device, dev.function, dev.sriov_cap + SRIOV_NUM_VFS, num_vfs)

    // Enable VFs
    var ctrl: u16 = ecam_read16(ecam_base, dev.bus, dev.device, dev.function, dev.sriov_cap + SRIOV_CTRL)
    ctrl = ctrl | SRIOV_CTRL_VFE | SRIOV_CTRL_MS
    ecam_write16(ecam_base, dev.bus, dev.device, dev.function, dev.sriov_cap + SRIOV_CTRL, ctrl)

    dev.num_vfs = num_vfs
    return 0
}

// Disable SR-IOV
export fn pcie_disable_sriov(device_idx: u32): u32 {
    if device_idx >= pcie_device_count {
        return 1
    }

    var dev: *PcieDevice = &pcie_devices[device_idx]
    if dev.sriov_cap == 0 {
        return 1
    }

    // Disable VFs
    var ctrl: u16 = ecam_read16(ecam_base, dev.bus, dev.device, dev.function, dev.sriov_cap + SRIOV_CTRL)
    ctrl = ctrl & ~SRIOV_CTRL_VFE
    ecam_write16(ecam_base, dev.bus, dev.device, dev.function, dev.sriov_cap + SRIOV_CTRL, ctrl)

    // Set num VFs to 0
    ecam_write16(ecam_base, dev.bus, dev.device, dev.function, dev.sriov_cap + SRIOV_NUM_VFS, 0)

    dev.num_vfs = 0
    return 0
}

// Get VF count
export fn pcie_get_vf_count(device_idx: u32): u16 {
    if device_idx >= pcie_device_count {
        return 0
    }

    return pcie_devices[device_idx].num_vfs
}

// Enable LTR (Latency Tolerance Reporting)
export fn pcie_enable_ltr(device_idx: u32): u32 {
    if device_idx >= pcie_device_count {
        return 1
    }

    var dev: *PcieDevice = &pcie_devices[device_idx]
    if dev.ltr_cap == 0 {
        return 1
    }

    // LTR is usually enabled via PCIe capability, not extended cap
    // Extended cap just contains max snoop/nosnoop latency values

    dev.ltr_enabled = 1
    foundation.serial_write_string("[PCIe] LTR enabled\n")
    return 0
}

// Get LTR max latency values
export fn pcie_get_ltr_max(device_idx: u32, snoop: *u16, nosnoop: *u16): u32 {
    if device_idx >= pcie_device_count {
        return 1
    }

    var dev: *PcieDevice = &pcie_devices[device_idx]
    if dev.ltr_cap == 0 {
        return 1
    }

    @ptrDeref(snoop) = ecam_read16(ecam_base, dev.bus, dev.device, dev.function, dev.ltr_cap + LTR_MAX_SNOOP)
    @ptrDeref(nosnoop) = ecam_read16(ecam_base, dev.bus, dev.device, dev.function, dev.ltr_cap + LTR_MAX_NOSNOOP)

    return 0
}

// Enable PTM (Precision Time Measurement)
export fn pcie_enable_ptm(device_idx: u32): u32 {
    if device_idx >= pcie_device_count {
        return 1
    }

    var dev: *PcieDevice = &pcie_devices[device_idx]
    if dev.ptm_cap == 0 {
        return 1
    }

    // Read capability register
    var cap: u32 = ecam_read32(ecam_base, dev.bus, dev.device, dev.function, dev.ptm_cap + PTM_CAP)

    // Enable PTM
    var ctrl: u32 = ecam_read32(ecam_base, dev.bus, dev.device, dev.function, dev.ptm_cap + PTM_CTRL)
    ctrl = ctrl | 0x01  // PTM Enable
    if (cap & 0x04) != 0 {  // Root Capable
        ctrl = ctrl | 0x02  // PTM Root Select
    }
    ecam_write32(ecam_base, dev.bus, dev.device, dev.function, dev.ptm_cap + PTM_CTRL, ctrl)

    dev.ptm_enabled = 1
    foundation.serial_write_string("[PCIe] PTM enabled\n")
    return 0
}

// Enable L1 PM Substates
export fn pcie_enable_l1ss(device_idx: u32): u32 {
    if device_idx >= pcie_device_count {
        return 1
    }

    var dev: *PcieDevice = &pcie_devices[device_idx]
    if dev.l1ss_cap == 0 {
        return 1
    }

    // Read capability to check what substates are supported
    var cap: u32 = ecam_read32(ecam_base, dev.bus, dev.device, dev.function, dev.l1ss_cap + 4)

    // Enable all supported substates
    var ctrl1: u32 = ecam_read32(ecam_base, dev.bus, dev.device, dev.function, dev.l1ss_cap + 8)
    if (cap & 0x01) != 0 { ctrl1 = ctrl1 | 0x01 }  // ASPM L1.1
    if (cap & 0x02) != 0 { ctrl1 = ctrl1 | 0x02 }  // ASPM L1.2
    if (cap & 0x04) != 0 { ctrl1 = ctrl1 | 0x04 }  // PCI-PM L1.1
    if (cap & 0x08) != 0 { ctrl1 = ctrl1 | 0x08 }  // PCI-PM L1.2
    ecam_write32(ecam_base, dev.bus, dev.device, dev.function, dev.l1ss_cap + 8, ctrl1)

    dev.l1ss_enabled = 1
    foundation.serial_write_string("[PCIe] L1 PM Substates enabled\n")
    return 0
}

// Handle AER interrupt
export fn pcie_aer_interrupt_handler() {
    var i: u32 = 0
    while i < pcie_device_count {
        var dev: *PcieDevice = &pcie_devices[i]
        if dev.aer_enabled != 0 {
            var uncorr: u32 = ecam_read32(ecam_base, dev.bus, dev.device, dev.function, dev.aer_cap + AER_UNCORR_STATUS)
            var corr: u32 = ecam_read32(ecam_base, dev.bus, dev.device, dev.function, dev.aer_cap + AER_CORR_STATUS)

            if uncorr != 0 or corr != 0 {
                foundation.serial_write_string("[PCIe] AER error on ")
                foundation.serial_write_dec(dev.bus)
                foundation.serial_write_string(":")
                foundation.serial_write_dec(dev.device)
                foundation.serial_write_string(".")
                foundation.serial_write_dec(dev.function)
                foundation.serial_write_string(" uncorr=")
                foundation.serial_write_hex(uncorr)
                foundation.serial_write_string(" corr=")
                foundation.serial_write_hex(corr)
                foundation.serial_write_string("\n")

                // Clear errors
                pcie_clear_aer_errors(i)
            }
        }
        i = i + 1
    }
}

// Get device info
export fn pcie_get_device_info(device_idx: u32, bus: *u32, dev: *u32, func: *u32, caps: *u32): u32 {
    if device_idx >= pcie_device_count {
        return 1
    }

    var device: *PcieDevice = &pcie_devices[device_idx]
    @ptrDeref(bus) = device.bus
    @ptrDeref(dev) = device.device
    @ptrDeref(func) = device.function
    @ptrDeref(caps) = device.caps_found

    return 0
}

// Set ECAM base address (called from ACPI MCFG parsing)
export fn pcie_set_ecam_base(base: u64) {
    ecam_base = base
    foundation.serial_write_string("[PCIe] ECAM base set to ")
    foundation.serial_write_hex64(base)
    foundation.serial_write_string("\n")
}
