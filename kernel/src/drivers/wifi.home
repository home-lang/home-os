// home-os WiFi Driver
// IEEE 802.11 wireless network support with WPA2/WPA3

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "../net/netdev.home" as netdev
import "pci.home" as pci

// WiFi operating modes
const WIFI_MODE_STATION: u32 = 0     // Client mode
const WIFI_MODE_AP: u32 = 1          // Access point mode
const WIFI_MODE_MONITOR: u32 = 2     // Monitor/promiscuous mode
const WIFI_MODE_ADHOC: u32 = 3       // Ad-hoc/IBSS mode
const WIFI_MODE_P2P: u32 = 4         // WiFi Direct

// WiFi states
const WIFI_STATE_DISABLED: u32 = 0
const WIFI_STATE_IDLE: u32 = 1
const WIFI_STATE_SCANNING: u32 = 2
const WIFI_STATE_AUTHENTICATING: u32 = 3
const WIFI_STATE_ASSOCIATING: u32 = 4
const WIFI_STATE_CONNECTED: u32 = 5
const WIFI_STATE_DISCONNECTING: u32 = 6

// Security types
const WIFI_SECURITY_OPEN: u32 = 0
const WIFI_SECURITY_WEP: u32 = 1
const WIFI_SECURITY_WPA: u32 = 2
const WIFI_SECURITY_WPA2: u32 = 3
const WIFI_SECURITY_WPA3: u32 = 4
const WIFI_SECURITY_WPA2_ENTERPRISE: u32 = 5

// 802.11 frame types
const WIFI_FRAME_MGMT: u8 = 0x00
const WIFI_FRAME_CTRL: u8 = 0x04
const WIFI_FRAME_DATA: u8 = 0x08

// Management frame subtypes
const WIFI_MGMT_ASSOC_REQ: u8 = 0x00
const WIFI_MGMT_ASSOC_RESP: u8 = 0x10
const WIFI_MGMT_REASSOC_REQ: u8 = 0x20
const WIFI_MGMT_REASSOC_RESP: u8 = 0x30
const WIFI_MGMT_PROBE_REQ: u8 = 0x40
const WIFI_MGMT_PROBE_RESP: u8 = 0x50
const WIFI_MGMT_BEACON: u8 = 0x80
const WIFI_MGMT_DISASSOC: u8 = 0xA0
const WIFI_MGMT_AUTH: u8 = 0xB0
const WIFI_MGMT_DEAUTH: u8 = 0xC0
const WIFI_MGMT_ACTION: u8 = 0xD0

// 802.11 channels (2.4 GHz)
const WIFI_CHANNEL_1: u32 = 2412
const WIFI_CHANNEL_6: u32 = 2437
const WIFI_CHANNEL_11: u32 = 2462

// 802.11 standards
const WIFI_STANDARD_B: u32 = 0x01
const WIFI_STANDARD_G: u32 = 0x02
const WIFI_STANDARD_N: u32 = 0x04
const WIFI_STANDARD_AC: u32 = 0x08
const WIFI_STANDARD_AX: u32 = 0x10

// Maximum values
const MAX_SSID_LEN: u32 = 32
const MAX_NETWORKS: u32 = 64
const MAX_TX_QUEUES: u32 = 4
const MAX_RX_BUFFERS: u32 = 256

// WiFi network information
struct WifiNetwork {
    ssid: [33]u8,              // SSID + null terminator
    ssid_len: u8,
    bssid: [6]u8,              // MAC address of AP
    channel: u8,
    frequency: u16,            // MHz
    signal_strength: i8,       // dBm
    noise: i8,                 // dBm
    security: u32,             // Security type
    capabilities: u16,         // Capability info
    beacon_interval: u16,      // TUs
    last_seen: u64,            // Timestamp
    supported_rates: u16,      // Supported data rates
    ht_capable: u32,           // 802.11n HT capable
    vht_capable: u32,          // 802.11ac VHT capable
    he_capable: u32            // 802.11ax HE capable
}

// WiFi hardware capabilities
struct WifiCapabilities {
    supported_bands: u32,      // 2.4GHz, 5GHz, 6GHz
    supported_standards: u32,  // b/g/n/ac/ax
    max_tx_power: u8,          // dBm
    num_antennas: u8,
    supports_ap: u32,
    supports_monitor: u32,
    supports_p2p: u32,
    supports_mesh: u32,
    hw_crypto: u32,            // Hardware encryption
    max_scan_ssids: u8
}

// WiFi driver state
struct WifiDriver {
    base_addr: u64,            // MMIO base address
    irq: u32,
    state: u32,
    mode: u32,

    // Hardware info
    mac_addr: [6]u8,
    capabilities: WifiCapabilities,

    // Current connection
    connected: u32,
    current_bssid: [6]u8,
    current_ssid: [33]u8,
    current_channel: u8,
    current_security: u32,

    // Scan results
    networks: [MAX_NETWORKS]WifiNetwork,
    network_count: u32,
    scan_in_progress: u32,

    // TX/RX queues
    tx_ring_base: u64,
    rx_ring_base: u64,
    tx_head: u32,
    tx_tail: u32,
    rx_head: u32,
    rx_tail: u32,

    // Statistics
    tx_packets: u64,
    rx_packets: u64,
    tx_bytes: u64,
    rx_bytes: u64,
    tx_errors: u32,
    rx_errors: u32,

    // Power management
    power_save: u32,
    tx_power: u8
}

// TX descriptor
struct WifiTxDesc {
    buffer_addr: u64,
    length: u16,
    flags: u16,
    rate: u8,
    retry_limit: u8,
    status: u16
}

// RX descriptor
struct WifiRxDesc {
    buffer_addr: u64,
    length: u16,
    flags: u16,
    rssi: i8,
    noise: i8,
    rate: u8,
    channel: u8
}

// 802.11 frame header
struct Wifi80211Header {
    frame_control: u16,
    duration: u16,
    addr1: [6]u8,              // Destination
    addr2: [6]u8,              // Source
    addr3: [6]u8,              // BSSID
    seq_ctrl: u16
}

// WPA key
struct WpaKey {
    key: [32]u8,
    key_len: u8,
    key_idx: u8,
    cipher: u32,
    seq: [8]u8
}

// Global driver instance
var wifi_driver: WifiDriver = undefined
var wifi_initialized: u32 = 0

// PCI device IDs for common WiFi chips
const INTEL_VENDOR_ID: u16 = 0x8086
const INTEL_AX200_ID: u16 = 0x2723
const INTEL_AX201_ID: u16 = 0x06F0

const REALTEK_VENDOR_ID: u16 = 0x10EC
const REALTEK_8822CE_ID: u16 = 0xC822

const ATHEROS_VENDOR_ID: u16 = 0x168C
const ATHEROS_QCA6174_ID: u16 = 0x003E

// MMIO register offsets (generic)
const WIFI_REG_STATUS: u32 = 0x00
const WIFI_REG_CONTROL: u32 = 0x04
const WIFI_REG_INT_STATUS: u32 = 0x08
const WIFI_REG_INT_MASK: u32 = 0x0C
const WIFI_REG_TX_CONFIG: u32 = 0x40
const WIFI_REG_RX_CONFIG: u32 = 0x44
const WIFI_REG_TX_RING_BASE: u32 = 0x200
const WIFI_REG_RX_RING_BASE: u32 = 0x220
const WIFI_REG_MAC_ADDR: u32 = 0x300

// Read MMIO register
fn wifi_read32(offset: u32): u32 {
    var addr: u64 = wifi_driver.base_addr + @intCast(offset, u64)
    return @volatile_load(@intToPtr(addr, *volatile u32))
}

// Write MMIO register
fn wifi_write32(offset: u32, value: u32) {
    var addr: u64 = wifi_driver.base_addr + @intCast(offset, u64)
    @volatile_store(@intToPtr(addr, *volatile u32), value)
}

// Initialize TX/RX rings
fn init_rings() {
    // Allocate TX ring
    wifi_driver.tx_ring_base = memory.alloc_pages(1)
    if wifi_driver.tx_ring_base == 0 {
        foundation.serial_write_string("[WiFi] Failed to allocate TX ring\n")
        return
    }

    // Allocate RX ring
    wifi_driver.rx_ring_base = memory.alloc_pages(1)
    if wifi_driver.rx_ring_base == 0 {
        foundation.serial_write_string("[WiFi] Failed to allocate RX ring\n")
        return
    }

    // Clear rings
    memory.memset(wifi_driver.tx_ring_base, 0, 4096)
    memory.memset(wifi_driver.rx_ring_base, 0, 4096)

    // Initialize RX buffers
    var i: u32 = 0
    while i < MAX_RX_BUFFERS {
        var desc: *WifiRxDesc = @intToPtr(wifi_driver.rx_ring_base + @intCast(i, u64) * @sizeOf(WifiRxDesc), *WifiRxDesc)
        desc.buffer_addr = memory.alloc_pages(1)
        desc.length = 0
        desc.flags = 0x8000  // Available for hardware
        i = i + 1
    }

    wifi_driver.tx_head = 0
    wifi_driver.tx_tail = 0
    wifi_driver.rx_head = 0
    wifi_driver.rx_tail = 0

    // Program ring addresses to hardware
    wifi_write32(WIFI_REG_TX_RING_BASE, @truncate(wifi_driver.tx_ring_base, u32))
    wifi_write32(WIFI_REG_TX_RING_BASE + 4, @truncate(wifi_driver.tx_ring_base >> 32, u32))
    wifi_write32(WIFI_REG_RX_RING_BASE, @truncate(wifi_driver.rx_ring_base, u32))
    wifi_write32(WIFI_REG_RX_RING_BASE + 4, @truncate(wifi_driver.rx_ring_base >> 32, u32))
}

// Read MAC address from hardware
fn read_mac_address() {
    var mac_low: u32 = wifi_read32(WIFI_REG_MAC_ADDR)
    var mac_high: u32 = wifi_read32(WIFI_REG_MAC_ADDR + 4)

    wifi_driver.mac_addr[0] = @truncate(mac_low, u8)
    wifi_driver.mac_addr[1] = @truncate(mac_low >> 8, u8)
    wifi_driver.mac_addr[2] = @truncate(mac_low >> 16, u8)
    wifi_driver.mac_addr[3] = @truncate(mac_low >> 24, u8)
    wifi_driver.mac_addr[4] = @truncate(mac_high, u8)
    wifi_driver.mac_addr[5] = @truncate(mac_high >> 8, u8)
}

// Detect and initialize WiFi hardware
fn detect_wifi_hardware(): u32 {
    // Scan PCI bus for WiFi devices
    var bus: u32 = 0
    while bus < 256 {
        var device: u32 = 0
        while device < 32 {
            var func: u32 = 0
            while func < 8 {
                var vendor_id: u16 = pci.pci_read_vendor(bus, device, func)
                var device_id: u16 = pci.pci_read_device(bus, device, func)

                if vendor_id != 0xFFFF {
                    // Check for known WiFi chips
                    if vendor_id == INTEL_VENDOR_ID {
                        if device_id == INTEL_AX200_ID or device_id == INTEL_AX201_ID {
                            foundation.serial_write_string("[WiFi] Found Intel AX200/AX201\n")
                            wifi_driver.base_addr = pci.pci_read_bar(bus, device, func, 0)
                            wifi_driver.irq = pci.pci_read_irq(bus, device, func)
                            pci.pci_enable_bus_master(bus, device, func)
                            return 1
                        }
                    } else if vendor_id == REALTEK_VENDOR_ID {
                        if device_id == REALTEK_8822CE_ID {
                            foundation.serial_write_string("[WiFi] Found Realtek 8822CE\n")
                            wifi_driver.base_addr = pci.pci_read_bar(bus, device, func, 0)
                            wifi_driver.irq = pci.pci_read_irq(bus, device, func)
                            pci.pci_enable_bus_master(bus, device, func)
                            return 1
                        }
                    } else if vendor_id == ATHEROS_VENDOR_ID {
                        if device_id == ATHEROS_QCA6174_ID {
                            foundation.serial_write_string("[WiFi] Found Atheros QCA6174\n")
                            wifi_driver.base_addr = pci.pci_read_bar(bus, device, func, 0)
                            wifi_driver.irq = pci.pci_read_irq(bus, device, func)
                            pci.pci_enable_bus_master(bus, device, func)
                            return 1
                        }
                    }
                }
                func = func + 1
            }
            device = device + 1
        }
        bus = bus + 1
    }

    return 0
}

// Initialize WiFi driver
export fn wifi_init() {
    foundation.serial_write_string("[WiFi] Initializing...\n")

    // Clear driver state
    wifi_driver.state = WIFI_STATE_DISABLED
    wifi_driver.mode = WIFI_MODE_STATION
    wifi_driver.connected = 0
    wifi_driver.network_count = 0
    wifi_driver.scan_in_progress = 0
    wifi_driver.tx_packets = 0
    wifi_driver.rx_packets = 0
    wifi_driver.tx_bytes = 0
    wifi_driver.rx_bytes = 0
    wifi_driver.tx_errors = 0
    wifi_driver.rx_errors = 0
    wifi_driver.power_save = 0
    wifi_driver.tx_power = 20  // 20 dBm default

    // Detect hardware
    if detect_wifi_hardware() == 0 {
        foundation.serial_write_string("[WiFi] No WiFi hardware detected\n")
        return
    }

    // Read MAC address
    read_mac_address()

    foundation.serial_write_string("[WiFi] MAC: ")
    var i: u32 = 0
    while i < 6 {
        foundation.serial_write_hex8(wifi_driver.mac_addr[i])
        if i < 5 {
            foundation.serial_write_string(":")
        }
        i = i + 1
    }
    foundation.serial_write_string("\n")

    // Initialize TX/RX rings
    init_rings()

    // Set default capabilities
    wifi_driver.capabilities.supported_bands = 0x03  // 2.4GHz + 5GHz
    wifi_driver.capabilities.supported_standards = WIFI_STANDARD_B | WIFI_STANDARD_G | WIFI_STANDARD_N | WIFI_STANDARD_AC
    wifi_driver.capabilities.max_tx_power = 23
    wifi_driver.capabilities.num_antennas = 2
    wifi_driver.capabilities.supports_ap = 1
    wifi_driver.capabilities.supports_monitor = 1
    wifi_driver.capabilities.supports_p2p = 1
    wifi_driver.capabilities.supports_mesh = 0
    wifi_driver.capabilities.hw_crypto = 1
    wifi_driver.capabilities.max_scan_ssids = 16

    // Enable interrupts
    wifi_write32(WIFI_REG_INT_MASK, 0xFFFFFFFF)

    wifi_driver.state = WIFI_STATE_IDLE
    wifi_initialized = 1

    foundation.serial_write_string("[WiFi] Initialized successfully\n")
}

// Start scanning for networks
export fn wifi_scan(): u32 {
    if wifi_initialized == 0 {
        return 0
    }

    if wifi_driver.state != WIFI_STATE_IDLE and wifi_driver.state != WIFI_STATE_CONNECTED {
        return 0
    }

    foundation.serial_write_string("[WiFi] Starting scan...\n")

    wifi_driver.scan_in_progress = 1
    wifi_driver.network_count = 0

    // Send probe requests on each channel
    var channel: u32 = 1
    while channel <= 11 {
        // Set channel
        set_channel(@truncate(channel, u8))

        // Send probe request
        send_probe_request()

        // Wait for responses
        foundation.delay_ms(50)

        channel = channel + 1
    }

    // Process received beacons/probe responses
    process_scan_results()

    wifi_driver.scan_in_progress = 0

    foundation.serial_write_string("[WiFi] Scan complete, found ")
    foundation.serial_write_dec(wifi_driver.network_count)
    foundation.serial_write_string(" networks\n")

    return wifi_driver.network_count
}

// Set channel
fn set_channel(channel: u8) {
    // Configure radio to specified channel
    var freq: u32 = 2407 + @intCast(channel, u32) * 5
    wifi_write32(WIFI_REG_CONTROL, freq)
}

// Send probe request frame
fn send_probe_request() {
    // Allocate TX descriptor
    var desc_idx: u32 = wifi_driver.tx_tail
    var desc: *WifiTxDesc = @intToPtr(wifi_driver.tx_ring_base + @intCast(desc_idx, u64) * @sizeOf(WifiTxDesc), *WifiTxDesc)

    // Allocate frame buffer
    var buffer: u64 = memory.alloc_pages(1)
    if buffer == 0 {
        return
    }

    // Build probe request frame
    var header: *Wifi80211Header = @intToPtr(buffer, *Wifi80211Header)
    header.frame_control = @intCast(WIFI_FRAME_MGMT, u16) | @intCast(WIFI_MGMT_PROBE_REQ, u16)
    header.duration = 0

    // Broadcast destination
    var i: u32 = 0
    while i < 6 {
        header.addr1[i] = 0xFF
        i = i + 1
    }

    // Source = our MAC
    i = 0
    while i < 6 {
        header.addr2[i] = wifi_driver.mac_addr[i]
        i = i + 1
    }

    // BSSID = broadcast
    i = 0
    while i < 6 {
        header.addr3[i] = 0xFF
        i = i + 1
    }

    header.seq_ctrl = 0

    // Set up TX descriptor
    desc.buffer_addr = buffer
    desc.length = @sizeOf(Wifi80211Header)
    desc.flags = 0x0001  // First and last fragment
    desc.rate = 0x0B     // 1 Mbps for management frames
    desc.retry_limit = 3
    desc.status = 0

    // Advance tail
    wifi_driver.tx_tail = (wifi_driver.tx_tail + 1) % MAX_TX_QUEUES

    // Trigger TX
    wifi_write32(WIFI_REG_TX_CONFIG, 0x01)
}

// Process scan results from RX ring
fn process_scan_results() {
    while wifi_driver.rx_head != wifi_driver.rx_tail {
        var desc: *WifiRxDesc = @intToPtr(wifi_driver.rx_ring_base + @intCast(wifi_driver.rx_head, u64) * @sizeOf(WifiRxDesc), *WifiRxDesc)

        if (desc.flags & 0x8000) != 0 {
            // Still owned by hardware
            break
        }

        // Parse received frame
        var header: *Wifi80211Header = @intToPtr(desc.buffer_addr, *Wifi80211Header)
        var frame_type: u8 = @truncate(header.frame_control, u8)

        if frame_type == (WIFI_FRAME_MGMT | WIFI_MGMT_BEACON) or frame_type == (WIFI_FRAME_MGMT | WIFI_MGMT_PROBE_RESP) {
            // Parse beacon/probe response
            parse_beacon(desc)
        }

        // Return buffer to hardware
        desc.length = 0
        desc.flags = 0x8000

        wifi_driver.rx_head = (wifi_driver.rx_head + 1) % MAX_RX_BUFFERS
    }
}

// Parse beacon frame and add network to list
fn parse_beacon(desc: *WifiRxDesc) {
    if wifi_driver.network_count >= MAX_NETWORKS {
        return
    }

    var network: *WifiNetwork = &wifi_driver.networks[wifi_driver.network_count]

    // Extract BSSID from frame header
    var header: *Wifi80211Header = @intToPtr(desc.buffer_addr, *Wifi80211Header)
    var i: u32 = 0
    while i < 6 {
        network.bssid[i] = header.addr2[i]
        i = i + 1
    }

    // Extract information from beacon body
    // (Simplified - real implementation would parse IEs)
    network.channel = desc.channel
    network.signal_strength = desc.rssi
    network.noise = desc.noise
    network.security = WIFI_SECURITY_WPA2  // Default assumption
    network.last_seen = foundation.get_ticks()

    // Check for duplicate
    i = 0
    while i < wifi_driver.network_count {
        var existing: *WifiNetwork = &wifi_driver.networks[i]
        var is_same: u32 = 1
        var j: u32 = 0
        while j < 6 {
            if existing.bssid[j] != network.bssid[j] {
                is_same = 0
                break
            }
            j = j + 1
        }
        if is_same != 0 {
            // Update existing entry
            existing.signal_strength = network.signal_strength
            existing.last_seen = network.last_seen
            return
        }
        i = i + 1
    }

    wifi_driver.network_count = wifi_driver.network_count + 1
}

// Connect to a network
export fn wifi_connect(ssid: [*]u8, password: [*]u8): u32 {
    if wifi_initialized == 0 {
        return 1
    }

    foundation.serial_write_string("[WiFi] Connecting to ")
    foundation.serial_write_string(ssid)
    foundation.serial_write_string("...\n")

    // Find network in scan results
    var network_idx: u32 = 0xFFFFFFFF
    var i: u32 = 0
    while i < wifi_driver.network_count {
        // Compare SSID
        var match: u32 = 1
        var j: u32 = 0
        while j < 32 {
            if wifi_driver.networks[i].ssid[j] != ssid[j] {
                match = 0
                break
            }
            if ssid[j] == 0 {
                break
            }
            j = j + 1
        }
        if match != 0 {
            network_idx = i
            break
        }
        i = i + 1
    }

    if network_idx == 0xFFFFFFFF {
        foundation.serial_write_string("[WiFi] Network not found in scan results\n")
        return 1
    }

    var network: *WifiNetwork = &wifi_driver.networks[network_idx]

    // Set channel
    set_channel(network.channel)

    // Copy connection info
    i = 0
    while i < 6 {
        wifi_driver.current_bssid[i] = network.bssid[i]
        i = i + 1
    }

    i = 0
    while ssid[i] != 0 and i < 32 {
        wifi_driver.current_ssid[i] = ssid[i]
        i = i + 1
    }
    wifi_driver.current_ssid[i] = 0

    wifi_driver.current_channel = network.channel
    wifi_driver.current_security = network.security

    // Start authentication
    wifi_driver.state = WIFI_STATE_AUTHENTICATING

    if send_auth_request() != 0 {
        foundation.serial_write_string("[WiFi] Authentication failed\n")
        wifi_driver.state = WIFI_STATE_IDLE
        return 1
    }

    // Start association
    wifi_driver.state = WIFI_STATE_ASSOCIATING

    if send_assoc_request() != 0 {
        foundation.serial_write_string("[WiFi] Association failed\n")
        wifi_driver.state = WIFI_STATE_IDLE
        return 1
    }

    // WPA handshake if needed
    if network.security >= WIFI_SECURITY_WPA {
        if do_wpa_handshake(password) != 0 {
            foundation.serial_write_string("[WiFi] WPA handshake failed\n")
            wifi_driver.state = WIFI_STATE_IDLE
            return 1
        }
    }

    wifi_driver.state = WIFI_STATE_CONNECTED
    wifi_driver.connected = 1

    foundation.serial_write_string("[WiFi] Connected successfully\n")
    return 0
}

// Send authentication request
fn send_auth_request(): u32 {
    var desc_idx: u32 = wifi_driver.tx_tail
    var desc: *WifiTxDesc = @intToPtr(wifi_driver.tx_ring_base + @intCast(desc_idx, u64) * @sizeOf(WifiTxDesc), *WifiTxDesc)

    var buffer: u64 = memory.alloc_pages(1)
    if buffer == 0 {
        return 1
    }

    var header: *Wifi80211Header = @intToPtr(buffer, *Wifi80211Header)
    header.frame_control = @intCast(WIFI_FRAME_MGMT, u16) | @intCast(WIFI_MGMT_AUTH, u16)
    header.duration = 0

    // To AP
    var i: u32 = 0
    while i < 6 {
        header.addr1[i] = wifi_driver.current_bssid[i]
        i = i + 1
    }

    // From us
    i = 0
    while i < 6 {
        header.addr2[i] = wifi_driver.mac_addr[i]
        i = i + 1
    }

    // BSSID
    i = 0
    while i < 6 {
        header.addr3[i] = wifi_driver.current_bssid[i]
        i = i + 1
    }

    header.seq_ctrl = 0

    // Auth body: algorithm (open), seq, status
    var body: *u16 = @intToPtr(buffer + @sizeOf(Wifi80211Header), *u16)
    body[0] = 0       // Open system
    body[1] = 1       // Sequence 1
    body[2] = 0       // Status success

    desc.buffer_addr = buffer
    desc.length = @sizeOf(Wifi80211Header) + 6
    desc.flags = 0x0001
    desc.rate = 0x0B
    desc.retry_limit = 5
    desc.status = 0

    wifi_driver.tx_tail = (wifi_driver.tx_tail + 1) % MAX_TX_QUEUES
    wifi_write32(WIFI_REG_TX_CONFIG, 0x01)

    // Wait for auth response
    foundation.delay_ms(100)

    return 0  // Simplified - would check for response
}

// Send association request
fn send_assoc_request(): u32 {
    var desc_idx: u32 = wifi_driver.tx_tail
    var desc: *WifiTxDesc = @intToPtr(wifi_driver.tx_ring_base + @intCast(desc_idx, u64) * @sizeOf(WifiTxDesc), *WifiTxDesc)

    var buffer: u64 = memory.alloc_pages(1)
    if buffer == 0 {
        return 1
    }

    var header: *Wifi80211Header = @intToPtr(buffer, *Wifi80211Header)
    header.frame_control = @intCast(WIFI_FRAME_MGMT, u16) | @intCast(WIFI_MGMT_ASSOC_REQ, u16)
    header.duration = 0

    // Addresses
    var i: u32 = 0
    while i < 6 {
        header.addr1[i] = wifi_driver.current_bssid[i]
        header.addr2[i] = wifi_driver.mac_addr[i]
        header.addr3[i] = wifi_driver.current_bssid[i]
        i = i + 1
    }

    header.seq_ctrl = 0

    desc.buffer_addr = buffer
    desc.length = @sizeOf(Wifi80211Header) + 50  // With IEs
    desc.flags = 0x0001
    desc.rate = 0x0B
    desc.retry_limit = 5
    desc.status = 0

    wifi_driver.tx_tail = (wifi_driver.tx_tail + 1) % MAX_TX_QUEUES
    wifi_write32(WIFI_REG_TX_CONFIG, 0x01)

    foundation.delay_ms(100)

    return 0
}

// Perform WPA 4-way handshake
fn do_wpa_handshake(password: [*]u8): u32 {
    // Simplified WPA handshake
    // Real implementation would:
    // 1. Receive EAPOL message 1 (ANonce from AP)
    // 2. Generate SNonce, compute PTK
    // 3. Send EAPOL message 2 (SNonce + MIC)
    // 4. Receive EAPOL message 3 (GTK + MIC)
    // 5. Send EAPOL message 4 (acknowledgment)

    foundation.serial_write_string("[WiFi] WPA handshake (simplified)\n")
    foundation.delay_ms(200)

    return 0
}

// Disconnect from network
export fn wifi_disconnect() {
    if wifi_initialized == 0 {
        return
    }

    if wifi_driver.connected == 0 {
        return
    }

    foundation.serial_write_string("[WiFi] Disconnecting...\n")

    wifi_driver.state = WIFI_STATE_DISCONNECTING

    // Send deauthentication frame
    var desc_idx: u32 = wifi_driver.tx_tail
    var desc: *WifiTxDesc = @intToPtr(wifi_driver.tx_ring_base + @intCast(desc_idx, u64) * @sizeOf(WifiTxDesc), *WifiTxDesc)

    var buffer: u64 = memory.alloc_pages(1)
    if buffer != 0 {
        var header: *Wifi80211Header = @intToPtr(buffer, *Wifi80211Header)
        header.frame_control = @intCast(WIFI_FRAME_MGMT, u16) | @intCast(WIFI_MGMT_DEAUTH, u16)

        var i: u32 = 0
        while i < 6 {
            header.addr1[i] = wifi_driver.current_bssid[i]
            header.addr2[i] = wifi_driver.mac_addr[i]
            header.addr3[i] = wifi_driver.current_bssid[i]
            i = i + 1
        }

        desc.buffer_addr = buffer
        desc.length = @sizeOf(Wifi80211Header) + 2
        desc.flags = 0x0001
        desc.rate = 0x0B
        desc.retry_limit = 1
        desc.status = 0

        wifi_driver.tx_tail = (wifi_driver.tx_tail + 1) % MAX_TX_QUEUES
        wifi_write32(WIFI_REG_TX_CONFIG, 0x01)
    }

    wifi_driver.connected = 0
    wifi_driver.state = WIFI_STATE_IDLE

    foundation.serial_write_string("[WiFi] Disconnected\n")
}

// Check if connected
export fn wifi_is_connected(): u32 {
    return wifi_driver.connected
}

// Get signal strength (RSSI)
export fn wifi_get_rssi(): i8 {
    if wifi_driver.connected == 0 {
        return -100
    }

    // Read current RSSI from hardware
    var status: u32 = wifi_read32(WIFI_REG_STATUS)
    return @truncate(status >> 24, i8)
}

// Set operating mode
export fn wifi_set_mode(mode: u32) {
    if wifi_initialized == 0 {
        return
    }

    wifi_driver.mode = mode

    var mode_str: [*]u8 = "Unknown"
    if mode == WIFI_MODE_STATION {
        mode_str = "Station"
    } else if mode == WIFI_MODE_AP {
        mode_str = "AP"
    } else if mode == WIFI_MODE_MONITOR {
        mode_str = "Monitor"
    }

    foundation.serial_write_string("[WiFi] Mode set to ")
    foundation.serial_write_string(mode_str)
    foundation.serial_write_string("\n")
}

// Get network count from last scan
export fn wifi_get_network_count(): u32 {
    return wifi_driver.network_count
}

// Get network info
export fn wifi_get_network(index: u32, ssid: [*]u8, signal: *i8, security: *u32): u32 {
    if index >= wifi_driver.network_count {
        return 1
    }

    var network: *WifiNetwork = &wifi_driver.networks[index]

    var i: u32 = 0
    while i < 32 {
        ssid[i] = network.ssid[i]
        if ssid[i] == 0 {
            break
        }
        i = i + 1
    }

    @ptrToInt(signal, i8) = network.signal_strength
    @ptrToInt(security, u32) = network.security

    return 0
}

// Get MAC address
export fn wifi_get_mac(mac: [*]u8) {
    var i: u32 = 0
    while i < 6 {
        mac[i] = wifi_driver.mac_addr[i]
        i = i + 1
    }
}

// Set TX power
export fn wifi_set_tx_power(power_dbm: u8) {
    wifi_driver.tx_power = power_dbm
    // Configure hardware
}

// Enable/disable power save
export fn wifi_set_power_save(enable: u32) {
    wifi_driver.power_save = enable
}

// Get statistics
export fn wifi_get_stats(tx_packets: *u64, rx_packets: *u64, tx_bytes: *u64, rx_bytes: *u64) {
    @ptrToInt(tx_packets, u64) = wifi_driver.tx_packets
    @ptrToInt(rx_packets, u64) = wifi_driver.rx_packets
    @ptrToInt(tx_bytes, u64) = wifi_driver.tx_bytes
    @ptrToInt(rx_bytes, u64) = wifi_driver.rx_bytes
}

// Interrupt handler
export fn wifi_interrupt_handler() {
    var status: u32 = wifi_read32(WIFI_REG_INT_STATUS)

    // TX completion
    if (status & 0x01) != 0 {
        process_tx_completion()
    }

    // RX packet
    if (status & 0x02) != 0 {
        process_rx_packet()
    }

    // Clear interrupts
    wifi_write32(WIFI_REG_INT_STATUS, status)
}

// Process TX completion
fn process_tx_completion() {
    while wifi_driver.tx_head != wifi_driver.tx_tail {
        var desc: *WifiTxDesc = @intToPtr(wifi_driver.tx_ring_base + @intCast(wifi_driver.tx_head, u64) * @sizeOf(WifiTxDesc), *WifiTxDesc)

        if desc.status == 0 {
            break  // Not complete yet
        }

        if (desc.status & 0x8000) != 0 {
            wifi_driver.tx_errors = wifi_driver.tx_errors + 1
        } else {
            wifi_driver.tx_packets = wifi_driver.tx_packets + 1
            wifi_driver.tx_bytes = wifi_driver.tx_bytes + @intCast(desc.length, u64)
        }

        // Free buffer
        memory.free_pages(desc.buffer_addr, 1)

        wifi_driver.tx_head = (wifi_driver.tx_head + 1) % MAX_TX_QUEUES
    }
}

// Process received packet
fn process_rx_packet() {
    while true {
        var desc: *WifiRxDesc = @intToPtr(wifi_driver.rx_ring_base + @intCast(wifi_driver.rx_head, u64) * @sizeOf(WifiRxDesc), *WifiRxDesc)

        if (desc.flags & 0x8000) != 0 {
            break  // Still owned by hardware
        }

        wifi_driver.rx_packets = wifi_driver.rx_packets + 1
        wifi_driver.rx_bytes = wifi_driver.rx_bytes + @intCast(desc.length, u64)

        // Process frame based on type
        var header: *Wifi80211Header = @intToPtr(desc.buffer_addr, *Wifi80211Header)
        var frame_type: u8 = @truncate(header.frame_control, u8) & 0x0C

        if frame_type == WIFI_FRAME_DATA {
            // Forward to network stack
            netdev.receive_packet(desc.buffer_addr + @sizeOf(Wifi80211Header), desc.length - @sizeOf(Wifi80211Header))
        }

        // Return buffer to hardware
        desc.length = 0
        desc.flags = 0x8000

        wifi_driver.rx_head = (wifi_driver.rx_head + 1) % MAX_RX_BUFFERS
    }
}

// Transmit data frame
export fn wifi_transmit(data: [*]u8, length: u32): u32 {
    if wifi_driver.connected == 0 {
        return 1
    }

    var desc_idx: u32 = wifi_driver.tx_tail
    var next_tail: u32 = (desc_idx + 1) % MAX_TX_QUEUES

    if next_tail == wifi_driver.tx_head {
        return 1  // TX ring full
    }

    var desc: *WifiTxDesc = @intToPtr(wifi_driver.tx_ring_base + @intCast(desc_idx, u64) * @sizeOf(WifiTxDesc), *WifiTxDesc)

    var buffer: u64 = memory.alloc_pages(1)
    if buffer == 0 {
        return 1
    }

    // Build data frame header
    var header: *Wifi80211Header = @intToPtr(buffer, *Wifi80211Header)
    header.frame_control = @intCast(WIFI_FRAME_DATA, u16) | 0x0100  // To DS
    header.duration = 0

    // To AP (addr1)
    var i: u32 = 0
    while i < 6 {
        header.addr1[i] = wifi_driver.current_bssid[i]
        i = i + 1
    }

    // From us (addr2)
    i = 0
    while i < 6 {
        header.addr2[i] = wifi_driver.mac_addr[i]
        i = i + 1
    }

    // Final destination (addr3) - from Ethernet header in data
    i = 0
    while i < 6 {
        header.addr3[i] = data[i]
        i = i + 1
    }

    header.seq_ctrl = 0

    // Copy data after header
    var payload: *u8 = @intToPtr(buffer + @sizeOf(Wifi80211Header), *u8)
    memory.memcpy(payload, data, length)

    desc.buffer_addr = buffer
    desc.length = @truncate(@sizeOf(Wifi80211Header) + length, u16)
    desc.flags = 0x0001
    desc.rate = 0x16  // 11 Mbps
    desc.retry_limit = 7
    desc.status = 0

    wifi_driver.tx_tail = next_tail
    wifi_write32(WIFI_REG_TX_CONFIG, 0x01)

    return 0
}
