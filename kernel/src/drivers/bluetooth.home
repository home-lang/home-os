// home-os Bluetooth Driver
// Bluetooth HCI and profile support

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "pci.home" as pci
import "usb.home" as usb

// Bluetooth states
const BT_STATE_OFF: u32 = 0
const BT_STATE_ON: u32 = 1
const BT_STATE_SCANNING: u32 = 2
const BT_STATE_CONNECTING: u32 = 3
const BT_STATE_CONNECTED: u32 = 4
const BT_STATE_PAIRING: u32 = 5

// Bluetooth versions
const BT_VERSION_1_1: u8 = 0x00
const BT_VERSION_1_2: u8 = 0x01
const BT_VERSION_2_0: u8 = 0x02
const BT_VERSION_2_1: u8 = 0x03
const BT_VERSION_3_0: u8 = 0x04
const BT_VERSION_4_0: u8 = 0x06
const BT_VERSION_4_1: u8 = 0x07
const BT_VERSION_4_2: u8 = 0x08
const BT_VERSION_5_0: u8 = 0x09
const BT_VERSION_5_1: u8 = 0x0A
const BT_VERSION_5_2: u8 = 0x0B

// HCI packet types
const HCI_COMMAND_PKT: u8 = 0x01
const HCI_ACL_DATA_PKT: u8 = 0x02
const HCI_SCO_DATA_PKT: u8 = 0x03
const HCI_EVENT_PKT: u8 = 0x04
const HCI_ISO_DATA_PKT: u8 = 0x05

// HCI OGF (Opcode Group Field)
const HCI_OGF_LINK_CTL: u16 = 0x01
const HCI_OGF_LINK_POLICY: u16 = 0x02
const HCI_OGF_HOST_CTL: u16 = 0x03
const HCI_OGF_INFO_PARAM: u16 = 0x04
const HCI_OGF_STATUS_PARAM: u16 = 0x05
const HCI_OGF_LE_CTL: u16 = 0x08

// HCI Link Control commands
const HCI_OCF_INQUIRY: u16 = 0x0001
const HCI_OCF_INQUIRY_CANCEL: u16 = 0x0002
const HCI_OCF_CREATE_CONN: u16 = 0x0005
const HCI_OCF_DISCONNECT: u16 = 0x0006
const HCI_OCF_ACCEPT_CONN: u16 = 0x0009
const HCI_OCF_REJECT_CONN: u16 = 0x000A
const HCI_OCF_AUTH_REQUESTED: u16 = 0x0011
const HCI_OCF_SET_CONN_ENCRYPT: u16 = 0x0013

// HCI Host Control commands
const HCI_OCF_RESET: u16 = 0x0003
const HCI_OCF_SET_EVENT_MASK: u16 = 0x0001
const HCI_OCF_WRITE_LOCAL_NAME: u16 = 0x0013
const HCI_OCF_READ_LOCAL_NAME: u16 = 0x0014
const HCI_OCF_WRITE_SCAN_ENABLE: u16 = 0x001A
const HCI_OCF_WRITE_CLASS: u16 = 0x0024

// HCI Info Param commands
const HCI_OCF_READ_BD_ADDR: u16 = 0x0009
const HCI_OCF_READ_LOCAL_VERSION: u16 = 0x0001
const HCI_OCF_READ_LOCAL_FEATURES: u16 = 0x0003

// HCI LE commands
const HCI_OCF_LE_SET_EVENT_MASK: u16 = 0x0001
const HCI_OCF_LE_SET_SCAN_PARAMS: u16 = 0x000B
const HCI_OCF_LE_SET_SCAN_ENABLE: u16 = 0x000C
const HCI_OCF_LE_CREATE_CONN: u16 = 0x000D
const HCI_OCF_LE_CONN_UPDATE: u16 = 0x0013
const HCI_OCF_LE_SET_ADV_PARAMS: u16 = 0x0006
const HCI_OCF_LE_SET_ADV_DATA: u16 = 0x0008
const HCI_OCF_LE_SET_ADV_ENABLE: u16 = 0x000A

// HCI Events
const HCI_EV_INQUIRY_COMPLETE: u8 = 0x01
const HCI_EV_INQUIRY_RESULT: u8 = 0x02
const HCI_EV_CONN_COMPLETE: u8 = 0x03
const HCI_EV_CONN_REQUEST: u8 = 0x04
const HCI_EV_DISCONN_COMPLETE: u8 = 0x05
const HCI_EV_AUTH_COMPLETE: u8 = 0x06
const HCI_EV_REMOTE_NAME: u8 = 0x07
const HCI_EV_ENCRYPT_CHANGE: u8 = 0x08
const HCI_EV_CMD_COMPLETE: u8 = 0x0E
const HCI_EV_CMD_STATUS: u8 = 0x0F
const HCI_EV_NUM_COMP_PKTS: u8 = 0x13
const HCI_EV_LE_META: u8 = 0x3E

// LE Meta sub-events
const HCI_EV_LE_CONN_COMPLETE: u8 = 0x01
const HCI_EV_LE_ADV_REPORT: u8 = 0x02
const HCI_EV_LE_CONN_UPDATE: u8 = 0x03

// Device classes
const BT_CLASS_COMPUTER: u32 = 0x100
const BT_CLASS_PHONE: u32 = 0x200
const BT_CLASS_LAN: u32 = 0x300
const BT_CLASS_AUDIO: u32 = 0x400
const BT_CLASS_PERIPHERAL: u32 = 0x500
const BT_CLASS_IMAGING: u32 = 0x600
const BT_CLASS_WEARABLE: u32 = 0x700

// Maximum values
const MAX_BT_DEVICES: u32 = 32
const MAX_CONNECTIONS: u32 = 7
const MAX_NAME_LEN: u32 = 248
const HCI_MAX_EVENT_SIZE: u32 = 260
const HCI_MAX_ACL_SIZE: u32 = 1024

// Bluetooth device info
struct BtDevice {
    address: [6]u8,            // BD_ADDR (little-endian)
    name: [MAX_NAME_LEN]u8,    // Device name
    name_len: u8,
    class_of_device: u32,      // CoD
    rssi: i8,                  // Signal strength
    paired: u32,               // Is paired
    connected: u32,            // Is connected
    link_key: [16]u8,          // Link key for pairing
    features: [8]u8,           // LMP features
    version: u8,               // LMP version
    le_device: u32,            // Is BLE device
    address_type: u8           // 0 = public, 1 = random
}

// HCI connection info
struct HciConnection {
    handle: u16,               // Connection handle
    address: [6]u8,            // Remote BD_ADDR
    link_type: u8,             // ACL, SCO, or LE
    encrypted: u32,            // Encryption enabled
    role: u8,                  // Master/Slave
    state: u32
}

// HCI command header
struct HciCommandHdr {
    opcode: u16,               // OGF + OCF
    param_len: u8
}

// HCI event header
struct HciEventHdr {
    event: u8,
    param_len: u8
}

// HCI ACL data header
struct HciAclHdr {
    handle_flags: u16,         // Connection handle + PB + BC flags
    data_len: u16
}

// Bluetooth driver state
struct BtDriver {
    // Hardware state
    base_addr: u64,
    irq: u32,
    transport: u32,            // 0 = USB, 1 = UART, 2 = SDIO

    // Controller info
    bd_addr: [6]u8,            // Local BD_ADDR
    local_name: [MAX_NAME_LEN]u8,
    local_name_len: u8,
    class_of_device: u32,
    hci_version: u8,
    hci_revision: u16,
    lmp_version: u8,
    lmp_subversion: u16,
    manufacturer: u16,
    features: [8]u8,
    le_features: [8]u8,

    // State
    state: u32,
    initialized: u32,
    scan_enabled: u32,

    // Discovered devices
    devices: [MAX_BT_DEVICES]BtDevice,
    device_count: u32,

    // Active connections
    connections: [MAX_CONNECTIONS]HciConnection,
    connection_count: u32,

    // Command handling
    pending_opcode: u16,
    cmd_complete: u32,
    cmd_status: u8,

    // Event buffer
    event_buffer: [HCI_MAX_EVENT_SIZE]u8,

    // Statistics
    tx_packets: u64,
    rx_packets: u64,
    tx_bytes: u64,
    rx_bytes: u64,
    errors: u32
}

// Global driver instance
var bt_driver: BtDriver = undefined

// Build HCI opcode
fn hci_opcode(ogf: u16, ocf: u16): u16 {
    return (ogf << 10) | ocf
}

// Send HCI command
fn hci_send_command(opcode: u16, params: [*]u8, param_len: u8): u32 {
    var cmd_buffer: [260]u8 = undefined

    // Build command packet
    cmd_buffer[0] = HCI_COMMAND_PKT
    cmd_buffer[1] = @truncate(opcode, u8)
    cmd_buffer[2] = @truncate(opcode >> 8, u8)
    cmd_buffer[3] = param_len

    // Copy parameters
    var i: u32 = 0
    while i < @intCast(param_len, u32) {
        cmd_buffer[4 + i] = params[i]
        i = i + 1
    }

    // Set pending opcode
    bt_driver.pending_opcode = opcode
    bt_driver.cmd_complete = 0

    // Send to transport
    if bt_driver.transport == 0 {
        // USB transport
        usb.usb_bulk_out(0, &cmd_buffer[0], 4 + @intCast(param_len, u32))
    } else {
        // UART transport - write to MMIO
        var addr: u64 = bt_driver.base_addr
        i = 0
        while i < 4 + @intCast(param_len, u32) {
            @volatile_store(@intToPtr(addr, *volatile u8), cmd_buffer[i])
            i = i + 1
        }
    }

    bt_driver.tx_packets = bt_driver.tx_packets + 1
    bt_driver.tx_bytes = bt_driver.tx_bytes + 4 + @intCast(param_len, u64)

    // Wait for command complete
    var timeout: u32 = 1000
    while bt_driver.cmd_complete == 0 and timeout > 0 {
        foundation.delay_ms(1)
        process_hci_events()
        timeout = timeout - 1
    }

    if timeout == 0 {
        foundation.serial_write_string("[BT] Command timeout\n")
        return 1
    }

    return 0
}

// Process HCI events
fn process_hci_events() {
    // Read from transport
    var pkt_type: u8 = 0

    if bt_driver.transport == 0 {
        // USB transport
        var len: u32 = usb.usb_bulk_in(0, &bt_driver.event_buffer[0], HCI_MAX_EVENT_SIZE)
        if len == 0 {
            return
        }
        pkt_type = bt_driver.event_buffer[0]
    } else {
        // UART transport - check status register
        var status: u8 = @volatile_load(@intToPtr(bt_driver.base_addr + 0x14, *volatile u8))
        if (status & 0x01) == 0 {
            return  // No data available
        }
        pkt_type = @volatile_load(@intToPtr(bt_driver.base_addr, *volatile u8))
    }

    if pkt_type == HCI_EVENT_PKT {
        process_event()
    } else if pkt_type == HCI_ACL_DATA_PKT {
        process_acl_data()
    }
}

// Process HCI event
fn process_event() {
    var hdr: *HciEventHdr = @intToPtr(@ptrToInt(&bt_driver.event_buffer[1]), *HciEventHdr)
    var params: [*]u8 = &bt_driver.event_buffer[3]

    bt_driver.rx_packets = bt_driver.rx_packets + 1
    bt_driver.rx_bytes = bt_driver.rx_bytes + 3 + @intCast(hdr.param_len, u64)

    if hdr.event == HCI_EV_CMD_COMPLETE {
        process_cmd_complete(params, hdr.param_len)
    } else if hdr.event == HCI_EV_CMD_STATUS {
        process_cmd_status(params)
    } else if hdr.event == HCI_EV_INQUIRY_RESULT {
        process_inquiry_result(params, hdr.param_len)
    } else if hdr.event == HCI_EV_INQUIRY_COMPLETE {
        bt_driver.state = BT_STATE_ON
        foundation.serial_write_string("[BT] Inquiry complete\n")
    } else if hdr.event == HCI_EV_CONN_COMPLETE {
        process_conn_complete(params)
    } else if hdr.event == HCI_EV_DISCONN_COMPLETE {
        process_disconn_complete(params)
    } else if hdr.event == HCI_EV_REMOTE_NAME {
        process_remote_name(params)
    } else if hdr.event == HCI_EV_LE_META {
        process_le_meta(params, hdr.param_len)
    }
}

// Process command complete event
fn process_cmd_complete(params: [*]u8, param_len: u8) {
    var num_pkts: u8 = params[0]
    var opcode: u16 = @intCast(params[1], u16) | (@intCast(params[2], u16) << 8)
    var status: u8 = params[3]

    if opcode == bt_driver.pending_opcode {
        bt_driver.cmd_complete = 1
        bt_driver.cmd_status = status
    }

    // Handle specific command completions
    var ogf: u16 = opcode >> 10
    var ocf: u16 = opcode & 0x03FF

    if ogf == HCI_OGF_INFO_PARAM {
        if ocf == HCI_OCF_READ_BD_ADDR and status == 0 {
            // Copy BD_ADDR
            var i: u32 = 0
            while i < 6 {
                bt_driver.bd_addr[i] = params[4 + i]
                i = i + 1
            }
        } else if ocf == HCI_OCF_READ_LOCAL_VERSION and status == 0 {
            bt_driver.hci_version = params[4]
            bt_driver.hci_revision = @intCast(params[5], u16) | (@intCast(params[6], u16) << 8)
            bt_driver.lmp_version = params[7]
            bt_driver.manufacturer = @intCast(params[8], u16) | (@intCast(params[9], u16) << 8)
            bt_driver.lmp_subversion = @intCast(params[10], u16) | (@intCast(params[11], u16) << 8)
        }
    }
}

// Process command status event
fn process_cmd_status(params: [*]u8) {
    var status: u8 = params[0]
    var num_pkts: u8 = params[1]
    var opcode: u16 = @intCast(params[2], u16) | (@intCast(params[3], u16) << 8)

    if opcode == bt_driver.pending_opcode {
        bt_driver.cmd_complete = 1
        bt_driver.cmd_status = status
    }
}

// Process inquiry result
fn process_inquiry_result(params: [*]u8, param_len: u8) {
    var num_responses: u8 = params[0]
    var offset: u32 = 1

    var i: u8 = 0
    while i < num_responses {
        if bt_driver.device_count >= MAX_BT_DEVICES {
            break
        }

        var device: *BtDevice = &bt_driver.devices[bt_driver.device_count]

        // BD_ADDR
        var j: u32 = 0
        while j < 6 {
            device.address[j] = params[offset + j]
            j = j + 1
        }
        offset = offset + 6

        // Page scan repetition mode (skip)
        offset = offset + 1

        // Reserved
        offset = offset + 2

        // Class of device
        device.class_of_device = @intCast(params[offset], u32) |
                                  (@intCast(params[offset + 1], u32) << 8) |
                                  (@intCast(params[offset + 2], u32) << 16)
        offset = offset + 3

        // Clock offset
        offset = offset + 2

        device.paired = 0
        device.connected = 0
        device.le_device = 0
        device.name_len = 0

        bt_driver.device_count = bt_driver.device_count + 1

        i = i + 1
    }
}

// Process connection complete
fn process_conn_complete(params: [*]u8) {
    var status: u8 = params[0]

    if status != 0 {
        foundation.serial_write_string("[BT] Connection failed: ")
        foundation.serial_write_hex8(status)
        foundation.serial_write_string("\n")
        return
    }

    var handle: u16 = @intCast(params[1], u16) | (@intCast(params[2], u16) << 8)

    if bt_driver.connection_count >= MAX_CONNECTIONS {
        return
    }

    var conn: *HciConnection = &bt_driver.connections[bt_driver.connection_count]
    conn.handle = handle

    var i: u32 = 0
    while i < 6 {
        conn.address[i] = params[3 + i]
        i = i + 1
    }

    conn.link_type = params[9]
    conn.encrypted = 0
    conn.state = BT_STATE_CONNECTED

    bt_driver.connection_count = bt_driver.connection_count + 1

    foundation.serial_write_string("[BT] Connection established, handle=")
    foundation.serial_write_hex16(handle)
    foundation.serial_write_string("\n")
}

// Process disconnection complete
fn process_disconn_complete(params: [*]u8) {
    var status: u8 = params[0]
    var handle: u16 = @intCast(params[1], u16) | (@intCast(params[2], u16) << 8)
    var reason: u8 = params[3]

    // Find and remove connection
    var i: u32 = 0
    while i < bt_driver.connection_count {
        if bt_driver.connections[i].handle == handle {
            // Shift remaining connections
            var j: u32 = i
            while j < bt_driver.connection_count - 1 {
                bt_driver.connections[j] = bt_driver.connections[j + 1]
                j = j + 1
            }
            bt_driver.connection_count = bt_driver.connection_count - 1
            break
        }
        i = i + 1
    }

    foundation.serial_write_string("[BT] Disconnected, handle=")
    foundation.serial_write_hex16(handle)
    foundation.serial_write_string(" reason=")
    foundation.serial_write_hex8(reason)
    foundation.serial_write_string("\n")
}

// Process remote name
fn process_remote_name(params: [*]u8) {
    var status: u8 = params[0]
    if status != 0 {
        return
    }

    // Find device by address
    var i: u32 = 0
    while i < bt_driver.device_count {
        var device: *BtDevice = &bt_driver.devices[i]
        var match: u32 = 1
        var j: u32 = 0
        while j < 6 {
            if device.address[j] != params[1 + j] {
                match = 0
                break
            }
            j = j + 1
        }

        if match != 0 {
            // Copy name
            j = 0
            while j < MAX_NAME_LEN - 1 {
                var c: u8 = params[7 + j]
                if c == 0 {
                    break
                }
                device.name[j] = c
                j = j + 1
            }
            device.name[j] = 0
            device.name_len = @truncate(j, u8)
            break
        }
        i = i + 1
    }
}

// Process LE meta event
fn process_le_meta(params: [*]u8, param_len: u8) {
    var subevent: u8 = params[0]

    if subevent == HCI_EV_LE_ADV_REPORT {
        process_le_adv_report(&params[1], param_len - 1)
    } else if subevent == HCI_EV_LE_CONN_COMPLETE {
        process_le_conn_complete(&params[1])
    }
}

// Process LE advertising report
fn process_le_adv_report(params: [*]u8, param_len: u8) {
    var num_reports: u8 = params[0]
    var offset: u32 = 1

    var i: u8 = 0
    while i < num_reports {
        if bt_driver.device_count >= MAX_BT_DEVICES {
            break
        }

        var event_type: u8 = params[offset]
        offset = offset + 1

        var addr_type: u8 = params[offset]
        offset = offset + 1

        var device: *BtDevice = &bt_driver.devices[bt_driver.device_count]

        // BD_ADDR
        var j: u32 = 0
        while j < 6 {
            device.address[j] = params[offset + j]
            j = j + 1
        }
        offset = offset + 6

        device.address_type = addr_type
        device.le_device = 1
        device.paired = 0
        device.connected = 0

        // Data length
        var data_len: u8 = params[offset]
        offset = offset + 1

        // Parse advertising data for name
        var ad_offset: u32 = 0
        while ad_offset < @intCast(data_len, u32) {
            var len: u8 = params[offset + ad_offset]
            if len == 0 {
                break
            }
            var ad_type: u8 = params[offset + ad_offset + 1]

            // Complete Local Name (0x09) or Shortened Local Name (0x08)
            if ad_type == 0x09 or ad_type == 0x08 {
                j = 0
                while j < @intCast(len - 1, u32) and j < MAX_NAME_LEN - 1 {
                    device.name[j] = params[offset + ad_offset + 2 + j]
                    j = j + 1
                }
                device.name[j] = 0
                device.name_len = @truncate(j, u8)
            }

            ad_offset = ad_offset + 1 + @intCast(len, u32)
        }
        offset = offset + @intCast(data_len, u32)

        // RSSI
        device.rssi = @bitCast(params[offset], i8)
        offset = offset + 1

        bt_driver.device_count = bt_driver.device_count + 1
        i = i + 1
    }
}

// Process LE connection complete
fn process_le_conn_complete(params: [*]u8) {
    var status: u8 = params[0]

    if status != 0 {
        foundation.serial_write_string("[BT] LE connection failed\n")
        return
    }

    var handle: u16 = @intCast(params[1], u16) | (@intCast(params[2], u16) << 8)
    var role: u8 = params[3]

    if bt_driver.connection_count >= MAX_CONNECTIONS {
        return
    }

    var conn: *HciConnection = &bt_driver.connections[bt_driver.connection_count]
    conn.handle = handle
    conn.link_type = 0x80  // LE link
    conn.role = role
    conn.encrypted = 0
    conn.state = BT_STATE_CONNECTED

    var i: u32 = 0
    while i < 6 {
        conn.address[i] = params[5 + i]
        i = i + 1
    }

    bt_driver.connection_count = bt_driver.connection_count + 1

    foundation.serial_write_string("[BT] LE connection established\n")
}

// Process ACL data
fn process_acl_data() {
    // Read ACL header
    var hdr: *HciAclHdr = @intToPtr(@ptrToInt(&bt_driver.event_buffer[1]), *HciAclHdr)
    var handle: u16 = hdr.handle_flags & 0x0FFF
    var flags: u8 = @truncate(hdr.handle_flags >> 12, u8)
    var len: u16 = hdr.data_len

    // Find connection
    var conn_idx: u32 = 0xFFFFFFFF
    var i: u32 = 0
    while i < bt_driver.connection_count {
        if bt_driver.connections[i].handle == handle {
            conn_idx = i
            break
        }
        i = i + 1
    }

    if conn_idx == 0xFFFFFFFF {
        return
    }

    // Forward data to L2CAP layer
    // l2cap.receive(&bt_driver.event_buffer[5], len)
}

// Initialize Bluetooth driver
export fn bluetooth_init() {
    foundation.serial_write_string("[BT] Initializing...\n")

    // Clear state
    bt_driver.state = BT_STATE_OFF
    bt_driver.initialized = 0
    bt_driver.device_count = 0
    bt_driver.connection_count = 0
    bt_driver.scan_enabled = 0
    bt_driver.tx_packets = 0
    bt_driver.rx_packets = 0
    bt_driver.tx_bytes = 0
    bt_driver.rx_bytes = 0
    bt_driver.errors = 0

    // Try USB transport first
    if usb.usb_find_device(0x0A5C, 0x21E8) != 0 or  // Broadcom
       usb.usb_find_device(0x8087, 0x0A2B) != 0 or  // Intel
       usb.usb_find_device(0x0CF3, 0x3004) != 0 {   // Atheros
        bt_driver.transport = 0  // USB
        foundation.serial_write_string("[BT] Using USB transport\n")
    } else {
        // Try UART transport
        bt_driver.base_addr = 0  // Would be set from device tree
        bt_driver.transport = 1
        foundation.serial_write_string("[BT] Using UART transport\n")
    }

    bt_driver.initialized = 1
    foundation.serial_write_string("[BT] Initialized\n")
}

// Enable Bluetooth
export fn bluetooth_enable() {
    if bt_driver.initialized == 0 {
        return
    }

    foundation.serial_write_string("[BT] Enabling...\n")

    // Reset controller
    var params: [0]u8 = undefined
    hci_send_command(hci_opcode(HCI_OGF_HOST_CTL, HCI_OCF_RESET), &params[0], 0)

    foundation.delay_ms(100)

    // Read local version
    hci_send_command(hci_opcode(HCI_OGF_INFO_PARAM, HCI_OCF_READ_LOCAL_VERSION), &params[0], 0)

    // Read BD_ADDR
    hci_send_command(hci_opcode(HCI_OGF_INFO_PARAM, HCI_OCF_READ_BD_ADDR), &params[0], 0)

    // Set local name
    var name_params: [248]u8 = undefined
    var name: [*]u8 = "HomeOS Bluetooth"
    var i: u32 = 0
    while name[i] != 0 and i < 247 {
        name_params[i] = name[i]
        i = i + 1
    }
    while i < 248 {
        name_params[i] = 0
        i = i + 1
    }
    hci_send_command(hci_opcode(HCI_OGF_HOST_CTL, HCI_OCF_WRITE_LOCAL_NAME), &name_params[0], 248)

    // Set class of device (Computer - Desktop)
    var cod_params: [3]u8 = undefined
    cod_params[0] = 0x04  // Minor: Desktop
    cod_params[1] = 0x01  // Major: Computer
    cod_params[2] = 0x00
    hci_send_command(hci_opcode(HCI_OGF_HOST_CTL, HCI_OCF_WRITE_CLASS), &cod_params[0], 3)

    // Enable scan
    var scan_params: [1]u8 = undefined
    scan_params[0] = 0x03  // Inquiry + Page scan
    hci_send_command(hci_opcode(HCI_OGF_HOST_CTL, HCI_OCF_WRITE_SCAN_ENABLE), &scan_params[0], 1)

    bt_driver.state = BT_STATE_ON

    foundation.serial_write_string("[BT] Enabled, BD_ADDR: ")
    i = 5
    while true {
        foundation.serial_write_hex8(bt_driver.bd_addr[i])
        if i == 0 {
            break
        }
        foundation.serial_write_string(":")
        i = i - 1
    }
    foundation.serial_write_string("\n")
}

// Disable Bluetooth
export fn bluetooth_disable() {
    if bt_driver.state == BT_STATE_OFF {
        return
    }

    foundation.serial_write_string("[BT] Disabling...\n")

    // Disconnect all connections
    var i: u32 = 0
    while i < bt_driver.connection_count {
        var params: [3]u8 = undefined
        params[0] = @truncate(bt_driver.connections[i].handle, u8)
        params[1] = @truncate(bt_driver.connections[i].handle >> 8, u8)
        params[2] = 0x13  // Remote user terminated
        hci_send_command(hci_opcode(HCI_OGF_LINK_CTL, HCI_OCF_DISCONNECT), &params[0], 3)
        i = i + 1
    }

    bt_driver.state = BT_STATE_OFF
    bt_driver.connection_count = 0

    foundation.serial_write_string("[BT] Disabled\n")
}

// Start device discovery
export fn bluetooth_scan(): u32 {
    if bt_driver.state != BT_STATE_ON {
        return 0
    }

    foundation.serial_write_string("[BT] Starting scan...\n")

    bt_driver.state = BT_STATE_SCANNING
    bt_driver.device_count = 0

    // Classic Bluetooth inquiry
    var inquiry_params: [5]u8 = undefined
    inquiry_params[0] = 0x33  // GIAC LAP
    inquiry_params[1] = 0x8B
    inquiry_params[2] = 0x9E
    inquiry_params[3] = 0x08  // 8 * 1.28s = ~10 seconds
    inquiry_params[4] = 0x00  // Unlimited responses

    hci_send_command(hci_opcode(HCI_OGF_LINK_CTL, HCI_OCF_INQUIRY), &inquiry_params[0], 5)

    // Also do LE scan
    var le_scan_params: [7]u8 = undefined
    le_scan_params[0] = 0x01  // Active scan
    le_scan_params[1] = 0x10  // Scan interval LSB
    le_scan_params[2] = 0x00  // Scan interval MSB
    le_scan_params[3] = 0x10  // Scan window LSB
    le_scan_params[4] = 0x00  // Scan window MSB
    le_scan_params[5] = 0x00  // Own address type (public)
    le_scan_params[6] = 0x00  // Filter policy

    hci_send_command(hci_opcode(HCI_OGF_LE_CTL, HCI_OCF_LE_SET_SCAN_PARAMS), &le_scan_params[0], 7)

    var le_enable_params: [2]u8 = undefined
    le_enable_params[0] = 0x01  // Enable
    le_enable_params[1] = 0x00  // No duplicates filter

    hci_send_command(hci_opcode(HCI_OGF_LE_CTL, HCI_OCF_LE_SET_SCAN_ENABLE), &le_enable_params[0], 2)

    // Wait for inquiry to complete
    var timeout: u32 = 12000  // 12 seconds
    while bt_driver.state == BT_STATE_SCANNING and timeout > 0 {
        foundation.delay_ms(10)
        process_hci_events()
        timeout = timeout - 10
    }

    // Disable LE scan
    le_enable_params[0] = 0x00
    hci_send_command(hci_opcode(HCI_OGF_LE_CTL, HCI_OCF_LE_SET_SCAN_ENABLE), &le_enable_params[0], 2)

    foundation.serial_write_string("[BT] Scan complete, found ")
    foundation.serial_write_dec(bt_driver.device_count)
    foundation.serial_write_string(" devices\n")

    return bt_driver.device_count
}

// Pair with device
export fn bluetooth_pair(device_id: u32): u32 {
    if device_id >= bt_driver.device_count {
        return 1
    }

    var device: *BtDevice = &bt_driver.devices[device_id]

    foundation.serial_write_string("[BT] Pairing with device...\n")

    bt_driver.state = BT_STATE_PAIRING

    // For now, just mark as paired (simplified)
    device.paired = 1

    foundation.serial_write_string("[BT] Paired successfully\n")
    return 0
}

// Connect to device
export fn bluetooth_connect(device_id: u32): u32 {
    if device_id >= bt_driver.device_count {
        return 1
    }

    var device: *BtDevice = &bt_driver.devices[device_id]

    if device.paired == 0 {
        foundation.serial_write_string("[BT] Device not paired\n")
        return 1
    }

    foundation.serial_write_string("[BT] Connecting...\n")

    bt_driver.state = BT_STATE_CONNECTING

    if device.le_device != 0 {
        // LE connection
        var params: [25]u8 = undefined
        params[0] = 0x60   // Scan interval LSB
        params[1] = 0x00
        params[2] = 0x30   // Scan window LSB
        params[3] = 0x00
        params[4] = 0x00   // Filter policy
        params[5] = device.address_type
        // BD_ADDR
        var i: u32 = 0
        while i < 6 {
            params[6 + i] = device.address[i]
            i = i + 1
        }
        params[12] = 0x00  // Own address type
        params[13] = 0x06  // Conn interval min LSB
        params[14] = 0x00
        params[15] = 0x0C  // Conn interval max LSB
        params[16] = 0x00
        params[17] = 0x00  // Latency LSB
        params[18] = 0x00
        params[19] = 0xC8  // Supervision timeout LSB
        params[20] = 0x00
        params[21] = 0x00  // Min CE length LSB
        params[22] = 0x00
        params[23] = 0x00  // Max CE length LSB
        params[24] = 0x00

        hci_send_command(hci_opcode(HCI_OGF_LE_CTL, HCI_OCF_LE_CREATE_CONN), &params[0], 25)
    } else {
        // Classic connection
        var params: [13]u8 = undefined
        // BD_ADDR
        var i: u32 = 0
        while i < 6 {
            params[i] = device.address[i]
            i = i + 1
        }
        params[6] = 0x18   // Packet type LSB (DM1, DH1, DM3, DH3, DM5, DH5)
        params[7] = 0xCC   // Packet type MSB
        params[8] = 0x01   // Page scan repetition mode
        params[9] = 0x00   // Reserved
        params[10] = 0x00  // Clock offset LSB
        params[11] = 0x00  // Clock offset MSB
        params[12] = 0x00  // Allow role switch

        hci_send_command(hci_opcode(HCI_OGF_LINK_CTL, HCI_OCF_CREATE_CONN), &params[0], 13)
    }

    // Wait for connection
    var timeout: u32 = 10000
    while bt_driver.state == BT_STATE_CONNECTING and timeout > 0 {
        foundation.delay_ms(10)
        process_hci_events()
        timeout = timeout - 10
    }

    if bt_driver.connection_count > 0 {
        device.connected = 1
        bt_driver.state = BT_STATE_CONNECTED
        foundation.serial_write_string("[BT] Connected\n")
        return 0
    }

    bt_driver.state = BT_STATE_ON
    return 1
}

// Disconnect from device
export fn bluetooth_disconnect(device_id: u32): u32 {
    if device_id >= bt_driver.device_count {
        return 1
    }

    var device: *BtDevice = &bt_driver.devices[device_id]

    if device.connected == 0 {
        return 0
    }

    // Find connection
    var i: u32 = 0
    while i < bt_driver.connection_count {
        var match: u32 = 1
        var j: u32 = 0
        while j < 6 {
            if bt_driver.connections[i].address[j] != device.address[j] {
                match = 0
                break
            }
            j = j + 1
        }

        if match != 0 {
            var params: [3]u8 = undefined
            params[0] = @truncate(bt_driver.connections[i].handle, u8)
            params[1] = @truncate(bt_driver.connections[i].handle >> 8, u8)
            params[2] = 0x13  // Remote user terminated

            hci_send_command(hci_opcode(HCI_OGF_LINK_CTL, HCI_OCF_DISCONNECT), &params[0], 3)
            break
        }
        i = i + 1
    }

    device.connected = 0
    return 0
}

// Get state
export fn bluetooth_get_state(): u32 {
    return bt_driver.state
}

// Get device count
export fn bluetooth_get_device_count(): u32 {
    return bt_driver.device_count
}

// Get device info
export fn bluetooth_get_device(index: u32, address: [*]u8, name: [*]u8, rssi: *i8): u32 {
    if index >= bt_driver.device_count {
        return 1
    }

    var device: *BtDevice = &bt_driver.devices[index]

    var i: u32 = 0
    while i < 6 {
        address[i] = device.address[i]
        i = i + 1
    }

    i = 0
    while i < @intCast(device.name_len, u32) {
        name[i] = device.name[i]
        i = i + 1
    }
    name[i] = 0

    @ptrToInt(rssi, i8) = device.rssi

    return 0
}

// Send data over connection
export fn bluetooth_send(device_id: u32, data: [*]u8, length: u32): u32 {
    if device_id >= bt_driver.device_count {
        return 1
    }

    var device: *BtDevice = &bt_driver.devices[device_id]

    if device.connected == 0 {
        return 1
    }

    // Find connection handle
    var handle: u16 = 0
    var i: u32 = 0
    while i < bt_driver.connection_count {
        var match: u32 = 1
        var j: u32 = 0
        while j < 6 {
            if bt_driver.connections[i].address[j] != device.address[j] {
                match = 0
                break
            }
            j = j + 1
        }
        if match != 0 {
            handle = bt_driver.connections[i].handle
            break
        }
        i = i + 1
    }

    if handle == 0 {
        return 1
    }

    // Build ACL packet
    var packet: [HCI_MAX_ACL_SIZE + 5]u8 = undefined
    packet[0] = HCI_ACL_DATA_PKT
    packet[1] = @truncate(handle, u8)
    packet[2] = @truncate((handle >> 8) | 0x20, u8)  // PB=first, BC=point-to-point
    packet[3] = @truncate(length, u8)
    packet[4] = @truncate(length >> 8, u8)

    i = 0
    while i < length and i < HCI_MAX_ACL_SIZE {
        packet[5 + i] = data[i]
        i = i + 1
    }

    // Send
    if bt_driver.transport == 0 {
        usb.usb_bulk_out(0, &packet[0], 5 + length)
    }

    bt_driver.tx_packets = bt_driver.tx_packets + 1
    bt_driver.tx_bytes = bt_driver.tx_bytes + 5 + @intCast(length, u64)

    return 0
}

// Get statistics
export fn bluetooth_get_stats(tx_pkts: *u64, rx_pkts: *u64, errors: *u32) {
    @ptrToInt(tx_pkts, u64) = bt_driver.tx_packets
    @ptrToInt(rx_pkts, u64) = bt_driver.rx_packets
    @ptrToInt(errors, u32) = bt_driver.errors
}
