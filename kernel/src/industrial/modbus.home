// home-os Kernel - Modbus Protocol
// Industrial communication protocol (RTU and TCP)

import "../core/foundation.home" as foundation
import "../network/network.home" as network

const MODBUS_TCP_PORT: u16 = 502
const MAX_MODBUS_DEVICES: u32 = 32

// Function codes
const MODBUS_READ_COILS: u8 = 0x01
const MODBUS_READ_DISCRETE_INPUTS: u8 = 0x02
const MODBUS_READ_HOLDING_REGISTERS: u8 = 0x03
const MODBUS_READ_INPUT_REGISTERS: u8 = 0x04
const MODBUS_WRITE_SINGLE_COIL: u8 = 0x05
const MODBUS_WRITE_SINGLE_REGISTER: u8 = 0x06
const MODBUS_WRITE_MULTIPLE_COILS: u8 = 0x0F
const MODBUS_WRITE_MULTIPLE_REGISTERS: u8 = 0x10

struct ModbusDevice {
  address: u8,
  name: [u8; 64],
  type: u32,  // 0=RTU, 1=TCP
  ip: u32,
  port: u16,
  connected: u32
}

var modbus_devices: [ModbusDevice; 32]
var modbus_device_count: u32 = 0

export fn modbus_init() {
  modbus_device_count = 0
  
  foundation.serial_write_string("[Modbus] Initialized\n")
}

export fn modbus_register_device(address: u8, name: u64, type: u32, ip: u32, port: u16) -> u32 {
  if modbus_device_count >= MAX_MODBUS_DEVICES { return 0xFFFFFFFF }
  
  var device_id: u32 = modbus_device_count
  
  modbus_devices[device_id].address = address
  modbus_devices[device_id].type = type
  modbus_devices[device_id].ip = ip
  modbus_devices[device_id].port = port
  modbus_devices[device_id].connected = 0
  
  // Copy name
  var i: u32 = 0
  while i < 63 {
    var ch: u8 = @intToPtr(name + i, u8)
    modbus_devices[device_id].name[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  
  modbus_device_count = modbus_device_count + 1
  
  foundation.serial_write_string("[Modbus] Device registered: ")
  foundation.serial_write_string(name)
  foundation.serial_write_string("\n")
  
  return device_id
}

export fn modbus_read_holding_registers(device_id: u32, start_addr: u16, count: u16, values_out: u64) -> u32 {
  if device_id >= modbus_device_count { return 0 }
  
  var type: u32 = modbus_devices[device_id].type
  
  if type == 0 {
    // Modbus RTU
    return modbus_rtu_read_holding_registers(device_id, start_addr, count, values_out)
  } else {
    // Modbus TCP
    return modbus_tcp_read_holding_registers(device_id, start_addr, count, values_out)
  }
}

fn modbus_tcp_read_holding_registers(device_id: u32, start_addr: u16, count: u16, values_out: u64) -> u32 {
  // Create socket
  var sock: u32 = network.socket_create(2, 1, 0)
  if sock == 0xFFFFFFFF { return 0 }
  
  // Connect to device
  var ip: u32 = modbus_devices[device_id].ip
  var port: u16 = modbus_devices[device_id].port
  
  if network.socket_connect(sock, ip, port) != 0 {
    network.socket_close(sock)
    return 0
  }
  
  // Build Modbus TCP request
  var request: [u8; 12]
  request[0] = 0  // Transaction ID high
  request[1] = 1  // Transaction ID low
  request[2] = 0  // Protocol ID high
  request[3] = 0  // Protocol ID low
  request[4] = 0  // Length high
  request[5] = 6  // Length low
  request[6] = modbus_devices[device_id].address  // Unit ID
  request[7] = MODBUS_READ_HOLDING_REGISTERS
  request[8] = @truncate(start_addr >> 8, u8)
  request[9] = @truncate(start_addr, u8)
  request[10] = @truncate(count >> 8, u8)
  request[11] = @truncate(count, u8)
  
  // Send request
  network.socket_send(sock, @ptrFromInt(request), 12)
  
  // Receive response
  var response: [u8; 256]
  var received: u32 = network.socket_recv(sock, @ptrFromInt(response), 256)
  
  network.socket_close(sock)
  
  if received < 9 { return 0 }
  
  // Parse response
  var byte_count: u8 = response[8]
  var i: u32 = 0
  while i < count {
    var high: u16 = response[9 + (i * 2)]
    var low: u16 = response[10 + (i * 2)]
    @intToPtr(values_out + (i * 2), u16) = (high << 8) | low
    i = i + 1
  }
  
  return count
}

fn modbus_rtu_read_holding_registers(device_id: u32, start_addr: u16, count: u16, values_out: u64) -> u32 {
  // Modbus RTU over serial
  return 0
}

export fn modbus_write_single_register(device_id: u32, addr: u16, value: u16) -> u32 {
  if device_id >= modbus_device_count { return 0 }
  
  var type: u32 = modbus_devices[device_id].type
  
  if type == 1 {
    return modbus_tcp_write_single_register(device_id, addr, value)
  }
  
  return 0
}

fn modbus_tcp_write_single_register(device_id: u32, addr: u16, value: u16) -> u32 {
  var sock: u32 = network.socket_create(2, 1, 0)
  if sock == 0xFFFFFFFF { return 0 }
  
  var ip: u32 = modbus_devices[device_id].ip
  var port: u16 = modbus_devices[device_id].port
  
  if network.socket_connect(sock, ip, port) != 0 {
    network.socket_close(sock)
    return 0
  }
  
  // Build request
  var request: [u8; 12]
  request[0] = 0
  request[1] = 1
  request[2] = 0
  request[3] = 0
  request[4] = 0
  request[5] = 6
  request[6] = modbus_devices[device_id].address
  request[7] = MODBUS_WRITE_SINGLE_REGISTER
  request[8] = @truncate(addr >> 8, u8)
  request[9] = @truncate(addr, u8)
  request[10] = @truncate(value >> 8, u8)
  request[11] = @truncate(value, u8)
  
  network.socket_send(sock, @ptrFromInt(request), 12)
  
  var response: [u8; 12]
  network.socket_recv(sock, @ptrFromInt(response), 12)
  
  network.socket_close(sock)
  
  return 1
}

export fn modbus_device_list() {
  foundation.serial_write_string("\n[Modbus] Devices:\n")
  
  var i: u32 = 0
  while i < modbus_device_count {
    foundation.serial_write_hex(i)
    foundation.serial_write_string(": ")
    foundation.serial_write_string(@ptrFromInt(modbus_devices[i].name))
    foundation.serial_write_string(" (Address ")
    foundation.serial_write_hex(modbus_devices[i].address)
    foundation.serial_write_string(")\n")
    
    i = i + 1
  }
}
