// home-os Kernel - OPC UA Protocol
// Open Platform Communications Unified Architecture for industrial automation

import "../core/foundation.home" as foundation
import "../net/tcp.home" as tcp

// ============================================================================
// OPC UA CONSTANTS
// ============================================================================

const OPCUA_PORT: u16 = 4840
const OPCUA_PROTOCOL_VERSION: u32 = 0

const MAX_OPCUA_SESSIONS: u32 = 16
const MAX_OPCUA_SUBSCRIPTIONS: u32 = 64
const MAX_OPCUA_NODES: u32 = 1024
const MAX_MONITORED_ITEMS: u32 = 256

// Message types
const OPCUA_MSG_HELLO: u32 = 0x48454C  // HEL
const OPCUA_MSG_ACK: u32 = 0x41434B    // ACK
const OPCUA_MSG_ERROR: u32 = 0x455252  // ERR
const OPCUA_MSG_OPEN: u32 = 0x4F504E   // OPN
const OPCUA_MSG_CLOSE: u32 = 0x434C4F  // CLO
const OPCUA_MSG_MESSAGE: u32 = 0x4D5347 // MSG

// Service IDs
const OPCUA_SVC_GET_ENDPOINTS: u32 = 428
const OPCUA_SVC_CREATE_SESSION: u32 = 461
const OPCUA_SVC_ACTIVATE_SESSION: u32 = 467
const OPCUA_SVC_CLOSE_SESSION: u32 = 473
const OPCUA_SVC_BROWSE: u32 = 527
const OPCUA_SVC_READ: u32 = 631
const OPCUA_SVC_WRITE: u32 = 673
const OPCUA_SVC_CALL: u32 = 712
const OPCUA_SVC_CREATE_SUBSCRIPTION: u32 = 787
const OPCUA_SVC_MODIFY_SUBSCRIPTION: u32 = 793
const OPCUA_SVC_DELETE_SUBSCRIPTION: u32 = 847
const OPCUA_SVC_CREATE_MONITORED_ITEMS: u32 = 751
const OPCUA_SVC_PUBLISH: u32 = 826

// Node ID types
const OPCUA_NODEID_NUMERIC: u8 = 0
const OPCUA_NODEID_STRING: u8 = 1
const OPCUA_NODEID_GUID: u8 = 2
const OPCUA_NODEID_OPAQUE: u8 = 3

// Attribute IDs
const OPCUA_ATTR_NODE_ID: u32 = 1
const OPCUA_ATTR_NODE_CLASS: u32 = 2
const OPCUA_ATTR_BROWSE_NAME: u32 = 3
const OPCUA_ATTR_DISPLAY_NAME: u32 = 4
const OPCUA_ATTR_DESCRIPTION: u32 = 5
const OPCUA_ATTR_VALUE: u32 = 13
const OPCUA_ATTR_DATA_TYPE: u32 = 14
const OPCUA_ATTR_ACCESS_LEVEL: u32 = 17

// Node classes
const OPCUA_NODE_OBJECT: u32 = 1
const OPCUA_NODE_VARIABLE: u32 = 2
const OPCUA_NODE_METHOD: u32 = 4
const OPCUA_NODE_OBJECT_TYPE: u32 = 8
const OPCUA_NODE_VARIABLE_TYPE: u32 = 16
const OPCUA_NODE_REFERENCE_TYPE: u32 = 32
const OPCUA_NODE_DATA_TYPE: u32 = 64
const OPCUA_NODE_VIEW: u32 = 128

// Data types
const OPCUA_TYPE_BOOLEAN: u32 = 1
const OPCUA_TYPE_SBYTE: u32 = 2
const OPCUA_TYPE_BYTE: u32 = 3
const OPCUA_TYPE_INT16: u32 = 4
const OPCUA_TYPE_UINT16: u32 = 5
const OPCUA_TYPE_INT32: u32 = 6
const OPCUA_TYPE_UINT32: u32 = 7
const OPCUA_TYPE_INT64: u32 = 8
const OPCUA_TYPE_UINT64: u32 = 9
const OPCUA_TYPE_FLOAT: u32 = 10
const OPCUA_TYPE_DOUBLE: u32 = 11
const OPCUA_TYPE_STRING: u32 = 12
const OPCUA_TYPE_DATETIME: u32 = 13

// ============================================================================
// OPC UA DATA STRUCTURES
// ============================================================================

struct OpcuaNodeId {
  namespace_index: u16,
  identifier_type: u8,
  numeric_id: u32,
  string_id: [u8; 64]
}

struct OpcuaVariant {
  type_id: u32,
  array_length: i32,  // -1 for scalar
  value_bool: u32,
  value_int: i64,
  value_uint: u64,
  value_float: f64,
  value_string: [u8; 256]
}

struct OpcuaNode {
  node_id: OpcuaNodeId,
  node_class: u32,
  browse_name: [u8; 64],
  display_name: [u8; 64],
  description: [u8; 128],
  data_type: u32,
  value: OpcuaVariant,
  access_level: u8,
  user_access_level: u8,
  parent_id: OpcuaNodeId,
  references: [OpcuaReference; 16],
  reference_count: u8
}

struct OpcuaReference {
  reference_type: OpcuaNodeId,
  is_forward: u32,
  target_id: OpcuaNodeId
}

struct OpcuaSession {
  session_id: OpcuaNodeId,
  auth_token: [u8; 32],
  client_nonce: [u8; 32],
  server_nonce: [u8; 32],
  endpoint_url: [u8; 128],
  client_desc: [u8; 64],
  timeout_ms: u32,
  activated: u32,
  socket: u32,
  last_activity: u64
}

struct OpcuaSubscription {
  subscription_id: u32,
  session_id: u32,
  publishing_interval: f64,
  lifetime_count: u32,
  max_keepalive_count: u32,
  max_notifications: u32,
  publishing_enabled: u32,
  priority: u8,
  seq_number: u32,
  last_publish: u64
}

struct OpcuaMonitoredItem {
  monitored_item_id: u32,
  subscription_id: u32,
  node_id: OpcuaNodeId,
  attribute_id: u32,
  sampling_interval: f64,
  queue_size: u32,
  discard_oldest: u32,
  last_value: OpcuaVariant,
  last_sample: u64
}

struct OpcuaServer {
  endpoint_url: [u8; 128],
  application_uri: [u8; 128],
  product_uri: [u8; 128],
  application_name: [u8; 64],
  server_socket: u32,
  running: u32
}

// ============================================================================
// OPC UA STATE
// ============================================================================

var opcua_server: OpcuaServer
var opcua_sessions: [OpcuaSession; 16]
var opcua_session_count: u32 = 0
var opcua_subscriptions: [OpcuaSubscription; 64]
var opcua_subscription_count: u32 = 0
var opcua_monitored: [OpcuaMonitoredItem; 256]
var opcua_monitored_count: u32 = 0
var opcua_nodes: [OpcuaNode; 1024]
var opcua_node_count: u32 = 0
var opcua_initialized: u32 = 0
var opcua_next_subscription_id: u32 = 1
var opcua_next_monitored_id: u32 = 1

// ============================================================================
// SERVER INITIALIZATION
// ============================================================================

export fn opcua_server_init(endpoint_url: u64, app_name: u64): u32 {
  foundation.serial_write_string("[OPC-UA] Initializing server...\n")

  copy_string_long(&opcua_server.endpoint_url, endpoint_url)
  copy_string(&opcua_server.application_name, app_name)
  copy_string_long(&opcua_server.application_uri, endpoint_url)
  copy_string_long(&opcua_server.product_uri, "urn:home-os:opcua:server")

  opcua_server.running = 0

  // Create root namespace
  create_root_nodes()

  opcua_initialized = 1

  foundation.serial_write_string("[OPC-UA] Server initialized\n")
  return 1
}

fn create_root_nodes() {
  // Root folder (ns=0, i=84)
  var root: *OpcuaNode = &opcua_nodes[opcua_node_count]
  root.node_id.namespace_index = 0
  root.node_id.identifier_type = OPCUA_NODEID_NUMERIC
  root.node_id.numeric_id = 84
  root.node_class = OPCUA_NODE_OBJECT
  copy_string(&root.browse_name, "Root")
  copy_string(&root.display_name, "Root")
  opcua_node_count = opcua_node_count + 1

  // Objects folder (ns=0, i=85)
  var objects: *OpcuaNode = &opcua_nodes[opcua_node_count]
  objects.node_id.namespace_index = 0
  objects.node_id.identifier_type = OPCUA_NODEID_NUMERIC
  objects.node_id.numeric_id = 85
  objects.node_class = OPCUA_NODE_OBJECT
  copy_string(&objects.browse_name, "Objects")
  copy_string(&objects.display_name, "Objects")
  objects.parent_id = root.node_id
  opcua_node_count = opcua_node_count + 1

  // Types folder (ns=0, i=86)
  var types: *OpcuaNode = &opcua_nodes[opcua_node_count]
  types.node_id.namespace_index = 0
  types.node_id.identifier_type = OPCUA_NODEID_NUMERIC
  types.node_id.numeric_id = 86
  types.node_class = OPCUA_NODE_OBJECT
  copy_string(&types.browse_name, "Types")
  copy_string(&types.display_name, "Types")
  types.parent_id = root.node_id
  opcua_node_count = opcua_node_count + 1

  // Views folder (ns=0, i=87)
  var views: *OpcuaNode = &opcua_nodes[opcua_node_count]
  views.node_id.namespace_index = 0
  views.node_id.identifier_type = OPCUA_NODEID_NUMERIC
  views.node_id.numeric_id = 87
  views.node_class = OPCUA_NODE_OBJECT
  copy_string(&views.browse_name, "Views")
  copy_string(&views.display_name, "Views")
  views.parent_id = root.node_id
  opcua_node_count = opcua_node_count + 1

  // Server object (ns=0, i=2253)
  var server: *OpcuaNode = &opcua_nodes[opcua_node_count]
  server.node_id.namespace_index = 0
  server.node_id.identifier_type = OPCUA_NODEID_NUMERIC
  server.node_id.numeric_id = 2253
  server.node_class = OPCUA_NODE_OBJECT
  copy_string(&server.browse_name, "Server")
  copy_string(&server.display_name, "Server")
  server.parent_id = objects.node_id
  opcua_node_count = opcua_node_count + 1
}

export fn opcua_server_start(): u32 {
  if opcua_initialized == 0 { return 0 }

  opcua_server.server_socket = tcp.tcp_listen(OPCUA_PORT)
  if opcua_server.server_socket == 0xFFFFFFFF {
    foundation.serial_write_string("[OPC-UA] Failed to start server\n")
    return 0
  }

  opcua_server.running = 1

  foundation.serial_write_string("[OPC-UA] Server listening on port ")
  foundation.serial_write_hex(OPCUA_PORT as u32)
  foundation.serial_write_string("\n")

  return 1
}

export fn opcua_server_stop() {
  opcua_server.running = 0
  tcp.tcp_close(opcua_server.server_socket)
  foundation.serial_write_string("[OPC-UA] Server stopped\n")
}

// ============================================================================
// NODE MANAGEMENT
// ============================================================================

export fn opcua_add_variable(ns: u16, id: u32, name: u64, data_type: u32, parent_id: u32): u32 {
  if opcua_node_count >= MAX_OPCUA_NODES { return 0xFFFFFFFF }

  var idx: u32 = opcua_node_count
  var node: *OpcuaNode = &opcua_nodes[idx]

  node.node_id.namespace_index = ns
  node.node_id.identifier_type = OPCUA_NODEID_NUMERIC
  node.node_id.numeric_id = id
  node.node_class = OPCUA_NODE_VARIABLE
  copy_string(&node.browse_name, name)
  copy_string(&node.display_name, name)
  node.data_type = data_type
  node.access_level = 0x03  // Read + Write
  node.user_access_level = 0x03

  // Set parent
  node.parent_id.namespace_index = 0
  node.parent_id.identifier_type = OPCUA_NODEID_NUMERIC
  node.parent_id.numeric_id = parent_id

  opcua_node_count = opcua_node_count + 1

  return idx
}

export fn opcua_set_value_int(node_idx: u32, value: i64): u32 {
  if node_idx >= opcua_node_count { return 0 }

  opcua_nodes[node_idx].value.type_id = OPCUA_TYPE_INT64
  opcua_nodes[node_idx].value.array_length = -1
  opcua_nodes[node_idx].value.value_int = value

  // Trigger data change for subscriptions
  trigger_data_change(node_idx)

  return 1
}

export fn opcua_set_value_float(node_idx: u32, value: f64): u32 {
  if node_idx >= opcua_node_count { return 0 }

  opcua_nodes[node_idx].value.type_id = OPCUA_TYPE_DOUBLE
  opcua_nodes[node_idx].value.array_length = -1
  opcua_nodes[node_idx].value.value_float = value

  trigger_data_change(node_idx)

  return 1
}

export fn opcua_set_value_bool(node_idx: u32, value: u32): u32 {
  if node_idx >= opcua_node_count { return 0 }

  opcua_nodes[node_idx].value.type_id = OPCUA_TYPE_BOOLEAN
  opcua_nodes[node_idx].value.array_length = -1
  opcua_nodes[node_idx].value.value_bool = value

  trigger_data_change(node_idx)

  return 1
}

export fn opcua_set_value_string(node_idx: u32, value: u64): u32 {
  if node_idx >= opcua_node_count { return 0 }

  opcua_nodes[node_idx].value.type_id = OPCUA_TYPE_STRING
  opcua_nodes[node_idx].value.array_length = -1
  copy_string_256(&opcua_nodes[node_idx].value.value_string, value)

  trigger_data_change(node_idx)

  return 1
}

fn trigger_data_change(node_idx: u32) {
  // Check monitored items for this node
  var i: u32 = 0
  while i < opcua_monitored_count {
    if node_id_equals(&opcua_monitored[i].node_id, &opcua_nodes[node_idx].node_id) {
      // Mark for notification
      opcua_monitored[i].last_value = opcua_nodes[node_idx].value
    }
    i = i + 1
  }
}

fn node_id_equals(a: *OpcuaNodeId, b: *OpcuaNodeId): u32 {
  if a.namespace_index != b.namespace_index { return 0 }
  if a.identifier_type != b.identifier_type { return 0 }
  if a.identifier_type == OPCUA_NODEID_NUMERIC {
    return a.numeric_id == b.numeric_id
  }
  return 0
}

// ============================================================================
// SESSION MANAGEMENT
// ============================================================================

fn create_session(socket: u32, client_desc: u64): u32 {
  if opcua_session_count >= MAX_OPCUA_SESSIONS { return 0xFFFFFFFF }

  var idx: u32 = opcua_session_count
  var session: *OpcuaSession = &opcua_sessions[idx]

  session.session_id.namespace_index = 1
  session.session_id.identifier_type = OPCUA_NODEID_NUMERIC
  session.session_id.numeric_id = idx + 1

  session.socket = socket
  session.timeout_ms = 30000
  session.activated = 0
  session.last_activity = foundation.get_tick_count()

  copy_string(&session.client_desc, client_desc)

  // Generate server nonce
  var i: u32 = 0
  while i < 32 {
    session.server_nonce[i] = ((foundation.get_tick_count() ^ (i * 41)) & 0xFF) as u8
    i = i + 1
  }

  opcua_session_count = opcua_session_count + 1

  foundation.serial_write_string("[OPC-UA] Session created: ")
  foundation.serial_write_hex(idx)
  foundation.serial_write_string("\n")

  return idx
}

fn activate_session(session_idx: u32): u32 {
  if session_idx >= opcua_session_count { return 0 }

  opcua_sessions[session_idx].activated = 1
  opcua_sessions[session_idx].last_activity = foundation.get_tick_count()

  foundation.serial_write_string("[OPC-UA] Session activated: ")
  foundation.serial_write_hex(session_idx)
  foundation.serial_write_string("\n")

  return 1
}

fn close_session(session_idx: u32) {
  if session_idx >= opcua_session_count { return }

  // Close subscriptions
  var i: u32 = 0
  while i < opcua_subscription_count {
    if opcua_subscriptions[i].session_id == session_idx {
      opcua_subscriptions[i].publishing_enabled = 0
    }
    i = i + 1
  }

  opcua_sessions[session_idx].activated = 0

  foundation.serial_write_string("[OPC-UA] Session closed: ")
  foundation.serial_write_hex(session_idx)
  foundation.serial_write_string("\n")
}

// ============================================================================
// SUBSCRIPTION MANAGEMENT
// ============================================================================

export fn opcua_create_subscription(session_idx: u32, interval: f64): u32 {
  if opcua_subscription_count >= MAX_OPCUA_SUBSCRIPTIONS { return 0xFFFFFFFF }

  var idx: u32 = opcua_subscription_count
  var sub: *OpcuaSubscription = &opcua_subscriptions[idx]

  sub.subscription_id = opcua_next_subscription_id
  opcua_next_subscription_id = opcua_next_subscription_id + 1

  sub.session_id = session_idx
  sub.publishing_interval = interval
  sub.lifetime_count = 10000
  sub.max_keepalive_count = 10
  sub.max_notifications = 1000
  sub.publishing_enabled = 1
  sub.priority = 0
  sub.seq_number = 1
  sub.last_publish = foundation.get_tick_count()

  opcua_subscription_count = opcua_subscription_count + 1

  return sub.subscription_id
}

export fn opcua_create_monitored_item(subscription_id: u32, ns: u16, node_id: u32, attr_id: u32, interval: f64): u32 {
  if opcua_monitored_count >= MAX_MONITORED_ITEMS { return 0xFFFFFFFF }

  var idx: u32 = opcua_monitored_count
  var item: *OpcuaMonitoredItem = &opcua_monitored[idx]

  item.monitored_item_id = opcua_next_monitored_id
  opcua_next_monitored_id = opcua_next_monitored_id + 1

  item.subscription_id = subscription_id
  item.node_id.namespace_index = ns
  item.node_id.identifier_type = OPCUA_NODEID_NUMERIC
  item.node_id.numeric_id = node_id
  item.attribute_id = attr_id
  item.sampling_interval = interval
  item.queue_size = 10
  item.discard_oldest = 1
  item.last_sample = foundation.get_tick_count()

  opcua_monitored_count = opcua_monitored_count + 1

  return item.monitored_item_id
}

// ============================================================================
// MESSAGE PROCESSING
// ============================================================================

export fn opcua_process() {
  if opcua_server.running == 0 { return }

  // Accept new connections
  var client_socket: u32 = tcp.tcp_accept(opcua_server.server_socket)
  if client_socket != 0xFFFFFFFF {
    handle_new_connection(client_socket)
  }

  // Process existing sessions
  var i: u32 = 0
  while i < opcua_session_count {
    if opcua_sessions[i].activated == 1 {
      process_session(i)
    }
    i = i + 1
  }

  // Process subscriptions
  process_subscriptions()
}

fn handle_new_connection(socket: u32) {
  foundation.serial_write_string("[OPC-UA] New connection\n")
  // Wait for HELLO message and respond with ACK
}

fn process_session(session_idx: u32) {
  var session: *OpcuaSession = &opcua_sessions[session_idx]

  // Check timeout
  var now: u64 = foundation.get_tick_count()
  if now - session.last_activity > session.timeout_ms {
    close_session(session_idx)
    return
  }

  // Read and process messages
  // ...
}

fn process_subscriptions() {
  var now: u64 = foundation.get_tick_count()

  var i: u32 = 0
  while i < opcua_subscription_count {
    var sub: *OpcuaSubscription = &opcua_subscriptions[i]

    if sub.publishing_enabled == 1 {
      var interval_ms: u64 = (sub.publishing_interval) as u64
      if now - sub.last_publish >= interval_ms {
        publish_subscription(i)
        sub.last_publish = now
      }
    }
    i = i + 1
  }
}

fn publish_subscription(sub_idx: u32) {
  // Collect data changes for this subscription
  // Build and send publish response
}

// ============================================================================
// CLIENT API
// ============================================================================

export fn opcua_client_connect(endpoint_url: u64): u32 {
  // Parse endpoint URL and connect
  foundation.serial_write_string("[OPC-UA] Client connecting to ")
  foundation.serial_write_string(endpoint_url)
  foundation.serial_write_string("\n")

  // Would establish TCP connection and perform OPC UA handshake
  return 0xFFFFFFFF
}

export fn opcua_client_read(session: u32, ns: u16, node_id: u32, value: *OpcuaVariant): u32 {
  // Send Read request
  return 0
}

export fn opcua_client_write(session: u32, ns: u16, node_id: u32, value: *OpcuaVariant): u32 {
  // Send Write request
  return 0
}

export fn opcua_client_browse(session: u32, ns: u16, node_id: u32): u32 {
  // Send Browse request
  return 0
}

export fn opcua_client_disconnect(session: u32) {
  // Close session and disconnect
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

fn copy_string(dest: *[u8; 64], src: u64) {
  var i: u32 = 0
  while i < 63 {
    var ch: u8 = @intToPtr(src + i, u8)
    (*dest)[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  (*dest)[i] = 0
}

fn copy_string_long(dest: *[u8; 128], src: u64) {
  var i: u32 = 0
  while i < 127 {
    var ch: u8 = @intToPtr(src + i, u8)
    (*dest)[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  (*dest)[i] = 0
}

fn copy_string_256(dest: *[u8; 256], src: u64) {
  var i: u32 = 0
  while i < 255 {
    var ch: u8 = @intToPtr(src + i, u8)
    (*dest)[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  (*dest)[i] = 0
}
