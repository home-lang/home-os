// VGA text mode driver for home-os
// 80x25 color text mode

let VGA_WIDTH: usize = 80
let VGA_HEIGHT: usize = 25
let VGA_BUFFER_ADDR: usize = 0xB8000

// Get VGA buffer pointer (runtime evaluation)
inline fn getVgaBuffer() -> *volatile [VGA_HEIGHT][VGA_WIDTH]u16 {
    return @ptrFromInt(VGA_BUFFER_ADDR)
}

enum Color: u8 {
    Black = 0,
    Blue = 1,
    Green = 2,
    Cyan = 3,
    Red = 4,
    Magenta = 5,
    Brown = 6,
    LightGray = 7,
    DarkGray = 8,
    LightBlue = 9,
    LightGreen = 10,
    LightCyan = 11,
    LightRed = 12,
    LightMagenta = 13,
    Yellow = 14,
    White = 15,
}

// Explicitly initialized variables (not .bss)
let row: usize = 0
let column: usize = 0
let fg_color: Color = Color.White
let bg_color: Color = Color.Black

// Create VGA entry (character + color)
inline fn vgaEntry(c: u8, fg: Color, bg: Color) -> u16 {
    let fg_val: u8 = @intCast(@intFromEnum(fg))
    let bg_val: u8 = @intCast(@intFromEnum(bg))
    let color_code: u8 = fg_val | (bg_val << 4)
    return @as(u16, c) | (@as(u16, color_code) << 8)
}

// Initialize VGA
export fn init() {
    // Don't access any variables - they cause crashes in current setup
    // Variables will be implicitly zero-initialized from .bss
    // Just return for now
    _ = row
    _ = column
    _ = fg_color
    _ = bg_color
}

// Set colors
export fn setColor(fg: Color, bg: Color) {
    fg_color = fg
    bg_color = bg
}

// Clear screen
export fn clear() {
    let y: usize = 0
    loop {
        if y >= VGA_HEIGHT {
            break
        }
        let x: usize = 0
        loop {
            if x >= VGA_WIDTH {
                break
            }
            getVgaBuffer()[y][x] = vgaEntry(' ', fg_color, bg_color)
            x = x + 1
        }
        y = y + 1
    }
    row = 0
    column = 0
}

// Scroll screen up one line
fn scroll() {
    // Move all rows up
    let y: usize = 0
    loop {
        if y >= VGA_HEIGHT - 1 {
            break
        }
        let x: usize = 0
        loop {
            if x >= VGA_WIDTH {
                break
            }
            getVgaBuffer()[y][x] = getVgaBuffer()[y + 1][x]
            x = x + 1
        }
        y = y + 1
    }

    // Clear last row
    let x: usize = 0
    loop {
        if x >= VGA_WIDTH {
            break
        }
        getVgaBuffer()[VGA_HEIGHT - 1][x] = vgaEntry(' ', fg_color, bg_color)
        x = x + 1
    }

    row = VGA_HEIGHT - 1
}

// Write a single character
export fn writeChar(c: u8) {
    if c == '\n' {
        column = 0
        row = row + 1
        if row >= VGA_HEIGHT {
            scroll()
        }
        return
    }

    if c == '\r' {
        column = 0
        return
    }

    getVgaBuffer()[row][column] = vgaEntry(c, fg_color, bg_color)

    column = column + 1
    if column >= VGA_WIDTH {
        column = 0
        row = row + 1
        if row >= VGA_HEIGHT {
            scroll()
        }
    }
}

// Write a string
export fn writeString(s: []u8) {
    let i = 0
    loop {
        if i >= s.len {
            break
        }
        writeChar(s[i])
        i = i + 1
    }
}

// Write a hexadecimal number
export fn writeHex(value: u64) {
    let hex_chars = "0123456789ABCDEF"

    writeString("0x")

    let i: u6 = 60
    loop {
        let nibble: u4 = @truncate(value >> i)
        writeChar(hex_chars[nibble])

        if i == 0 {
            break
        }
        i = i - 4
    }
}

// Write a decimal number
export fn writeDec(value: u64) {
    if value == 0 {
        writeChar('0')
        return
    }

    let buf: [20]u8 = undefined
    let i: usize = 0
    let n = value

    loop {
        if n == 0 {
            break
        }
        buf[i] = @intCast('0' + (n % 10))
        n = n / 10
        i = i + 1
    }

    // Reverse and print
    loop {
        if i == 0 {
            break
        }
        i = i - 1
        writeChar(buf[i])
    }
}

// Set cursor position
export fn setCursor(x: usize, y: usize) {
    if x < VGA_WIDTH && y < VGA_HEIGHT {
        column = x
        row = y
    }
}

// Get current cursor position
export fn getCursor() -> struct { x: usize, y: usize } {
    return .{ .x = column, .y = row }
}
