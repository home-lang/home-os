// home-os VFS - Extended Attributes (xattr)
// Implements extended file attributes for metadata storage

import "foundation.home" as foundation
import "memory.home" as memory
import "filesystem.home" as filesystem
import "vfs_permissions.home" as perms

// ============================================================================
// CONSTANTS
// ============================================================================

const MAX_XATTRS_PER_FILE: u32 = 16
const MAX_XATTR_NAME_LEN: u32 = 256
const MAX_XATTR_VALUE_LEN: u32 = 4096
const MAX_TOTAL_XATTRS: u32 = 1024

// xattr namespaces
const XATTR_USER: u32 = 0       // user.*
const XATTR_SYSTEM: u32 = 1     // system.*
const XATTR_SECURITY: u32 = 2   // security.*
const XATTR_TRUSTED: u32 = 3    // trusted.*

// ============================================================================
// DATA STRUCTURES
// ============================================================================

struct ExtendedAttribute {
  ino: u32,                       // Inode this xattr belongs to
  namespace: u32,                 // Namespace
  name: [u8; 256],                // Attribute name
  name_len: u32,                  // Name length
  value: u64,                     // Pointer to value data
  value_len: u32,                 // Value length
  active: u32                     // 1 if in use
}

struct XattrStats {
  total_xattrs: u64,
  active_xattrs: u32,
  user_xattrs: u32,
  system_xattrs: u32,
  security_xattrs: u32,
  trusted_xattrs: u32,
  total_value_bytes: u64
}

// ============================================================================
// GLOBAL STATE
// ============================================================================

var xattrs: [ExtendedAttribute; 1024]
var xattr_count: u32 = 0
var xattr_stats: XattrStats
var xattr_initialized: u32 = 0

// ============================================================================
// NAMESPACE DETECTION
// ============================================================================

fn detect_namespace(name: *u8): u32 {
  // user.*
  if name[0] == ('u' as u8) and name[1] == ('s' as u8) and name[2] == ('e' as u8) and name[3] == ('r' as u8) and name[4] == ('.' as u8) {
    return XATTR_USER
  }

  // system.*
  if name[0] == ('s' as u8) and name[1] == ('y' as u8) and name[2] == ('s' as u8) and name[3] == ('t' as u8) and name[4] == ('e' as u8) and name[5] == ('m' as u8) and name[6] == ('.' as u8) {
    return XATTR_SYSTEM
  }

  // security.*
  if name[0] == ('s' as u8) and name[1] == ('e' as u8) and name[2] == ('c' as u8) and name[3] == ('u' as u8) and name[4] == ('r' as u8) and name[5] == ('i' as u8) and name[6] == ('t' as u8) and name[7] == ('y' as u8) and name[8] == ('.' as u8) {
    return XATTR_SECURITY
  }

  // trusted.*
  if name[0] == ('t' as u8) and name[1] == ('r' as u8) and name[2] == ('u' as u8) and name[3] == ('s' as u8) and name[4] == ('t' as u8) and name[5] == ('e' as u8) and name[6] == ('d' as u8) and name[7] == ('.' as u8) {
    return XATTR_TRUSTED
  }

  return XATTR_USER  // Default
}

// ============================================================================
// SET XATTR
// ============================================================================

export fn vfs_setxattr(ino: u32, name: u64, value: u64, value_len: u32, flags: u32, uid: u32, gid: u32): u32 {
  var inode_ptr: u64 = filesystem.inode_get(ino)
  if inode_ptr == 0 {
    return 1  // Invalid inode
  }

  var inode: *filesystem.Inode = @ptrFromInt(inode_ptr)
  var name_ptr: *u8 = @ptrFromInt(name)

  // Get name length
  var name_len: u32 = 0
  while name_ptr[name_len] != 0 and name_len < MAX_XATTR_NAME_LEN {
    name_len = name_len + 1
  }

  if name_len == 0 or name_len >= MAX_XATTR_NAME_LEN {
    return 1  // Invalid name
  }

  if value_len > MAX_XATTR_VALUE_LEN {
    return 1  // Value too large
  }

  // Detect namespace
  var ns: u32 = detect_namespace(name_ptr)

  // Permission check
  if ns == XATTR_USER {
    // Need write permission for user xattrs
    if perms.can_write(inode, uid, gid) == 0 {
      return 1  // EACCES
    }
  } else if ns == XATTR_SYSTEM or ns == XATTR_SECURITY or ns == XATTR_TRUSTED {
    // Need to be root for system/security/trusted xattrs
    if uid != 0 {
      return 1  // EPERM
    }
  }

  // Check if xattr already exists
  var existing_idx: u32 = 0xFFFFFFFF
  var i: u32 = 0
  while i < MAX_TOTAL_XATTRS {
    if xattrs[i].active == 1 and xattrs[i].ino == ino {
      // Compare names
      var names_match: u32 = 1
      var j: u32 = 0
      while j < name_len {
        if xattrs[i].name[j] != name_ptr[j] {
          names_match = 0
          break
        }
        j = j + 1
      }

      if names_match == 1 and xattrs[i].name_len == name_len {
        existing_idx = i
        break
      }
    }
    i = i + 1
  }

  // If exists, update it
  if existing_idx != 0xFFFFFFFF {
    // Free old value
    if xattrs[existing_idx].value != 0 {
      memory.pmm_free_page(xattrs[existing_idx].value)
      xattr_stats.total_value_bytes = xattr_stats.total_value_bytes - xattrs[existing_idx].value_len
    }

    // Allocate new value
    var value_data: u64 = memory.pmm_alloc_page()
    if value_data == 0 {
      return 1  // ENOMEM
    }

    memory.memcpy(value_data, value, value_len)
    xattrs[existing_idx].value = value_data
    xattrs[existing_idx].value_len = value_len
    xattr_stats.total_value_bytes = xattr_stats.total_value_bytes + value_len

    return 0  // Updated
  }

  // Create new xattr
  i = 0
  while i < MAX_TOTAL_XATTRS {
    if xattrs[i].active == 0 {
      // Count existing xattrs for this inode
      var count_for_inode: u32 = 0
      var j: u32 = 0
      while j < MAX_TOTAL_XATTRS {
        if xattrs[j].active == 1 and xattrs[j].ino == ino {
          count_for_inode = count_for_inode + 1
        }
        j = j + 1
      }

      if count_for_inode >= MAX_XATTRS_PER_FILE {
        return 1  // Too many xattrs for this file
      }

      // Allocate value storage
      var value_data: u64 = memory.pmm_alloc_page()
      if value_data == 0 {
        return 1  // ENOMEM
      }

      memory.memcpy(value_data, value, value_len)

      // Copy name
      j = 0
      while j < name_len {
        xattrs[i].name[j] = name_ptr[j]
        j = j + 1
      }
      xattrs[i].name[name_len] = 0

      xattrs[i].ino = ino
      xattrs[i].namespace = ns
      xattrs[i].name_len = name_len
      xattrs[i].value = value_data
      xattrs[i].value_len = value_len
      xattrs[i].active = 1

      xattr_count = xattr_count + 1
      xattr_stats.total_xattrs = xattr_stats.total_xattrs + 1
      xattr_stats.active_xattrs = xattr_count
      xattr_stats.total_value_bytes = xattr_stats.total_value_bytes + value_len

      if ns == XATTR_USER {
        xattr_stats.user_xattrs = xattr_stats.user_xattrs + 1
      } else if ns == XATTR_SYSTEM {
        xattr_stats.system_xattrs = xattr_stats.system_xattrs + 1
      } else if ns == XATTR_SECURITY {
        xattr_stats.security_xattrs = xattr_stats.security_xattrs + 1
      } else if ns == XATTR_TRUSTED {
        xattr_stats.trusted_xattrs = xattr_stats.trusted_xattrs + 1
      }

      return 0  // Created
    }
    i = i + 1
  }

  return 1  // No free slots
}

// ============================================================================
// GET XATTR
// ============================================================================

export fn vfs_getxattr(ino: u32, name: u64, value: u64, value_len: u32, uid: u32, gid: u32): i32 {
  var inode_ptr: u64 = filesystem.inode_get(ino)
  if inode_ptr == 0 {
    return -1  // Invalid inode
  }

  var inode: *filesystem.Inode = @ptrFromInt(inode_ptr)
  var name_ptr: *u8 = @ptrFromInt(name)

  // Get name length
  var name_len: u32 = 0
  while name_ptr[name_len] != 0 and name_len < MAX_XATTR_NAME_LEN {
    name_len = name_len + 1
  }

  // Permission check
  if perms.can_read(inode, uid, gid) == 0 {
    return -1  // EACCES
  }

  // Find xattr
  var i: u32 = 0
  while i < MAX_TOTAL_XATTRS {
    if xattrs[i].active == 1 and xattrs[i].ino == ino {
      // Compare names
      var names_match: u32 = 1
      var j: u32 = 0
      while j < name_len {
        if xattrs[i].name[j] != name_ptr[j] {
          names_match = 0
          break
        }
        j = j + 1
      }

      if names_match == 1 and xattrs[i].name_len == name_len {
        // Found it
        if value == 0 {
          // Just return size
          return xattrs[i].value_len
        }

        // Copy value
        var copy_len: u32 = xattrs[i].value_len
        if copy_len > value_len {
          copy_len = value_len
        }

        memory.memcpy(value, xattrs[i].value, copy_len)
        return copy_len
      }
    }
    i = i + 1
  }

  return -1  // Not found (ENODATA)
}

// ============================================================================
// LIST XATTRS
// ============================================================================

export fn vfs_listxattr(ino: u32, list: u64, list_len: u32, uid: u32, gid: u32): i32 {
  var inode_ptr: u64 = filesystem.inode_get(ino)
  if inode_ptr == 0 {
    return -1  // Invalid inode
  }

  var inode: *filesystem.Inode = @ptrFromInt(inode_ptr)

  // Permission check
  if perms.can_read(inode, uid, gid) == 0 {
    return -1  // EACCES
  }

  var total_size: u32 = 0
  var offset: u32 = 0
  var list_ptr: *u8 = @ptrFromInt(list)

  var i: u32 = 0
  while i < MAX_TOTAL_XATTRS {
    if xattrs[i].active == 1 and xattrs[i].ino == ino {
      var entry_len: u32 = xattrs[i].name_len + 1  // +1 for null terminator
      total_size = total_size + entry_len

      if list != 0 and offset + entry_len <= list_len {
        // Copy name
        var j: u32 = 0
        while j < xattrs[i].name_len {
          list_ptr[offset + j] = xattrs[i].name[j]
          j = j + 1
        }
        list_ptr[offset + j] = 0  // Null terminator
        offset = offset + entry_len
      }
    }
    i = i + 1
  }

  return total_size
}

// ============================================================================
// REMOVE XATTR
// ============================================================================

export fn vfs_removexattr(ino: u32, name: u64, uid: u32, gid: u32): u32 {
  var inode_ptr: u64 = filesystem.inode_get(ino)
  if inode_ptr == 0 {
    return 1  // Invalid inode
  }

  var inode: *filesystem.Inode = @ptrFromInt(inode_ptr)
  var name_ptr: *u8 = @ptrFromInt(name)

  // Get name length
  var name_len: u32 = 0
  while name_ptr[name_len] != 0 and name_len < MAX_XATTR_NAME_LEN {
    name_len = name_len + 1
  }

  // Detect namespace and check permissions
  var ns: u32 = detect_namespace(name_ptr)

  if ns == XATTR_USER {
    if perms.can_write(inode, uid, gid) == 0 {
      return 1  // EACCES
    }
  } else {
    if uid != 0 {
      return 1  // EPERM
    }
  }

  // Find and remove xattr
  var i: u32 = 0
  while i < MAX_TOTAL_XATTRS {
    if xattrs[i].active == 1 and xattrs[i].ino == ino {
      // Compare names
      var names_match: u32 = 1
      var j: u32 = 0
      while j < name_len {
        if xattrs[i].name[j] != name_ptr[j] {
          names_match = 0
          break
        }
        j = j + 1
      }

      if names_match == 1 and xattrs[i].name_len == name_len {
        // Free value
        if xattrs[i].value != 0 {
          memory.pmm_free_page(xattrs[i].value)
          xattr_stats.total_value_bytes = xattr_stats.total_value_bytes - xattrs[i].value_len
        }

        xattrs[i].active = 0
        xattr_count = xattr_count - 1
        xattr_stats.active_xattrs = xattr_count

        return 0  // Removed
      }
    }
    i = i + 1
  }

  return 1  // Not found
}

// ============================================================================
// CLEANUP
// ============================================================================

export fn xattr_cleanup_inode(ino: u32) {
  var i: u32 = 0
  while i < MAX_TOTAL_XATTRS {
    if xattrs[i].active == 1 and xattrs[i].ino == ino {
      if xattrs[i].value != 0 {
        memory.pmm_free_page(xattrs[i].value)
        xattr_stats.total_value_bytes = xattr_stats.total_value_bytes - xattrs[i].value_len
      }
      xattrs[i].active = 0
      xattr_count = xattr_count - 1
    }
    i = i + 1
  }
  xattr_stats.active_xattrs = xattr_count
}

// ============================================================================
// STATISTICS
// ============================================================================

export fn xattr_get_stats(): XattrStats {
  return xattr_stats
}

export fn xattr_print_stats() {
  foundation.serial_write_string("[Extended Attributes Stats]\n")
  foundation.serial_write_string("  Total xattrs created: ")
  foundation.serial_write_u64(xattr_stats.total_xattrs)
  foundation.serial_write_string("\n  Active xattrs: ")
  foundation.serial_write_u32(xattr_stats.active_xattrs)
  foundation.serial_write_string("\n  User xattrs: ")
  foundation.serial_write_u32(xattr_stats.user_xattrs)
  foundation.serial_write_string("\n  System xattrs: ")
  foundation.serial_write_u32(xattr_stats.system_xattrs)
  foundation.serial_write_string("\n  Security xattrs: ")
  foundation.serial_write_u32(xattr_stats.security_xattrs)
  foundation.serial_write_string("\n  Trusted xattrs: ")
  foundation.serial_write_u32(xattr_stats.trusted_xattrs)
  foundation.serial_write_string("\n  Total value bytes: ")
  foundation.serial_write_u64(xattr_stats.total_value_bytes)
  foundation.serial_write_string("\n")
}

// ============================================================================
// INITIALIZATION
// ============================================================================

export fn xattr_init() {
  if xattr_initialized == 1 { return }

  var i: u32 = 0
  while i < MAX_TOTAL_XATTRS {
    xattrs[i].active = 0
    xattrs[i].ino = 0
    xattrs[i].value = 0
    i = i + 1
  }

  xattr_count = 0
  xattr_stats.total_xattrs = 0
  xattr_stats.active_xattrs = 0
  xattr_stats.user_xattrs = 0
  xattr_stats.system_xattrs = 0
  xattr_stats.security_xattrs = 0
  xattr_stats.trusted_xattrs = 0
  xattr_stats.total_value_bytes = 0

  xattr_initialized = 1

  foundation.serial_write_string("[Extended Attributes] Initialized (1024 xattrs, 16 per file max)\n")
}
