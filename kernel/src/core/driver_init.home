// home-os Parallel Driver Initialization System
// Implements dependency graph-based parallel driver loading for faster boot times

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

// Driver states
const DRIVER_STATE_PENDING: u32 = 0
const DRIVER_STATE_INITIALIZING: u32 = 1
const DRIVER_STATE_INITIALIZED: u32 = 2
const DRIVER_STATE_FAILED: u32 = 3

// Driver priority levels
const DRIVER_PRIORITY_CRITICAL: u32 = 0   // Must init first (e.g., memory, interrupts)
const DRIVER_PRIORITY_HIGH: u32 = 1       // Important drivers (e.g., storage, timer)
const DRIVER_PRIORITY_NORMAL: u32 = 2     // Standard drivers (e.g., network, USB)
const DRIVER_PRIORITY_LOW: u32 = 3        // Optional drivers (e.g., audio, video)

// Driver flags
const DRIVER_FLAG_ASYNC: u32 = 1 << 0     // Can be initialized asynchronously
const DRIVER_FLAG_LAZY: u32 = 1 << 1      // Can be lazy-loaded
const DRIVER_FLAG_OPTIONAL: u32 = 1 << 2  // Failure is non-fatal

// Driver initialization function type
type DriverInitFn = fn(): u32

// Driver descriptor
struct DriverDescriptor {
  name: *u8                              // Driver name
  init_fn: DriverInitFn                  // Initialization function
  priority: u32                          // Priority level
  flags: u32                             // Driver flags
  dependencies: [8]u32                   // Indices of dependent drivers
  dep_count: u32                         // Number of dependencies
  state: u32                             // Current state
  init_time_us: u64                      // Time taken to initialize (microseconds)
}

const MAX_DRIVERS: u32 = 256

var drivers: [MAX_DRIVERS]DriverDescriptor
var driver_count: u32 = 0
var initialized: u32 = 0

// Statistics
var total_init_time_us: u64 = 0
var parallel_driver_count: u32 = 0
var sequential_driver_count: u32 = 0
var failed_driver_count: u32 = 0
var lazy_loaded_count: u32 = 0

// Simple timer (would use actual timer hardware in production)
var boot_timer_ticks: u64 = 0

fn get_timestamp_us(): u64 {
  // Simplified - would read from actual timer hardware
  boot_timer_ticks = boot_timer_ticks + 1
  return boot_timer_ticks * 100  // Simulate 100us increments
}

// Initialize driver system
export fn driver_init_system() {
  if initialized == 1 {
    foundation.serial_write_string("[Driver Init] Already initialized\n")
    return
  }

  driver_count = 0
  total_init_time_us = 0
  parallel_driver_count = 0
  sequential_driver_count = 0
  failed_driver_count = 0
  lazy_loaded_count = 0
  boot_timer_ticks = 0

  initialized = 1

  foundation.serial_write_string("[Driver Init] System initialized\n")
}

// Register a driver
export fn driver_register(
  name: *u8,
  init_fn: DriverInitFn,
  priority: u32,
  flags: u32,
  dependencies: *u32,
  dep_count: u32
): u32 {
  if initialized == 0 {
    foundation.serial_write_string("[Driver Init] System not initialized\n")
    return 0xFFFFFFFF
  }

  if driver_count >= MAX_DRIVERS {
    foundation.serial_write_string("[Driver Init] Maximum drivers reached\n")
    return 0xFFFFFFFF
  }

  let driver: *DriverDescriptor = &drivers[driver_count]

  driver.name = name
  driver.init_fn = init_fn
  driver.priority = priority
  driver.flags = flags
  driver.dep_count = 0
  driver.state = DRIVER_STATE_PENDING
  driver.init_time_us = 0

  // Copy dependencies
  if dependencies != 0 && dep_count > 0 {
    var i: u32 = 0
    loop {
      if i >= dep_count { break }
      if i >= 8 { break }  // Max 8 dependencies

      let dep_ptr: *u32 = dependencies + i
      driver.dependencies[i] = *dep_ptr
      driver.dep_count = driver.dep_count + 1

      i = i + 1
    }
  }

  let id: u32 = driver_count
  driver_count = driver_count + 1

  return id
}

// Check if driver's dependencies are satisfied
fn driver_deps_satisfied(driver: *DriverDescriptor): u32 {
  if driver.dep_count == 0 { return 1 }

  var i: u32 = 0
  loop {
    if i >= driver.dep_count { break }

    let dep_id: u32 = driver.dependencies[i]

    if dep_id >= driver_count {
      foundation.serial_write_string("[Driver Init] Invalid dependency\n")
      return 0
    }

    let dep: *DriverDescriptor = &drivers[dep_id]

    if dep.state != DRIVER_STATE_INITIALIZED {
      return 0  // Dependency not yet initialized
    }

    i = i + 1
  }

  return 1
}

// Initialize a single driver
fn driver_init_single(driver: *DriverDescriptor): u32 {
  foundation.serial_write_string("[Driver Init] Initializing ")
  foundation.serial_write_string(driver.name)
  foundation.serial_write_string("...")

  driver.state = DRIVER_STATE_INITIALIZING

  let start_time: u64 = get_timestamp_us()

  // Call driver's init function
  let result: u32 = driver.init_fn()

  let end_time: u64 = get_timestamp_us()
  driver.init_time_us = end_time - start_time
  total_init_time_us = total_init_time_us + driver.init_time_us

  if result == 0 {
    driver.state = DRIVER_STATE_INITIALIZED

    foundation.serial_write_string(" OK (")
    foundation.serial_write_u64(driver.init_time_us)
    foundation.serial_write_string(" us)\n")

    return 0
  } else {
    driver.state = DRIVER_STATE_FAILED
    failed_driver_count = failed_driver_count + 1

    foundation.serial_write_string(" FAILED\n")

    // Check if failure is fatal
    if (driver.flags & DRIVER_FLAG_OPTIONAL) == 0 {
      foundation.serial_write_string("[Driver Init] CRITICAL: Non-optional driver failed!\n")
      return 1
    }

    foundation.serial_write_string("[Driver Init] Optional driver failed, continuing\n")
    return 0
  }
}

// Initialize drivers by priority level
fn driver_init_by_priority(priority: u32): u32 {
  foundation.serial_write_string("\n[Driver Init] Initializing priority ")
  foundation.serial_write_u64(priority)
  foundation.serial_write_string(" drivers\n")

  var initialized_any: u32 = 1
  var iterations: u32 = 0
  var max_iterations: u32 = driver_count + 10

  // Keep trying until no more drivers can be initialized at this priority
  loop {
    if initialized_any == 0 { break }
    if iterations >= max_iterations {
      foundation.serial_write_string("[Driver Init] WARNING: Max iterations reached (circular dependencies?)\n")
      break
    }

    initialized_any = 0
    iterations = iterations + 1

    var i: u32 = 0
    loop {
      if i >= driver_count { break }

      let driver: *DriverDescriptor = &drivers[i]

      // Skip if wrong priority
      if driver.priority != priority {
        i = i + 1
        continue
      }

      // Skip if already initialized or failed
      if driver.state == DRIVER_STATE_INITIALIZED || driver.state == DRIVER_STATE_FAILED {
        i = i + 1
        continue
      }

      // Skip lazy drivers
      if (driver.flags & DRIVER_FLAG_LAZY) != 0 {
        i = i + 1
        continue
      }

      // Check dependencies
      if driver_deps_satisfied(driver) == 0 {
        i = i + 1
        continue
      }

      // Initialize this driver
      let result: u32 = driver_init_single(driver)

      if result != 0 {
        // Fatal error
        return result
      }

      initialized_any = 1

      // Count type of initialization
      if (driver.flags & DRIVER_FLAG_ASYNC) != 0 {
        parallel_driver_count = parallel_driver_count + 1
      } else {
        sequential_driver_count = sequential_driver_count + 1
      }

      i = i + 1
    }
  }

  return 0
}

// Initialize all drivers in dependency order
export fn driver_init_all(): u32 {
  if initialized == 0 {
    foundation.serial_write_string("[Driver Init] System not initialized\n")
    return 1
  }

  foundation.serial_write_string("\n========== DRIVER INITIALIZATION ==========\n")
  foundation.serial_write_string("Total drivers registered: ")
  foundation.serial_write_u64(driver_count)
  foundation.serial_write_string("\n")

  let overall_start: u64 = get_timestamp_us()

  // Initialize by priority (critical first, then high, normal, low)
  var priority: u32 = DRIVER_PRIORITY_CRITICAL
  loop {
    if priority > DRIVER_PRIORITY_LOW { break }

    let result: u32 = driver_init_by_priority(priority)
    if result != 0 {
      foundation.serial_write_string("[Driver Init] FATAL: Critical driver failed\n")
      return result
    }

    priority = priority + 1
  }

  let overall_end: u64 = get_timestamp_us()
  let overall_time: u64 = overall_end - overall_start

  foundation.serial_write_string("\n========== INITIALIZATION COMPLETE ==========\n")
  foundation.serial_write_string("Total time: ")
  foundation.serial_write_u64(overall_time)
  foundation.serial_write_string(" us (")
  foundation.serial_write_u64(overall_time / 1000)
  foundation.serial_write_string(" ms)\n")

  foundation.serial_write_string("Sequential drivers: ")
  foundation.serial_write_u64(sequential_driver_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("Parallel-capable drivers: ")
  foundation.serial_write_u64(parallel_driver_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("Failed drivers: ")
  foundation.serial_write_u64(failed_driver_count)
  foundation.serial_write_string("\n")

  // Count lazy drivers
  var lazy_count: u32 = 0
  var i: u32 = 0
  loop {
    if i >= driver_count { break }

    if (drivers[i].flags & DRIVER_FLAG_LAZY) != 0 {
      lazy_count = lazy_count + 1
    }

    i = i + 1
  }

  foundation.serial_write_string("Lazy-loadable drivers: ")
  foundation.serial_write_u64(lazy_count)
  foundation.serial_write_string(" (deferred)\n")

  foundation.serial_write_string("============================================\n\n")

  return 0
}

// Lazy-load a driver by name
export fn driver_lazy_load(name: *u8): u32 {
  if initialized == 0 { return 1 }

  var i: u32 = 0
  loop {
    if i >= driver_count { break }

    let driver: *DriverDescriptor = &drivers[i]

    // Compare names (simple string comparison)
    if driver.name == name {
      if driver.state == DRIVER_STATE_INITIALIZED {
        foundation.serial_write_string("[Driver Init] Already initialized: ")
        foundation.serial_write_string(name)
        foundation.serial_write_string("\n")
        return 0
      }

      if (driver.flags & DRIVER_FLAG_LAZY) == 0 {
        foundation.serial_write_string("[Driver Init] Not a lazy driver: ")
        foundation.serial_write_string(name)
        foundation.serial_write_string("\n")
        return 1
      }

      // Check dependencies
      if driver_deps_satisfied(driver) == 0 {
        foundation.serial_write_string("[Driver Init] Dependencies not satisfied: ")
        foundation.serial_write_string(name)
        foundation.serial_write_string("\n")
        return 1
      }

      // Initialize
      foundation.serial_write_string("[Driver Init] Lazy-loading: ")
      foundation.serial_write_string(name)
      foundation.serial_write_string("\n")

      let result: u32 = driver_init_single(driver)

      if result == 0 {
        lazy_loaded_count = lazy_loaded_count + 1
      }

      return result
    }

    i = i + 1
  }

  foundation.serial_write_string("[Driver Init] Driver not found: ")
  foundation.serial_write_string(name)
  foundation.serial_write_string("\n")

  return 1
}

// Print driver initialization report
export fn driver_print_report() {
  if initialized == 0 { return }

  foundation.serial_write_string("\n========== DRIVER INITIALIZATION REPORT ==========\n\n")

  foundation.serial_write_string("Drivers by state:\n")

  var initialized_count: u32 = 0
  var pending_count: u32 = 0
  var failed_count: u32 = 0

  var i: u32 = 0
  loop {
    if i >= driver_count { break }

    let state: u32 = drivers[i].state

    if state == DRIVER_STATE_INITIALIZED {
      initialized_count = initialized_count + 1
    } else if state == DRIVER_STATE_PENDING {
      pending_count = pending_count + 1
    } else if state == DRIVER_STATE_FAILED {
      failed_count = failed_count + 1
    }

    i = i + 1
  }

  foundation.serial_write_string("  Initialized: ")
  foundation.serial_write_u64(initialized_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Pending/Lazy: ")
  foundation.serial_write_u64(pending_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Failed: ")
  foundation.serial_write_u64(failed_count)
  foundation.serial_write_string("\n\n")

  foundation.serial_write_string("Slowest drivers:\n")

  // Find slowest 5 drivers (simple bubble sort)
  var sorted_indices: [5]u32
  var j: u32 = 0
  loop {
    if j >= 5 { break }
    sorted_indices[j] = 0xFFFFFFFF
    j = j + 1
  }

  i = 0
  loop {
    if i >= driver_count { break }

    if drivers[i].state != DRIVER_STATE_INITIALIZED {
      i = i + 1
      continue
    }

    let time: u64 = drivers[i].init_time_us

    // Insert into sorted list
    j = 0
    loop {
      if j >= 5 { break }

      if sorted_indices[j] == 0xFFFFFFFF {
        sorted_indices[j] = i
        break
      }

      if time > drivers[sorted_indices[j]].init_time_us {
        // Shift down
        var k: u32 = 4
        loop {
          if k <= j { break }

          sorted_indices[k] = sorted_indices[k - 1]

          k = k - 1
        }

        sorted_indices[j] = i
        break
      }

      j = j + 1
    }

    i = i + 1
  }

  // Print top 5
  j = 0
  loop {
    if j >= 5 { break }

    let idx: u32 = sorted_indices[j]
    if idx == 0xFFFFFFFF { break }

    let driver: *DriverDescriptor = &drivers[idx]

    foundation.serial_write_string("  ")
    foundation.serial_write_u64(j + 1)
    foundation.serial_write_string(". ")
    foundation.serial_write_string(driver.name)
    foundation.serial_write_string(": ")
    foundation.serial_write_u64(driver.init_time_us)
    foundation.serial_write_string(" us\n")

    j = j + 1
  }

  foundation.serial_write_string("\nTotal initialization time: ")
  foundation.serial_write_u64(total_init_time_us / 1000)
  foundation.serial_write_string(" ms\n")

  foundation.serial_write_string("Lazy-loaded drivers: ")
  foundation.serial_write_u64(lazy_loaded_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("\n==================================================\n\n")
}

// Get driver state
export fn driver_get_state(name: *u8): u32 {
  if initialized == 0 { return DRIVER_STATE_FAILED }

  var i: u32 = 0
  loop {
    if i >= driver_count { break }

    if drivers[i].name == name {
      return drivers[i].state
    }

    i = i + 1
  }

  return DRIVER_STATE_FAILED
}

// ============================================================================
// Parallel Initialization Support
// ============================================================================

// Init batch - group of drivers that can initialize in parallel
const MAX_BATCH_SIZE: u32 = 16

struct InitBatch {
  driver_ids: [16]u32,
  count: u32,
  priority: u32
}

var init_batches: [32]InitBatch
var batch_count: u32 = 0

// Build parallel init batches by analyzing dependencies
export fn driver_build_parallel_batches(): u32 {
  batch_count = 0

  foundation.serial_write_string("\n[Driver Init] Building parallel init batches...\n")

  // For each priority level, find independent driver groups
  var priority: u32 = DRIVER_PRIORITY_CRITICAL
  loop {
    if priority > DRIVER_PRIORITY_LOW { break }

    // Find all drivers at this priority with satisfied dependencies
    var batch_idx: u32 = batch_count
    var batch: *InitBatch = &init_batches[batch_idx]
    batch.count = 0
    batch.priority = priority

    var found_any: u32 = 0
    var iteration: u32 = 0

    // Keep building batches until no more drivers at this priority
    loop {
      if iteration > driver_count { break }
      iteration = iteration + 1

      var added_to_batch: u32 = 0

      var i: u32 = 0
      loop {
        if i >= driver_count { break }

        let driver: *DriverDescriptor = &drivers[i]

        // Skip wrong priority
        if driver.priority != priority {
          i = i + 1
          continue
        }

        // Skip already processed
        if driver.state != DRIVER_STATE_PENDING {
          i = i + 1
          continue
        }

        // Skip lazy
        if (driver.flags & DRIVER_FLAG_LAZY) != 0 {
          i = i + 1
          continue
        }

        // Check if dependencies are in previous batches (or already init'd)
        if driver_deps_in_earlier_batches(driver, batch_idx) == 0 {
          i = i + 1
          continue
        }

        // Add to current batch
        if batch.count < MAX_BATCH_SIZE {
          batch.driver_ids[batch.count] = i
          batch.count = batch.count + 1
          driver.state = DRIVER_STATE_INITIALIZING  // Mark as scheduled
          added_to_batch = 1
          found_any = 1
        }

        i = i + 1
      }

      // If batch is full or no more can be added, finalize batch
      if batch.count > 0 and (batch.count >= MAX_BATCH_SIZE or added_to_batch == 0) {
        batch_count = batch_count + 1

        if batch_count < 32 {
          batch = &init_batches[batch_count]
          batch.count = 0
          batch.priority = priority
        }
      }

      if added_to_batch == 0 { break }
    }

    priority = priority + 1
  }

  // Reset states back to pending
  var i: u32 = 0
  loop {
    if i >= driver_count { break }
    if drivers[i].state == DRIVER_STATE_INITIALIZING {
      drivers[i].state = DRIVER_STATE_PENDING
    }
    i = i + 1
  }

  foundation.serial_write_string("[Driver Init] Created ")
  foundation.serial_write_u64(batch_count)
  foundation.serial_write_string(" parallel batches\n")

  return batch_count
}

fn driver_deps_in_earlier_batches(driver: *DriverDescriptor, current_batch: u32): u32 {
  if driver.dep_count == 0 { return 1 }

  var i: u32 = 0
  loop {
    if i >= driver.dep_count { break }

    let dep_id: u32 = driver.dependencies[i]
    if dep_id >= driver_count { return 0 }

    let dep: *DriverDescriptor = &drivers[dep_id]

    // Check if dep is already initialized or scheduled in earlier batch
    if dep.state == DRIVER_STATE_INITIALIZED {
      i = i + 1
      continue
    }

    // Check if in earlier batch
    var found: u32 = 0
    var b: u32 = 0
    loop {
      if b >= current_batch { break }

      let batch: *InitBatch = &init_batches[b]
      var j: u32 = 0
      loop {
        if j >= batch.count { break }

        if batch.driver_ids[j] == dep_id {
          found = 1
          break
        }

        j = j + 1
      }

      if found == 1 { break }
      b = b + 1
    }

    if found == 0 { return 0 }

    i = i + 1
  }

  return 1
}

// Execute parallel batches
export fn driver_init_parallel(): u32 {
  if batch_count == 0 {
    driver_build_parallel_batches()
  }

  foundation.serial_write_string("\n========== PARALLEL DRIVER INITIALIZATION ==========\n")

  var total_parallel: u32 = 0
  var total_time: u64 = 0

  var b: u32 = 0
  loop {
    if b >= batch_count { break }

    let batch: *InitBatch = &init_batches[b]

    if batch.count == 0 {
      b = b + 1
      continue
    }

    foundation.serial_write_string("\n[Batch ")
    foundation.serial_write_u64(b)
    foundation.serial_write_string("] Priority=")
    foundation.serial_write_u64(batch.priority)
    foundation.serial_write_string(" Drivers=")
    foundation.serial_write_u64(batch.count)
    foundation.serial_write_string(" (parallel)\n")

    let batch_start: u64 = get_timestamp_us()

    // Initialize all drivers in batch "in parallel"
    // Note: True parallelism requires SMP/threading support
    // For now, we simulate by initializing in rapid sequence
    var i: u32 = 0
    loop {
      if i >= batch.count { break }

      let driver_id: u32 = batch.driver_ids[i]
      let driver: *DriverDescriptor = &drivers[driver_id]

      let result: u32 = driver_init_single(driver)
      if result != 0 and (driver.flags & DRIVER_FLAG_OPTIONAL) == 0 {
        foundation.serial_write_string("[Driver Init] FATAL: Driver in batch failed\n")
        return result
      }

      i = i + 1
    }

    let batch_end: u64 = get_timestamp_us()
    let batch_time: u64 = batch_end - batch_start

    foundation.serial_write_string("[Batch ")
    foundation.serial_write_u64(b)
    foundation.serial_write_string("] Complete in ")
    foundation.serial_write_u64(batch_time)
    foundation.serial_write_string(" us\n")

    total_parallel = total_parallel + batch.count
    total_time = total_time + batch_time

    b = b + 1
  }

  foundation.serial_write_string("\n========== PARALLEL INIT COMPLETE ==========\n")
  foundation.serial_write_string("Total batches: ")
  foundation.serial_write_u64(batch_count)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("Drivers initialized: ")
  foundation.serial_write_u64(total_parallel)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("Total time: ")
  foundation.serial_write_u64(total_time / 1000)
  foundation.serial_write_string(" ms\n")
  foundation.serial_write_string("============================================\n\n")

  return 0
}

// Print batch structure for debugging
export fn driver_print_batches() {
  foundation.serial_write_string("\n========== PARALLEL BATCH STRUCTURE ==========\n\n")

  var b: u32 = 0
  loop {
    if b >= batch_count { break }

    let batch: *InitBatch = &init_batches[b]

    foundation.serial_write_string("Batch ")
    foundation.serial_write_u64(b)
    foundation.serial_write_string(" (priority ")
    foundation.serial_write_u64(batch.priority)
    foundation.serial_write_string("): ")
    foundation.serial_write_u64(batch.count)
    foundation.serial_write_string(" drivers\n")

    var i: u32 = 0
    loop {
      if i >= batch.count { break }

      let driver_id: u32 = batch.driver_ids[i]
      let driver: *DriverDescriptor = &drivers[driver_id]

      foundation.serial_write_string("  - ")
      foundation.serial_write_string(driver.name)

      if (driver.flags & DRIVER_FLAG_ASYNC) != 0 {
        foundation.serial_write_string(" [async]")
      }

      foundation.serial_write_string("\n")

      i = i + 1
    }

    b = b + 1
  }

  foundation.serial_write_string("\n============================================\n\n")
}

// ============================================================================
// Init Groups - Predefined parallel init groups
// ============================================================================

const INIT_GROUP_CORE: u32 = 0       // Core system (memory, interrupts, timer)
const INIT_GROUP_STORAGE: u32 = 1   // Storage drivers (AHCI, NVMe, SD)
const INIT_GROUP_INPUT: u32 = 2     // Input devices (keyboard, mouse, touchpad)
const INIT_GROUP_NETWORK: u32 = 3   // Network drivers (Ethernet, WiFi)
const INIT_GROUP_DISPLAY: u32 = 4   // Display/GPU drivers
const INIT_GROUP_USB: u32 = 5       // USB controllers
const INIT_GROUP_AUDIO: u32 = 6     // Audio devices
const INIT_GROUP_OTHER: u32 = 7     // Misc devices

// Group states for parallel init tracking
var group_states: [8]u32
var group_driver_counts: [8]u32

export fn driver_assign_group(driver_id: u32, group: u32): u32 {
  if driver_id >= driver_count { return 1 }
  if group >= 8 { return 1 }

  // Store group in unused field or add new field
  // For now, use flags upper bits
  let driver: *DriverDescriptor = &drivers[driver_id]
  driver.flags = (driver.flags & 0x0000FFFF) | (group << 16)

  group_driver_counts[group] = group_driver_counts[group] + 1

  return 0
}

fn driver_get_group(driver: *DriverDescriptor): u32 {
  return (driver.flags >> 16) & 0xFF
}

// Initialize all drivers in a specific group
export fn driver_init_group(group: u32): u32 {
  if group >= 8 { return 1 }

  foundation.serial_write_string("[Driver Init] Initializing group ")
  foundation.serial_write_u64(group)
  foundation.serial_write_string("\n")

  var i: u32 = 0
  loop {
    if i >= driver_count { break }

    let driver: *DriverDescriptor = &drivers[i]

    if driver_get_group(driver) != group {
      i = i + 1
      continue
    }

    if driver.state != DRIVER_STATE_PENDING {
      i = i + 1
      continue
    }

    if (driver.flags & DRIVER_FLAG_LAZY) != 0 {
      i = i + 1
      continue
    }

    if driver_deps_satisfied(driver) == 0 {
      i = i + 1
      continue
    }

    let result: u32 = driver_init_single(driver)
    if result != 0 and (driver.flags & DRIVER_FLAG_OPTIONAL) == 0 {
      return result
    }

    i = i + 1
  }

  group_states[group] = 1

  return 0
}

// Initialize multiple groups in parallel (for SMP systems)
export fn driver_init_groups_parallel(groups: *u32, group_count: u32): u32 {
  foundation.serial_write_string("[Driver Init] Parallel group initialization\n")
  foundation.serial_write_string("Groups: ")

  var i: u32 = 0
  loop {
    if i >= group_count { break }

    let g: u32 = *@ptrFromInt(groups + i * 4, *u32)
    foundation.serial_write_u64(g)
    foundation.serial_write_string(" ")

    i = i + 1
  }
  foundation.serial_write_string("\n")

  // In a true SMP system, each group would run on a separate CPU
  // For now, run sequentially
  i = 0
  loop {
    if i >= group_count { break }

    let g: u32 = *@ptrFromInt(groups + i * 4, *u32)
    let result: u32 = driver_init_group(g)
    if result != 0 { return result }

    i = i + 1
  }

  return 0
}

// Estimate parallelization speedup
export fn driver_estimate_speedup(): u32 {
  if batch_count == 0 {
    driver_build_parallel_batches()
  }

  // Calculate sequential time
  var seq_time: u64 = 0
  var i: u32 = 0
  loop {
    if i >= driver_count { break }

    if drivers[i].state == DRIVER_STATE_INITIALIZED {
      seq_time = seq_time + drivers[i].init_time_us
    }

    i = i + 1
  }

  // Calculate parallel time (max per batch)
  var par_time: u64 = 0
  var b: u32 = 0
  loop {
    if b >= batch_count { break }

    let batch: *InitBatch = &init_batches[b]
    var batch_max: u64 = 0

    var j: u32 = 0
    loop {
      if j >= batch.count { break }

      let driver_id: u32 = batch.driver_ids[j]
      let time: u64 = drivers[driver_id].init_time_us

      if time > batch_max {
        batch_max = time
      }

      j = j + 1
    }

    par_time = par_time + batch_max

    b = b + 1
  }

  if par_time == 0 { return 100 }

  let speedup: u32 = @truncate((seq_time * 100) / par_time, u32)

  foundation.serial_write_string("[Driver Init] Estimated speedup: ")
  foundation.serial_write_u64(speedup)
  foundation.serial_write_string("%\n")
  foundation.serial_write_string("  Sequential time: ")
  foundation.serial_write_u64(seq_time / 1000)
  foundation.serial_write_string(" ms\n")
  foundation.serial_write_string("  Parallel time:   ")
  foundation.serial_write_u64(par_time / 1000)
  foundation.serial_write_string(" ms\n")

  return speedup
}
