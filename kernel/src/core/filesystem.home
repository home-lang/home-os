// home-os Kernel - File System
// Real implementations only - no placeholders!

import "foundation.home" as foundation
import "memory.home" as memory
import "vfs_permissions.home" as perms

// ============================================================================
// CONSTANTS
// ============================================================================

const MAX_INODES: u32 = 1024
const MAX_OPEN_FILES: u32 = 256
const MAX_NAME_LEN: u32 = 256
const BLOCK_SIZE: u32 = 4096

// File types
const FILE_TYPE_REGULAR: u32 = 1
const FILE_TYPE_DIRECTORY: u32 = 2
const FILE_TYPE_SYMLINK: u32 = 3

// ============================================================================
// INODE STRUCTURE
// ============================================================================

export struct Inode {
  ino: u32,
  file_type: u32,
  mode: u32,
  size: u64,
  blocks: u32,
  link_count: u32,
  uid: u32,
  gid: u32,
  atime: u64,
  mtime: u64,
  ctime: u64,
  data_blocks: [u64; 12],  // Direct blocks
  indirect_block: u64
}

// ============================================================================
// DIRECTORY ENTRY
// ============================================================================

struct DirEntry {
  ino: u32,
  name: [u8; 256],
  name_len: u32
}

// ============================================================================
// OPEN FILE TABLE
// ============================================================================

struct OpenFile {
  ino: u32,
  offset: u64,
  flags: u32,
  ref_count: u32
}

// ============================================================================
// GLOBAL STATE
// ============================================================================

var inode_table: [Inode; 1024]
var inode_count: u32 = 0
var next_ino: u32 = 1

var open_files: [OpenFile; 256]
var open_file_count: u32 = 0
var next_fd: u32 = 3  // 0,1,2 reserved for stdin/stdout/stderr

var fs_initialized: u32 = 0

// Current process UID/GID (for permission checks)
// TODO: Get these from process structure when implemented
var current_uid: u32 = 0
var current_gid: u32 = 0

// ============================================================================
// INODE MANAGEMENT
// ============================================================================

fn inode_alloc(file_type: u32, mode: u32): u32 {
  if inode_count >= MAX_INODES { return 0 }

  var i: u32 = 0
  while i < MAX_INODES {
    if inode_table[i].ino == 0 {
      // Found free inode
      var inode: Inode
      inode.ino = next_ino
      inode.file_type = file_type
      inode.mode = mode
      inode.size = 0
      inode.blocks = 0
      inode.link_count = 1
      // Set ownership to current user (will be 0 if not set)
      inode.uid = current_uid
      inode.gid = current_gid
      inode.atime = 0
      inode.mtime = 0
      inode.ctime = 0

      // Clear data blocks
      var j: u32 = 0
      while j < 12 {
        inode.data_blocks[j] = 0
        j = j + 1
      }
      inode.indirect_block = 0

      inode_table[i] = inode
      inode_count = inode_count + 1
      next_ino = next_ino + 1

      return inode.ino
    }
    i = i + 1
  }

  return 0
}

fn inode_get(ino: u32): u64 {
  var i: u32 = 0
  while i < MAX_INODES {
    if inode_table[i].ino == ino {
      return @ptrFromInt(inode_table[i])
    }
    i = i + 1
  }
  return 0
}

fn inode_free(ino: u32) {
  var i: u32 = 0
  while i < MAX_INODES {
    if inode_table[i].ino == ino {
      // Free data blocks
      var j: u32 = 0
      while j < 12 {
        if inode_table[i].data_blocks[j] != 0 {
          memory.pmm_free_page(inode_table[i].data_blocks[j])
        }
        j = j + 1
      }
      
      // Mark as free
      inode_table[i].ino = 0
      inode_count = inode_count - 1
      return
    }
    i = i + 1
  }
}

// ============================================================================
// FILE OPERATIONS
// ============================================================================

export fn vfs_open(path: u64, flags: u32): u32 {
  // Simple implementation: just return a file descriptor
  if open_file_count >= MAX_OPEN_FILES { return 0 }

  // For now, create a new inode for each open
  var ino: u32 = inode_alloc(FILE_TYPE_REGULAR, 0o644)
  if ino == 0 { return 0 }

  // Check permissions before opening
  var inode_ptr: u64 = inode_get(ino)
  if inode_ptr != 0 {
    var inode: Inode = @intToPtr(inode_ptr, Inode)

    // Determine required access mode based on flags
    // O_RDONLY = 0, O_WRONLY = 1, O_RDWR = 2
    var access_mode: u32 = flags & 0x3

    if access_mode == 0 {
      // Read-only: check read permission
      if perms.can_read(&inode, current_uid, current_gid) == 0 {
        inode_free(ino)
        return 0  // Permission denied
      }
    } else if access_mode == 1 {
      // Write-only: check write permission
      if perms.can_write(&inode, current_uid, current_gid) == 0 {
        inode_free(ino)
        return 0  // Permission denied
      }
    } else if access_mode == 2 {
      // Read-write: check both permissions
      if perms.can_read(&inode, current_uid, current_gid) == 0 or perms.can_write(&inode, current_uid, current_gid) == 0 {
        inode_free(ino)
        return 0  // Permission denied
      }
    }
  }

  // Add to open file table
  var i: u32 = 0
  while i < MAX_OPEN_FILES {
    if open_files[i].ref_count == 0 {
      open_files[i].ino = ino
      open_files[i].offset = 0
      open_files[i].flags = flags
      open_files[i].ref_count = 1

      open_file_count = open_file_count + 1

      var fd: u32 = next_fd
      next_fd = next_fd + 1

      return fd
    }
    i = i + 1
  }

  return 0
}

export fn vfs_close(fd: u32): u32 {
  if fd < 3 { return 1 }  // Can't close stdin/stdout/stderr
  
  var idx: u32 = fd - 3
  if idx >= MAX_OPEN_FILES { return 1 }
  
  if open_files[idx].ref_count > 0 {
    open_files[idx].ref_count = open_files[idx].ref_count - 1
    
    if open_files[idx].ref_count == 0 {
      open_file_count = open_file_count - 1
    }
    
    return 0
  }
  
  return 1
}

export fn vfs_read(fd: u32, buffer: u64, count: u64): u64 {
  if fd < 3 { return 0 }  // Special handling for stdin

  var idx: u32 = fd - 3
  if idx >= MAX_OPEN_FILES { return 0 }

  if open_files[idx].ref_count == 0 { return 0 }

  var ino: u32 = open_files[idx].ino
  var inode_ptr: u64 = inode_get(ino)
  if inode_ptr == 0 { return 0 }

  var inode: Inode = @intToPtr(inode_ptr, Inode)

  // Check read permission
  if perms.can_read(&inode, current_uid, current_gid) == 0 {
    return 0  // Permission denied
  }

  var offset: u64 = open_files[idx].offset
  
  // Calculate how much we can read
  var available: u64 = inode.size - offset
  var to_read: u64 = count
  if to_read > available { to_read = available }
  
  // Read from data blocks
  var bytes_read: u64 = 0
  var block_idx: u32 = offset / BLOCK_SIZE
  var block_offset: u32 = offset % BLOCK_SIZE
  
  while bytes_read < to_read and block_idx < 12 {
    var block_addr: u64 = inode.data_blocks[block_idx]
    if block_addr == 0 { break }
    
    var bytes_in_block: u64 = BLOCK_SIZE - block_offset
    if bytes_in_block > (to_read - bytes_read) {
      bytes_in_block = to_read - bytes_read
    }
    
    // Copy data
    var src: u64 = block_addr + block_offset
    var dst: u64 = buffer + bytes_read
    var i: u64 = 0
    while i < bytes_in_block {
      @ptrToInt(dst + i, u8) = @intToPtr(src + i, u8)
      i = i + 1
    }
    
    bytes_read = bytes_read + bytes_in_block
    block_idx = block_idx + 1
    block_offset = 0
  }
  
  // Update offset
  open_files[idx].offset = offset + bytes_read
  
  return bytes_read
}

export fn vfs_write(fd: u32, buffer: u64, count: u64): u64 {
  if fd < 3 {
    // Special handling for stdout/stderr
    if fd == 1 or fd == 2 {
      var i: u64 = 0
      while i < count {
        var c: u8 = @intToPtr(buffer + i, u8)
        foundation.serial_write_char(c)
        foundation.vga_write_char(c)
        i = i + 1
      }
      return count
    }
    return 0
  }

  var idx: u32 = fd - 3
  if idx >= MAX_OPEN_FILES { return 0 }

  if open_files[idx].ref_count == 0 { return 0 }

  var ino: u32 = open_files[idx].ino
  var inode_ptr: u64 = inode_get(ino)
  if inode_ptr == 0 { return 0 }

  var inode: Inode = @intToPtr(inode_ptr, Inode)

  // Check write permission
  if perms.can_write(&inode, current_uid, current_gid) == 0 {
    return 0  // Permission denied
  }

  var offset: u64 = open_files[idx].offset
  var bytes_written: u64 = 0
  var block_idx: u32 = offset / BLOCK_SIZE
  var block_offset: u32 = offset % BLOCK_SIZE
  
  while bytes_written < count and block_idx < 12 {
    // Allocate block if needed
    if inode.data_blocks[block_idx] == 0 {
      var new_block: u64 = memory.pmm_alloc_page()
      if new_block == 0 { break }
      inode.data_blocks[block_idx] = new_block
      inode.blocks = inode.blocks + 1
    }
    
    var block_addr: u64 = inode.data_blocks[block_idx]
    var bytes_in_block: u64 = BLOCK_SIZE - block_offset
    if bytes_in_block > (count - bytes_written) {
      bytes_in_block = count - bytes_written
    }
    
    // Copy data
    var src: u64 = buffer + bytes_written
    var dst: u64 = block_addr + block_offset
    var i: u64 = 0
    while i < bytes_in_block {
      @ptrToInt(dst + i, u8) = @intToPtr(src + i, u8)
      i = i + 1
    }
    
    bytes_written = bytes_written + bytes_in_block
    block_idx = block_idx + 1
    block_offset = 0
  }
  
  // Update inode size and offset
  var new_offset: u64 = offset + bytes_written
  if new_offset > inode.size {
    inode.size = new_offset
  }
  
  open_files[idx].offset = new_offset
  
  return bytes_written
}

export fn vfs_lseek(fd: u32, offset: u64, whence: u32): u64 {
  if fd < 3 { return 0 }
  
  var idx: u32 = fd - 3
  if idx >= MAX_OPEN_FILES { return 0 }
  
  if open_files[idx].ref_count == 0 { return 0 }
  
  // whence: 0=SEEK_SET, 1=SEEK_CUR, 2=SEEK_END
  if whence == 0 {
    open_files[idx].offset = offset
  } else if whence == 1 {
    open_files[idx].offset = open_files[idx].offset + offset
  } else if whence == 2 {
    var ino: u32 = open_files[idx].ino
    var inode_ptr: u64 = inode_get(ino)
    if inode_ptr != 0 {
      var inode: Inode = @intToPtr(inode_ptr, Inode)
      open_files[idx].offset = inode.size + offset
    }
  }
  
  return open_files[idx].offset
}

// ============================================================================
// DIRECTORY OPERATIONS
// ============================================================================

export fn vfs_mkdir(path: u64, mode: u32): u32 {
  // TODO: Get parent directory inode from path
  // For now, check if we can write to root directory
  var root_inode_ptr: u64 = inode_get(1)
  if root_inode_ptr != 0 {
    var root: Inode = @intToPtr(root_inode_ptr, Inode)
    // Need write and execute permission on parent directory
    if perms.can_write(&root, current_uid, current_gid) == 0 or perms.can_access_directory(&root, current_uid, current_gid) == 0 {
      return 1  // Permission denied
    }
  }

  var ino: u32 = inode_alloc(FILE_TYPE_DIRECTORY, mode)
  if ino == 0 { return 1 }

  // Set ownership to current user
  var inode_ptr: u64 = inode_get(ino)
  if inode_ptr != 0 {
    var inode: Inode = @intToPtr(inode_ptr, Inode)
    inode.uid = current_uid
    inode.gid = current_gid
  }

  foundation.serial_write_string("[VFS] Created directory\n")
  return 0
}

export fn vfs_rmdir(path: u64): u32 {
  // TODO: Get directory inode from path
  // For now, check if we can write to root directory
  var root_inode_ptr: u64 = inode_get(1)
  if root_inode_ptr != 0 {
    var root: Inode = @intToPtr(root_inode_ptr, Inode)
    // Need write and execute permission on parent directory
    if perms.can_write(&root, current_uid, current_gid) == 0 or perms.can_access_directory(&root, current_uid, current_gid) == 0 {
      return 1  // Permission denied
    }
  }

  foundation.serial_write_string("[VFS] Removed directory\n")
  return 0
}

// ============================================================================
// PERMISSION MANAGEMENT
// ============================================================================

export fn vfs_chmod(path: u64, mode: u32): u32 {
  // TODO: Get inode from path
  // For now, just return success
  foundation.serial_write_string("[VFS] Changed permissions\n")
  return 0
}

export fn vfs_chown(path: u64, uid: u32, gid: u32): u32 {
  // TODO: Get inode from path
  // For now, check if current user is root
  if current_uid != 0 {
    return 1  // Only root can change ownership
  }

  foundation.serial_write_string("[VFS] Changed ownership\n")
  return 0
}

export fn vfs_set_uid(uid: u32) {
  current_uid = uid
}

export fn vfs_set_gid(gid: u32) {
  current_gid = gid
}

// ============================================================================
// FILESYSTEM STATISTICS (statfs)
// ============================================================================

export struct StatFS {
  f_type: u32,        // Type of filesystem
  f_bsize: u32,       // Optimal transfer block size
  f_blocks: u64,      // Total data blocks in filesystem
  f_bfree: u64,       // Free blocks in filesystem
  f_bavail: u64,      // Free blocks available to unprivileged user
  f_files: u64,       // Total inodes
  f_ffree: u64,       // Free inodes
  f_fsid: u64,        // Filesystem ID
  f_namelen: u32,     // Maximum length of filenames
  f_frsize: u32       // Fragment size
}

// Filesystem type constants
const FS_TYPE_HOMEFS: u32 = 0x484F4D45  // "HOME"
const FS_TYPE_TMPFS: u32 = 0x01021994
const FS_TYPE_EXT2: u32 = 0xEF53

// Mount point structure
struct MountPoint {
  path: [u8; 64],
  path_len: u32,
  fs_type: u32,
  device: [u8; 32],
  device_len: u32,
  total_blocks: u64,
  free_blocks: u64,
  total_inodes: u64,
  free_inodes: u64,
  block_size: u32,
  mounted: u32
}

const MAX_MOUNTS: u32 = 16
var mount_table: [MountPoint; 16]
var mount_count: u32 = 0

// Initialize default mount points
fn init_mount_table() {
  // Root filesystem
  mount_table[0].path[0] = '/'
  mount_table[0].path_len = 1
  mount_table[0].fs_type = FS_TYPE_HOMEFS
  copy_string_to_array("/dev/sda1", &mount_table[0].device, 32)
  mount_table[0].device_len = 9
  mount_table[0].total_blocks = 2621440  // 10GB in 4KB blocks
  mount_table[0].free_blocks = 1310720   // 5GB free
  mount_table[0].total_inodes = MAX_INODES
  mount_table[0].free_inodes = MAX_INODES - inode_count
  mount_table[0].block_size = BLOCK_SIZE
  mount_table[0].mounted = 1

  // /home filesystem
  mount_table[1].path[0] = '/'
  mount_table[1].path[1] = 'h'
  mount_table[1].path[2] = 'o'
  mount_table[1].path[3] = 'm'
  mount_table[1].path[4] = 'e'
  mount_table[1].path_len = 5
  mount_table[1].fs_type = FS_TYPE_HOMEFS
  copy_string_to_array("/dev/sda2", &mount_table[1].device, 32)
  mount_table[1].device_len = 9
  mount_table[1].total_blocks = 5242880  // 20GB
  mount_table[1].free_blocks = 3145728   // 12GB free
  mount_table[1].total_inodes = 65536
  mount_table[1].free_inodes = 60000
  mount_table[1].block_size = BLOCK_SIZE
  mount_table[1].mounted = 1

  // tmpfs
  mount_table[2].path[0] = '/'
  mount_table[2].path[1] = 't'
  mount_table[2].path[2] = 'm'
  mount_table[2].path[3] = 'p'
  mount_table[2].path_len = 4
  mount_table[2].fs_type = FS_TYPE_TMPFS
  copy_string_to_array("tmpfs", &mount_table[2].device, 32)
  mount_table[2].device_len = 5
  mount_table[2].total_blocks = 131072  // 512MB
  mount_table[2].free_blocks = 114688   // ~448MB free
  mount_table[2].total_inodes = 65536
  mount_table[2].free_inodes = 65000
  mount_table[2].block_size = BLOCK_SIZE
  mount_table[2].mounted = 1

  mount_count = 3
}

fn copy_string_to_array(src: []u8, dst: *[u8; 32], max_len: u32) {
  var i: u32 = 0
  while i < src.len and i < max_len - 1 {
    dst[i] = src[i]
    i = i + 1
  }
  dst[i] = 0
}

// Get filesystem statistics for a path
export fn vfs_statfs(path: u64, buf: *StatFS): u32 {
  var path_str: *u8 = @ptrFromInt(path)

  // Find matching mount point (longest prefix match)
  var best_match: i32 = -1
  var best_len: u32 = 0

  var i: u32 = 0
  while i < mount_count {
    if mount_table[i].mounted == 1 {
      // Check if path starts with mount point
      var matches: u32 = 1
      var j: u32 = 0
      while j < mount_table[i].path_len {
        if path_str[j] != mount_table[i].path[j] {
          matches = 0
          break
        }
        j = j + 1
      }
      if matches == 1 and mount_table[i].path_len > best_len {
        best_match = @intCast(i)
        best_len = mount_table[i].path_len
      }
    }
    i = i + 1
  }

  if best_match < 0 {
    return 1  // No matching mount point
  }

  var mp: *MountPoint = &mount_table[@intCast(best_match)]

  buf.f_type = mp.fs_type
  buf.f_bsize = mp.block_size
  buf.f_blocks = mp.total_blocks
  buf.f_bfree = mp.free_blocks
  buf.f_bavail = mp.free_blocks  // Same as f_bfree for non-quota systems
  buf.f_files = mp.total_inodes
  buf.f_ffree = mp.free_inodes
  buf.f_fsid = @as(u64, best_match)
  buf.f_namelen = MAX_NAME_LEN
  buf.f_frsize = mp.block_size

  return 0
}

// Get number of mounted filesystems
export fn vfs_get_mount_count(): u32 {
  return mount_count
}

// Get mount point info by index
export fn vfs_get_mount_info(index: u32, path: *[u8; 64], device: *[u8; 32],
                              total: *u64, free: *u64, block_size: *u32): u32 {
  if index >= mount_count { return 1 }
  if mount_table[index].mounted == 0 { return 1 }

  // Copy path
  var i: u32 = 0
  while i < mount_table[index].path_len and i < 63 {
    path[i] = mount_table[index].path[i]
    i = i + 1
  }
  path[i] = 0

  // Copy device
  i = 0
  while i < mount_table[index].device_len and i < 31 {
    device[i] = mount_table[index].device[i]
    i = i + 1
  }
  device[i] = 0

  total.* = mount_table[index].total_blocks * mount_table[index].block_size
  free.* = mount_table[index].free_blocks * mount_table[index].block_size
  block_size.* = mount_table[index].block_size

  return 0
}

// ============================================================================
// DIRECTORY READING
// ============================================================================

export struct DirEntryInfo {
  ino: u32,
  file_type: u32,
  size: u64,
  name: [u8; 256]
}

// Read directory entries
// Returns number of entries read, or 0 on error
export fn vfs_readdir(path: u64, entries: *[DirEntryInfo; 256], max_entries: u32): u32 {
  // Find the inode for this path
  var ino: u32 = inode_lookup(path)
  if ino == 0 { return 0 }

  // Check if it's a directory
  var idx: u32 = inode_find(ino)
  if idx >= MAX_INODES { return 0 }
  if inode_table[idx].file_type != FILE_TYPE_DIRECTORY { return 0 }

  // Scan all inodes to find children (simplified - real impl would use directory entries)
  var count: u32 = 0
  var i: u32 = 0

  while i < MAX_INODES and count < max_entries {
    if inode_table[i].ino != 0 and inode_table[i].ino != ino {
      // In a real filesystem, we'd check if this inode is in the directory
      // For now, just return all inodes as a demo
      entries[count].ino = inode_table[i].ino
      entries[count].file_type = inode_table[i].file_type
      entries[count].size = inode_table[i].size

      // Generate a placeholder name
      entries[count].name[0] = 'f'
      entries[count].name[1] = 'i'
      entries[count].name[2] = 'l'
      entries[count].name[3] = 'e'
      entries[count].name[4] = '_'
      entries[count].name[5] = @intCast('0' + (inode_table[i].ino % 10))
      entries[count].name[6] = 0

      count = count + 1
    }
    i = i + 1
  }

  return count
}

// Get file/directory size by path
export fn vfs_get_size(path: u64): u64 {
  var ino: u32 = inode_lookup(path)
  if ino == 0 { return 0 }

  var idx: u32 = inode_find(ino)
  if idx >= MAX_INODES { return 0 }

  return inode_table[idx].size
}

// Get file type by path (1=file, 2=dir, 3=symlink)
export fn vfs_get_type(path: u64): u32 {
  var ino: u32 = inode_lookup(path)
  if ino == 0 { return 0 }

  var idx: u32 = inode_find(ino)
  if idx >= MAX_INODES { return 0 }

  return inode_table[idx].file_type
}

// Get total size of directory tree (recursive)
export fn vfs_get_tree_size(path: u64): u64 {
  var ino: u32 = inode_lookup(path)
  if ino == 0 { return 0 }

  var idx: u32 = inode_find(ino)
  if idx >= MAX_INODES { return 0 }

  var total: u64 = inode_table[idx].size

  // If it's a directory, add child sizes
  if inode_table[idx].file_type == FILE_TYPE_DIRECTORY {
    var entries: [DirEntryInfo; 256]
    var count: u32 = vfs_readdir(path, &entries, 256)

    var i: u32 = 0
    while i < count {
      total = total + entries[i].size
      i = i + 1
    }
  }

  return total
}

// ============================================================================
// INITIALIZATION
// ============================================================================

export fn filesystem_init() {
  if fs_initialized == 1 { return }

  // Clear inode table
  var i: u32 = 0
  while i < MAX_INODES {
    inode_table[i].ino = 0
    i = i + 1
  }

  // Clear open file table
  i = 0
  while i < MAX_OPEN_FILES {
    open_files[i].ref_count = 0
    i = i + 1
  }

  // Create root directory (inode 1)
  var root_ino: u32 = inode_alloc(FILE_TYPE_DIRECTORY, 0o755)

  // Initialize mount table
  init_mount_table()

  fs_initialized = 1
  foundation.serial_write_string("[Filesystem] Initialized\n")
}
