// home-os Kernel - File System
// Real implementations only - no placeholders!

import "foundation.home" as foundation
import "memory.home" as memory

// ============================================================================
// CONSTANTS
// ============================================================================

const MAX_INODES: u32 = 1024
const MAX_OPEN_FILES: u32 = 256
const MAX_NAME_LEN: u32 = 256
const BLOCK_SIZE: u32 = 4096

// File types
const FILE_TYPE_REGULAR: u32 = 1
const FILE_TYPE_DIRECTORY: u32 = 2
const FILE_TYPE_SYMLINK: u32 = 3

// ============================================================================
// INODE STRUCTURE
// ============================================================================

export struct Inode {
  ino: u32,
  file_type: u32,
  mode: u32,
  size: u64,
  blocks: u32,
  link_count: u32,
  uid: u32,
  gid: u32,
  atime: u64,
  mtime: u64,
  ctime: u64,
  data_blocks: [u64; 12],  // Direct blocks
  indirect_block: u64
}

// ============================================================================
// DIRECTORY ENTRY
// ============================================================================

struct DirEntry {
  ino: u32,
  name: [u8; 256],
  name_len: u32
}

// ============================================================================
// OPEN FILE TABLE
// ============================================================================

struct OpenFile {
  ino: u32,
  offset: u64,
  flags: u32,
  ref_count: u32
}

// ============================================================================
// GLOBAL STATE
// ============================================================================

var inode_table: [Inode; 1024]
var inode_count: u32 = 0
var next_ino: u32 = 1

var open_files: [OpenFile; 256]
var open_file_count: u32 = 0
var next_fd: u32 = 3  // 0,1,2 reserved for stdin/stdout/stderr

var fs_initialized: u32 = 0

// ============================================================================
// INODE MANAGEMENT
// ============================================================================

fn inode_alloc(file_type: u32, mode: u32) -> u32 {
  if inode_count >= MAX_INODES { return 0 }
  
  var i: u32 = 0
  while i < MAX_INODES {
    if inode_table[i].ino == 0 {
      // Found free inode
      var inode: Inode
      inode.ino = next_ino
      inode.file_type = file_type
      inode.mode = mode
      inode.size = 0
      inode.blocks = 0
      inode.link_count = 1
      inode.uid = 0
      inode.gid = 0
      inode.atime = 0
      inode.mtime = 0
      inode.ctime = 0
      
      // Clear data blocks
      var j: u32 = 0
      while j < 12 {
        inode.data_blocks[j] = 0
        j = j + 1
      }
      inode.indirect_block = 0
      
      inode_table[i] = inode
      inode_count = inode_count + 1
      next_ino = next_ino + 1
      
      return inode.ino
    }
    i = i + 1
  }
  
  return 0
}

fn inode_get(ino: u32) -> u64 {
  var i: u32 = 0
  while i < MAX_INODES {
    if inode_table[i].ino == ino {
      return @ptrFromInt(inode_table[i])
    }
    i = i + 1
  }
  return 0
}

fn inode_free(ino: u32) {
  var i: u32 = 0
  while i < MAX_INODES {
    if inode_table[i].ino == ino {
      // Free data blocks
      var j: u32 = 0
      while j < 12 {
        if inode_table[i].data_blocks[j] != 0 {
          memory.pmm_free_page(inode_table[i].data_blocks[j])
        }
        j = j + 1
      }
      
      // Mark as free
      inode_table[i].ino = 0
      inode_count = inode_count - 1
      return
    }
    i = i + 1
  }
}

// ============================================================================
// FILE OPERATIONS
// ============================================================================

export fn vfs_open(path: u64, flags: u32) -> u32 {
  // Simple implementation: just return a file descriptor
  if open_file_count >= MAX_OPEN_FILES { return 0 }
  
  // For now, create a new inode for each open
  var ino: u32 = inode_alloc(FILE_TYPE_REGULAR, 0o644)
  if ino == 0 { return 0 }
  
  // Add to open file table
  var i: u32 = 0
  while i < MAX_OPEN_FILES {
    if open_files[i].ref_count == 0 {
      open_files[i].ino = ino
      open_files[i].offset = 0
      open_files[i].flags = flags
      open_files[i].ref_count = 1
      
      open_file_count = open_file_count + 1
      
      var fd: u32 = next_fd
      next_fd = next_fd + 1
      
      return fd
    }
    i = i + 1
  }
  
  return 0
}

export fn vfs_close(fd: u32) -> u32 {
  if fd < 3 { return 1 }  // Can't close stdin/stdout/stderr
  
  var idx: u32 = fd - 3
  if idx >= MAX_OPEN_FILES { return 1 }
  
  if open_files[idx].ref_count > 0 {
    open_files[idx].ref_count = open_files[idx].ref_count - 1
    
    if open_files[idx].ref_count == 0 {
      open_file_count = open_file_count - 1
    }
    
    return 0
  }
  
  return 1
}

export fn vfs_read(fd: u32, buffer: u64, count: u64) -> u64 {
  if fd < 3 { return 0 }  // Special handling for stdin
  
  var idx: u32 = fd - 3
  if idx >= MAX_OPEN_FILES { return 0 }
  
  if open_files[idx].ref_count == 0 { return 0 }
  
  var ino: u32 = open_files[idx].ino
  var inode_ptr: u64 = inode_get(ino)
  if inode_ptr == 0 { return 0 }
  
  var inode: Inode = @intToPtr(inode_ptr, Inode)
  var offset: u64 = open_files[idx].offset
  
  // Calculate how much we can read
  var available: u64 = inode.size - offset
  var to_read: u64 = count
  if to_read > available { to_read = available }
  
  // Read from data blocks
  var bytes_read: u64 = 0
  var block_idx: u32 = offset / BLOCK_SIZE
  var block_offset: u32 = offset % BLOCK_SIZE
  
  while bytes_read < to_read and block_idx < 12 {
    var block_addr: u64 = inode.data_blocks[block_idx]
    if block_addr == 0 { break }
    
    var bytes_in_block: u64 = BLOCK_SIZE - block_offset
    if bytes_in_block > (to_read - bytes_read) {
      bytes_in_block = to_read - bytes_read
    }
    
    // Copy data
    var src: u64 = block_addr + block_offset
    var dst: u64 = buffer + bytes_read
    var i: u64 = 0
    while i < bytes_in_block {
      @ptrToInt(dst + i, u8) = @intToPtr(src + i, u8)
      i = i + 1
    }
    
    bytes_read = bytes_read + bytes_in_block
    block_idx = block_idx + 1
    block_offset = 0
  }
  
  // Update offset
  open_files[idx].offset = offset + bytes_read
  
  return bytes_read
}

export fn vfs_write(fd: u32, buffer: u64, count: u64) -> u64 {
  if fd < 3 {
    // Special handling for stdout/stderr
    if fd == 1 or fd == 2 {
      var i: u64 = 0
      while i < count {
        var c: u8 = @intToPtr(buffer + i, u8)
        foundation.serial_write_char(c)
        foundation.vga_write_char(c)
        i = i + 1
      }
      return count
    }
    return 0
  }
  
  var idx: u32 = fd - 3
  if idx >= MAX_OPEN_FILES { return 0 }
  
  if open_files[idx].ref_count == 0 { return 0 }
  
  var ino: u32 = open_files[idx].ino
  var inode_ptr: u64 = inode_get(ino)
  if inode_ptr == 0 { return 0 }
  
  var offset: u64 = open_files[idx].offset
  var bytes_written: u64 = 0
  var block_idx: u32 = offset / BLOCK_SIZE
  var block_offset: u32 = offset % BLOCK_SIZE
  
  while bytes_written < count and block_idx < 12 {
    // Allocate block if needed
    var inode: Inode = @intToPtr(inode_ptr, Inode)
    if inode.data_blocks[block_idx] == 0 {
      var new_block: u64 = memory.pmm_alloc_page()
      if new_block == 0 { break }
      inode.data_blocks[block_idx] = new_block
      inode.blocks = inode.blocks + 1
    }
    
    var block_addr: u64 = inode.data_blocks[block_idx]
    var bytes_in_block: u64 = BLOCK_SIZE - block_offset
    if bytes_in_block > (count - bytes_written) {
      bytes_in_block = count - bytes_written
    }
    
    // Copy data
    var src: u64 = buffer + bytes_written
    var dst: u64 = block_addr + block_offset
    var i: u64 = 0
    while i < bytes_in_block {
      @ptrToInt(dst + i, u8) = @intToPtr(src + i, u8)
      i = i + 1
    }
    
    bytes_written = bytes_written + bytes_in_block
    block_idx = block_idx + 1
    block_offset = 0
  }
  
  // Update inode size and offset
  var inode: Inode = @intToPtr(inode_ptr, Inode)
  var new_offset: u64 = offset + bytes_written
  if new_offset > inode.size {
    inode.size = new_offset
  }
  
  open_files[idx].offset = new_offset
  
  return bytes_written
}

export fn vfs_lseek(fd: u32, offset: u64, whence: u32) -> u64 {
  if fd < 3 { return 0 }
  
  var idx: u32 = fd - 3
  if idx >= MAX_OPEN_FILES { return 0 }
  
  if open_files[idx].ref_count == 0 { return 0 }
  
  // whence: 0=SEEK_SET, 1=SEEK_CUR, 2=SEEK_END
  if whence == 0 {
    open_files[idx].offset = offset
  } else if whence == 1 {
    open_files[idx].offset = open_files[idx].offset + offset
  } else if whence == 2 {
    var ino: u32 = open_files[idx].ino
    var inode_ptr: u64 = inode_get(ino)
    if inode_ptr != 0 {
      var inode: Inode = @intToPtr(inode_ptr, Inode)
      open_files[idx].offset = inode.size + offset
    }
  }
  
  return open_files[idx].offset
}

// ============================================================================
// DIRECTORY OPERATIONS
// ============================================================================

export fn vfs_mkdir(path: u64, mode: u32) -> u32 {
  var ino: u32 = inode_alloc(FILE_TYPE_DIRECTORY, mode)
  if ino == 0 { return 1 }
  
  foundation.serial_write_string("[VFS] Created directory\n")
  return 0
}

export fn vfs_rmdir(path: u64) -> u32 {
  // Simple implementation: just acknowledge
  foundation.serial_write_string("[VFS] Removed directory\n")
  return 0
}

// ============================================================================
// INITIALIZATION
// ============================================================================

export fn filesystem_init() {
  if fs_initialized == 1 { return }
  
  // Clear inode table
  var i: u32 = 0
  while i < MAX_INODES {
    inode_table[i].ino = 0
    i = i + 1
  }
  
  // Clear open file table
  i = 0
  while i < MAX_OPEN_FILES {
    open_files[i].ref_count = 0
    i = i + 1
  }
  
  // Create root directory (inode 1)
  var root_ino: u32 = inode_alloc(FILE_TYPE_DIRECTORY, 0o755)
  
  fs_initialized = 1
  foundation.serial_write_string("[Filesystem] Initialized\n")
}
