// home-os VFS - Symbolic Links
// Implements symbolic link (symlink) support

import "foundation.home" as foundation
import "memory.home" as memory
import "filesystem.home" as filesystem
import "vfs_permissions.home" as perms

// ============================================================================
// CONSTANTS
// ============================================================================

const MAX_SYMLINK_LEN: u32 = 4096  // Max symlink target path length
const MAX_SYMLINK_DEPTH: u32 = 40  // Prevent infinite loops
const FILE_TYPE_SYMLINK: u32 = 3

// ============================================================================
// SYMLINK CREATION
// ============================================================================

export fn vfs_symlink(target: u64, linkpath: u64, uid: u32, gid: u32): u32 {
  // Create a new inode for the symlink
  var ino: u32 = filesystem.inode_alloc(FILE_TYPE_SYMLINK, 0o777)
  if ino == 0 { return 1 }

  var inode_ptr: u64 = filesystem.inode_get(ino)
  if inode_ptr == 0 {
    filesystem.inode_free(ino)
    return 1
  }

  var inode: *filesystem.Inode = @ptrFromInt(inode_ptr)

  // Set ownership
  inode.uid = uid
  inode.gid = gid

  // Get target path length
  var target_len: u32 = 0
  var target_ptr: *u8 = @ptrFromInt(target)
  while target_ptr[target_len] != 0 and target_len < MAX_SYMLINK_LEN {
    target_len = target_len + 1
  }

  if target_len == 0 or target_len >= MAX_SYMLINK_LEN {
    filesystem.inode_free(ino)
    return 1
  }

  // Store target path in the first data block
  var block: u64 = memory.pmm_alloc_page()
  if block == 0 {
    filesystem.inode_free(ino)
    return 1
  }

  inode.data_blocks[0] = block
  inode.blocks = 1
  inode.size = target_len

  // Copy target path to block
  memory.memcpy(block, target, target_len)

  // Null-terminate
  var block_ptr: *u8 = @ptrFromInt(block)
  block_ptr[target_len] = 0

  foundation.serial_write_string("[VFS] Created symlink: ")
  foundation.serial_write_string(target_ptr)
  foundation.serial_write_string("\n")

  return 0
}

// ============================================================================
// SYMLINK READING
// ============================================================================

export fn vfs_readlink(linkpath: u64, buffer: u64, bufsize: u32): u32 {
  // TODO: Get inode from linkpath
  // For now, just return error
  return 0xFFFFFFFF
}

export fn vfs_readlink_inode(inode: *filesystem.Inode, buffer: u64, bufsize: u32): u32 {
  // Verify it's a symlink
  if inode.file_type != FILE_TYPE_SYMLINK {
    return 0xFFFFFFFF
  }

  // Read target from first data block
  if inode.data_blocks[0] == 0 {
    return 0xFFFFFFFF
  }

  var target_len: u32 = inode.size
  if target_len > bufsize {
    target_len = bufsize - 1
  }

  memory.memcpy(buffer, inode.data_blocks[0], target_len)

  // Null-terminate
  var buffer_ptr: *u8 = @ptrFromInt(buffer)
  buffer_ptr[target_len] = 0

  return target_len
}

// ============================================================================
// SYMLINK FOLLOWING
// ============================================================================

fn follow_symlink_internal(inode: *filesystem.Inode, resolved_path: u64, depth: u32): u32 {
  if depth > MAX_SYMLINK_DEPTH {
    foundation.serial_write_string("[VFS] Symlink loop detected\n")
    return 1  // Too many symlinks (ELOOP)
  }

  if inode.file_type != FILE_TYPE_SYMLINK {
    return 0  // Not a symlink, we're done
  }

  // Read the symlink target
  var target_buffer: [u8; 4096]
  var target_len: u32 = vfs_readlink_inode(inode, @ptrFromInt(&target_buffer), 4096)

  if target_len == 0xFFFFFFFF {
    return 1  // Failed to read symlink
  }

  // Copy target to resolved_path
  memory.memcpy(resolved_path, @ptrFromInt(&target_buffer), target_len)
  var resolved_ptr: *u8 = @ptrFromInt(resolved_path)
  resolved_ptr[target_len] = 0

  // TODO: If target is absolute, use it directly
  // TODO: If target is relative, combine with current directory
  // TODO: Recursively resolve if target is also a symlink

  return 0
}

export fn follow_symlink(linkpath: u64, resolved_path: u64): u32 {
  // TODO: Get inode from linkpath
  // For now, just copy linkpath to resolved_path
  var i: u32 = 0
  var src_ptr: *u8 = @ptrFromInt(linkpath)
  var dst_ptr: *u8 = @ptrFromInt(resolved_path)

  while src_ptr[i] != 0 and i < MAX_SYMLINK_LEN {
    dst_ptr[i] = src_ptr[i]
    i = i + 1
  }
  dst_ptr[i] = 0

  return 0
}

// ============================================================================
// SYMLINK CHECKING
// ============================================================================

export fn is_symlink(inode: *filesystem.Inode): u32 {
  return if inode.file_type == FILE_TYPE_SYMLINK { 1 } else { 0 }
}

// ============================================================================
// SYMLINK UTILITIES
// ============================================================================

export fn vfs_lstat(path: u64, stat_buf: u64): u32 {
  // Like stat() but doesn't follow symlinks
  // TODO: Implement when path resolution is complete
  return 0
}

export fn vfs_realpath(path: u64, resolved: u64): u32 {
  // Resolve all symlinks and return canonical absolute path
  // TODO: Implement full path resolution with symlink following

  var depth: u32 = 0
  var current_path: [u8; 4096]

  // Copy input path
  var i: u32 = 0
  var path_ptr: *u8 = @ptrFromInt(path)
  while path_ptr[i] != 0 and i < 4096 {
    current_path[i] = path_ptr[i]
    i = i + 1
  }
  current_path[i] = 0

  // TODO: For each component in path:
  //   1. Check if it's a symlink
  //   2. If yes, read target and replace
  //   3. Increment depth and check MAX_SYMLINK_DEPTH
  //   4. Continue with next component

  // For now, just copy path to resolved
  memory.memcpy(resolved, @ptrFromInt(&current_path), i)
  var resolved_ptr: *u8 = @ptrFromInt(resolved)
  resolved_ptr[i] = 0

  return 0
}

// ============================================================================
// INITIALIZATION
// ============================================================================

export fn symlinks_init() {
  foundation.serial_write_string("[Symlinks] Initialized (max depth: 40)\n")
}
