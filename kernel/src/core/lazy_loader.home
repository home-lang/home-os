// home-os Lazy Service Loading System
// Defers non-essential service initialization for faster headless boots

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "./driver_init.home" as driver_init

// Service categories
const SERVICE_ESSENTIAL: u32 = 1 << 0      // Required for boot
const SERVICE_NETWORK: u32 = 1 << 1        // Network services
const SERVICE_STORAGE: u32 = 1 << 2        // Storage services
const SERVICE_GUI: u32 = 1 << 3            // GUI services
const SERVICE_AUDIO: u32 = 1 << 4          // Audio services
const SERVICE_INPUT: u32 = 1 << 5          // Input devices
const SERVICE_VIDEO: u32 = 1 << 6          // Video/graphics
const SERVICE_DEBUG: u32 = 1 << 7          // Debug tools

// Service states
const SERVICE_STATE_DEFERRED: u32 = 0
const SERVICE_STATE_LOADING: u32 = 1
const SERVICE_STATE_LOADED: u32 = 2
const SERVICE_STATE_FAILED: u32 = 3

// Service load triggers
const TRIGGER_MANUAL: u32 = 0              // Explicit load request
const TRIGGER_ON_DEMAND: u32 = 1           // First use
const TRIGGER_TIMER: u32 = 2               // After timeout
const TRIGGER_EVENT: u32 = 3               // Specific event

// Service initialization function
type ServiceInitFn = fn(): u32

// Service descriptor
struct ServiceDescriptor {
  name: *u8
  category: u32
  init_fn: ServiceInitFn
  state: u32
  load_trigger: u32
  load_time_us: u64
  priority: u32                            // Load order within category
}

const MAX_SERVICES: u32 = 128

var services: [MAX_SERVICES]ServiceDescriptor
var service_count: u32 = 0
var initialized: u32 = 0

// Configuration: which categories to defer
var defer_categories: u32 = 0

// Statistics
var deferred_count: u32 = 0
var loaded_count: u32 = 0
var failed_count: u32 = 0

// Initialize lazy loader
export fn lazy_loader_init() {
  if initialized == 1 {
    foundation.serial_write_string("[Lazy Loader] Already initialized\n")
    return
  }

  service_count = 0
  defer_categories = 0
  deferred_count = 0
  loaded_count = 0
  failed_count = 0

  initialized = 1

  foundation.serial_write_string("[Lazy Loader] System initialized\n")
}

// Configure which categories to defer
export fn lazy_loader_configure(categories: u32) {
  defer_categories = categories

  foundation.serial_write_string("[Lazy Loader] Deferring categories: 0x")
  foundation.serial_write_u64(categories)
  foundation.serial_write_string("\n")
}

// Register a service for potential lazy loading
export fn lazy_loader_register(
  name: *u8,
  category: u32,
  init_fn: ServiceInitFn,
  load_trigger: u32,
  priority: u32
): u32 {
  if initialized == 0 {
    foundation.serial_write_string("[Lazy Loader] Not initialized\n")
    return 0xFFFFFFFF
  }

  if service_count >= MAX_SERVICES {
    foundation.serial_write_string("[Lazy Loader] Maximum services reached\n")
    return 0xFFFFFFFF
  }

  let service: *ServiceDescriptor = &services[service_count]

  service.name = name
  service.category = category
  service.init_fn = init_fn
  service.state = SERVICE_STATE_DEFERRED
  service.load_trigger = load_trigger
  service.load_time_us = 0
  service.priority = priority

  let id: u32 = service_count
  service_count = service_count + 1

  return id
}

// Check if a service should be deferred
fn should_defer_service(service: *ServiceDescriptor): u32 {
  // Essential services are never deferred
  if (service.category & SERVICE_ESSENTIAL) != 0 {
    return 0
  }

  // Check if category is in defer list
  if (service.category & defer_categories) != 0 {
    return 1
  }

  return 0
}

// Load a single service
fn load_service(service: *ServiceDescriptor): u32 {
  foundation.serial_write_string("[Lazy Loader] Loading ")
  foundation.serial_write_string(service.name)
  foundation.serial_write_string("...")

  service.state = SERVICE_STATE_LOADING

  let start_time: u64 = driver_init.get_timestamp_us()
  let result: u32 = service.init_fn()
  let end_time: u64 = driver_init.get_timestamp_us()

  service.load_time_us = end_time - start_time

  if result == 0 {
    service.state = SERVICE_STATE_LOADED
    loaded_count = loaded_count + 1

    foundation.serial_write_string(" OK (")
    foundation.serial_write_u64(service.load_time_us)
    foundation.serial_write_string(" us)\n")

    return 0
  } else {
    service.state = SERVICE_STATE_FAILED
    failed_count = failed_count + 1

    foundation.serial_write_string(" FAILED\n")

    return 1
  }
}

// Initialize all non-deferred services
export fn lazy_loader_init_essential(): u32 {
  if initialized == 0 { return 1 }

  foundation.serial_write_string("\n[Lazy Loader] Loading essential services\n")

  var i: u32 = 0
  loop {
    if i >= service_count { break }

    let service: *ServiceDescriptor = &services[i]

    if should_defer_service(service) == 0 {
      let result: u32 = load_service(service)
      if result != 0 {
        // Essential service failed - this is fatal
        if (service.category & SERVICE_ESSENTIAL) != 0 {
          foundation.serial_write_string("[Lazy Loader] FATAL: Essential service failed!\n")
          return 1
        }
      }
    } else {
      deferred_count = deferred_count + 1
    }

    i = i + 1
  }

  foundation.serial_write_string("[Lazy Loader] Essential services loaded, ")
  foundation.serial_write_u64(deferred_count)
  foundation.serial_write_string(" services deferred\n\n")

  return 0
}

// Load services by category
export fn lazy_loader_load_category(category: u32): u32 {
  if initialized == 0 { return 1 }

  foundation.serial_write_string("\n[Lazy Loader] Loading category 0x")
  foundation.serial_write_u64(category)
  foundation.serial_write_string(" services\n")

  var loaded_any: u32 = 0

  var i: u32 = 0
  loop {
    if i >= service_count { break }

    let service: *ServiceDescriptor = &services[i]

    // Skip if wrong category
    if (service.category & category) == 0 {
      i = i + 1
      continue
    }

    // Skip if already loaded or failed
    if service.state == SERVICE_STATE_LOADED || service.state == SERVICE_STATE_FAILED {
      i = i + 1
      continue
    }

    load_service(service)
    loaded_any = 1

    i = i + 1
  }

  if loaded_any == 0 {
    foundation.serial_write_string("[Lazy Loader] No services found for category\n")
  }

  return 0
}

// Load a specific service by name
export fn lazy_loader_load_service(name: *u8): u32 {
  if initialized == 0 { return 1 }

  var i: u32 = 0
  loop {
    if i >= service_count { break }

    let service: *ServiceDescriptor = &services[i]

    if service.name == name {
      if service.state == SERVICE_STATE_LOADED {
        foundation.serial_write_string("[Lazy Loader] Already loaded: ")
        foundation.serial_write_string(name)
        foundation.serial_write_string("\n")
        return 0
      }

      return load_service(service)
    }

    i = i + 1
  }

  foundation.serial_write_string("[Lazy Loader] Service not found: ")
  foundation.serial_write_string(name)
  foundation.serial_write_string("\n")

  return 1
}

// Load all remaining deferred services
export fn lazy_loader_load_all_deferred(): u32 {
  if initialized == 0 { return 1 }

  foundation.serial_write_string("\n[Lazy Loader] Loading all deferred services\n")

  var i: u32 = 0
  loop {
    if i >= service_count { break }

    let service: *ServiceDescriptor = &services[i]

    if service.state == SERVICE_STATE_DEFERRED {
      load_service(service)
    }

    i = i + 1
  }

  foundation.serial_write_string("[Lazy Loader] All deferred services processed\n\n")

  return 0
}

// Print lazy loader status
export fn lazy_loader_print_status() {
  if initialized == 0 { return }

  foundation.serial_write_string("\n========== LAZY LOADER STATUS ==========\n\n")

  foundation.serial_write_string("Total services: ")
  foundation.serial_write_u64(service_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("Loaded: ")
  foundation.serial_write_u64(loaded_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("Deferred: ")
  foundation.serial_write_u64(deferred_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("Failed: ")
  foundation.serial_write_u64(failed_count)
  foundation.serial_write_string("\n\n")

  foundation.serial_write_string("Deferred services:\n")

  var i: u32 = 0
  loop {
    if i >= service_count { break }

    let service: *ServiceDescriptor = &services[i]

    if service.state == SERVICE_STATE_DEFERRED {
      foundation.serial_write_string("  - ")
      foundation.serial_write_string(service.name)
      foundation.serial_write_string(" (category: 0x")
      foundation.serial_write_u64(service.category)
      foundation.serial_write_string(")\n")
    }

    i = i + 1
  }

  foundation.serial_write_string("\n========================================\n\n")
}

// Get boot time savings from deferred services
export fn lazy_loader_get_savings_estimate(): u64 {
  if initialized == 0 { return 0 }

  // Estimate: each deferred service saves ~100ms boot time
  return deferred_count * 100000  // microseconds
}

// Preset configuration for headless boot
export fn lazy_loader_configure_headless() {
  lazy_loader_configure(
    SERVICE_GUI | SERVICE_AUDIO | SERVICE_VIDEO
  )

  foundation.serial_write_string("[Lazy Loader] Configured for headless boot\n")
}

// Preset configuration for minimal boot
export fn lazy_loader_configure_minimal() {
  lazy_loader_configure(
    SERVICE_GUI | SERVICE_AUDIO | SERVICE_VIDEO |
    SERVICE_INPUT | SERVICE_DEBUG
  )

  foundation.serial_write_string("[Lazy Loader] Configured for minimal boot\n")
}

// Preset configuration for desktop boot
export fn lazy_loader_configure_desktop() {
  lazy_loader_configure(
    SERVICE_DEBUG  // Only defer debug tools
  )

  foundation.serial_write_string("[Lazy Loader] Configured for desktop boot\n")
}
