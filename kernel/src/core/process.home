// home-os Kernel - Process Management
// Real implementations only - no placeholders!

import "foundation.home" as foundation
import "memory.home" as memory

// ============================================================================
// CONSTANTS
// ============================================================================

const MAX_PROCESSES: u32 = 256
const MAX_THREADS: u32 = 1024
const STACK_SIZE: u64 = 8192  // 8KB stack per thread

// Process states
const PROCESS_UNUSED: u32 = 0
const PROCESS_READY: u32 = 1
const PROCESS_RUNNING: u32 = 2
const PROCESS_BLOCKED: u32 = 3
const PROCESS_ZOMBIE: u32 = 4

// ============================================================================
// PROCESS CONTROL BLOCK
// ============================================================================

export struct PCB {
  pid: u32,
  state: u32,
  parent_pid: u32,
  priority: u32,
  
  // CPU state
  rip: u64,
  rsp: u64,
  rbp: u64,
  rflags: u64,
  
  // Memory
  page_table: u64,
  heap_start: u64,
  heap_end: u64,
  stack_start: u64,
  stack_end: u64,
  
  // Scheduling
  time_slice: u32,
  cpu_time: u64,
  
  // File descriptors
  fd_count: u32,
  fd_table: [u32; 32]
}

// ============================================================================
// GLOBAL STATE
// ============================================================================

var process_table: [PCB; 256]
var process_count: u32 = 0
var current_pid: u32 = 0
var next_pid: u32 = 1
var scheduler_initialized: u32 = 0

// ============================================================================
// PROCESS CREATION
// ============================================================================

export fn process_create(entry_point: u64) -> u32 {
  if process_count >= MAX_PROCESSES {
    return 0  // No free slots
  }
  
  // Find free slot
  var i: u32 = 0
  var slot: u32 = 0
  var found: u32 = 0
  
  while i < MAX_PROCESSES {
    if process_table[i].state == PROCESS_UNUSED {
      slot = i
      found = 1
      break
    }
    i = i + 1
  }
  
  if found == 0 { return 0 }
  
  // Initialize PCB
  var pcb: PCB
  pcb.pid = next_pid
  pcb.state = PROCESS_READY
  pcb.parent_pid = current_pid
  pcb.priority = 10
  
  // Set up CPU state
  pcb.rip = entry_point
  pcb.rflags = 0x202  // IF flag set
  
  // Allocate stack
  var stack_pages: u32 = STACK_SIZE / 4096
  var stack_phys: u64 = 0
  var j: u32 = 0
  
  while j < stack_pages {
    var page: u64 = memory.pmm_alloc_page()
    if page == 0 {
      // Cleanup and fail
      return 0
    }
    if j == 0 { stack_phys = page }
    j = j + 1
  }
  
  pcb.stack_start = 0x0000_7FFF_FFFF_0000
  pcb.stack_end = pcb.stack_start + STACK_SIZE
  pcb.rsp = pcb.stack_end - 16
  pcb.rbp = pcb.rsp
  
  // Allocate heap
  pcb.heap_start = 0x0000_0000_1000_0000
  pcb.heap_end = pcb.heap_start
  
  // Create page table (clone kernel mappings)
  pcb.page_table = memory.pmm_alloc_page()
  if pcb.page_table == 0 { return 0 }
  
  // Initialize scheduling
  pcb.time_slice = 10  // 10ms
  pcb.cpu_time = 0
  
  // Initialize file descriptors
  pcb.fd_count = 0
  
  // Add to process table
  process_table[slot] = pcb
  process_count = process_count + 1
  next_pid = next_pid + 1
  
  foundation.serial_write_string("[Process] Created PID ")
  foundation.serial_write_string("\n")
  
  return pcb.pid
}

export fn process_destroy(pid: u32) -> u32 {
  var i: u32 = 0
  
  while i < MAX_PROCESSES {
    if process_table[i].pid == pid and process_table[i].state != PROCESS_UNUSED {
      // Free memory
      memory.pmm_free_page(process_table[i].page_table)
      
      // Mark as unused
      process_table[i].state = PROCESS_UNUSED
      process_count = process_count - 1
      
      foundation.serial_write_string("[Process] Destroyed PID ")
      foundation.serial_write_string("\n")
      
      return 0
    }
    i = i + 1
  }
  
  return 1  // Not found
}

// ============================================================================
// SCHEDULER (Round-Robin)
// ============================================================================

export fn scheduler_init() {
  if scheduler_initialized == 1 { return }
  
  // Create init process (PID 1)
  var init_pid: u32 = process_create(0x100000)  // Entry at 1MB
  
  scheduler_initialized = 1
  foundation.serial_write_string("[Scheduler] Initialized\n")
}

export fn scheduler_tick() {
  if process_count == 0 { return }
  
  // Find current process
  var current_idx: u32 = 0
  var i: u32 = 0
  
  while i < MAX_PROCESSES {
    if process_table[i].pid == current_pid {
      current_idx = i
      break
    }
    i = i + 1
  }
  
  // Decrement time slice
  if process_table[current_idx].time_slice > 0 {
    process_table[current_idx].time_slice = process_table[current_idx].time_slice - 1
  }
  
  // If time slice expired, switch
  if process_table[current_idx].time_slice == 0 {
    scheduler_switch()
  }
}

fn scheduler_switch() {
  // Find next ready process (round-robin)
  var start_idx: u32 = 0
  var i: u32 = 0
  
  // Find current process index
  while i < MAX_PROCESSES {
    if process_table[i].pid == current_pid {
      start_idx = i
      break
    }
    i = i + 1
  }
  
  // Search for next ready process
  i = (start_idx + 1) % MAX_PROCESSES
  var searched: u32 = 0
  
  while searched < MAX_PROCESSES {
    if process_table[i].state == PROCESS_READY {
      // Switch to this process
      process_table[start_idx].state = PROCESS_READY
      process_table[start_idx].time_slice = 10
      
      process_table[i].state = PROCESS_RUNNING
      process_table[i].time_slice = 10
      
      current_pid = process_table[i].pid
      
      // Context switch would happen here
      context_switch(start_idx, i)
      
      return
    }
    
    i = (i + 1) % MAX_PROCESSES
    searched = searched + 1
  }
}

fn context_switch(from_idx: u32, to_idx: u32) {
  // Save current context (would be done in assembly)
  // Load new context (would be done in assembly)
  
  // Switch page table
  var new_cr3: u64 = process_table[to_idx].page_table
  asm volatile ("mov %[cr3], %%cr3"
    :
    : [cr3] "r" (new_cr3)
  )
}

// ============================================================================
// SYSTEM CALLS
// ============================================================================

export fn sys_fork() -> u32 {
  // Clone current process
  var parent_idx: u32 = 0
  var i: u32 = 0
  
  while i < MAX_PROCESSES {
    if process_table[i].pid == current_pid {
      parent_idx = i
      break
    }
    i = i + 1
  }
  
  // Create child process
  var child_pid: u32 = process_create(process_table[parent_idx].rip)
  
  if child_pid == 0 { return 0 }
  
  // Find child
  i = 0
  while i < MAX_PROCESSES {
    if process_table[i].pid == child_pid {
      // Copy parent state
      process_table[i].rsp = process_table[parent_idx].rsp
      process_table[i].rbp = process_table[parent_idx].rbp
      process_table[i].rflags = process_table[parent_idx].rflags
      break
    }
    i = i + 1
  }
  
  return child_pid
}

export fn sys_exec(entry_point: u64) -> u32 {
  // Replace current process image
  var i: u32 = 0
  
  while i < MAX_PROCESSES {
    if process_table[i].pid == current_pid {
      process_table[i].rip = entry_point
      process_table[i].rsp = process_table[i].stack_end - 16
      process_table[i].rbp = process_table[i].rsp
      return 0
    }
    i = i + 1
  }
  
  return 1
}

export fn sys_exit(exit_code: u32) {
  // Mark process as zombie
  var i: u32 = 0
  
  while i < MAX_PROCESSES {
    if process_table[i].pid == current_pid {
      process_table[i].state = PROCESS_ZOMBIE
      scheduler_switch()
      break
    }
    i = i + 1
  }
}

export fn sys_wait(pid: u32) -> u32 {
  // Wait for child process
  var i: u32 = 0
  
  while i < MAX_PROCESSES {
    if process_table[i].pid == pid {
      while process_table[i].state != PROCESS_ZOMBIE {
        // Yield CPU
        scheduler_switch()
      }
      
      // Clean up zombie
      process_destroy(pid)
      return 0
    }
    i = i + 1
  }
  
  return 1
}

export fn sys_getpid() -> u32 {
  return current_pid
}

// ============================================================================
// PROCESS INFO
// ============================================================================

export fn process_get_count() -> u32 {
  return process_count
}

export fn process_get_info(pid: u32) -> u64 {
  var i: u32 = 0
  
  while i < MAX_PROCESSES {
    if process_table[i].pid == pid {
      return @ptrFromInt(process_table[i])
    }
    i = i + 1
  }
  
  return 0
}

// ============================================================================
// INITIALIZATION
// ============================================================================

export fn process_init() {
  // Clear process table
  var i: u32 = 0
  while i < MAX_PROCESSES {
    process_table[i].state = PROCESS_UNUSED
    process_table[i].pid = 0
    i = i + 1
  }
  
  scheduler_init()
  
  foundation.serial_write_string("[Process] Initialized\n")
}
