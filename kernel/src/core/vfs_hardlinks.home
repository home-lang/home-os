// home-os VFS - Hard Links
// Implements hard link support (multiple directory entries pointing to same inode)

import "foundation.home" as foundation
import "memory.home" as memory
import "filesystem.home" as filesystem
import "vfs_permissions.home" as perms

// ============================================================================
// CONSTANTS
// ============================================================================

const MAX_LINKS: u32 = 1000  // Maximum hard links to a single inode

// ============================================================================
// HARD LINK CREATION
// ============================================================================

export fn vfs_link(oldpath: u64, newpath: u64, uid: u32, gid: u32): u32 {
  // Get the inode for oldpath using path resolution
  var old_ino: u32 = filesystem.inode_lookup(oldpath)

  if old_ino == 0 {
    foundation.serial_write_string("[VFS] Hard link source not found\n")
    return 1  // ENOENT
  }

  var inode_ptr: u64 = filesystem.inode_get(old_ino)
  if inode_ptr == 0 {
    return 1
  }

  var inode: *filesystem.Inode = @ptrFromInt(inode_ptr)

  // Cannot hard link directories (would create cycles)
  if inode.file_type == 2 {  // FILE_TYPE_DIRECTORY
    foundation.serial_write_string("[VFS] Cannot hard link directories\n")
    return 1  // EPERM
  }

  // Cannot hard link symbolic links (in many systems)
  if inode.file_type == 3 {  // FILE_TYPE_SYMLINK
    foundation.serial_write_string("[VFS] Cannot hard link symbolic links\n")
    return 1  // EPERM
  }

  // Check permission to link (need read access to original file)
  if perms.can_read(inode, uid, gid) == 0 {
    foundation.serial_write_string("[VFS] Permission denied for hard link\n")
    return 1  // EACCES
  }

  // Check link count limit
  if inode.link_count >= MAX_LINKS {
    foundation.serial_write_string("[VFS] Too many links\n")
    return 1  // EMLINK
  }

  // Parse newpath to get parent directory and filename
  var newpath_ptr: *u8 = @ptrFromInt(newpath)

  // Find parent directory and filename
  var parent_path: [u8; 4096]
  var filename: [u8; 256]
  var filename_len: u32 = 0

  // Find last slash to separate parent from filename
  var last_slash: u32 = 0
  var path_len: u32 = 0
  while newpath_ptr[path_len] != 0 and path_len < 4095 {
    if newpath_ptr[path_len] == '/' {
      last_slash = path_len
    }
    parent_path[path_len] = newpath_ptr[path_len]
    path_len = path_len + 1
  }

  // Extract filename
  var i: u32 = last_slash + 1
  while i < path_len and filename_len < 255 {
    filename[filename_len] = newpath_ptr[i]
    filename_len = filename_len + 1
    i = i + 1
  }
  filename[filename_len] = 0

  // Truncate parent path at last slash
  if last_slash > 0 {
    parent_path[last_slash] = 0
  } else {
    parent_path[0] = '/'
    parent_path[1] = 0
  }

  // Get parent directory inode
  var parent_ino: u32 = filesystem.inode_lookup(@intFromPtr(&parent_path))
  if parent_ino == 0 {
    foundation.serial_write_string("[VFS] Parent directory not found\n")
    return 1  // ENOENT
  }

  // Check write permission on parent directory
  var parent_ptr: u64 = filesystem.inode_get(parent_ino)
  if parent_ptr == 0 {
    return 1
  }
  var parent_inode: *filesystem.Inode = @ptrFromInt(parent_ptr)

  if perms.can_write(parent_inode, uid, gid) == 0 {
    foundation.serial_write_string("[VFS] Permission denied for parent directory\n")
    return 1  // EACCES
  }

  // Create directory entry pointing to the same inode
  var result: u32 = filesystem.dir_add_entry(parent_ino, &filename, filename_len, old_ino)
  if result != 0 {
    foundation.serial_write_string("[VFS] Failed to create directory entry\n")
    return 1
  }

  // Increment link count
  inode.link_count = inode.link_count + 1

  foundation.serial_write_string("[VFS] Created hard link (links: ")
  foundation.serial_write_u32(inode.link_count)
  foundation.serial_write_string(")\n")

  return 0
}

// ============================================================================
// HARD LINK REMOVAL
// ============================================================================

export fn vfs_unlink_hardlink(ino: u32): u32 {
  var inode_ptr: u64 = filesystem.inode_get(ino)
  if inode_ptr == 0 {
    return 1
  }

  var inode: *filesystem.Inode = @ptrFromInt(inode_ptr)

  // Decrement link count
  if inode.link_count > 0 {
    inode.link_count = inode.link_count - 1
  }

  foundation.serial_write_string("[VFS] Removed hard link (remaining: ")
  foundation.serial_write_u32(inode.link_count)
  foundation.serial_write_string(")\n")

  // If link count reaches 0, actually delete the inode and data
  if inode.link_count == 0 {
    foundation.serial_write_string("[VFS] No more links, freeing inode\n")
    filesystem.inode_free(ino)
    return 0
  }

  // Otherwise, just removed one link
  return 0
}

// ============================================================================
// LINK COUNT MANAGEMENT
// ============================================================================

export fn get_link_count(ino: u32): u32 {
  var inode_ptr: u64 = filesystem.inode_get(ino)
  if inode_ptr == 0 {
    return 0
  }

  var inode: *filesystem.Inode = @ptrFromInt(inode_ptr)
  return inode.link_count
}

export fn increment_link_count(ino: u32): u32 {
  var inode_ptr: u64 = filesystem.inode_get(ino)
  if inode_ptr == 0 {
    return 1
  }

  var inode: *filesystem.Inode = @ptrFromInt(inode_ptr)

  if inode.link_count >= MAX_LINKS {
    return 1  // Too many links
  }

  inode.link_count = inode.link_count + 1
  return 0
}

export fn decrement_link_count(ino: u32): u32 {
  var inode_ptr: u64 = filesystem.inode_get(ino)
  if inode_ptr == 0 {
    return 1
  }

  var inode: *filesystem.Inode = @ptrFromInt(inode_ptr)

  if inode.link_count > 0 {
    inode.link_count = inode.link_count - 1
  }

  // Return 1 if this was the last link
  return if inode.link_count == 0 { 1 } else { 0 }
}

// ============================================================================
// HARD LINK UTILITIES
// ============================================================================

export fn can_create_hardlink(inode: *filesystem.Inode): u32 {
  // Cannot hard link directories
  if inode.file_type == 2 {
    return 0
  }

  // Cannot hard link symlinks (in many systems)
  if inode.file_type == 3 {
    return 0
  }

  // Check link count limit
  if inode.link_count >= MAX_LINKS {
    return 0
  }

  return 1
}

export fn is_last_link(ino: u32): u32 {
  var inode_ptr: u64 = filesystem.inode_get(ino)
  if inode_ptr == 0 {
    return 1
  }

  var inode: *filesystem.Inode = @ptrFromInt(inode_ptr)
  return if inode.link_count <= 1 { 1 } else { 0 }
}

// ============================================================================
// STATISTICS
// ============================================================================

struct HardLinkStats {
  total_hardlinks: u64,
  max_links_per_file: u32,
  files_with_multiple_links: u32
}

var hardlink_stats: HardLinkStats

export fn hardlink_get_stats(): HardLinkStats {
  return hardlink_stats
}

export fn hardlink_update_stats() {
  hardlink_stats.total_hardlinks = 0
  hardlink_stats.max_links_per_file = 0
  hardlink_stats.files_with_multiple_links = 0

  // Scan all inodes
  var i: u32 = 0
  while i < 1024 {  // MAX_INODES
    var inode_ptr: u64 = filesystem.inode_get(i)
    if inode_ptr != 0 {
      var inode: *filesystem.Inode = @ptrFromInt(inode_ptr)
      if inode.ino != 0 and inode.file_type == 1 {  // Regular file
        hardlink_stats.total_hardlinks = hardlink_stats.total_hardlinks + inode.link_count

        if inode.link_count > hardlink_stats.max_links_per_file {
          hardlink_stats.max_links_per_file = inode.link_count
        }

        if inode.link_count > 1 {
          hardlink_stats.files_with_multiple_links = hardlink_stats.files_with_multiple_links + 1
        }
      }
    }
    i = i + 1
  }
}

export fn hardlink_print_stats() {
  hardlink_update_stats()

  foundation.serial_write_string("[Hard Link Stats]\n")
  foundation.serial_write_string("  Total hard links: ")
  foundation.serial_write_u64(hardlink_stats.total_hardlinks)
  foundation.serial_write_string("\n  Max links per file: ")
  foundation.serial_write_u32(hardlink_stats.max_links_per_file)
  foundation.serial_write_string("\n  Files with multiple links: ")
  foundation.serial_write_u32(hardlink_stats.files_with_multiple_links)
  foundation.serial_write_string("\n")
}

// ============================================================================
// INITIALIZATION
// ============================================================================

export fn hardlinks_init() {
  hardlink_stats.total_hardlinks = 0
  hardlink_stats.max_links_per_file = 0
  hardlink_stats.files_with_multiple_links = 0

  foundation.serial_write_string("[Hard Links] Initialized (max 1000 links per file)\n")
}
