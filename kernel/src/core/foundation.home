// home-os Kernel - Phase 1: Foundation
// Real implementations only - no placeholders!

// ============================================================================
// CONSTANTS
// ============================================================================

export const MULTIBOOT2_MAGIC: u32 = 0x36d76289
export const COM1_PORT: u16 = 0x3F8
export const VGA_BUFFER: u64 = 0xB8000
export const PAGE_SIZE: u64 = 4096

// ============================================================================
// CPU OPERATIONS (Real inline assembly)
// ============================================================================

export fn cli() {
  asm volatile ("cli")
}

export fn sti() {
  asm volatile ("sti")
}

export fn hlt() {
  asm volatile ("hlt")
}

export fn outb(port: u16, value: u8) {
  asm volatile ("outb %[value], %[port]"
    :
    : [port] "{dx}" (port),
      [value] "{al}" (value)
  )
}

export fn inb(port: u16) -> u8 {
  var result: u8
  asm volatile ("inb %[port], %[result]"
    : [result] "={al}" (result)
    : [port] "{dx}" (port)
  )
  return result
}

export fn cpuid(leaf: u32) -> u32 {
  var eax: u32
  asm volatile ("cpuid"
    : "={eax}" (eax)
    : "{eax}" (leaf)
    : "ebx", "ecx", "edx"
  )
  return eax
}

export fn rdtsc() -> u64 {
  var low: u32
  var high: u32
  asm volatile ("rdtsc"
    : "={eax}" (low), "={edx}" (high)
  )
  return (high << 32) | low
}

// ============================================================================
// SERIAL PORT (Real implementation)
// ============================================================================

var serial_initialized: u32 = 0

export fn serial_init() {
  if serial_initialized == 1 { return }
  
  // Disable interrupts
  outb(COM1_PORT + 1, 0x00)
  
  // Set baud rate divisor (115200 baud)
  outb(COM1_PORT + 3, 0x80)  // Enable DLAB
  outb(COM1_PORT + 0, 0x01)  // Divisor low byte
  outb(COM1_PORT + 1, 0x00)  // Divisor high byte
  
  // 8 bits, no parity, one stop bit
  outb(COM1_PORT + 3, 0x03)
  
  // Enable FIFO, clear, 14-byte threshold
  outb(COM1_PORT + 2, 0xC7)
  
  // Enable IRQs, set RTS/DSR
  outb(COM1_PORT + 4, 0x0B)
  
  serial_initialized = 1
}

fn serial_transmit_ready() -> u32 {
  return (inb(COM1_PORT + 5) & 0x20) != 0
}

export fn serial_write_char(c: u8) {
  while serial_transmit_ready() == 0 {}
  outb(COM1_PORT, c)
}

export fn serial_write_string(s: u64) {
  var i: u32 = 0
  var ptr: u64 = s
  
  while i < 1024 {
    var c: u8 = @intToPtr(ptr, u8)
    if c == 0 { break }
    serial_write_char(c)
    ptr = ptr + 1
    i = i + 1
  }
}

// ============================================================================
// VGA TEXT MODE (Real implementation)
// ============================================================================

var vga_row: u32 = 0
var vga_col: u32 = 0
const VGA_WIDTH: u32 = 80
const VGA_HEIGHT: u32 = 25
const VGA_COLOR: u8 = 0x0F  // White on black

export fn vga_clear() {
  var i: u32 = 0
  while i < VGA_WIDTH * VGA_HEIGHT {
    var offset: u64 = VGA_BUFFER + (i * 2)
    @ptrToInt(offset, u8) = 32  // Space character
    @ptrToInt(offset + 1, u8) = VGA_COLOR
    i = i + 1
  }
  vga_row = 0
  vga_col = 0
}

export fn vga_write_char(c: u8) {
  if c == 10 {  // Newline
    vga_row = vga_row + 1
    vga_col = 0
    if vga_row >= VGA_HEIGHT {
      vga_scroll()
      vga_row = VGA_HEIGHT - 1
    }
    return
  }
  
  if vga_col >= VGA_WIDTH {
    vga_row = vga_row + 1
    vga_col = 0
    if vga_row >= VGA_HEIGHT {
      vga_scroll()
      vga_row = VGA_HEIGHT - 1
    }
  }
  
  var offset: u64 = VGA_BUFFER + ((vga_row * VGA_WIDTH + vga_col) * 2)
  @ptrToInt(offset, u8) = c
  @ptrToInt(offset + 1, u8) = VGA_COLOR
  vga_col = vga_col + 1
}

export fn vga_write_string(s: u64) {
  var i: u32 = 0
  var ptr: u64 = s
  
  while i < 1024 {
    var c: u8 = @intToPtr(ptr, u8)
    if c == 0 { break }
    vga_write_char(c)
    ptr = ptr + 1
    i = i + 1
  }
}

fn vga_scroll() {
  // Copy each line up one row
  var row: u32 = 1
  while row < VGA_HEIGHT {
    var col: u32 = 0
    while col < VGA_WIDTH {
      var src: u64 = VGA_BUFFER + ((row * VGA_WIDTH + col) * 2)
      var dst: u64 = VGA_BUFFER + (((row - 1) * VGA_WIDTH + col) * 2)
      @ptrToInt(dst, u8) = @intToPtr(src, u8)
      @ptrToInt(dst + 1, u8) = @intToPtr(src + 1, u8)
      col = col + 1
    }
    row = row + 1
  }
  
  // Clear last line
  var col: u32 = 0
  while col < VGA_WIDTH {
    var offset: u64 = VGA_BUFFER + (((VGA_HEIGHT - 1) * VGA_WIDTH + col) * 2)
    @ptrToInt(offset, u8) = 32
    @ptrToInt(offset + 1, u8) = VGA_COLOR
    col = col + 1
  }
}

// ============================================================================
// GDT (Real implementation)
// ============================================================================

struct GDTEntry {
  limit_low: u16,
  base_low: u16,
  base_middle: u8,
  access: u8,
  granularity: u8,
  base_high: u8
}

struct GDTPointer {
  limit: u16,
  base: u64
}

var gdt: [5]GDTEntry
var gdt_ptr: GDTPointer

export fn gdt_init() {
  // Null descriptor
  gdt[0].limit_low = 0
  gdt[0].base_low = 0
  gdt[0].base_middle = 0
  gdt[0].access = 0
  gdt[0].granularity = 0
  gdt[0].base_high = 0
  
  // Kernel code segment
  gdt[1].limit_low = 0xFFFF
  gdt[1].base_low = 0
  gdt[1].base_middle = 0
  gdt[1].access = 0x9A
  gdt[1].granularity = 0xCF
  gdt[1].base_high = 0
  
  // Kernel data segment
  gdt[2].limit_low = 0xFFFF
  gdt[2].base_low = 0
  gdt[2].base_middle = 0
  gdt[2].access = 0x92
  gdt[2].granularity = 0xCF
  gdt[2].base_high = 0
  
  // User code segment
  gdt[3].limit_low = 0xFFFF
  gdt[3].base_low = 0
  gdt[3].base_middle = 0
  gdt[3].access = 0xFA
  gdt[3].granularity = 0xCF
  gdt[3].base_high = 0
  
  // User data segment
  gdt[4].limit_low = 0xFFFF
  gdt[4].base_low = 0
  gdt[4].base_middle = 0
  gdt[4].access = 0xF2
  gdt[4].granularity = 0xCF
  gdt[4].base_high = 0
  
  // Load GDT
  gdt_ptr.limit = (@sizeOf(GDTEntry) * 5) - 1
  gdt_ptr.base = @ptrFromInt(gdt)
  
  asm volatile ("lgdt (%[gdt_ptr])"
    :
    : [gdt_ptr] "r" (@ptrFromInt(gdt_ptr))
  )
}

// ============================================================================
// INITIALIZATION
// ============================================================================

export fn foundation_init() {
  serial_init()
  vga_clear()
  gdt_init()
  
  serial_write_string("[Foundation] Initialized\n")
  vga_write_string("Foundation OK\n")
}
