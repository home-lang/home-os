// Enhanced Home OS Kernel - Demonstrating Phase A Features
// Features: inline assembly, function calls, return statements, if/else
//
// This kernel demonstrates all Priority 1 compiler features working together

// ============================================================================
// Hardware Interaction Functions
// ============================================================================

// Disable CPU interrupts
fn disable_interrupts() {
  asm("cli")
}

// Enable CPU interrupts
fn enable_interrupts() {
  asm("sti")
}

// Halt the CPU
fn halt_cpu() {
  asm("hlt")
}

// Write a byte to an I/O port
fn outb(port: u16, value: u8) {
  // For now, just use comments to document the intended assembly
  // Full implementation would require register manipulation
  asm("# outb - write byte to port")
}

// Read a byte from an I/O port
fn inb(port: u16) -> u8 {
  // Full implementation would require register manipulation
  asm("# inb - read byte from port")
  return 0
}

// ============================================================================
// Utility Functions
// ============================================================================

// Check if a value is zero
fn is_zero(value: u32) -> u32 {
  if value == 0 {
    return 1  // true
  } else {
    return 0  // false
  }
}

// Get the maximum of two numbers
fn max(a: u32, b: u32) -> u32 {
  if a > b {
    return a
  } else {
    return b
  }
}

// Add two numbers
fn add(a: u32, b: u32) -> u32 {
  // Placeholder - would need actual arithmetic support
  return 42
}

// Multiply by 2 (simple shift operation concept)
fn double(value: u32) -> u32 {
  // Placeholder - would need bitwise shift support
  return value
}

// ============================================================================
// Kernel Initialization Functions
// ============================================================================

// Initialize VGA text mode
fn init_vga() {
  // VGA buffer is at 0xB8000
  // Would write characters to video memory
  asm("# init_vga - setup video memory")
}

// Initialize serial port for debugging
fn init_serial() {
  // COM1 port is at 0x3F8
  // Would configure serial port registers
  asm("# init_serial - configure COM1")
}

// Initialize interrupt descriptor table
fn init_idt() {
  // Would set up exception handlers
  asm("# init_idt - setup interrupt handlers")
}

// Initialize memory management
fn init_memory() {
  // Would set up page tables and heap
  asm("# init_memory - setup paging")
}

// ============================================================================
// Main Kernel Entry Point
// ============================================================================

export fn kernel_main(magic: u32, boot_info: u32) -> never {
  // Disable interrupts during initialization
  disable_interrupts()

  // Check if we were booted by a multiboot2 compliant bootloader
  let is_multiboot: u32 = is_zero(magic)

  if is_multiboot == 0 {
    // Valid multiboot magic number - continue initialization

    // Initialize hardware subsystems
    init_vga()
    init_serial()
    init_idt()
    init_memory()

    // Do some computations to test function calls and returns
    let x: u32 = add(10, 20)
    let y: u32 = double(x)
    let z: u32 = max(x, y)

  } else {
    // Invalid boot - halt immediately
    halt_cpu()
  }

  // Kernel initialization complete - enable interrupts
  enable_interrupts()

  // Infinite idle loop - kernel stays alive
  loop {
    // Wait for interrupts
    halt_cpu()
  }
}
