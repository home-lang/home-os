// HomeOS Craft GPU Integration
// Bridge between HomeOS graphics subsystem and Craft's GPU acceleration

const basics = @import("basics")
const gpu = @import("drivers/gpu")
const pci = @import("drivers/pci")

// ============================================
// Craft GPU Backend Types
// ============================================

const CRAFT_BACKEND_AUTO: u8 = 0
const CRAFT_BACKEND_METAL: u8 = 1      // macOS
const CRAFT_BACKEND_VULKAN: u8 = 2     // Linux/Windows
const CRAFT_BACKEND_OPENGL: u8 = 3     // Fallback
const CRAFT_BACKEND_SOFTWARE: u8 = 4   // No acceleration

// ============================================
// Power Preference
// ============================================

const POWER_DEFAULT: u8 = 0
const POWER_LOW: u8 = 1           // Prefer integrated GPU
const POWER_HIGH_PERFORMANCE: u8 = 2  // Prefer discrete GPU

// ============================================
// Craft GPU Configuration
// ============================================

struct CraftGPUConfig {
    backend: u8
    vsync: bool
    max_fps: u32            // 0 = unlimited
    hardware_decode: bool
    canvas_acceleration: bool
    webgl_enabled: bool
    webgl2_enabled: bool
    power_preference: u8
}

// ============================================
// Craft GPU Info
// ============================================

struct CraftGPUInfo {
    vendor: [64]u8
    renderer: [64]u8
    version: [32]u8
    backend: u8
    memory_mb: u64
    discrete: bool

    // Extended info
    max_texture_size: u32
    max_render_targets: u8
    supports_compute: bool
    supports_raytracing: bool
    driver_version: u32
}

// ============================================
// Shader Types
// ============================================

const SHADER_VERTEX: u8 = 0
const SHADER_FRAGMENT: u8 = 1
const SHADER_COMPUTE: u8 = 2
const SHADER_GEOMETRY: u8 = 3

struct CraftShader {
    shader_type: u8
    handle: u64
    compiled: bool
    source: *const u8
    source_len: u32
    entry_point: [64]u8
}

// ============================================
// Render Pass
// ============================================

struct CraftRenderPass {
    handle: u64
    color_attachments: [8]u64
    depth_attachment: u64
    stencil_attachment: u64
    clear_color: [4]f32
    clear_depth: f32
    clear_stencil: u8
}

// ============================================
// Pipeline State
// ============================================

struct CraftPipelineState {
    handle: u64
    vertex_shader: *CraftShader
    fragment_shader: *CraftShader
    compute_shader: *CraftShader

    // Blend state
    blend_enabled: bool
    src_blend: u8
    dst_blend: u8
    blend_op: u8

    // Depth state
    depth_test: bool
    depth_write: bool
    depth_func: u8

    // Rasterizer state
    cull_mode: u8
    fill_mode: u8
    front_face: u8
}

// ============================================
// Buffer Types
// ============================================

const BUFFER_VERTEX: u8 = 0
const BUFFER_INDEX: u8 = 1
const BUFFER_UNIFORM: u8 = 2
const BUFFER_STORAGE: u8 = 3

struct CraftBuffer {
    buffer_type: u8
    handle: u64
    size: u64
    mapped: bool
    data: *u8
}

// ============================================
// Texture
// ============================================

const TEXTURE_2D: u8 = 0
const TEXTURE_CUBE: u8 = 1
const TEXTURE_3D: u8 = 2
const TEXTURE_ARRAY: u8 = 3

const FORMAT_RGBA8: u8 = 0
const FORMAT_BGRA8: u8 = 1
const FORMAT_RGB10A2: u8 = 2
const FORMAT_RG16F: u8 = 3
const FORMAT_RGBA16F: u8 = 4
const FORMAT_RGBA32F: u8 = 5
const FORMAT_DEPTH24: u8 = 6
const FORMAT_DEPTH32F: u8 = 7
const FORMAT_DEPTH24_STENCIL8: u8 = 8

struct CraftTexture {
    texture_type: u8
    format: u8
    handle: u64
    width: u32
    height: u32
    depth: u32
    mip_levels: u8
    samples: u8
}

// ============================================
// Sampler
// ============================================

const FILTER_NEAREST: u8 = 0
const FILTER_LINEAR: u8 = 1
const FILTER_CUBIC: u8 = 2

const WRAP_REPEAT: u8 = 0
const WRAP_CLAMP: u8 = 1
const WRAP_MIRROR: u8 = 2

struct CraftSampler {
    handle: u64
    min_filter: u8
    mag_filter: u8
    mip_filter: u8
    wrap_u: u8
    wrap_v: u8
    wrap_w: u8
    max_anisotropy: u8
}

// ============================================
// Command Buffer
// ============================================

struct CraftCommandBuffer {
    handle: u64
    recording: bool
    submitted: bool
}

// ============================================
// Craft GPU State
// ============================================

struct CraftGPU {
    config: CraftGPUConfig
    info: CraftGPUInfo
    initialized: bool

    // Active state
    current_pass: *CraftRenderPass
    current_pipeline: *CraftPipelineState

    // Statistics
    draw_calls: u64
    triangles: u64
    fps: f32
    frame_time_ms: f32

    // Frame tracking
    frame_number: u64
    last_frame_time: u64
}

// ============================================
// Global State
// ============================================

var craft_gpu: CraftGPU = undefined
var gpu_initialized: bool = false

// ============================================
// Initialization
// ============================================

export fn craft_gpu_init(config: *CraftGPUConfig): bool {
    if gpu_initialized {
        return true
    }

    basics.print("[CRAFT_GPU] Initializing Craft GPU integration\n")

    craft_gpu.config = *config
    craft_gpu.initialized = false
    craft_gpu.current_pass = null
    craft_gpu.current_pipeline = null
    craft_gpu.draw_calls = 0
    craft_gpu.triangles = 0
    craft_gpu.fps = 0
    craft_gpu.frame_time_ms = 0
    craft_gpu.frame_number = 0
    craft_gpu.last_frame_time = 0

    // Detect best backend
    let backend = detect_backend()
    if backend == CRAFT_BACKEND_SOFTWARE {
        basics.print("[CRAFT_GPU] Warning: No hardware acceleration available\n")
    }

    craft_gpu.config.backend = backend

    // Query GPU info
    query_gpu_info(&craft_gpu.info)

    craft_gpu.initialized = true
    gpu_initialized = true

    basics.print("[CRAFT_GPU] Initialized with backend: ")
    basics.print(get_backend_name(backend))
    basics.print("\n")

    return true
}

export fn craft_gpu_deinit(): void {
    if not gpu_initialized {
        return
    }

    // Cleanup resources
    gpu_initialized = false
    craft_gpu.initialized = false

    basics.print("[CRAFT_GPU] Shutdown complete\n")
}

fn detect_backend(): u8 {
    if craft_gpu.config.backend != CRAFT_BACKEND_AUTO {
        return craft_gpu.config.backend
    }

    // Check for Vulkan support first (preferred on most platforms)
    if check_vulkan_support() {
        return CRAFT_BACKEND_VULKAN
    }

    // Check for Metal (macOS/iOS)
    if check_metal_support() {
        return CRAFT_BACKEND_METAL
    }

    // Fall back to OpenGL
    if check_opengl_support() {
        return CRAFT_BACKEND_OPENGL
    }

    return CRAFT_BACKEND_SOFTWARE
}

fn check_vulkan_support(): bool {
    // Check for Vulkan-capable GPU via PCI
    // Look for compatible graphics cards
    var dev = pci.find_device_by_class(0x03, 0x00)  // VGA controller
    if dev != null {
        // Check if driver supports Vulkan
        return true
    }
    return false
}

fn check_metal_support(): bool {
    // Metal is macOS only - check if we're running on Apple silicon
    // or Intel Mac with Metal support
    return false  // HomeOS doesn't run on macOS
}

fn check_opengl_support(): bool {
    // Almost all GPUs support OpenGL
    var dev = pci.find_device_by_class(0x03, 0x00)
    return dev != null
}

fn query_gpu_info(info: *CraftGPUInfo): void {
    // Find GPU
    var dev = pci.find_device_by_class(0x03, 0x00)

    if dev == null {
        basics.memcpy(&info.vendor, "Unknown", 8)
        basics.memcpy(&info.renderer, "Software Renderer", 17)
        basics.memcpy(&info.version, "1.0", 4)
        info.backend = CRAFT_BACKEND_SOFTWARE
        info.memory_mb = 0
        info.discrete = false
        info.max_texture_size = 4096
        info.max_render_targets = 4
        info.supports_compute = false
        info.supports_raytracing = false
        return
    }

    // Identify vendor
    switch dev.vendor_id {
        0x10DE => basics.memcpy(&info.vendor, "NVIDIA", 7),
        0x1002 => basics.memcpy(&info.vendor, "AMD", 4),
        0x8086 => basics.memcpy(&info.vendor, "Intel", 6),
        else => basics.memcpy(&info.vendor, "Unknown", 8)
    }

    // Get renderer name based on device ID
    // This would be a lookup table in practice
    basics.memcpy(&info.renderer, "GPU", 4)
    basics.memcpy(&info.version, "1.0", 4)

    info.backend = craft_gpu.config.backend
    info.memory_mb = gpu.get_vram_size()
    info.discrete = dev.vendor_id != 0x8086  // Intel is typically integrated

    // Query capabilities
    info.max_texture_size = 16384
    info.max_render_targets = 8
    info.supports_compute = true
    info.supports_raytracing = dev.vendor_id == 0x10DE  // NVIDIA RTX
    info.driver_version = 1
}

fn get_backend_name(backend: u8): *const u8 {
    return switch backend {
        CRAFT_BACKEND_AUTO => "Auto",
        CRAFT_BACKEND_METAL => "Metal",
        CRAFT_BACKEND_VULKAN => "Vulkan",
        CRAFT_BACKEND_OPENGL => "OpenGL",
        CRAFT_BACKEND_SOFTWARE => "Software",
        else => "Unknown"
    }
}

// ============================================
// Resource Creation
// ============================================

export fn craft_create_shader(shader_type: u8, source: *const u8, source_len: u32): *CraftShader {
    var shader = basics.kmalloc(@sizeOf(CraftShader)) as *CraftShader
    if shader == null {
        return null
    }

    shader.shader_type = shader_type
    shader.handle = basics.get_timestamp()  // Unique handle
    shader.compiled = false
    shader.source = source
    shader.source_len = source_len
    basics.memcpy(&shader.entry_point, "main", 5)

    // Compile shader based on backend
    switch craft_gpu.config.backend {
        CRAFT_BACKEND_VULKAN => compile_spirv(shader),
        CRAFT_BACKEND_OPENGL => compile_glsl(shader),
        CRAFT_BACKEND_METAL => compile_metal(shader),
        else => {}
    }

    return shader
}

fn compile_spirv(shader: *CraftShader): void {
    // SPIR-V compilation for Vulkan
    // Would use glslang or shaderc
    shader.compiled = true
}

fn compile_glsl(shader: *CraftShader): void {
    // OpenGL shader compilation
    shader.compiled = true
}

fn compile_metal(shader: *CraftShader): void {
    // Metal shader compilation (MSL)
    shader.compiled = true
}

export fn craft_destroy_shader(shader: *CraftShader): void {
    if shader != null {
        basics.kfree(shader)
    }
}

export fn craft_create_buffer(buffer_type: u8, size: u64): *CraftBuffer {
    var buffer = basics.kmalloc(@sizeOf(CraftBuffer)) as *CraftBuffer
    if buffer == null {
        return null
    }

    buffer.buffer_type = buffer_type
    buffer.handle = basics.get_timestamp()
    buffer.size = size
    buffer.mapped = false
    buffer.data = basics.kmalloc(size as u32)

    return buffer
}

export fn craft_destroy_buffer(buffer: *CraftBuffer): void {
    if buffer != null {
        if buffer.data != null {
            basics.kfree(buffer.data)
        }
        basics.kfree(buffer)
    }
}

export fn craft_create_texture(tex_type: u8, format: u8, width: u32, height: u32, depth: u32): *CraftTexture {
    var texture = basics.kmalloc(@sizeOf(CraftTexture)) as *CraftTexture
    if texture == null {
        return null
    }

    texture.texture_type = tex_type
    texture.format = format
    texture.handle = basics.get_timestamp()
    texture.width = width
    texture.height = height
    texture.depth = depth
    texture.mip_levels = 1
    texture.samples = 1

    return texture
}

export fn craft_destroy_texture(texture: *CraftTexture): void {
    if texture != null {
        basics.kfree(texture)
    }
}

// ============================================
// Rendering
// ============================================

export fn craft_begin_frame(): void {
    craft_gpu.frame_number = craft_gpu.frame_number + 1
    craft_gpu.draw_calls = 0
    craft_gpu.triangles = 0

    let now = basics.get_timestamp()
    if craft_gpu.last_frame_time != 0 {
        let delta = now - craft_gpu.last_frame_time
        craft_gpu.frame_time_ms = delta as f32 / 1000000.0
        if craft_gpu.frame_time_ms > 0 {
            craft_gpu.fps = 1000.0 / craft_gpu.frame_time_ms
        }
    }
    craft_gpu.last_frame_time = now
}

export fn craft_end_frame(): void {
    // VSync if enabled
    if craft_gpu.config.vsync {
        gpu.wait_vsync()
    }

    // FPS limiting
    if craft_gpu.config.max_fps > 0 {
        let target_time = 1000000000 / craft_gpu.config.max_fps as u64
        let elapsed = basics.get_timestamp() - craft_gpu.last_frame_time
        if elapsed < target_time {
            basics.sleep_ns(target_time - elapsed)
        }
    }
}

export fn craft_begin_render_pass(pass: *CraftRenderPass): void {
    craft_gpu.current_pass = pass

    // Clear attachments if needed
    if pass.clear_color[3] > 0 {
        gpu.clear_color(
            pass.clear_color[0],
            pass.clear_color[1],
            pass.clear_color[2],
            pass.clear_color[3]
        )
    }

    if pass.clear_depth > 0 {
        gpu.clear_depth(pass.clear_depth)
    }
}

export fn craft_end_render_pass(): void {
    craft_gpu.current_pass = null
}

export fn craft_set_pipeline(pipeline: *CraftPipelineState): void {
    craft_gpu.current_pipeline = pipeline
}

export fn craft_draw(vertex_count: u32, instance_count: u32): void {
    craft_gpu.draw_calls = craft_gpu.draw_calls + 1
    craft_gpu.triangles = craft_gpu.triangles + vertex_count as u64 / 3

    // Forward to GPU driver
    gpu.draw_arrays(0, vertex_count, instance_count)
}

export fn craft_draw_indexed(index_count: u32, instance_count: u32): void {
    craft_gpu.draw_calls = craft_gpu.draw_calls + 1
    craft_gpu.triangles = craft_gpu.triangles + index_count as u64 / 3

    gpu.draw_indexed(0, index_count, instance_count)
}

// ============================================
// Query Functions
// ============================================

export fn craft_get_info(): *CraftGPUInfo {
    return &craft_gpu.info
}

export fn craft_get_fps(): f32 {
    return craft_gpu.fps
}

export fn craft_get_frame_time(): f32 {
    return craft_gpu.frame_time_ms
}

export fn craft_get_draw_calls(): u64 {
    return craft_gpu.draw_calls
}

export fn craft_get_triangle_count(): u64 {
    return craft_gpu.triangles
}

export fn craft_is_acceleration_available(): bool {
    return craft_gpu.config.backend != CRAFT_BACKEND_SOFTWARE
}

export fn craft_set_vsync(enabled: bool): void {
    craft_gpu.config.vsync = enabled
}

export fn craft_set_max_fps(fps: u32): void {
    craft_gpu.config.max_fps = fps
}

export fn craft_set_power_preference(preference: u8): void {
    craft_gpu.config.power_preference = preference
}
