// home-os OpenGL 1.x Compatible Software Renderer
// Implements fixed-function pipeline with software rasterization

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "../drivers/gpu.home" as gpu

// ============================================================================
// OpenGL Constants
// ============================================================================

// Primitive types
const GL_POINTS: u32 = 0x0000
const GL_LINES: u32 = 0x0001
const GL_LINE_LOOP: u32 = 0x0002
const GL_LINE_STRIP: u32 = 0x0003
const GL_TRIANGLES: u32 = 0x0004
const GL_TRIANGLE_STRIP: u32 = 0x0005
const GL_TRIANGLE_FAN: u32 = 0x0006
const GL_QUADS: u32 = 0x0007
const GL_QUAD_STRIP: u32 = 0x0008
const GL_POLYGON: u32 = 0x0009

// Buffer bits
const GL_COLOR_BUFFER_BIT: u32 = 0x4000
const GL_DEPTH_BUFFER_BIT: u32 = 0x0100
const GL_STENCIL_BUFFER_BIT: u32 = 0x0400

// Enable/Disable capabilities
const GL_DEPTH_TEST: u32 = 0x0B71
const GL_BLEND: u32 = 0x0BE2
const GL_TEXTURE_2D: u32 = 0x0DE1
const GL_LIGHTING: u32 = 0x0B50
const GL_LIGHT0: u32 = 0x4000
const GL_LIGHT1: u32 = 0x4001
const GL_LIGHT2: u32 = 0x4002
const GL_LIGHT3: u32 = 0x4003
const GL_CULL_FACE: u32 = 0x0B44
const GL_FOG: u32 = 0x0B60
const GL_NORMALIZE: u32 = 0x0BA1
const GL_ALPHA_TEST: u32 = 0x0BC0

// Matrix modes
const GL_MODELVIEW: u32 = 0x1700
const GL_PROJECTION: u32 = 0x1701
const GL_TEXTURE: u32 = 0x1702

// Blend functions
const GL_ZERO: u32 = 0
const GL_ONE: u32 = 1
const GL_SRC_ALPHA: u32 = 0x0302
const GL_ONE_MINUS_SRC_ALPHA: u32 = 0x0303
const GL_DST_ALPHA: u32 = 0x0304
const GL_ONE_MINUS_DST_ALPHA: u32 = 0x0305

// Depth functions
const GL_NEVER: u32 = 0x0200
const GL_LESS: u32 = 0x0201
const GL_EQUAL: u32 = 0x0202
const GL_LEQUAL: u32 = 0x0203
const GL_GREATER: u32 = 0x0204
const GL_NOTEQUAL: u32 = 0x0205
const GL_GEQUAL: u32 = 0x0206
const GL_ALWAYS: u32 = 0x0207

// Face culling
const GL_FRONT: u32 = 0x0404
const GL_BACK: u32 = 0x0405
const GL_FRONT_AND_BACK: u32 = 0x0408

// Polygon modes
const GL_POINT: u32 = 0x1B00
const GL_LINE: u32 = 0x1B01
const GL_FILL: u32 = 0x1B02

// Shade model
const GL_FLAT: u32 = 0x1D00
const GL_SMOOTH: u32 = 0x1D01

// Texture parameters
const GL_TEXTURE_MIN_FILTER: u32 = 0x2801
const GL_TEXTURE_MAG_FILTER: u32 = 0x2800
const GL_TEXTURE_WRAP_S: u32 = 0x2802
const GL_TEXTURE_WRAP_T: u32 = 0x2803
const GL_NEAREST: u32 = 0x2600
const GL_LINEAR: u32 = 0x2601
const GL_REPEAT: u32 = 0x2901
const GL_CLAMP: u32 = 0x2900

// Light parameters
const GL_AMBIENT: u32 = 0x1200
const GL_DIFFUSE: u32 = 0x1201
const GL_SPECULAR: u32 = 0x1202
const GL_POSITION: u32 = 0x1203
const GL_SHININESS: u32 = 0x1601

// Fog parameters
const GL_FOG_MODE: u32 = 0x0B65
const GL_FOG_DENSITY: u32 = 0x0B62
const GL_FOG_START: u32 = 0x0B63
const GL_FOG_END: u32 = 0x0B64
const GL_FOG_COLOR: u32 = 0x0B66
const GL_LINEAR_FOG: u32 = 0x2601
const GL_EXP: u32 = 0x0800
const GL_EXP2: u32 = 0x0801

// ============================================================================
// Data Structures
// ============================================================================

const MAX_MATRIX_STACK: u32 = 32
const MAX_VERTICES: u32 = 4096
const MAX_LIGHTS: u32 = 8
const MAX_TEXTURES: u32 = 256

// 4x4 Matrix
struct Mat4 {
    m: [f32; 16]  // Column-major order
}

// 4D Vector
struct Vec4 {
    x: f32,
    y: f32,
    z: f32,
    w: f32
}

// 3D Vector
struct Vec3 {
    x: f32,
    y: f32,
    z: f32
}

// Color (RGBA float)
struct Color4f {
    r: f32,
    g: f32,
    b: f32,
    a: f32
}

// Vertex with all attributes
struct GLVertex {
    position: Vec4,
    color: Color4f,
    normal: Vec3,
    texcoord: Vec4,   // s, t, r, q
    clip_pos: Vec4,   // After MVP transform
    screen_x: f32,
    screen_y: f32,
    screen_z: f32
}

// Light source
struct GLLight {
    enabled: u32,
    ambient: Color4f,
    diffuse: Color4f,
    specular: Color4f,
    position: Vec4     // w=0 for directional, w=1 for positional
}

// Material properties
struct GLMaterial {
    ambient: Color4f,
    diffuse: Color4f,
    specular: Color4f,
    emission: Color4f,
    shininess: f32
}

// Texture object
struct GLTexture {
    id: u32,
    width: u32,
    height: u32,
    data: u64,
    min_filter: u32,
    mag_filter: u32,
    wrap_s: u32,
    wrap_t: u32,
    in_use: u32
}

// Fog state
struct GLFog {
    enabled: u32,
    mode: u32,
    density: f32,
    start: f32,
    end: f32,
    color: Color4f
}

// OpenGL context state
struct GLContext {
    initialized: u32,

    // Viewport
    viewport_x: i32,
    viewport_y: i32,
    viewport_width: u32,
    viewport_height: u32,

    // Clear values
    clear_color: Color4f,
    clear_depth: f32,

    // Matrix stacks
    matrix_mode: u32,
    modelview_stack: [Mat4; 32],
    projection_stack: [Mat4; 32],
    texture_stack: [Mat4; 32],
    modelview_depth: u32,
    projection_depth: u32,
    texture_depth: u32,

    // Current state
    current_color: Color4f,
    current_normal: Vec3,
    current_texcoord: Vec4,

    // Rendering state
    primitive_mode: u32,
    in_begin_end: u32,

    // Vertex buffer for current primitive
    vertex_buffer: [GLVertex; 4096],
    vertex_count: u32,

    // Capabilities
    depth_test_enabled: u32,
    blend_enabled: u32,
    texture_2d_enabled: u32,
    lighting_enabled: u32,
    cull_face_enabled: u32,
    fog_enabled: u32,
    normalize_enabled: u32,

    // Blending
    blend_src: u32,
    blend_dst: u32,

    // Depth
    depth_func: u32,

    // Culling
    cull_face_mode: u32,
    front_face: u32,   // GL_CCW or GL_CW

    // Shading
    shade_model: u32,

    // Polygon mode
    polygon_mode_front: u32,
    polygon_mode_back: u32,

    // Current texture
    current_texture: u32
}

// Global state
var gl: GLContext
var lights: [GLLight; 8]
var material: GLMaterial
var textures: [GLTexture; 256]
var fog: GLFog

// ============================================================================
// Matrix Operations
// ============================================================================

fn mat4_identity(): Mat4 {
    var m: Mat4
    var i: u32 = 0
    while i < 16 {
        m.m[i] = 0.0
        i = i + 1
    }
    m.m[0] = 1.0
    m.m[5] = 1.0
    m.m[10] = 1.0
    m.m[15] = 1.0
    return m
}

fn mat4_multiply(a: *Mat4, b: *Mat4): Mat4 {
    var result: Mat4

    var col: u32 = 0
    while col < 4 {
        var row: u32 = 0
        while row < 4 {
            var sum: f32 = 0.0
            var k: u32 = 0
            while k < 4 {
                sum = sum + a.m[k * 4 + row] * b.m[col * 4 + k]
                k = k + 1
            }
            result.m[col * 4 + row] = sum
            row = row + 1
        }
        col = col + 1
    }

    return result
}

fn mat4_transform_vec4(m: *Mat4, v: Vec4): Vec4 {
    var result: Vec4
    result.x = m.m[0] * v.x + m.m[4] * v.y + m.m[8] * v.z + m.m[12] * v.w
    result.y = m.m[1] * v.x + m.m[5] * v.y + m.m[9] * v.z + m.m[13] * v.w
    result.z = m.m[2] * v.x + m.m[6] * v.y + m.m[10] * v.z + m.m[14] * v.w
    result.w = m.m[3] * v.x + m.m[7] * v.y + m.m[11] * v.z + m.m[15] * v.w
    return result
}

fn mat4_transform_vec3_normal(m: *Mat4, v: Vec3): Vec3 {
    // Transform normal (ignore translation)
    var result: Vec3
    result.x = m.m[0] * v.x + m.m[4] * v.y + m.m[8] * v.z
    result.y = m.m[1] * v.x + m.m[5] * v.y + m.m[9] * v.z
    result.z = m.m[2] * v.x + m.m[6] * v.y + m.m[10] * v.z
    return result
}

fn get_current_matrix(): *Mat4 {
    if gl.matrix_mode == GL_MODELVIEW {
        return &gl.modelview_stack[gl.modelview_depth]
    } else if gl.matrix_mode == GL_PROJECTION {
        return &gl.projection_stack[gl.projection_depth]
    } else {
        return &gl.texture_stack[gl.texture_depth]
    }
}

fn get_current_stack_depth(): *u32 {
    if gl.matrix_mode == GL_MODELVIEW {
        return &gl.modelview_depth
    } else if gl.matrix_mode == GL_PROJECTION {
        return &gl.projection_depth
    } else {
        return &gl.texture_depth
    }
}

// ============================================================================
// Vector Operations
// ============================================================================

fn vec3_dot(a: Vec3, b: Vec3): f32 {
    return a.x * b.x + a.y * b.y + a.z * b.z
}

fn vec3_normalize(v: Vec3): Vec3 {
    let len: f32 = foundation.sqrt(v.x * v.x + v.y * v.y + v.z * v.z)
    if len < 0.0001 {
        return v
    }
    var result: Vec3
    result.x = v.x / len
    result.y = v.y / len
    result.z = v.z / len
    return result
}

fn vec3_sub(a: Vec3, b: Vec3): Vec3 {
    var result: Vec3
    result.x = a.x - b.x
    result.y = a.y - b.y
    result.z = a.z - b.z
    return result
}

fn vec3_cross(a: Vec3, b: Vec3): Vec3 {
    var result: Vec3
    result.x = a.y * b.z - a.z * b.y
    result.y = a.z * b.x - a.x * b.z
    result.z = a.x * b.y - a.y * b.x
    return result
}

// ============================================================================
// Color Operations
// ============================================================================

fn color_clamp(c: Color4f): Color4f {
    var result: Color4f
    result.r = if c.r < 0.0 { 0.0 } else if c.r > 1.0 { 1.0 } else { c.r }
    result.g = if c.g < 0.0 { 0.0 } else if c.g > 1.0 { 1.0 } else { c.g }
    result.b = if c.b < 0.0 { 0.0 } else if c.b > 1.0 { 1.0 } else { c.b }
    result.a = if c.a < 0.0 { 0.0 } else if c.a > 1.0 { 1.0 } else { c.a }
    return result
}

fn color_to_u32(c: Color4f): u32 {
    let cc: Color4f = color_clamp(c)
    let r: u32 = (cc.r * 255.0) as u32
    let g: u32 = (cc.g * 255.0) as u32
    let b: u32 = (cc.b * 255.0) as u32
    let a: u32 = (cc.a * 255.0) as u32
    return (a << 24) | (r << 16) | (g << 8) | b
}

fn color_add(a: Color4f, b: Color4f): Color4f {
    var result: Color4f
    result.r = a.r + b.r
    result.g = a.g + b.g
    result.b = a.b + b.b
    result.a = a.a + b.a
    return result
}

fn color_multiply(a: Color4f, b: Color4f): Color4f {
    var result: Color4f
    result.r = a.r * b.r
    result.g = a.g * b.g
    result.b = a.b * b.b
    result.a = a.a * b.a
    return result
}

fn color_scale(c: Color4f, s: f32): Color4f {
    var result: Color4f
    result.r = c.r * s
    result.g = c.g * s
    result.b = c.b * s
    result.a = c.a
    return result
}

// ============================================================================
// Initialization
// ============================================================================

export fn glInit() {
    if gl.initialized == 1 { return }

    // Initialize GPU
    gpu.gpu_init()

    // Set default viewport
    gl.viewport_x = 0
    gl.viewport_y = 0
    gl.viewport_width = gpu.gpu_get_width()
    gl.viewport_height = gpu.gpu_get_height()

    // Clear values
    gl.clear_color.r = 0.0
    gl.clear_color.g = 0.0
    gl.clear_color.b = 0.0
    gl.clear_color.a = 1.0
    gl.clear_depth = 1.0

    // Initialize matrix stacks
    gl.matrix_mode = GL_MODELVIEW
    gl.modelview_depth = 0
    gl.projection_depth = 0
    gl.texture_depth = 0

    gl.modelview_stack[0] = mat4_identity()
    gl.projection_stack[0] = mat4_identity()
    gl.texture_stack[0] = mat4_identity()

    // Default vertex attributes
    gl.current_color.r = 1.0
    gl.current_color.g = 1.0
    gl.current_color.b = 1.0
    gl.current_color.a = 1.0

    gl.current_normal.x = 0.0
    gl.current_normal.y = 0.0
    gl.current_normal.z = 1.0

    gl.current_texcoord.x = 0.0
    gl.current_texcoord.y = 0.0
    gl.current_texcoord.z = 0.0
    gl.current_texcoord.w = 1.0

    // Default state
    gl.in_begin_end = 0
    gl.vertex_count = 0

    gl.depth_test_enabled = 0
    gl.blend_enabled = 0
    gl.texture_2d_enabled = 0
    gl.lighting_enabled = 0
    gl.cull_face_enabled = 0
    gl.fog_enabled = 0
    gl.normalize_enabled = 0

    gl.blend_src = GL_ONE
    gl.blend_dst = GL_ZERO
    gl.depth_func = GL_LESS
    gl.cull_face_mode = GL_BACK
    gl.front_face = 0  // GL_CCW
    gl.shade_model = GL_SMOOTH
    gl.polygon_mode_front = GL_FILL
    gl.polygon_mode_back = GL_FILL
    gl.current_texture = 0xFFFFFFFF

    // Initialize lights
    var i: u32 = 0
    while i < MAX_LIGHTS {
        lights[i].enabled = 0
        lights[i].ambient.r = 0.0
        lights[i].ambient.g = 0.0
        lights[i].ambient.b = 0.0
        lights[i].ambient.a = 1.0
        lights[i].diffuse.r = if i == 0 { 1.0 } else { 0.0 }
        lights[i].diffuse.g = if i == 0 { 1.0 } else { 0.0 }
        lights[i].diffuse.b = if i == 0 { 1.0 } else { 0.0 }
        lights[i].diffuse.a = 1.0
        lights[i].specular.r = if i == 0 { 1.0 } else { 0.0 }
        lights[i].specular.g = if i == 0 { 1.0 } else { 0.0 }
        lights[i].specular.b = if i == 0 { 1.0 } else { 0.0 }
        lights[i].specular.a = 1.0
        lights[i].position.x = 0.0
        lights[i].position.y = 0.0
        lights[i].position.z = 1.0
        lights[i].position.w = 0.0  // Directional by default
        i = i + 1
    }

    // Initialize material
    material.ambient.r = 0.2
    material.ambient.g = 0.2
    material.ambient.b = 0.2
    material.ambient.a = 1.0
    material.diffuse.r = 0.8
    material.diffuse.g = 0.8
    material.diffuse.b = 0.8
    material.diffuse.a = 1.0
    material.specular.r = 0.0
    material.specular.g = 0.0
    material.specular.b = 0.0
    material.specular.a = 1.0
    material.emission.r = 0.0
    material.emission.g = 0.0
    material.emission.b = 0.0
    material.emission.a = 1.0
    material.shininess = 0.0

    // Initialize fog
    fog.enabled = 0
    fog.mode = GL_EXP
    fog.density = 1.0
    fog.start = 0.0
    fog.end = 1.0
    fog.color.r = 0.0
    fog.color.g = 0.0
    fog.color.b = 0.0
    fog.color.a = 1.0

    // Initialize textures
    i = 0
    while i < MAX_TEXTURES {
        textures[i].in_use = 0
        i = i + 1
    }

    gl.initialized = 1
    foundation.serial_write_string("[OpenGL] Software renderer initialized\n")
}

export fn glShutdown() {
    if gl.initialized == 0 { return }

    // Free textures
    var i: u32 = 0
    while i < MAX_TEXTURES {
        if textures[i].in_use == 1 and textures[i].data != 0 {
            memory.kfree(textures[i].data)
        }
        i = i + 1
    }

    gl.initialized = 0
}

// ============================================================================
// State Management
// ============================================================================

export fn glEnable(cap: u32) {
    if gl.initialized == 0 { return }

    if cap == GL_DEPTH_TEST {
        gl.depth_test_enabled = 1
        gpu.gpu_enable_depth_test()
    } else if cap == GL_BLEND {
        gl.blend_enabled = 1
    } else if cap == GL_TEXTURE_2D {
        gl.texture_2d_enabled = 1
    } else if cap == GL_LIGHTING {
        gl.lighting_enabled = 1
    } else if cap == GL_LIGHT0 {
        lights[0].enabled = 1
    } else if cap == GL_LIGHT1 {
        lights[1].enabled = 1
    } else if cap == GL_LIGHT2 {
        lights[2].enabled = 1
    } else if cap == GL_LIGHT3 {
        lights[3].enabled = 1
    } else if cap == GL_CULL_FACE {
        gl.cull_face_enabled = 1
    } else if cap == GL_FOG {
        gl.fog_enabled = 1
        fog.enabled = 1
    } else if cap == GL_NORMALIZE {
        gl.normalize_enabled = 1
    }
}

export fn glDisable(cap: u32) {
    if gl.initialized == 0 { return }

    if cap == GL_DEPTH_TEST {
        gl.depth_test_enabled = 0
        gpu.gpu_disable_depth_test()
    } else if cap == GL_BLEND {
        gl.blend_enabled = 0
    } else if cap == GL_TEXTURE_2D {
        gl.texture_2d_enabled = 0
    } else if cap == GL_LIGHTING {
        gl.lighting_enabled = 0
    } else if cap == GL_LIGHT0 {
        lights[0].enabled = 0
    } else if cap == GL_LIGHT1 {
        lights[1].enabled = 0
    } else if cap == GL_LIGHT2 {
        lights[2].enabled = 0
    } else if cap == GL_LIGHT3 {
        lights[3].enabled = 0
    } else if cap == GL_CULL_FACE {
        gl.cull_face_enabled = 0
    } else if cap == GL_FOG {
        gl.fog_enabled = 0
        fog.enabled = 0
    } else if cap == GL_NORMALIZE {
        gl.normalize_enabled = 0
    }
}

export fn glIsEnabled(cap: u32): u32 {
    if cap == GL_DEPTH_TEST { return gl.depth_test_enabled }
    if cap == GL_BLEND { return gl.blend_enabled }
    if cap == GL_TEXTURE_2D { return gl.texture_2d_enabled }
    if cap == GL_LIGHTING { return gl.lighting_enabled }
    if cap == GL_CULL_FACE { return gl.cull_face_enabled }
    if cap == GL_FOG { return gl.fog_enabled }
    return 0
}

// ============================================================================
// Clear Operations
// ============================================================================

export fn glClearColor(r: f32, g: f32, b: f32, a: f32) {
    gl.clear_color.r = r
    gl.clear_color.g = g
    gl.clear_color.b = b
    gl.clear_color.a = a
}

export fn glClearDepth(depth: f32) {
    gl.clear_depth = depth
}

export fn glClear(mask: u32) {
    if gl.initialized == 0 { return }

    if (mask & GL_COLOR_BUFFER_BIT) != 0 {
        let color: u32 = color_to_u32(gl.clear_color)
        gpu.gpu_clear(color)
    }

    if (mask & GL_DEPTH_BUFFER_BIT) != 0 {
        // GPU layer handles Z-buffer clearing
    }
}

// ============================================================================
// Viewport and Projection
// ============================================================================

export fn glViewport(x: i32, y: i32, width: i32, height: i32) {
    gl.viewport_x = x
    gl.viewport_y = y
    gl.viewport_width = width as u32
    gl.viewport_height = height as u32
}

export fn glMatrixMode(mode: u32) {
    gl.matrix_mode = mode
}

export fn glLoadIdentity() {
    let m: *Mat4 = get_current_matrix()
    *m = mat4_identity()
}

export fn glLoadMatrixf(matrix: *f32) {
    let m: *Mat4 = get_current_matrix()
    var i: u32 = 0
    while i < 16 {
        m.m[i] = *(matrix as u64 + i * 4) as *f32
        i = i + 1
    }
}

export fn glMultMatrixf(matrix: *f32) {
    let current: *Mat4 = get_current_matrix()
    var mult: Mat4
    var i: u32 = 0
    while i < 16 {
        mult.m[i] = *(matrix as u64 + i * 4) as *f32
        i = i + 1
    }
    *current = mat4_multiply(current, &mult)
}

export fn glPushMatrix() {
    let depth: *u32 = get_current_stack_depth()
    if *depth >= MAX_MATRIX_STACK - 1 { return }

    if gl.matrix_mode == GL_MODELVIEW {
        gl.modelview_stack[*depth + 1] = gl.modelview_stack[*depth]
    } else if gl.matrix_mode == GL_PROJECTION {
        gl.projection_stack[*depth + 1] = gl.projection_stack[*depth]
    } else {
        gl.texture_stack[*depth + 1] = gl.texture_stack[*depth]
    }

    *depth = *depth + 1
}

export fn glPopMatrix() {
    let depth: *u32 = get_current_stack_depth()
    if *depth == 0 { return }
    *depth = *depth - 1
}

export fn glTranslatef(x: f32, y: f32, z: f32) {
    var trans: Mat4 = mat4_identity()
    trans.m[12] = x
    trans.m[13] = y
    trans.m[14] = z

    let current: *Mat4 = get_current_matrix()
    *current = mat4_multiply(current, &trans)
}

export fn glRotatef(angle: f32, x: f32, y: f32, z: f32) {
    let rad: f32 = angle * 3.14159265359 / 180.0

    // Normalize axis
    let len: f32 = foundation.sqrt(x * x + y * y + z * z)
    if len < 0.0001 { return }

    let nx: f32 = x / len
    let ny: f32 = y / len
    let nz: f32 = z / len

    let c: f32 = foundation.cos(rad)
    let s: f32 = foundation.sin(rad)
    let nc: f32 = 1.0 - c

    var rot: Mat4 = mat4_identity()

    rot.m[0] = nx * nx * nc + c
    rot.m[1] = ny * nx * nc + nz * s
    rot.m[2] = nz * nx * nc - ny * s

    rot.m[4] = nx * ny * nc - nz * s
    rot.m[5] = ny * ny * nc + c
    rot.m[6] = nz * ny * nc + nx * s

    rot.m[8] = nx * nz * nc + ny * s
    rot.m[9] = ny * nz * nc - nx * s
    rot.m[10] = nz * nz * nc + c

    let current: *Mat4 = get_current_matrix()
    *current = mat4_multiply(current, &rot)
}

export fn glScalef(x: f32, y: f32, z: f32) {
    var scale: Mat4 = mat4_identity()
    scale.m[0] = x
    scale.m[5] = y
    scale.m[10] = z

    let current: *Mat4 = get_current_matrix()
    *current = mat4_multiply(current, &scale)
}

export fn glOrtho(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32) {
    var ortho: Mat4 = mat4_identity()

    let rl: f32 = right - left
    let tb: f32 = top - bottom
    let fn_: f32 = far - near

    ortho.m[0] = 2.0 / rl
    ortho.m[5] = 2.0 / tb
    ortho.m[10] = -2.0 / fn_
    ortho.m[12] = -(right + left) / rl
    ortho.m[13] = -(top + bottom) / tb
    ortho.m[14] = -(far + near) / fn_

    let current: *Mat4 = get_current_matrix()
    *current = mat4_multiply(current, &ortho)
}

export fn glFrustum(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32) {
    var frustum: Mat4
    var i: u32 = 0
    while i < 16 {
        frustum.m[i] = 0.0
        i = i + 1
    }

    let rl: f32 = right - left
    let tb: f32 = top - bottom
    let fn_: f32 = far - near

    frustum.m[0] = 2.0 * near / rl
    frustum.m[5] = 2.0 * near / tb
    frustum.m[8] = (right + left) / rl
    frustum.m[9] = (top + bottom) / tb
    frustum.m[10] = -(far + near) / fn_
    frustum.m[11] = -1.0
    frustum.m[14] = -2.0 * far * near / fn_

    let current: *Mat4 = get_current_matrix()
    *current = mat4_multiply(current, &frustum)
}

export fn gluPerspective(fovy: f32, aspect: f32, near: f32, far: f32) {
    let fovy_rad: f32 = fovy * 3.14159265359 / 180.0
    let f: f32 = 1.0 / foundation.tan(fovy_rad / 2.0)

    var persp: Mat4
    var i: u32 = 0
    while i < 16 {
        persp.m[i] = 0.0
        i = i + 1
    }

    persp.m[0] = f / aspect
    persp.m[5] = f
    persp.m[10] = (far + near) / (near - far)
    persp.m[11] = -1.0
    persp.m[14] = 2.0 * far * near / (near - far)

    let current: *Mat4 = get_current_matrix()
    *current = mat4_multiply(current, &persp)
}

export fn gluLookAt(eyeX: f32, eyeY: f32, eyeZ: f32,
                    centerX: f32, centerY: f32, centerZ: f32,
                    upX: f32, upY: f32, upZ: f32) {
    var f: Vec3
    f.x = centerX - eyeX
    f.y = centerY - eyeY
    f.z = centerZ - eyeZ
    f = vec3_normalize(f)

    var up: Vec3
    up.x = upX
    up.y = upY
    up.z = upZ
    up = vec3_normalize(up)

    let s: Vec3 = vec3_normalize(vec3_cross(f, up))
    let u: Vec3 = vec3_cross(s, f)

    var lookat: Mat4 = mat4_identity()
    lookat.m[0] = s.x
    lookat.m[4] = s.y
    lookat.m[8] = s.z
    lookat.m[1] = u.x
    lookat.m[5] = u.y
    lookat.m[9] = u.z
    lookat.m[2] = -f.x
    lookat.m[6] = -f.y
    lookat.m[10] = -f.z

    let current: *Mat4 = get_current_matrix()
    *current = mat4_multiply(current, &lookat)

    glTranslatef(-eyeX, -eyeY, -eyeZ)
}

// ============================================================================
// Vertex Attributes
// ============================================================================

export fn glColor3f(r: f32, g: f32, b: f32) {
    gl.current_color.r = r
    gl.current_color.g = g
    gl.current_color.b = b
    gl.current_color.a = 1.0
}

export fn glColor4f(r: f32, g: f32, b: f32, a: f32) {
    gl.current_color.r = r
    gl.current_color.g = g
    gl.current_color.b = b
    gl.current_color.a = a
}

export fn glColor3ub(r: u8, g: u8, b: u8) {
    gl.current_color.r = (r as f32) / 255.0
    gl.current_color.g = (g as f32) / 255.0
    gl.current_color.b = (b as f32) / 255.0
    gl.current_color.a = 1.0
}

export fn glColor4ub(r: u8, g: u8, b: u8, a: u8) {
    gl.current_color.r = (r as f32) / 255.0
    gl.current_color.g = (g as f32) / 255.0
    gl.current_color.b = (b as f32) / 255.0
    gl.current_color.a = (a as f32) / 255.0
}

export fn glNormal3f(x: f32, y: f32, z: f32) {
    gl.current_normal.x = x
    gl.current_normal.y = y
    gl.current_normal.z = z

    if gl.normalize_enabled == 1 {
        gl.current_normal = vec3_normalize(gl.current_normal)
    }
}

export fn glTexCoord2f(s: f32, t: f32) {
    gl.current_texcoord.x = s
    gl.current_texcoord.y = t
    gl.current_texcoord.z = 0.0
    gl.current_texcoord.w = 1.0
}

export fn glTexCoord3f(s: f32, t: f32, r: f32) {
    gl.current_texcoord.x = s
    gl.current_texcoord.y = t
    gl.current_texcoord.z = r
    gl.current_texcoord.w = 1.0
}

// ============================================================================
// Immediate Mode Rendering
// ============================================================================

export fn glBegin(mode: u32) {
    if gl.initialized == 0 { return }
    if gl.in_begin_end == 1 { return }  // Nested glBegin

    gl.primitive_mode = mode
    gl.in_begin_end = 1
    gl.vertex_count = 0
}

export fn glVertex2f(x: f32, y: f32) {
    glVertex4f(x, y, 0.0, 1.0)
}

export fn glVertex3f(x: f32, y: f32, z: f32) {
    glVertex4f(x, y, z, 1.0)
}

export fn glVertex4f(x: f32, y: f32, z: f32, w: f32) {
    if gl.in_begin_end == 0 { return }
    if gl.vertex_count >= MAX_VERTICES { return }

    var v: *GLVertex = &gl.vertex_buffer[gl.vertex_count]

    v.position.x = x
    v.position.y = y
    v.position.z = z
    v.position.w = w

    v.color = gl.current_color
    v.normal = gl.current_normal
    v.texcoord = gl.current_texcoord

    gl.vertex_count = gl.vertex_count + 1
}

export fn glEnd() {
    if gl.in_begin_end == 0 { return }
    gl.in_begin_end = 0

    if gl.vertex_count == 0 { return }

    // Transform all vertices
    transform_vertices()

    // Apply lighting if enabled
    if gl.lighting_enabled == 1 {
        apply_lighting()
    }

    // Rasterize primitives
    rasterize_primitives()
}

// ============================================================================
// Vertex Transformation
// ============================================================================

fn transform_vertices() {
    let modelview: *Mat4 = &gl.modelview_stack[gl.modelview_depth]
    let projection: *Mat4 = &gl.projection_stack[gl.projection_depth]

    var mvp: Mat4 = mat4_multiply(projection, modelview)

    var i: u32 = 0
    while i < gl.vertex_count {
        var v: *GLVertex = &gl.vertex_buffer[i]

        // Transform to clip space
        v.clip_pos = mat4_transform_vec4(&mvp, v.position)

        // Perspective divide
        if v.clip_pos.w != 0.0 {
            let inv_w: f32 = 1.0 / v.clip_pos.w
            v.clip_pos.x = v.clip_pos.x * inv_w
            v.clip_pos.y = v.clip_pos.y * inv_w
            v.clip_pos.z = v.clip_pos.z * inv_w
        }

        // Transform to screen space
        v.screen_x = (v.clip_pos.x * 0.5 + 0.5) * (gl.viewport_width as f32) + (gl.viewport_x as f32)
        v.screen_y = (1.0 - (v.clip_pos.y * 0.5 + 0.5)) * (gl.viewport_height as f32) + (gl.viewport_y as f32)
        v.screen_z = v.clip_pos.z * 0.5 + 0.5

        // Transform normal to eye space for lighting
        v.normal = mat4_transform_vec3_normal(modelview, v.normal)
        if gl.normalize_enabled == 1 {
            v.normal = vec3_normalize(v.normal)
        }

        i = i + 1
    }
}

// ============================================================================
// Lighting
// ============================================================================

fn apply_lighting() {
    let modelview: *Mat4 = &gl.modelview_stack[gl.modelview_depth]

    var i: u32 = 0
    while i < gl.vertex_count {
        var v: *GLVertex = &gl.vertex_buffer[i]

        // Start with emission
        var color: Color4f = material.emission

        // Add ambient contribution (global ambient * material ambient)
        var global_ambient: Color4f
        global_ambient.r = 0.2
        global_ambient.g = 0.2
        global_ambient.b = 0.2
        global_ambient.a = 1.0
        color = color_add(color, color_multiply(global_ambient, material.ambient))

        // Process each enabled light
        var light_idx: u32 = 0
        while light_idx < MAX_LIGHTS {
            if lights[light_idx].enabled == 1 {
                let lit_color: Color4f = compute_light_contribution(v, &lights[light_idx], modelview)
                color = color_add(color, lit_color)
            }
            light_idx = light_idx + 1
        }

        // Clamp and store
        v.color = color_clamp(color)
        v.color.a = material.diffuse.a  // Alpha from material

        i = i + 1
    }
}

fn compute_light_contribution(v: *GLVertex, light: *GLLight, modelview: *Mat4): Color4f {
    var result: Color4f
    result.r = 0.0
    result.g = 0.0
    result.b = 0.0
    result.a = 0.0

    // Transform light position to eye space
    let light_pos_eye: Vec4 = mat4_transform_vec4(modelview, light.position)

    // Get vertex position in eye space
    let vertex_pos_eye: Vec4 = mat4_transform_vec4(modelview, v.position)

    // Calculate light direction
    var light_dir: Vec3
    if light.position.w == 0.0 {
        // Directional light
        light_dir.x = light_pos_eye.x
        light_dir.y = light_pos_eye.y
        light_dir.z = light_pos_eye.z
    } else {
        // Positional light
        light_dir.x = light_pos_eye.x - vertex_pos_eye.x
        light_dir.y = light_pos_eye.y - vertex_pos_eye.y
        light_dir.z = light_pos_eye.z - vertex_pos_eye.z
    }
    light_dir = vec3_normalize(light_dir)

    // Ambient contribution
    result = color_add(result, color_multiply(light.ambient, material.ambient))

    // Diffuse contribution
    let n_dot_l: f32 = vec3_dot(v.normal, light_dir)
    if n_dot_l > 0.0 {
        let diffuse: Color4f = color_multiply(light.diffuse, material.diffuse)
        result = color_add(result, color_scale(diffuse, n_dot_l))

        // Specular contribution
        if material.shininess > 0.0 {
            // View direction (towards eye, which is at origin in eye space)
            var view_dir: Vec3
            view_dir.x = -vertex_pos_eye.x
            view_dir.y = -vertex_pos_eye.y
            view_dir.z = -vertex_pos_eye.z
            view_dir = vec3_normalize(view_dir)

            // Reflection vector: R = 2 * (N . L) * N - L
            var reflect: Vec3
            reflect.x = 2.0 * n_dot_l * v.normal.x - light_dir.x
            reflect.y = 2.0 * n_dot_l * v.normal.y - light_dir.y
            reflect.z = 2.0 * n_dot_l * v.normal.z - light_dir.z
            reflect = vec3_normalize(reflect)

            let r_dot_v: f32 = vec3_dot(reflect, view_dir)
            if r_dot_v > 0.0 {
                let spec_factor: f32 = foundation.pow(r_dot_v, material.shininess)
                let specular: Color4f = color_multiply(light.specular, material.specular)
                result = color_add(result, color_scale(specular, spec_factor))
            }
        }
    }

    return result
}

// ============================================================================
// Rasterization
// ============================================================================

fn rasterize_primitives() {
    if gl.primitive_mode == GL_POINTS {
        rasterize_points()
    } else if gl.primitive_mode == GL_LINES {
        rasterize_lines()
    } else if gl.primitive_mode == GL_LINE_STRIP {
        rasterize_line_strip()
    } else if gl.primitive_mode == GL_LINE_LOOP {
        rasterize_line_loop()
    } else if gl.primitive_mode == GL_TRIANGLES {
        rasterize_triangles()
    } else if gl.primitive_mode == GL_TRIANGLE_STRIP {
        rasterize_triangle_strip()
    } else if gl.primitive_mode == GL_TRIANGLE_FAN {
        rasterize_triangle_fan()
    } else if gl.primitive_mode == GL_QUADS {
        rasterize_quads()
    } else if gl.primitive_mode == GL_POLYGON {
        rasterize_polygon()
    }
}

fn rasterize_points() {
    var i: u32 = 0
    while i < gl.vertex_count {
        let v: *GLVertex = &gl.vertex_buffer[i]
        let color: u32 = color_to_u32(v.color)
        gpu.gpu_draw_pixel(v.screen_x as i32, v.screen_y as i32, color)
        i = i + 1
    }
}

fn rasterize_lines() {
    var i: u32 = 0
    while i + 1 < gl.vertex_count {
        let v0: *GLVertex = &gl.vertex_buffer[i]
        let v1: *GLVertex = &gl.vertex_buffer[i + 1]

        if gl.shade_model == GL_FLAT {
            let color: u32 = color_to_u32(v1.color)
            gpu.gpu_draw_line(v0.screen_x as i32, v0.screen_y as i32,
                              v1.screen_x as i32, v1.screen_y as i32, color)
        } else {
            draw_line_interpolated(v0, v1)
        }

        i = i + 2
    }
}

fn rasterize_line_strip() {
    var i: u32 = 0
    while i + 1 < gl.vertex_count {
        let v0: *GLVertex = &gl.vertex_buffer[i]
        let v1: *GLVertex = &gl.vertex_buffer[i + 1]
        let color: u32 = color_to_u32(v1.color)
        gpu.gpu_draw_line(v0.screen_x as i32, v0.screen_y as i32,
                          v1.screen_x as i32, v1.screen_y as i32, color)
        i = i + 1
    }
}

fn rasterize_line_loop() {
    if gl.vertex_count < 2 { return }

    var i: u32 = 0
    while i < gl.vertex_count {
        let v0: *GLVertex = &gl.vertex_buffer[i]
        let v1: *GLVertex = &gl.vertex_buffer[(i + 1) % gl.vertex_count]
        let color: u32 = color_to_u32(v1.color)
        gpu.gpu_draw_line(v0.screen_x as i32, v0.screen_y as i32,
                          v1.screen_x as i32, v1.screen_y as i32, color)
        i = i + 1
    }
}

fn rasterize_triangles() {
    var i: u32 = 0
    while i + 2 < gl.vertex_count {
        let v0: *GLVertex = &gl.vertex_buffer[i]
        let v1: *GLVertex = &gl.vertex_buffer[i + 1]
        let v2: *GLVertex = &gl.vertex_buffer[i + 2]

        if not should_cull_triangle(v0, v1, v2) {
            rasterize_single_triangle(v0, v1, v2)
        }

        i = i + 3
    }
}

fn rasterize_triangle_strip() {
    var i: u32 = 0
    while i + 2 < gl.vertex_count {
        let v0: *GLVertex = &gl.vertex_buffer[i]
        let v1: *GLVertex = &gl.vertex_buffer[i + 1]
        let v2: *GLVertex = &gl.vertex_buffer[i + 2]

        // Alternate winding for triangle strip
        if (i & 1) == 0 {
            if not should_cull_triangle(v0, v1, v2) {
                rasterize_single_triangle(v0, v1, v2)
            }
        } else {
            if not should_cull_triangle(v0, v2, v1) {
                rasterize_single_triangle(v0, v2, v1)
            }
        }

        i = i + 1
    }
}

fn rasterize_triangle_fan() {
    if gl.vertex_count < 3 { return }

    let v0: *GLVertex = &gl.vertex_buffer[0]

    var i: u32 = 1
    while i + 1 < gl.vertex_count {
        let v1: *GLVertex = &gl.vertex_buffer[i]
        let v2: *GLVertex = &gl.vertex_buffer[i + 1]

        if not should_cull_triangle(v0, v1, v2) {
            rasterize_single_triangle(v0, v1, v2)
        }

        i = i + 1
    }
}

fn rasterize_quads() {
    var i: u32 = 0
    while i + 3 < gl.vertex_count {
        let v0: *GLVertex = &gl.vertex_buffer[i]
        let v1: *GLVertex = &gl.vertex_buffer[i + 1]
        let v2: *GLVertex = &gl.vertex_buffer[i + 2]
        let v3: *GLVertex = &gl.vertex_buffer[i + 3]

        // Render as two triangles
        if not should_cull_triangle(v0, v1, v2) {
            rasterize_single_triangle(v0, v1, v2)
        }
        if not should_cull_triangle(v0, v2, v3) {
            rasterize_single_triangle(v0, v2, v3)
        }

        i = i + 4
    }
}

fn rasterize_polygon() {
    if gl.vertex_count < 3 { return }

    // Render as triangle fan from first vertex
    let v0: *GLVertex = &gl.vertex_buffer[0]

    var i: u32 = 1
    while i + 1 < gl.vertex_count {
        let v1: *GLVertex = &gl.vertex_buffer[i]
        let v2: *GLVertex = &gl.vertex_buffer[i + 1]

        if not should_cull_triangle(v0, v1, v2) {
            rasterize_single_triangle(v0, v1, v2)
        }

        i = i + 1
    }
}

fn should_cull_triangle(v0: *GLVertex, v1: *GLVertex, v2: *GLVertex): bool {
    if gl.cull_face_enabled == 0 { return false }

    // Calculate signed area (determines winding)
    let area: f32 = (v1.screen_x - v0.screen_x) * (v2.screen_y - v0.screen_y) -
                    (v2.screen_x - v0.screen_x) * (v1.screen_y - v0.screen_y)

    // CCW winding has positive area
    let is_ccw: bool = area > 0.0

    if gl.cull_face_mode == GL_BACK {
        // Cull back faces (CW)
        return not is_ccw
    } else if gl.cull_face_mode == GL_FRONT {
        // Cull front faces (CCW)
        return is_ccw
    } else {
        // GL_FRONT_AND_BACK - cull all
        return true
    }
}

fn rasterize_single_triangle(v0: *GLVertex, v1: *GLVertex, v2: *GLVertex) {
    if gl.polygon_mode_front == GL_LINE or gl.polygon_mode_back == GL_LINE {
        // Wireframe mode
        let color: u32 = color_to_u32(v0.color)
        gpu.gpu_draw_triangle(
            v0.screen_x as i32, v0.screen_y as i32,
            v1.screen_x as i32, v1.screen_y as i32,
            v2.screen_x as i32, v2.screen_y as i32,
            color
        )
        return
    }

    if gl.polygon_mode_front == GL_POINT or gl.polygon_mode_back == GL_POINT {
        // Point mode
        let c0: u32 = color_to_u32(v0.color)
        let c1: u32 = color_to_u32(v1.color)
        let c2: u32 = color_to_u32(v2.color)
        gpu.gpu_draw_pixel(v0.screen_x as i32, v0.screen_y as i32, c0)
        gpu.gpu_draw_pixel(v1.screen_x as i32, v1.screen_y as i32, c1)
        gpu.gpu_draw_pixel(v2.screen_x as i32, v2.screen_y as i32, c2)
        return
    }

    // Filled triangle
    if gl.shade_model == GL_FLAT {
        // Use last vertex color
        let color: u32 = color_to_u32(v2.color)
        gpu.gpu_fill_triangle(
            v0.screen_x as i32, v0.screen_y as i32,
            v1.screen_x as i32, v1.screen_y as i32,
            v2.screen_x as i32, v2.screen_y as i32,
            color
        )
    } else if gl.texture_2d_enabled == 1 and gl.current_texture < MAX_TEXTURES {
        // Textured triangle
        gpu.gpu_fill_triangle_textured(
            v0.screen_x as i32, v0.screen_y as i32, v0.texcoord.x, v0.texcoord.y,
            v1.screen_x as i32, v1.screen_y as i32, v1.texcoord.x, v1.texcoord.y,
            v2.screen_x as i32, v2.screen_y as i32, v2.texcoord.x, v2.texcoord.y,
            gl.current_texture
        )
    } else {
        // Gouraud shaded (interpolate colors) - fall back to flat for now
        let color: u32 = color_to_u32(v0.color)
        gpu.gpu_fill_triangle(
            v0.screen_x as i32, v0.screen_y as i32,
            v1.screen_x as i32, v1.screen_y as i32,
            v2.screen_x as i32, v2.screen_y as i32,
            color
        )
    }
}

fn draw_line_interpolated(v0: *GLVertex, v1: *GLVertex) {
    // For now, use flat color (full Gouraud line would be more complex)
    let color: u32 = color_to_u32(v0.color)
    gpu.gpu_draw_line(v0.screen_x as i32, v0.screen_y as i32,
                      v1.screen_x as i32, v1.screen_y as i32, color)
}

// ============================================================================
// Texture Functions
// ============================================================================

export fn glGenTextures(n: u32, textures_out: *u32) {
    var count: u32 = 0
    var i: u32 = 0

    while i < MAX_TEXTURES and count < n {
        if textures[i].in_use == 0 {
            textures[i].in_use = 1
            textures[i].id = i
            textures[i].width = 0
            textures[i].height = 0
            textures[i].data = 0
            textures[i].min_filter = GL_NEAREST
            textures[i].mag_filter = GL_NEAREST
            textures[i].wrap_s = GL_REPEAT
            textures[i].wrap_t = GL_REPEAT

            let ptr: *u32 = (textures_out as u64 + count * 4) as *u32
            *ptr = i
            count = count + 1
        }
        i = i + 1
    }
}

export fn glDeleteTextures(n: u32, tex_ids: *u32) {
    var i: u32 = 0
    while i < n {
        let ptr: *u32 = (tex_ids as u64 + i * 4) as *u32
        let id: u32 = *ptr

        if id < MAX_TEXTURES and textures[id].in_use == 1 {
            if textures[id].data != 0 {
                memory.kfree(textures[id].data)
            }
            textures[id].in_use = 0
        }
        i = i + 1
    }
}

export fn glBindTexture(target: u32, texture: u32) {
    if target != GL_TEXTURE_2D { return }
    if texture >= MAX_TEXTURES { return }

    gl.current_texture = texture
}

export fn glTexImage2D(target: u32, level: u32, internal_format: u32,
                       width: i32, height: i32, border: i32,
                       format: u32, type_: u32, data: *u8) {
    if target != GL_TEXTURE_2D { return }
    if gl.current_texture >= MAX_TEXTURES { return }
    if level != 0 { return }  // No mipmaps for now

    let tex: *GLTexture = &textures[gl.current_texture]

    // Free old data
    if tex.data != 0 {
        memory.kfree(tex.data)
    }

    tex.width = width as u32
    tex.height = height as u32

    // Allocate and copy texture data (assume RGBA)
    let size: u64 = (width as u64) * (height as u64) * 4
    tex.data = memory.kmalloc(size)

    if tex.data != 0 and data != 0 as *u8 {
        memory.memcpy(tex.data as *u8, data, size)
    }

    // Create GPU texture
    let gpu_tex: i32 = gpu.gpu_create_texture(width as u32, height as u32, 0)  // RGBA8888
    if gpu_tex >= 0 and data != 0 as *u8 {
        gpu.gpu_update_texture(gpu_tex as u32, data, size)
    }
}

export fn glTexParameteri(target: u32, pname: u32, param: i32) {
    if target != GL_TEXTURE_2D { return }
    if gl.current_texture >= MAX_TEXTURES { return }

    let tex: *GLTexture = &textures[gl.current_texture]

    if pname == GL_TEXTURE_MIN_FILTER {
        tex.min_filter = param as u32
    } else if pname == GL_TEXTURE_MAG_FILTER {
        tex.mag_filter = param as u32
    } else if pname == GL_TEXTURE_WRAP_S {
        tex.wrap_s = param as u32
    } else if pname == GL_TEXTURE_WRAP_T {
        tex.wrap_t = param as u32
    }
}

// ============================================================================
// Fog Functions
// ============================================================================

export fn glFogi(pname: u32, param: i32) {
    if pname == GL_FOG_MODE {
        fog.mode = param as u32
    }
}

export fn glFogf(pname: u32, param: f32) {
    if pname == GL_FOG_DENSITY {
        fog.density = param
    } else if pname == GL_FOG_START {
        fog.start = param
    } else if pname == GL_FOG_END {
        fog.end = param
    }
}

export fn glFogfv(pname: u32, params: *f32) {
    if pname == GL_FOG_COLOR {
        fog.color.r = *params
        fog.color.g = *(params as u64 + 4) as *f32
        fog.color.b = *(params as u64 + 8) as *f32
        fog.color.a = *(params as u64 + 12) as *f32
    }
}

// ============================================================================
// Light Functions
// ============================================================================

export fn glLightfv(light: u32, pname: u32, params: *f32) {
    let idx: u32 = light - GL_LIGHT0
    if idx >= MAX_LIGHTS { return }

    if pname == GL_AMBIENT {
        lights[idx].ambient.r = *params
        lights[idx].ambient.g = *(params as u64 + 4) as *f32
        lights[idx].ambient.b = *(params as u64 + 8) as *f32
        lights[idx].ambient.a = *(params as u64 + 12) as *f32
    } else if pname == GL_DIFFUSE {
        lights[idx].diffuse.r = *params
        lights[idx].diffuse.g = *(params as u64 + 4) as *f32
        lights[idx].diffuse.b = *(params as u64 + 8) as *f32
        lights[idx].diffuse.a = *(params as u64 + 12) as *f32
    } else if pname == GL_SPECULAR {
        lights[idx].specular.r = *params
        lights[idx].specular.g = *(params as u64 + 4) as *f32
        lights[idx].specular.b = *(params as u64 + 8) as *f32
        lights[idx].specular.a = *(params as u64 + 12) as *f32
    } else if pname == GL_POSITION {
        lights[idx].position.x = *params
        lights[idx].position.y = *(params as u64 + 4) as *f32
        lights[idx].position.z = *(params as u64 + 8) as *f32
        lights[idx].position.w = *(params as u64 + 12) as *f32
    }
}

// ============================================================================
// Material Functions
// ============================================================================

export fn glMaterialfv(face: u32, pname: u32, params: *f32) {
    if pname == GL_AMBIENT {
        material.ambient.r = *params
        material.ambient.g = *(params as u64 + 4) as *f32
        material.ambient.b = *(params as u64 + 8) as *f32
        material.ambient.a = *(params as u64 + 12) as *f32
    } else if pname == GL_DIFFUSE {
        material.diffuse.r = *params
        material.diffuse.g = *(params as u64 + 4) as *f32
        material.diffuse.b = *(params as u64 + 8) as *f32
        material.diffuse.a = *(params as u64 + 12) as *f32
    } else if pname == GL_SPECULAR {
        material.specular.r = *params
        material.specular.g = *(params as u64 + 4) as *f32
        material.specular.b = *(params as u64 + 8) as *f32
        material.specular.a = *(params as u64 + 12) as *f32
    }
}

export fn glMaterialf(face: u32, pname: u32, param: f32) {
    if pname == GL_SHININESS {
        material.shininess = param
    }
}

// ============================================================================
// Blending
// ============================================================================

export fn glBlendFunc(sfactor: u32, dfactor: u32) {
    gl.blend_src = sfactor
    gl.blend_dst = dfactor

    // Map to GPU blend mode
    if sfactor == GL_SRC_ALPHA and dfactor == GL_ONE_MINUS_SRC_ALPHA {
        gpu.gpu_set_blend_mode(1)  // BLEND_ALPHA
    } else if sfactor == GL_ONE and dfactor == GL_ONE {
        gpu.gpu_set_blend_mode(2)  // BLEND_ADDITIVE
    } else {
        gpu.gpu_set_blend_mode(0)  // BLEND_NONE
    }
}

// ============================================================================
// Depth
// ============================================================================

export fn glDepthFunc(func: u32) {
    gl.depth_func = func
}

export fn glDepthMask(flag: u32) {
    // GPU handles this
}

// ============================================================================
// Culling
// ============================================================================

export fn glCullFace(mode: u32) {
    gl.cull_face_mode = mode
}

export fn glFrontFace(mode: u32) {
    gl.front_face = mode
}

// ============================================================================
// Polygon Mode
// ============================================================================

export fn glPolygonMode(face: u32, mode: u32) {
    if face == GL_FRONT or face == GL_FRONT_AND_BACK {
        gl.polygon_mode_front = mode
    }
    if face == GL_BACK or face == GL_FRONT_AND_BACK {
        gl.polygon_mode_back = mode
    }
}

export fn glShadeModel(mode: u32) {
    gl.shade_model = mode
}

// ============================================================================
// Buffer Swap
// ============================================================================

export fn glFlush() {
    gpu.gpu_present()
}

export fn glFinish() {
    gpu.gpu_present()
}

export fn glutSwapBuffers() {
    gpu.gpu_present()
}

// ============================================================================
// Utility Functions
// ============================================================================

export fn glGetError(): u32 {
    return 0  // GL_NO_ERROR
}

export fn glGetString(name: u32): *u8 {
    return "HomeOS OpenGL 1.1 Software Renderer" as *u8
}
