// home-os High-Resolution Timers
// Nanosecond precision timers with red-black tree scheduling

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "../sync/spinlock.home" as spinlock
import "clocksource.home" as clocksource

// Timer states
const HRTIMER_STATE_INACTIVE: u32 = 0
const HRTIMER_STATE_ENQUEUED: u32 = 1
const HRTIMER_STATE_CALLBACK: u32 = 2
const HRTIMER_STATE_MIGRATE: u32 = 4

// Timer modes
const HRTIMER_MODE_ABS: u32 = 0           // Absolute time
const HRTIMER_MODE_REL: u32 = 1           // Relative to now
const HRTIMER_MODE_PINNED: u32 = 2        // Don't migrate between CPUs
const HRTIMER_MODE_SOFT: u32 = 4          // Soft IRQ context
const HRTIMER_MODE_HARD: u32 = 8          // Hard IRQ context

// Callback return values
const HRTIMER_NORESTART: u32 = 0          // Don't restart
const HRTIMER_RESTART: u32 = 1            // Restart timer

// Timer clock bases
const HRTIMER_BASE_MONOTONIC: u32 = 0     // CLOCK_MONOTONIC
const HRTIMER_BASE_REALTIME: u32 = 1      // CLOCK_REALTIME
const HRTIMER_BASE_BOOTTIME: u32 = 2      // CLOCK_BOOTTIME
const HRTIMER_BASE_TAI: u32 = 3           // CLOCK_TAI
const HRTIMER_MAX_CLOCK_BASES: u32 = 4

// Maximum timers
const MAX_TIMERS: u32 = 256

// Red-black tree node color
const RB_RED: u32 = 0
const RB_BLACK: u32 = 1

// High-resolution timer
struct HrTimer {
    // Timing
    expires: u64,                 // Absolute expiration time (ns)
    softexpires: u64,             // Soft expiration (for range timers)
    interval: u64,                // For periodic timers

    // Callback
    callback: fn(*HrTimer): u32,  // Returns HRTIMER_RESTART or HRTIMER_NORESTART
    data: u64,                    // User data

    // Tree linkage
    rb_parent: u32,               // Parent node index
    rb_left: u32,                 // Left child index
    rb_right: u32,                // Right child index
    rb_color: u32,                // RB_RED or RB_BLACK

    // State
    state: u32,
    mode: u32,
    base: u32,                    // Clock base

    // Identity
    id: u32,
    active: u32
}

// Timer clock base
struct HrTimerClockBase {
    name: [16]u8,
    offset: i64,                  // Offset from monotonic
    resolution: u64,              // Minimum resolution (ns)
    running: *HrTimer,            // Currently running timer
    lock: spinlock.Spinlock
}

// CPU-local timer state
struct HrTimerCpuBase {
    bases: [HRTIMER_MAX_CLOCK_BASES]HrTimerClockBase,
    lock: spinlock.Spinlock,
    active_count: u32,
    clock_was_set: u32,
    nr_events: u64,
    nr_retries: u64,
    in_hrtirq: u32,
    hres_active: u32
}

// Timer pool
var timers: [MAX_TIMERS]HrTimer = undefined
var timer_used: [MAX_TIMERS]u32 = undefined

// Red-black tree root for each base (index into timers array, 0xFFFFFFFF = null)
var rb_roots: [HRTIMER_MAX_CLOCK_BASES]u32 = undefined
var rb_leftmost: [HRTIMER_MAX_CLOCK_BASES]u32 = undefined  // Cached leftmost (soonest to expire)

// CPU base
var cpu_base: HrTimerCpuBase = undefined

// Statistics
var total_starts: u64 = 0
var total_cancels: u64 = 0
var total_expires: u64 = 0
var total_restarts: u64 = 0

// Global lock
var hrtimer_lock: spinlock.Spinlock = undefined

// Null index
const NIL: u32 = 0xFFFFFFFF

// Get current time for clock base
fn get_base_time(base: u32): u64 {
    var mono: u64 = clocksource.clocksource_read_ns()

    if base == HRTIMER_BASE_MONOTONIC {
        return mono
    } else if base == HRTIMER_BASE_REALTIME {
        return mono + @bitCast(cpu_base.bases[HRTIMER_BASE_REALTIME].offset, u64)
    } else if base == HRTIMER_BASE_BOOTTIME {
        return mono + @bitCast(cpu_base.bases[HRTIMER_BASE_BOOTTIME].offset, u64)
    } else if base == HRTIMER_BASE_TAI {
        return mono + @bitCast(cpu_base.bases[HRTIMER_BASE_TAI].offset, u64)
    }

    return mono
}

// Allocate timer
fn alloc_timer(): u32 {
    var i: u32 = 0
    while i < MAX_TIMERS {
        if timer_used[i] == 0 {
            timer_used[i] = 1
            timers[i].id = i
            timers[i].active = 0
            timers[i].state = HRTIMER_STATE_INACTIVE
            timers[i].rb_parent = NIL
            timers[i].rb_left = NIL
            timers[i].rb_right = NIL
            timers[i].rb_color = RB_RED
            return i
        }
        i = i + 1
    }
    return NIL
}

// Free timer
fn free_timer(id: u32) {
    if id < MAX_TIMERS {
        timer_used[id] = 0
        timers[id].active = 0
    }
}

// Red-black tree: rotate left
fn rb_rotate_left(base: u32, x: u32) {
    var y: u32 = timers[x].rb_right
    timers[x].rb_right = timers[y].rb_left

    if timers[y].rb_left != NIL {
        timers[timers[y].rb_left].rb_parent = x
    }

    timers[y].rb_parent = timers[x].rb_parent

    if timers[x].rb_parent == NIL {
        rb_roots[base] = y
    } else if x == timers[timers[x].rb_parent].rb_left {
        timers[timers[x].rb_parent].rb_left = y
    } else {
        timers[timers[x].rb_parent].rb_right = y
    }

    timers[y].rb_left = x
    timers[x].rb_parent = y
}

// Red-black tree: rotate right
fn rb_rotate_right(base: u32, y: u32) {
    var x: u32 = timers[y].rb_left
    timers[y].rb_left = timers[x].rb_right

    if timers[x].rb_right != NIL {
        timers[timers[x].rb_right].rb_parent = y
    }

    timers[x].rb_parent = timers[y].rb_parent

    if timers[y].rb_parent == NIL {
        rb_roots[base] = x
    } else if y == timers[timers[y].rb_parent].rb_right {
        timers[timers[y].rb_parent].rb_right = x
    } else {
        timers[timers[y].rb_parent].rb_left = x
    }

    timers[x].rb_right = y
    timers[y].rb_parent = x
}

// Red-black tree: fix after insert
fn rb_insert_fixup(base: u32, z: u32) {
    while z != rb_roots[base] and timers[timers[z].rb_parent].rb_color == RB_RED {
        if timers[z].rb_parent == timers[timers[timers[z].rb_parent].rb_parent].rb_left {
            var y: u32 = timers[timers[timers[z].rb_parent].rb_parent].rb_right
            if y != NIL and timers[y].rb_color == RB_RED {
                timers[timers[z].rb_parent].rb_color = RB_BLACK
                timers[y].rb_color = RB_BLACK
                timers[timers[timers[z].rb_parent].rb_parent].rb_color = RB_RED
                z = timers[timers[z].rb_parent].rb_parent
            } else {
                if z == timers[timers[z].rb_parent].rb_right {
                    z = timers[z].rb_parent
                    rb_rotate_left(base, z)
                }
                timers[timers[z].rb_parent].rb_color = RB_BLACK
                timers[timers[timers[z].rb_parent].rb_parent].rb_color = RB_RED
                rb_rotate_right(base, timers[timers[z].rb_parent].rb_parent)
            }
        } else {
            var y: u32 = timers[timers[timers[z].rb_parent].rb_parent].rb_left
            if y != NIL and timers[y].rb_color == RB_RED {
                timers[timers[z].rb_parent].rb_color = RB_BLACK
                timers[y].rb_color = RB_BLACK
                timers[timers[timers[z].rb_parent].rb_parent].rb_color = RB_RED
                z = timers[timers[z].rb_parent].rb_parent
            } else {
                if z == timers[timers[z].rb_parent].rb_left {
                    z = timers[z].rb_parent
                    rb_rotate_right(base, z)
                }
                timers[timers[z].rb_parent].rb_color = RB_BLACK
                timers[timers[timers[z].rb_parent].rb_parent].rb_color = RB_RED
                rb_rotate_left(base, timers[timers[z].rb_parent].rb_parent)
            }
        }
    }

    timers[rb_roots[base]].rb_color = RB_BLACK
}

// Insert timer into tree
fn rb_insert(base: u32, timer_id: u32) {
    var y: u32 = NIL
    var x: u32 = rb_roots[base]
    var expires: u64 = timers[timer_id].expires

    // Find insertion point
    while x != NIL {
        y = x
        if expires < timers[x].expires {
            x = timers[x].rb_left
        } else {
            x = timers[x].rb_right
        }
    }

    timers[timer_id].rb_parent = y

    if y == NIL {
        rb_roots[base] = timer_id
    } else if expires < timers[y].expires {
        timers[y].rb_left = timer_id
    } else {
        timers[y].rb_right = timer_id
    }

    timers[timer_id].rb_left = NIL
    timers[timer_id].rb_right = NIL
    timers[timer_id].rb_color = RB_RED

    rb_insert_fixup(base, timer_id)

    // Update leftmost if this is the new minimum
    if rb_leftmost[base] == NIL or expires < timers[rb_leftmost[base]].expires {
        rb_leftmost[base] = timer_id
    }
}

// Find minimum node
fn rb_minimum(node: u32): u32 {
    var x: u32 = node
    while x != NIL and timers[x].rb_left != NIL {
        x = timers[x].rb_left
    }
    return x
}

// Transplant subtree
fn rb_transplant(base: u32, u: u32, v: u32) {
    if timers[u].rb_parent == NIL {
        rb_roots[base] = v
    } else if u == timers[timers[u].rb_parent].rb_left {
        timers[timers[u].rb_parent].rb_left = v
    } else {
        timers[timers[u].rb_parent].rb_right = v
    }
    if v != NIL {
        timers[v].rb_parent = timers[u].rb_parent
    }
}

// Remove timer from tree
fn rb_remove(base: u32, timer_id: u32) {
    var z: u32 = timer_id
    var y: u32 = z
    var x: u32 = NIL
    var y_original_color: u32 = timers[y].rb_color

    // Update leftmost cache
    if rb_leftmost[base] == timer_id {
        if timers[timer_id].rb_right != NIL {
            rb_leftmost[base] = rb_minimum(timers[timer_id].rb_right)
        } else {
            rb_leftmost[base] = timers[timer_id].rb_parent
        }
        if rb_leftmost[base] == NIL {
            // Tree will be empty
        }
    }

    if timers[z].rb_left == NIL {
        x = timers[z].rb_right
        rb_transplant(base, z, timers[z].rb_right)
    } else if timers[z].rb_right == NIL {
        x = timers[z].rb_left
        rb_transplant(base, z, timers[z].rb_left)
    } else {
        y = rb_minimum(timers[z].rb_right)
        y_original_color = timers[y].rb_color
        x = timers[y].rb_right

        if timers[y].rb_parent == z {
            if x != NIL {
                timers[x].rb_parent = y
            }
        } else {
            rb_transplant(base, y, timers[y].rb_right)
            timers[y].rb_right = timers[z].rb_right
            if timers[y].rb_right != NIL {
                timers[timers[y].rb_right].rb_parent = y
            }
        }

        rb_transplant(base, z, y)
        timers[y].rb_left = timers[z].rb_left
        if timers[y].rb_left != NIL {
            timers[timers[y].rb_left].rb_parent = y
        }
        timers[y].rb_color = timers[z].rb_color
    }

    // Would need delete fixup here for full RB tree correctness
    // Simplified for now
}

// Initialize hrtimer subsystem
export fn hrtimer_init() {
    foundation.serial_write_string("[HRTimer] Initializing high-resolution timers...\n")

    spinlock.spinlock_init(&hrtimer_lock)

    // Clear timer pool
    var i: u32 = 0
    while i < MAX_TIMERS {
        timer_used[i] = 0
        timers[i].active = 0
        timers[i].state = HRTIMER_STATE_INACTIVE
        i = i + 1
    }

    // Initialize clock bases
    i = 0
    while i < HRTIMER_MAX_CLOCK_BASES {
        rb_roots[i] = NIL
        rb_leftmost[i] = NIL

        spinlock.spinlock_init(&cpu_base.bases[i].lock)
        cpu_base.bases[i].offset = 0
        cpu_base.bases[i].resolution = 1000  // 1 microsecond default
        cpu_base.bases[i].running = null
        i = i + 1
    }

    // Set clock base names
    memory.memcpy(&cpu_base.bases[0].name[0], "monotonic", 9)
    memory.memcpy(&cpu_base.bases[1].name[0], "realtime", 8)
    memory.memcpy(&cpu_base.bases[2].name[0], "boottime", 8)
    memory.memcpy(&cpu_base.bases[3].name[0], "tai", 3)

    cpu_base.active_count = 0
    cpu_base.clock_was_set = 0
    cpu_base.nr_events = 0
    cpu_base.nr_retries = 0
    cpu_base.in_hrtirq = 0
    cpu_base.hres_active = 1

    spinlock.spinlock_init(&cpu_base.lock)

    total_starts = 0
    total_cancels = 0
    total_expires = 0
    total_restarts = 0

    foundation.serial_write_string("[HRTimer] High-resolution timers initialized\n")
}

// Create and initialize a timer
export fn hrtimer_create(callback: fn(*HrTimer): u32, data: u64, base: u32): u32 {
    spinlock.spinlock_acquire(&hrtimer_lock)

    var id: u32 = alloc_timer()
    if id == NIL {
        spinlock.spinlock_release(&hrtimer_lock)
        return NIL
    }

    timers[id].callback = callback
    timers[id].data = data
    timers[id].base = base
    timers[id].mode = HRTIMER_MODE_REL
    timers[id].interval = 0
    timers[id].expires = 0
    timers[id].softexpires = 0

    spinlock.spinlock_release(&hrtimer_lock)
    return id
}

// Start timer (nanoseconds)
export fn hrtimer_start(timer_id: u32, expires_ns: u64, mode: u32): u32 {
    if timer_id >= MAX_TIMERS or timer_used[timer_id] == 0 {
        return 1
    }

    spinlock.spinlock_acquire(&hrtimer_lock)

    var timer: *HrTimer = &timers[timer_id]
    var base: u32 = timer.base

    // Remove if already enqueued
    if timer.state == HRTIMER_STATE_ENQUEUED {
        rb_remove(base, timer_id)
        cpu_base.active_count = cpu_base.active_count - 1
    }

    // Calculate expiration time
    if (mode & HRTIMER_MODE_ABS) != 0 {
        timer.expires = expires_ns
    } else {
        var now: u64 = get_base_time(base)
        timer.expires = now + expires_ns
    }

    timer.softexpires = timer.expires
    timer.mode = mode
    timer.state = HRTIMER_STATE_ENQUEUED
    timer.active = 1

    // Insert into tree
    rb_insert(base, timer_id)
    cpu_base.active_count = cpu_base.active_count + 1

    total_starts = total_starts + 1

    spinlock.spinlock_release(&hrtimer_lock)

    // Reprogram hardware timer if this is the new earliest
    if rb_leftmost[base] == timer_id {
        program_next_event()
    }

    return 0
}

// Start periodic timer
export fn hrtimer_start_periodic(timer_id: u32, interval_ns: u64): u32 {
    if timer_id >= MAX_TIMERS or timer_used[timer_id] == 0 {
        return 1
    }

    timers[timer_id].interval = interval_ns
    return hrtimer_start(timer_id, interval_ns, HRTIMER_MODE_REL)
}

// Cancel timer
export fn hrtimer_cancel(timer_id: u32): u32 {
    if timer_id >= MAX_TIMERS or timer_used[timer_id] == 0 {
        return 1
    }

    spinlock.spinlock_acquire(&hrtimer_lock)

    var timer: *HrTimer = &timers[timer_id]

    if timer.state == HRTIMER_STATE_ENQUEUED {
        rb_remove(timer.base, timer_id)
        cpu_base.active_count = cpu_base.active_count - 1
    }

    timer.state = HRTIMER_STATE_INACTIVE
    timer.active = 0
    total_cancels = total_cancels + 1

    spinlock.spinlock_release(&hrtimer_lock)
    return 0
}

// Destroy timer
export fn hrtimer_destroy(timer_id: u32) {
    hrtimer_cancel(timer_id)

    spinlock.spinlock_acquire(&hrtimer_lock)
    free_timer(timer_id)
    spinlock.spinlock_release(&hrtimer_lock)
}

// Forward timer for periodic timers
fn hrtimer_forward(timer: *HrTimer, now: u64): u64 {
    if timer.interval == 0 {
        return 0
    }

    var overruns: u64 = 0

    if timer.expires < now {
        var delta: u64 = now - timer.expires
        overruns = delta / timer.interval + 1
        timer.expires = timer.expires + overruns * timer.interval
    }

    return overruns
}

// Run expired timers
fn run_expired_timers(base: u32) {
    var now: u64 = get_base_time(base)

    while rb_leftmost[base] != NIL {
        var timer_id: u32 = rb_leftmost[base]
        var timer: *HrTimer = &timers[timer_id]

        if timer.expires > now {
            break  // No more expired timers
        }

        // Remove from tree
        rb_remove(base, timer_id)
        cpu_base.active_count = cpu_base.active_count - 1

        timer.state = HRTIMER_STATE_CALLBACK
        cpu_base.bases[base].running = timer

        spinlock.spinlock_release(&hrtimer_lock)

        // Call the callback
        var restart: u32 = timer.callback(timer)

        spinlock.spinlock_acquire(&hrtimer_lock)

        cpu_base.bases[base].running = null
        total_expires = total_expires + 1
        cpu_base.nr_events = cpu_base.nr_events + 1

        if restart == HRTIMER_RESTART {
            // Periodic timer - reschedule
            now = get_base_time(base)
            hrtimer_forward(timer, now)
            timer.state = HRTIMER_STATE_ENQUEUED
            rb_insert(base, timer_id)
            cpu_base.active_count = cpu_base.active_count + 1
            total_restarts = total_restarts + 1
        } else {
            timer.state = HRTIMER_STATE_INACTIVE
            timer.active = 0
        }
    }
}

// Program hardware timer for next event
fn program_next_event() {
    var earliest: u64 = 0xFFFFFFFFFFFFFFFF
    var found: u32 = 0

    var i: u32 = 0
    while i < HRTIMER_MAX_CLOCK_BASES {
        if rb_leftmost[i] != NIL {
            var expires: u64 = timers[rb_leftmost[i]].expires
            if expires < earliest {
                earliest = expires
                found = 1
            }
        }
        i = i + 1
    }

    if found != 0 {
        clocksource.clocksource_set_next_event(earliest)
    }
}

// Timer tick handler (called from timer interrupt)
export fn hrtimer_tick() {
    spinlock.spinlock_acquire(&hrtimer_lock)

    cpu_base.in_hrtirq = 1

    // Process all clock bases
    var i: u32 = 0
    while i < HRTIMER_MAX_CLOCK_BASES {
        run_expired_timers(i)
        i = i + 1
    }

    cpu_base.in_hrtirq = 0

    // Schedule next event
    program_next_event()

    spinlock.spinlock_release(&hrtimer_lock)
}

// Get number of active timers
export fn hrtimer_get_active_count(): u32 {
    return cpu_base.active_count
}

// Get next expiration time
export fn hrtimer_get_next_expiry(): u64 {
    var earliest: u64 = 0xFFFFFFFFFFFFFFFF

    spinlock.spinlock_acquire(&hrtimer_lock)

    var i: u32 = 0
    while i < HRTIMER_MAX_CLOCK_BASES {
        if rb_leftmost[i] != NIL {
            var expires: u64 = timers[rb_leftmost[i]].expires
            if expires < earliest {
                earliest = expires
            }
        }
        i = i + 1
    }

    spinlock.spinlock_release(&hrtimer_lock)
    return earliest
}

// Check if timer is active
export fn hrtimer_is_active(timer_id: u32): u32 {
    if timer_id >= MAX_TIMERS {
        return 0
    }
    return timers[timer_id].active
}

// Check if timer is currently executing callback
export fn hrtimer_callback_running(timer_id: u32): u32 {
    if timer_id >= MAX_TIMERS {
        return 0
    }
    return timers[timer_id].state == HRTIMER_STATE_CALLBACK
}

// Get remaining time until expiration
export fn hrtimer_get_remaining(timer_id: u32): u64 {
    if timer_id >= MAX_TIMERS or timer_used[timer_id] == 0 {
        return 0
    }

    var timer: *HrTimer = &timers[timer_id]
    if timer.state != HRTIMER_STATE_ENQUEUED {
        return 0
    }

    var now: u64 = get_base_time(timer.base)
    if timer.expires <= now {
        return 0
    }

    return timer.expires - now
}

// Set clock offset (for REALTIME, TAI)
export fn hrtimer_set_offset(base: u32, offset_ns: i64) {
    if base >= HRTIMER_MAX_CLOCK_BASES {
        return
    }

    spinlock.spinlock_acquire(&cpu_base.bases[base].lock)
    cpu_base.bases[base].offset = offset_ns
    cpu_base.clock_was_set = 1
    spinlock.spinlock_release(&cpu_base.bases[base].lock)
}

// Get statistics
export fn hrtimer_get_stats(starts: *u64, cancels: *u64, expires: *u64, restarts: *u64) {
    @ptrDeref(starts) = total_starts
    @ptrDeref(cancels) = total_cancels
    @ptrDeref(expires) = total_expires
    @ptrDeref(restarts) = total_restarts
}

// Nanosleep implementation
export fn hrtimer_nanosleep(nsec: u64) {
    // Create a temporary timer that does nothing
    var timer_id: u32 = hrtimer_create(null, 0, HRTIMER_BASE_MONOTONIC)
    if timer_id == NIL {
        return
    }

    // Start with relative time
    hrtimer_start(timer_id, nsec, HRTIMER_MODE_REL)

    // Wait for expiration
    while hrtimer_is_active(timer_id) != 0 {
        foundation.hlt()
    }

    hrtimer_destroy(timer_id)
}

// Microsleep
export fn hrtimer_usleep(usec: u64) {
    hrtimer_nanosleep(usec * 1000)
}

// Millisleep
export fn hrtimer_msleep(msec: u64) {
    hrtimer_nanosleep(msec * 1000000)
}

// Get current monotonic time in nanoseconds
export fn hrtimer_get_ns(): u64 {
    return get_base_time(HRTIMER_BASE_MONOTONIC)
}

// Get resolution
export fn hrtimer_get_resolution(): u64 {
    return cpu_base.bases[HRTIMER_BASE_MONOTONIC].resolution
}
