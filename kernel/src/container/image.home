// home-os Kernel - Container Image Management
// OCI image format support

import "../core/foundation.home" as foundation
import "../core/filesystem.home" as filesystem
import "overlayfs.home" as overlayfs

const MAX_IMAGES: u32 = 256
const MAX_IMAGE_LAYERS: u32 = 128

struct ImageLayer {
  digest: [u8; 64],
  size: u64,
  path: [u8; 256]
}

struct Image {
  name: [u8; 256],
  tag: [u8; 64],
  digest: [u8; 64],
  layers: [ImageLayer; 128],
  layer_count: u32,
  size: u64,
  created: u64
}

var images: [Image; 256]
var image_count: u32 = 0

export fn image_init() {
  image_count = 0
  foundation.serial_write_string("[Image] Image manager initialized\n")
}

export fn image_pull(name: u64, tag: u64) -> u32 {
  foundation.serial_write_string("[Image] Pulling ")
  foundation.serial_write_string(name)
  foundation.serial_write_string(":")
  foundation.serial_write_string(tag)
  foundation.serial_write_string("\n")
  
  if image_count >= MAX_IMAGES { return 0xFFFFFFFF }
  
  var image_id: u32 = image_count
  
  // Copy name and tag
  image_copy_string(@ptrFromInt(images[image_id].name), name, 256)
  image_copy_string(@ptrFromInt(images[image_id].tag), tag, 64)
  
  images[image_id].layer_count = 0
  images[image_id].size = 0
  images[image_id].created = foundation.timer_get_ticks()
  
  // Download manifest
  // Download layers
  // Extract layers
  
  image_count = image_count + 1
  
  foundation.serial_write_string("[Image] Pulled successfully\n")
  
  return image_id
}

fn image_copy_string(dest: u64, src: u64, max_len: u32) {
  var i: u32 = 0
  while i < max_len - 1 {
    var ch: u8 = @intToPtr(src + i, u8)
    @intToPtr(dest + i, u8) = ch
    if ch == 0 { break }
    i = i + 1
  }
  @intToPtr(dest + i, u8) = 0
}

export fn image_build(dockerfile: u64, tag: u64) -> u32 {
  foundation.serial_write_string("[Image] Building from ")
  foundation.serial_write_string(dockerfile)
  foundation.serial_write_string("\n")
  
  // Parse Dockerfile
  // Execute build steps
  // Create layers
  // Tag image
  
  return 0
}

export fn image_list() {
  foundation.serial_write_string("\n[Image] Images:\n")
  foundation.serial_write_string("Repository                    Tag       Size      Created\n")
  foundation.serial_write_string("------------------------------------------------------------\n")
  
  var i: u32 = 0
  while i < image_count {
    foundation.serial_write_string(@ptrFromInt(images[i].name))
    foundation.serial_write_string("  ")
    foundation.serial_write_string(@ptrFromInt(images[i].tag))
    foundation.serial_write_string("  ")
    foundation.serial_write_hex(@truncate(images[i].size / (1024 * 1024), u32))
    foundation.serial_write_string(" MB  ")
    foundation.serial_write_hex(@truncate(images[i].created, u32))
    foundation.serial_write_string("\n")
    
    i = i + 1
  }
}

export fn image_remove(name: u64, tag: u64) -> u32 {
  foundation.serial_write_string("[Image] Removing ")
  foundation.serial_write_string(name)
  foundation.serial_write_string(":")
  foundation.serial_write_string(tag)
  foundation.serial_write_string("\n")
  
  // Find and remove image
  // Delete layers
  
  return 1
}

export fn image_export(image_id: u32, output_file: u64) -> u32 {
  if image_id >= image_count { return 0 }
  
  foundation.serial_write_string("[Image] Exporting to ")
  foundation.serial_write_string(output_file)
  foundation.serial_write_string("\n")
  
  // Create tar archive with layers
  
  return 1
}

export fn image_import(input_file: u64, name: u64, tag: u64) -> u32 {
  foundation.serial_write_string("[Image] Importing from ")
  foundation.serial_write_string(input_file)
  foundation.serial_write_string("\n")
  
  // Extract tar archive
  // Load layers
  // Register image
  
  return 0
}

export fn image_get_count() -> u32 {
  return image_count
}
