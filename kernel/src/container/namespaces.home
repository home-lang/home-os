// home-os Kernel - Namespaces
// Process isolation for containers

import "../core/foundation.home" as foundation

// Namespace types
const NS_PID: u32 = 1 << 0
const NS_MOUNT: u32 = 1 << 1
const NS_NETWORK: u32 = 1 << 2
const NS_UTS: u32 = 1 << 3
const NS_IPC: u32 = 1 << 4
const NS_USER: u32 = 1 << 5
const NS_CGROUP: u32 = 1 << 6

const MAX_NAMESPACES: u32 = 256

struct Namespace {
  id: u32,
  types: u32,
  pid_offset: u32,
  hostname: [u8; 64],
  domainname: [u8; 64],
  root_uid: u32,
  root_gid: u32,
  active: u32
}

var namespaces: [Namespace; 256]
var namespace_count: u32 = 0
var namespace_initialized: u32 = 0

export fn namespace_init() {
  if namespace_initialized == 1 { return }
  
  namespace_count = 0
  
  // Create root namespace
  namespace_create_root()
  
  namespace_initialized = 1
  foundation.serial_write_string("[Namespaces] Initialized\n")
}

fn namespace_create_root() -> u32 {
  var ns_id: u32 = namespace_count
  
  namespaces[ns_id].id = ns_id
  namespaces[ns_id].types = 0xFFFFFFFF  // All types
  namespaces[ns_id].pid_offset = 0
  namespaces[ns_id].root_uid = 0
  namespaces[ns_id].root_gid = 0
  namespaces[ns_id].active = 1
  
  // Set hostname
  var hostname: u64 = @ptrFromInt("home-os")
  var i: u32 = 0
  while i < 63 {
    var ch: u8 = @intToPtr(hostname + i, u8)
    namespaces[ns_id].hostname[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  
  namespace_count = namespace_count + 1
  
  return ns_id
}

export fn namespace_create() -> u32 {
  if namespace_count >= MAX_NAMESPACES { return 0xFFFFFFFF }
  
  var ns_id: u32 = namespace_count
  
  namespaces[ns_id].id = ns_id
  namespaces[ns_id].types = NS_PID | NS_MOUNT | NS_NETWORK | NS_UTS | NS_IPC
  namespaces[ns_id].pid_offset = ns_id * 10000  // Offset PIDs
  namespaces[ns_id].root_uid = 0
  namespaces[ns_id].root_gid = 0
  namespaces[ns_id].active = 1
  
  // Default hostname
  var hostname: u64 = @ptrFromInt("container")
  var i: u32 = 0
  while i < 63 {
    var ch: u8 = @intToPtr(hostname + i, u8)
    namespaces[ns_id].hostname[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  
  namespace_count = namespace_count + 1
  
  foundation.serial_write_string("[Namespaces] Created namespace ")
  foundation.serial_write_hex(ns_id)
  foundation.serial_write_string("\n")
  
  return ns_id
}

export fn namespace_enter(ns_id: u32) -> u32 {
  if ns_id >= namespace_count { return 0 }
  
  foundation.serial_write_string("[Namespaces] Entering namespace ")
  foundation.serial_write_hex(ns_id)
  foundation.serial_write_string("\n")
  
  // Set current namespace for process
  foundation.process_set_namespace(ns_id)
  
  return 1
}

export fn namespace_set_hostname(ns_id: u32, hostname: u64) -> u32 {
  if ns_id >= namespace_count { return 0 }
  
  var i: u32 = 0
  while i < 63 {
    var ch: u8 = @intToPtr(hostname + i, u8)
    namespaces[ns_id].hostname[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  namespaces[ns_id].hostname[i] = 0
  
  return 1
}

export fn namespace_get_hostname(ns_id: u32, hostname_out: u64) -> u32 {
  if ns_id >= namespace_count { return 0 }
  
  var i: u32 = 0
  while i < 64 {
    @intToPtr(hostname_out + i, u8) = namespaces[ns_id].hostname[i]
    if namespaces[ns_id].hostname[i] == 0 { break }
    i = i + 1
  }
  
  return 1
}

export fn namespace_map_pid(ns_id: u32, global_pid: u32) -> u32 {
  if ns_id >= namespace_count { return global_pid }
  
  // Map global PID to namespace PID
  if global_pid < namespaces[ns_id].pid_offset {
    return global_pid
  }
  
  return global_pid - namespaces[ns_id].pid_offset
}

export fn namespace_unmap_pid(ns_id: u32, ns_pid: u32) -> u32 {
  if ns_id >= namespace_count { return ns_pid }
  
  // Map namespace PID to global PID
  return ns_pid + namespaces[ns_id].pid_offset
}

export fn namespace_set_user_mapping(ns_id: u32, root_uid: u32, root_gid: u32) -> u32 {
  if ns_id >= namespace_count { return 0 }
  
  namespaces[ns_id].root_uid = root_uid
  namespaces[ns_id].root_gid = root_gid
  namespaces[ns_id].types = namespaces[ns_id].types | NS_USER
  
  return 1
}

export fn namespace_map_uid(ns_id: u32, uid: u32) -> u32 {
  if ns_id >= namespace_count { return uid }
  
  if (namespaces[ns_id].types & NS_USER) == 0 {
    return uid
  }
  
  // Simple mapping: root in namespace maps to configured UID
  if uid == 0 {
    return namespaces[ns_id].root_uid
  }
  
  return uid
}

export fn namespace_destroy(ns_id: u32) -> u32 {
  if ns_id >= namespace_count { return 0 }
  if ns_id == 0 { return 0 }  // Cannot destroy root namespace
  
  namespaces[ns_id].active = 0
  
  return 1
}

export fn namespace_get_count() -> u32 {
  return namespace_count
}
