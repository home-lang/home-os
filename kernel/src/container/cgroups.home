// home-os Kernel - Cgroups (Control Groups)
// Resource management and accounting for containers

import "../core/foundation.home" as foundation

// Cgroup subsystems
const CGROUP_CPU: u32 = 1 << 0
const CGROUP_MEMORY: u32 = 1 << 1
const CGROUP_IO: u32 = 1 << 2
const CGROUP_PIDS: u32 = 1 << 3
const CGROUP_NET: u32 = 1 << 4

const MAX_CGROUPS: u32 = 256
const MAX_PROCESSES_PER_CGROUP: u32 = 1024

struct CgroupLimits {
  cpu_shares: u32,
  cpu_quota: u64,
  cpu_period: u64,
  memory_limit: u64,
  memory_soft_limit: u64,
  io_weight: u32,
  io_max_bps: u64,
  pids_max: u32
}

struct CgroupStats {
  cpu_usage: u64,
  memory_usage: u64,
  io_read_bytes: u64,
  io_write_bytes: u64,
  pids_current: u32
}

struct Cgroup {
  name: [u8; 128],
  parent: u32,
  enabled_subsystems: u32,
  limits: CgroupLimits,
  stats: CgroupStats,
  processes: [u32; 1024],
  process_count: u32,
  active: u32
}

var cgroups: [Cgroup; 256]
var cgroup_count: u32 = 0
var cgroup_initialized: u32 = 0

export fn cgroup_init() {
  if cgroup_initialized == 1 { return }
  
  cgroup_count = 0
  
  // Create root cgroup
  cgroup_create(@ptrFromInt("/"), 0xFFFFFFFF)
  
  cgroup_initialized = 1
  foundation.serial_write_string("[Cgroups] Control groups initialized\n")
}

export fn cgroup_create(name: u64, parent: u32) -> u32 {
  if cgroup_count >= MAX_CGROUPS { return 0xFFFFFFFF }
  
  var cgroup_id: u32 = cgroup_count
  
  // Copy name
  var i: u32 = 0
  while i < 127 {
    var ch: u8 = @intToPtr(name + i, u8)
    cgroups[cgroup_id].name[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  cgroups[cgroup_id].name[i] = 0
  
  cgroups[cgroup_id].parent = parent
  cgroups[cgroup_id].enabled_subsystems = 0
  cgroups[cgroup_id].process_count = 0
  cgroups[cgroup_id].active = 1
  
  // Initialize limits (unlimited by default)
  cgroups[cgroup_id].limits.cpu_shares = 1024
  cgroups[cgroup_id].limits.cpu_quota = 0
  cgroups[cgroup_id].limits.cpu_period = 100000
  cgroups[cgroup_id].limits.memory_limit = 0
  cgroups[cgroup_id].limits.memory_soft_limit = 0
  cgroups[cgroup_id].limits.io_weight = 100
  cgroups[cgroup_id].limits.io_max_bps = 0
  cgroups[cgroup_id].limits.pids_max = 0
  
  // Initialize stats
  cgroups[cgroup_id].stats.cpu_usage = 0
  cgroups[cgroup_id].stats.memory_usage = 0
  cgroups[cgroup_id].stats.io_read_bytes = 0
  cgroups[cgroup_id].stats.io_write_bytes = 0
  cgroups[cgroup_id].stats.pids_current = 0
  
  cgroup_count = cgroup_count + 1
  
  foundation.serial_write_string("[Cgroups] Created cgroup: ")
  foundation.serial_write_string(name)
  foundation.serial_write_string("\n")
  
  return cgroup_id
}

export fn cgroup_add_process(cgroup_id: u32, pid: u32) -> u32 {
  if cgroup_id >= cgroup_count { return 0 }
  if cgroups[cgroup_id].process_count >= MAX_PROCESSES_PER_CGROUP { return 0 }
  
  // Check pids limit
  if cgroups[cgroup_id].limits.pids_max > 0 {
    if cgroups[cgroup_id].process_count >= cgroups[cgroup_id].limits.pids_max {
      return 0  // Limit exceeded
    }
  }
  
  cgroups[cgroup_id].processes[cgroups[cgroup_id].process_count] = pid
  cgroups[cgroup_id].process_count = cgroups[cgroup_id].process_count + 1
  cgroups[cgroup_id].stats.pids_current = cgroups[cgroup_id].process_count
  
  return 1
}

export fn cgroup_remove_process(cgroup_id: u32, pid: u32) -> u32 {
  if cgroup_id >= cgroup_count { return 0 }
  
  var i: u32 = 0
  while i < cgroups[cgroup_id].process_count {
    if cgroups[cgroup_id].processes[i] == pid {
      // Shift processes
      var j: u32 = i
      while j < cgroups[cgroup_id].process_count - 1 {
        cgroups[cgroup_id].processes[j] = cgroups[cgroup_id].processes[j + 1]
        j = j + 1
      }
      
      cgroups[cgroup_id].process_count = cgroups[cgroup_id].process_count - 1
      cgroups[cgroup_id].stats.pids_current = cgroups[cgroup_id].process_count
      
      return 1
    }
    i = i + 1
  }
  
  return 0
}

export fn cgroup_set_cpu_limit(cgroup_id: u32, shares: u32, quota: u64, period: u64) -> u32 {
  if cgroup_id >= cgroup_count { return 0 }
  
  cgroups[cgroup_id].limits.cpu_shares = shares
  cgroups[cgroup_id].limits.cpu_quota = quota
  cgroups[cgroup_id].limits.cpu_period = period
  cgroups[cgroup_id].enabled_subsystems = cgroups[cgroup_id].enabled_subsystems | CGROUP_CPU
  
  foundation.serial_write_string("[Cgroups] Set CPU limit for ")
  foundation.serial_write_string(@ptrFromInt(cgroups[cgroup_id].name))
  foundation.serial_write_string(": shares=")
  foundation.serial_write_hex(shares)
  foundation.serial_write_string("\n")
  
  return 1
}

export fn cgroup_set_memory_limit(cgroup_id: u32, limit: u64, soft_limit: u64) -> u32 {
  if cgroup_id >= cgroup_count { return 0 }
  
  cgroups[cgroup_id].limits.memory_limit = limit
  cgroups[cgroup_id].limits.memory_soft_limit = soft_limit
  cgroups[cgroup_id].enabled_subsystems = cgroups[cgroup_id].enabled_subsystems | CGROUP_MEMORY
  
  foundation.serial_write_string("[Cgroups] Set memory limit for ")
  foundation.serial_write_string(@ptrFromInt(cgroups[cgroup_id].name))
  foundation.serial_write_string(": ")
  foundation.serial_write_hex(@truncate(limit / (1024 * 1024), u32))
  foundation.serial_write_string(" MB\n")
  
  return 1
}

export fn cgroup_set_io_limit(cgroup_id: u32, weight: u32, max_bps: u64) -> u32 {
  if cgroup_id >= cgroup_count { return 0 }
  
  cgroups[cgroup_id].limits.io_weight = weight
  cgroups[cgroup_id].limits.io_max_bps = max_bps
  cgroups[cgroup_id].enabled_subsystems = cgroups[cgroup_id].enabled_subsystems | CGROUP_IO
  
  return 1
}

export fn cgroup_set_pids_limit(cgroup_id: u32, max_pids: u32) -> u32 {
  if cgroup_id >= cgroup_count { return 0 }
  
  cgroups[cgroup_id].limits.pids_max = max_pids
  cgroups[cgroup_id].enabled_subsystems = cgroups[cgroup_id].enabled_subsystems | CGROUP_PIDS
  
  return 1
}

export fn cgroup_check_memory_limit(cgroup_id: u32, requested: u64) -> u32 {
  if cgroup_id >= cgroup_count { return 1 }
  
  if cgroups[cgroup_id].limits.memory_limit == 0 {
    return 1  // No limit
  }
  
  if cgroups[cgroup_id].stats.memory_usage + requested > cgroups[cgroup_id].limits.memory_limit {
    return 0  // Would exceed limit
  }
  
  return 1
}

export fn cgroup_update_stats(cgroup_id: u32, cpu_usage: u64, memory_usage: u64, io_read: u64, io_write: u64) {
  if cgroup_id >= cgroup_count { return }
  
  cgroups[cgroup_id].stats.cpu_usage = cpu_usage
  cgroups[cgroup_id].stats.memory_usage = memory_usage
  cgroups[cgroup_id].stats.io_read_bytes = io_read
  cgroups[cgroup_id].stats.io_write_bytes = io_write
}

export fn cgroup_get_stats(cgroup_id: u32, stats_out: u64) -> u32 {
  if cgroup_id >= cgroup_count { return 0 }
  
  // Copy stats to output
  var stats_ptr: u64 = @ptrFromInt(cgroups[cgroup_id].stats)
  var i: u32 = 0
  while i < 40 {  // sizeof(CgroupStats)
    @intToPtr(stats_out + i, u8) = @intToPtr(stats_ptr + i, u8)
    i = i + 1
  }
  
  return 1
}

export fn cgroup_find(name: u64) -> u32 {
  var i: u32 = 0
  while i < cgroup_count {
    if cgroup_strcmp(@ptrFromInt(cgroups[i].name), name) == 1 {
      return i
    }
    i = i + 1
  }
  return 0xFFFFFFFF
}

fn cgroup_strcmp(s1: u64, s2: u64) -> u32 {
  var i: u32 = 0
  while 1 == 1 {
    var c1: u8 = @intToPtr(s1 + i, u8)
    var c2: u8 = @intToPtr(s2 + i, u8)
    
    if c1 != c2 { return 0 }
    if c1 == 0 { return 1 }
    
    i = i + 1
  }
  return 0
}

export fn cgroup_destroy(cgroup_id: u32) -> u32 {
  if cgroup_id >= cgroup_count { return 0 }
  if cgroup_id == 0 { return 0 }  // Cannot destroy root
  
  // Remove all processes
  cgroups[cgroup_id].process_count = 0
  cgroups[cgroup_id].active = 0
  
  return 1
}

export fn cgroup_get_count() -> u32 {
  return cgroup_count
}
