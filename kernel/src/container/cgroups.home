// home-os Kernel - Cgroups (Control Groups) v2
// Comprehensive resource management and accounting for containers

import "../core/foundation.home" as foundation

// Cgroup subsystem types (controllers)
const CGROUP_CPU: u32 = 1 << 0       // CPU controller
const CGROUP_CPUACCT: u32 = 1 << 1   // CPU accounting
const CGROUP_CPUSET: u32 = 1 << 2    // CPU/memory node pinning
const CGROUP_MEMORY: u32 = 1 << 3    // Memory controller
const CGROUP_IO: u32 = 1 << 4        // I/O controller
const CGROUP_PIDS: u32 = 1 << 5      // PID controller
const CGROUP_NET: u32 = 1 << 6       // Network controller
const CGROUP_DEVICES: u32 = 1 << 7   // Device access control
const CGROUP_FREEZER: u32 = 1 << 8   // Process freezer
const CGROUP_HUGETLB: u32 = 1 << 9   // HugeTLB controller
const CGROUP_RDMA: u32 = 1 << 10     // RDMA controller
const CGROUP_MISC: u32 = 1 << 11     // Miscellaneous controller

const CGROUP_ALL: u32 = 0xFFF

// Cgroup version
const CGROUP_V1: u32 = 1
const CGROUP_V2: u32 = 2

// Freezer states
const FREEZER_RUNNING: u32 = 0
const FREEZER_FREEZING: u32 = 1
const FREEZER_FROZEN: u32 = 2
const FREEZER_THAWED: u32 = 3

// Device access permissions
const DEV_ALLOW_READ: u32 = 1 << 0
const DEV_ALLOW_WRITE: u32 = 1 << 1
const DEV_ALLOW_MKNOD: u32 = 1 << 2
const DEV_DENY_ALL: u32 = 0
const DEV_ALLOW_ALL: u32 = 0x7

// Device types
const DEV_TYPE_ALL: u8 = 0
const DEV_TYPE_CHAR: u8 = 1
const DEV_TYPE_BLOCK: u8 = 2

const MAX_CGROUPS: u32 = 1024
const MAX_PROCESSES_PER_CGROUP: u32 = 4096
const MAX_CHILDREN: u32 = 64
const MAX_DEVICES: u32 = 64
const MAX_CPUS: u32 = 256
const MAX_MEMORY_NODES: u32 = 16

// CPU limits and accounting
struct CpuController {
  shares: u32,              // Relative weight (1-10000)
  cfs_quota_us: i64,        // Bandwidth limit (-1 = unlimited)
  cfs_period_us: u64,       // Bandwidth period (default 100000)
  rt_runtime_us: i64,       // Real-time bandwidth limit
  rt_period_us: u64,        // Real-time period

  // Accounting
  usage_usec: u64,          // Total CPU time used
  user_usec: u64,           // User mode CPU time
  system_usec: u64,         // Kernel mode CPU time
  nr_periods: u64,          // Number of periods elapsed
  nr_throttled: u64,        // Number of times throttled
  throttled_usec: u64       // Total time spent throttled
}

// CPU set controller
struct CpusetController {
  cpus: [u8; 32],           // Bitmask of allowed CPUs (up to 256)
  mems: [u8; 2],            // Bitmask of allowed memory nodes (up to 16)
  cpu_exclusive: u32,       // Exclusive CPU access
  mem_exclusive: u32,       // Exclusive memory access
  mem_hardwall: u32,        // Memory hardwall mode
  sched_load_balance: u32,  // Enable load balancing
  effective_cpus: u32,      // Number of effective CPUs
  effective_mems: u32       // Number of effective memory nodes
}

// Memory controller
struct MemoryController {
  // Limits
  limit_bytes: u64,         // Hard memory limit
  soft_limit_bytes: u64,    // Soft limit for reclaim
  swap_limit_bytes: u64,    // Swap limit
  memsw_limit_bytes: u64,   // Memory + swap limit
  kmem_limit_bytes: u64,    // Kernel memory limit
  tcpmem_limit_bytes: u64,  // TCP buffer limit

  // High/Low watermarks
  high_bytes: u64,          // Memory pressure starts
  low_bytes: u64,           // Memory is protected below this
  min_bytes: u64,           // Memory is always protected

  // Accounting
  current_bytes: u64,       // Current memory usage
  swap_current_bytes: u64,  // Current swap usage
  kmem_current_bytes: u64,  // Kernel memory usage
  anon_bytes: u64,          // Anonymous memory
  file_bytes: u64,          // File-backed memory
  kernel_stack_bytes: u64,  // Kernel stack usage
  slab_bytes: u64,          // Slab allocator usage

  // Events
  oom_kill: u64,            // OOM kill events
  oom_kill_disable: u32,    // Disable OOM killer
  under_oom: u32,           // Currently under OOM
  max_usage_bytes: u64,     // Peak memory usage
  failcnt: u64              // Allocation failures
}

// I/O controller
struct IoController {
  weight: u32,              // Relative weight (1-10000)

  // Per-device limits (simplified - just track max values)
  max_rbps: u64,            // Max read bytes/sec
  max_wbps: u64,            // Max write bytes/sec
  max_riops: u64,           // Max read IOPS
  max_wiops: u64,           // Max write IOPS

  // Accounting
  read_bytes: u64,          // Total bytes read
  write_bytes: u64,         // Total bytes written
  read_ios: u64,            // Total read operations
  write_ios: u64,           // Total write operations
  discard_bytes: u64,       // Total bytes discarded
  discard_ios: u64          // Total discard operations
}

// PID controller
struct PidsController {
  max: u32,                 // Maximum number of tasks
  current: u32,             // Current number of tasks
  peak: u32,                // Peak number of tasks
  events_max: u64           // Times limit was hit
}

// Network controller
struct NetController {
  classid: u32,             // Network class ID for tc
  priority: u32,            // Network priority

  // Accounting
  rx_bytes: u64,            // Bytes received
  tx_bytes: u64,            // Bytes transmitted
  rx_packets: u64,          // Packets received
  tx_packets: u64           // Packets transmitted
}

// Device entry for device controller
struct DeviceEntry {
  dev_type: u8,             // c (char), b (block), a (all)
  major: u32,               // Major device number
  minor: u32,               // Minor device number
  permissions: u32,         // r, w, m flags
  valid: u32
}

// Device controller
struct DevicesController {
  default_allow: u32,       // Default policy (allow or deny)
  devices: [DeviceEntry; 64],
  device_count: u32
}

// Freezer controller
struct FreezerController {
  state: u32,               // Current state
  self_freezing: u32,       // Self-freezing requested
  parent_freezing: u32      // Parent is frozen
}

// HugeTLB controller
struct HugetlbController {
  limit_2mb: u64,           // 2MB huge page limit
  limit_1gb: u64,           // 1GB huge page limit
  usage_2mb: u64,           // Current 2MB usage
  usage_1gb: u64,           // Current 1GB usage
  max_2mb: u64,             // Peak 2MB usage
  max_1gb: u64,             // Peak 1GB usage
  failcnt_2mb: u64,         // 2MB allocation failures
  failcnt_1gb: u64          // 1GB allocation failures
}

// Full cgroup structure
struct Cgroup {
  id: u32,
  name: [u8; 256],
  parent: u32,
  children: [u32; 64],
  child_count: u32,

  // Version and enabled controllers
  version: u32,
  enabled_controllers: u32,
  subtree_control: u32,      // Controllers delegated to children

  // Controllers
  cpu: CpuController,
  cpuset: CpusetController,
  memory: MemoryController,
  io: IoController,
  pids: PidsController,
  net: NetController,
  devices: DevicesController,
  freezer: FreezerController,
  hugetlb: HugetlbController,

  // Process tracking
  processes: [u32; 4096],
  process_count: u32,
  threaded: u32,             // Threaded mode (cgroup v2)

  // State
  active: u32,
  populated: u32,            // Has processes (directly or descendants)
  notify_on_release: u32,    // Notify on last process exit
  release_agent_path: [u8; 256]
}

var cgroups: [Cgroup; 1024]
var cgroup_count: u32 = 0
var cgroup_initialized: u32 = 0
var default_cgroup_version: u32 = CGROUP_V2

// Statistics
struct CgroupStats {
  total_created: u64,
  total_destroyed: u64,
  max_depth: u32,
  total_processes: u32
}

var cg_stats: CgroupStats

export fn cgroup_init() {
  if cgroup_initialized == 1 { return }

  cgroup_count = 0

  // Clear stats
  cg_stats.total_created = 0
  cg_stats.total_destroyed = 0
  cg_stats.max_depth = 0
  cg_stats.total_processes = 0

  // Create root cgroup
  cgroup_create_root()

  cgroup_initialized = 1
  foundation.serial_write_string("[Cgroups] Control groups initialized (v2 unified hierarchy)\n")
}

fn cgroup_create_root(): u32 {
  var cg_id: u32 = cgroup_count

  cgroups[cg_id].id = cg_id
  cgroup_set_name(cg_id, "/", 1)
  cgroups[cg_id].parent = 0xFFFFFFFF  // No parent
  cgroups[cg_id].child_count = 0
  cgroups[cg_id].version = default_cgroup_version
  cgroups[cg_id].enabled_controllers = CGROUP_ALL
  cgroups[cg_id].subtree_control = CGROUP_ALL

  // Initialize CPU controller
  cgroups[cg_id].cpu.shares = 1024
  cgroups[cg_id].cpu.cfs_quota_us = -1  // Unlimited
  cgroups[cg_id].cpu.cfs_period_us = 100000
  cgroups[cg_id].cpu.rt_runtime_us = 0
  cgroups[cg_id].cpu.rt_period_us = 1000000
  cgroups[cg_id].cpu.usage_usec = 0
  cgroups[cg_id].cpu.user_usec = 0
  cgroups[cg_id].cpu.system_usec = 0
  cgroups[cg_id].cpu.nr_periods = 0
  cgroups[cg_id].cpu.nr_throttled = 0
  cgroups[cg_id].cpu.throttled_usec = 0

  // Initialize cpuset controller - all CPUs and memory nodes
  var i: u32 = 0
  while i < 32 {
    cgroups[cg_id].cpuset.cpus[i] = 0xFF  // All CPUs enabled
    i = i + 1
  }
  cgroups[cg_id].cpuset.mems[0] = 0xFF
  cgroups[cg_id].cpuset.mems[1] = 0xFF
  cgroups[cg_id].cpuset.cpu_exclusive = 0
  cgroups[cg_id].cpuset.mem_exclusive = 0
  cgroups[cg_id].cpuset.mem_hardwall = 0
  cgroups[cg_id].cpuset.sched_load_balance = 1
  cgroups[cg_id].cpuset.effective_cpus = 256
  cgroups[cg_id].cpuset.effective_mems = 16

  // Initialize memory controller - unlimited
  cgroups[cg_id].memory.limit_bytes = 0xFFFFFFFFFFFFFFFF
  cgroups[cg_id].memory.soft_limit_bytes = 0xFFFFFFFFFFFFFFFF
  cgroups[cg_id].memory.swap_limit_bytes = 0xFFFFFFFFFFFFFFFF
  cgroups[cg_id].memory.memsw_limit_bytes = 0xFFFFFFFFFFFFFFFF
  cgroups[cg_id].memory.kmem_limit_bytes = 0xFFFFFFFFFFFFFFFF
  cgroups[cg_id].memory.tcpmem_limit_bytes = 0xFFFFFFFFFFFFFFFF
  cgroups[cg_id].memory.high_bytes = 0xFFFFFFFFFFFFFFFF
  cgroups[cg_id].memory.low_bytes = 0
  cgroups[cg_id].memory.min_bytes = 0
  cgroups[cg_id].memory.current_bytes = 0
  cgroups[cg_id].memory.swap_current_bytes = 0
  cgroups[cg_id].memory.kmem_current_bytes = 0
  cgroups[cg_id].memory.anon_bytes = 0
  cgroups[cg_id].memory.file_bytes = 0
  cgroups[cg_id].memory.kernel_stack_bytes = 0
  cgroups[cg_id].memory.slab_bytes = 0
  cgroups[cg_id].memory.oom_kill = 0
  cgroups[cg_id].memory.oom_kill_disable = 0
  cgroups[cg_id].memory.under_oom = 0
  cgroups[cg_id].memory.max_usage_bytes = 0
  cgroups[cg_id].memory.failcnt = 0

  // Initialize I/O controller
  cgroups[cg_id].io.weight = 100
  cgroups[cg_id].io.max_rbps = 0xFFFFFFFFFFFFFFFF
  cgroups[cg_id].io.max_wbps = 0xFFFFFFFFFFFFFFFF
  cgroups[cg_id].io.max_riops = 0xFFFFFFFFFFFFFFFF
  cgroups[cg_id].io.max_wiops = 0xFFFFFFFFFFFFFFFF
  cgroups[cg_id].io.read_bytes = 0
  cgroups[cg_id].io.write_bytes = 0
  cgroups[cg_id].io.read_ios = 0
  cgroups[cg_id].io.write_ios = 0
  cgroups[cg_id].io.discard_bytes = 0
  cgroups[cg_id].io.discard_ios = 0

  // Initialize pids controller
  cgroups[cg_id].pids.max = 0xFFFFFFFF  // Unlimited
  cgroups[cg_id].pids.current = 0
  cgroups[cg_id].pids.peak = 0
  cgroups[cg_id].pids.events_max = 0

  // Initialize net controller
  cgroups[cg_id].net.classid = 0
  cgroups[cg_id].net.priority = 0
  cgroups[cg_id].net.rx_bytes = 0
  cgroups[cg_id].net.tx_bytes = 0
  cgroups[cg_id].net.rx_packets = 0
  cgroups[cg_id].net.tx_packets = 0

  // Initialize devices controller - allow all by default for root
  cgroups[cg_id].devices.default_allow = 1
  cgroups[cg_id].devices.device_count = 0

  // Initialize freezer controller
  cgroups[cg_id].freezer.state = FREEZER_RUNNING
  cgroups[cg_id].freezer.self_freezing = 0
  cgroups[cg_id].freezer.parent_freezing = 0

  // Initialize hugetlb controller
  cgroups[cg_id].hugetlb.limit_2mb = 0xFFFFFFFFFFFFFFFF
  cgroups[cg_id].hugetlb.limit_1gb = 0xFFFFFFFFFFFFFFFF
  cgroups[cg_id].hugetlb.usage_2mb = 0
  cgroups[cg_id].hugetlb.usage_1gb = 0
  cgroups[cg_id].hugetlb.max_2mb = 0
  cgroups[cg_id].hugetlb.max_1gb = 0
  cgroups[cg_id].hugetlb.failcnt_2mb = 0
  cgroups[cg_id].hugetlb.failcnt_1gb = 0

  cgroups[cg_id].process_count = 0
  cgroups[cg_id].threaded = 0
  cgroups[cg_id].active = 1
  cgroups[cg_id].populated = 0
  cgroups[cg_id].notify_on_release = 0

  cgroup_count = cgroup_count + 1
  cg_stats.total_created = cg_stats.total_created + 1

  return cg_id
}

// Create a new cgroup
export fn cgroup_create(name: u64, parent: u32): u32 {
  if cgroup_count >= MAX_CGROUPS { return 0xFFFFFFFF }
  if parent >= cgroup_count && parent != 0xFFFFFFFF { return 0xFFFFFFFF }
  if parent != 0xFFFFFFFF && cgroups[parent].child_count >= MAX_CHILDREN { return 0xFFFFFFFF }

  var cg_id: u32 = cgroup_count
  var parent_id: u32 = parent
  if parent_id == 0xFFFFFFFF { parent_id = 0 }

  cgroups[cg_id].id = cg_id

  // Copy name
  var i: u32 = 0
  while i < 255 {
    var ch: u8 = @intToPtr(name + i, u8)
    cgroups[cg_id].name[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  cgroups[cg_id].name[i] = 0

  cgroups[cg_id].parent = parent_id
  cgroups[cg_id].child_count = 0
  cgroups[cg_id].version = cgroups[parent_id].version
  cgroups[cg_id].enabled_controllers = cgroups[parent_id].subtree_control
  cgroups[cg_id].subtree_control = 0  // Children get none by default

  // Add to parent's children
  cgroups[parent_id].children[cgroups[parent_id].child_count] = cg_id
  cgroups[parent_id].child_count = cgroups[parent_id].child_count + 1

  // Inherit controller settings from parent
  cgroup_inherit_controllers(cg_id, parent_id)

  cgroups[cg_id].process_count = 0
  cgroups[cg_id].threaded = 0
  cgroups[cg_id].active = 1
  cgroups[cg_id].populated = 0
  cgroups[cg_id].notify_on_release = 0

  cgroup_count = cgroup_count + 1
  cg_stats.total_created = cg_stats.total_created + 1

  // Update max depth
  var depth: u32 = cgroup_get_depth(cg_id)
  if depth > cg_stats.max_depth {
    cg_stats.max_depth = depth
  }

  foundation.serial_write_string("[Cgroups] Created: ")
  foundation.serial_write_string(name)
  foundation.serial_write_string("\n")

  return cg_id
}

fn cgroup_inherit_controllers(cg_id: u32, parent_id: u32) {
  // CPU controller - inherit defaults
  cgroups[cg_id].cpu.shares = 1024
  cgroups[cg_id].cpu.cfs_quota_us = -1
  cgroups[cg_id].cpu.cfs_period_us = cgroups[parent_id].cpu.cfs_period_us
  cgroups[cg_id].cpu.rt_runtime_us = 0
  cgroups[cg_id].cpu.rt_period_us = cgroups[parent_id].cpu.rt_period_us
  cgroups[cg_id].cpu.usage_usec = 0
  cgroups[cg_id].cpu.user_usec = 0
  cgroups[cg_id].cpu.system_usec = 0
  cgroups[cg_id].cpu.nr_periods = 0
  cgroups[cg_id].cpu.nr_throttled = 0
  cgroups[cg_id].cpu.throttled_usec = 0

  // cpuset - inherit from parent
  var i: u32 = 0
  while i < 32 {
    cgroups[cg_id].cpuset.cpus[i] = cgroups[parent_id].cpuset.cpus[i]
    i = i + 1
  }
  cgroups[cg_id].cpuset.mems[0] = cgroups[parent_id].cpuset.mems[0]
  cgroups[cg_id].cpuset.mems[1] = cgroups[parent_id].cpuset.mems[1]
  cgroups[cg_id].cpuset.cpu_exclusive = 0
  cgroups[cg_id].cpuset.mem_exclusive = 0
  cgroups[cg_id].cpuset.mem_hardwall = 0
  cgroups[cg_id].cpuset.sched_load_balance = 1
  cgroups[cg_id].cpuset.effective_cpus = cgroups[parent_id].cpuset.effective_cpus
  cgroups[cg_id].cpuset.effective_mems = cgroups[parent_id].cpuset.effective_mems

  // Memory - inherit limits from parent
  cgroups[cg_id].memory.limit_bytes = cgroups[parent_id].memory.limit_bytes
  cgroups[cg_id].memory.soft_limit_bytes = cgroups[parent_id].memory.soft_limit_bytes
  cgroups[cg_id].memory.swap_limit_bytes = cgroups[parent_id].memory.swap_limit_bytes
  cgroups[cg_id].memory.memsw_limit_bytes = cgroups[parent_id].memory.memsw_limit_bytes
  cgroups[cg_id].memory.kmem_limit_bytes = cgroups[parent_id].memory.kmem_limit_bytes
  cgroups[cg_id].memory.tcpmem_limit_bytes = cgroups[parent_id].memory.tcpmem_limit_bytes
  cgroups[cg_id].memory.high_bytes = cgroups[parent_id].memory.high_bytes
  cgroups[cg_id].memory.low_bytes = 0
  cgroups[cg_id].memory.min_bytes = 0
  cgroups[cg_id].memory.current_bytes = 0
  cgroups[cg_id].memory.swap_current_bytes = 0
  cgroups[cg_id].memory.kmem_current_bytes = 0
  cgroups[cg_id].memory.anon_bytes = 0
  cgroups[cg_id].memory.file_bytes = 0
  cgroups[cg_id].memory.kernel_stack_bytes = 0
  cgroups[cg_id].memory.slab_bytes = 0
  cgroups[cg_id].memory.oom_kill = 0
  cgroups[cg_id].memory.oom_kill_disable = 0
  cgroups[cg_id].memory.under_oom = 0
  cgroups[cg_id].memory.max_usage_bytes = 0
  cgroups[cg_id].memory.failcnt = 0

  // I/O controller
  cgroups[cg_id].io.weight = 100
  cgroups[cg_id].io.max_rbps = cgroups[parent_id].io.max_rbps
  cgroups[cg_id].io.max_wbps = cgroups[parent_id].io.max_wbps
  cgroups[cg_id].io.max_riops = cgroups[parent_id].io.max_riops
  cgroups[cg_id].io.max_wiops = cgroups[parent_id].io.max_wiops
  cgroups[cg_id].io.read_bytes = 0
  cgroups[cg_id].io.write_bytes = 0
  cgroups[cg_id].io.read_ios = 0
  cgroups[cg_id].io.write_ios = 0
  cgroups[cg_id].io.discard_bytes = 0
  cgroups[cg_id].io.discard_ios = 0

  // PIDs controller
  cgroups[cg_id].pids.max = cgroups[parent_id].pids.max
  cgroups[cg_id].pids.current = 0
  cgroups[cg_id].pids.peak = 0
  cgroups[cg_id].pids.events_max = 0

  // Network controller
  cgroups[cg_id].net.classid = 0
  cgroups[cg_id].net.priority = 0
  cgroups[cg_id].net.rx_bytes = 0
  cgroups[cg_id].net.tx_bytes = 0
  cgroups[cg_id].net.rx_packets = 0
  cgroups[cg_id].net.tx_packets = 0

  // Devices controller - inherit permissions
  cgroups[cg_id].devices.default_allow = cgroups[parent_id].devices.default_allow
  cgroups[cg_id].devices.device_count = 0

  // Freezer
  cgroups[cg_id].freezer.state = cgroups[parent_id].freezer.state
  cgroups[cg_id].freezer.self_freezing = 0
  cgroups[cg_id].freezer.parent_freezing = cgroups[parent_id].freezer.state == FREEZER_FROZEN ? 1 : 0

  // HugeTLB
  cgroups[cg_id].hugetlb.limit_2mb = cgroups[parent_id].hugetlb.limit_2mb
  cgroups[cg_id].hugetlb.limit_1gb = cgroups[parent_id].hugetlb.limit_1gb
  cgroups[cg_id].hugetlb.usage_2mb = 0
  cgroups[cg_id].hugetlb.usage_1gb = 0
  cgroups[cg_id].hugetlb.max_2mb = 0
  cgroups[cg_id].hugetlb.max_1gb = 0
  cgroups[cg_id].hugetlb.failcnt_2mb = 0
  cgroups[cg_id].hugetlb.failcnt_1gb = 0
}

// Add process to cgroup
export fn cgroup_add_process(cg_id: u32, pid: u32): u32 {
  if cg_id >= cgroup_count { return 0 }
  if cgroups[cg_id].active == 0 { return 0 }
  if cgroups[cg_id].process_count >= MAX_PROCESSES_PER_CGROUP { return 0 }

  // Check pids limit
  if (cgroups[cg_id].enabled_controllers & CGROUP_PIDS) != 0 {
    var total_pids: u32 = cgroup_count_pids(cg_id)
    if cgroups[cg_id].pids.max != 0xFFFFFFFF && total_pids >= cgroups[cg_id].pids.max {
      cgroups[cg_id].pids.events_max = cgroups[cg_id].pids.events_max + 1
      return 0  // Limit exceeded
    }
  }

  // Check if frozen
  if (cgroups[cg_id].enabled_controllers & CGROUP_FREEZER) != 0 {
    if cgroups[cg_id].freezer.state == FREEZER_FROZEN {
      return 0  // Cannot add to frozen cgroup
    }
  }

  cgroups[cg_id].processes[cgroups[cg_id].process_count] = pid
  cgroups[cg_id].process_count = cgroups[cg_id].process_count + 1

  // Update pids controller
  cgroups[cg_id].pids.current = cgroups[cg_id].process_count
  if cgroups[cg_id].pids.current > cgroups[cg_id].pids.peak {
    cgroups[cg_id].pids.peak = cgroups[cg_id].pids.current
  }

  // Mark as populated
  cgroups[cg_id].populated = 1
  cg_stats.total_processes = cg_stats.total_processes + 1

  return 1
}

// Remove process from cgroup
export fn cgroup_remove_process(cg_id: u32, pid: u32): u32 {
  if cg_id >= cgroup_count { return 0 }

  var i: u32 = 0
  while i < cgroups[cg_id].process_count {
    if cgroups[cg_id].processes[i] == pid {
      // Shift remaining
      var j: u32 = i
      while j < cgroups[cg_id].process_count - 1 {
        cgroups[cg_id].processes[j] = cgroups[cg_id].processes[j + 1]
        j = j + 1
      }

      cgroups[cg_id].process_count = cgroups[cg_id].process_count - 1
      cgroups[cg_id].pids.current = cgroups[cg_id].process_count

      if cg_stats.total_processes > 0 {
        cg_stats.total_processes = cg_stats.total_processes - 1
      }

      // Update populated status
      if cgroups[cg_id].process_count == 0 && cgroups[cg_id].child_count == 0 {
        cgroups[cg_id].populated = 0

        // Trigger notify_on_release if set
        if cgroups[cg_id].notify_on_release == 1 {
          cgroup_notify_release(cg_id)
        }
      }

      return 1
    }
    i = i + 1
  }

  return 0
}

// CPU controller: set weight/shares
export fn cgroup_set_cpu_shares(cg_id: u32, shares: u32): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_CPU) == 0 { return 0 }

  cgroups[cg_id].cpu.shares = shares
  return 1
}

// CPU controller: set bandwidth limit
export fn cgroup_set_cpu_quota(cg_id: u32, quota_us: i64, period_us: u64): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_CPU) == 0 { return 0 }

  cgroups[cg_id].cpu.cfs_quota_us = quota_us
  cgroups[cg_id].cpu.cfs_period_us = period_us

  foundation.serial_write_string("[Cgroups] CPU quota set for ")
  foundation.serial_write_string(@ptrFromInt(cgroups[cg_id].name))
  foundation.serial_write_string("\n")

  return 1
}

// CPU controller: update accounting
export fn cgroup_cpu_charge(cg_id: u32, usage_usec: u64, user_usec: u64, system_usec: u64) {
  if cg_id >= cgroup_count { return }

  cgroups[cg_id].cpu.usage_usec = cgroups[cg_id].cpu.usage_usec + usage_usec
  cgroups[cg_id].cpu.user_usec = cgroups[cg_id].cpu.user_usec + user_usec
  cgroups[cg_id].cpu.system_usec = cgroups[cg_id].cpu.system_usec + system_usec

  // Propagate to parent
  if cgroups[cg_id].parent != 0xFFFFFFFF {
    cgroup_cpu_charge(cgroups[cg_id].parent, usage_usec, user_usec, system_usec)
  }
}

// CPU controller: check if throttled
export fn cgroup_cpu_should_throttle(cg_id: u32): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_CPU) == 0 { return 0 }

  if cgroups[cg_id].cpu.cfs_quota_us < 0 { return 0 }  // Unlimited

  // Check if quota exceeded for current period
  var period_usage: u64 = cgroups[cg_id].cpu.usage_usec % cgroups[cg_id].cpu.cfs_period_us
  if period_usage >= @intToU64(cgroups[cg_id].cpu.cfs_quota_us) {
    cgroups[cg_id].cpu.nr_throttled = cgroups[cg_id].cpu.nr_throttled + 1
    return 1
  }

  return 0
}

// cpuset controller: set allowed CPUs
export fn cgroup_set_cpuset_cpus(cg_id: u32, cpus: u64): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_CPUSET) == 0 { return 0 }

  // Parse CPU mask (simplified - just take first 256 bits)
  var i: u32 = 0
  while i < 32 {
    cgroups[cg_id].cpuset.cpus[i] = @intToPtr(cpus + i, u8)
    i = i + 1
  }

  // Count effective CPUs
  cgroups[cg_id].cpuset.effective_cpus = 0
  i = 0
  while i < 32 {
    var byte: u8 = cgroups[cg_id].cpuset.cpus[i]
    while byte != 0 {
      cgroups[cg_id].cpuset.effective_cpus = cgroups[cg_id].cpuset.effective_cpus + (byte & 1)
      byte = byte >> 1
    }
    i = i + 1
  }

  return 1
}

// Memory controller: set limit
export fn cgroup_set_memory_limit(cg_id: u32, limit_bytes: u64): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_MEMORY) == 0 { return 0 }

  cgroups[cg_id].memory.limit_bytes = limit_bytes

  foundation.serial_write_string("[Cgroups] Memory limit set for ")
  foundation.serial_write_string(@ptrFromInt(cgroups[cg_id].name))
  foundation.serial_write_string(": ")
  foundation.serial_write_hex(@truncate(limit_bytes / (1024 * 1024), u32))
  foundation.serial_write_string(" MB\n")

  return 1
}

// Memory controller: set soft limit
export fn cgroup_set_memory_soft_limit(cg_id: u32, soft_limit_bytes: u64): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_MEMORY) == 0 { return 0 }

  cgroups[cg_id].memory.soft_limit_bytes = soft_limit_bytes
  return 1
}

// Memory controller: set swap limit
export fn cgroup_set_swap_limit(cg_id: u32, swap_limit_bytes: u64): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_MEMORY) == 0 { return 0 }

  cgroups[cg_id].memory.swap_limit_bytes = swap_limit_bytes
  return 1
}

// Memory controller: set high watermark
export fn cgroup_set_memory_high(cg_id: u32, high_bytes: u64): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_MEMORY) == 0 { return 0 }

  cgroups[cg_id].memory.high_bytes = high_bytes
  return 1
}

// Memory controller: charge memory
export fn cgroup_memory_charge(cg_id: u32, bytes: u64): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_MEMORY) == 0 { return 1 }

  // Check against limit
  if cgroups[cg_id].memory.current_bytes + bytes > cgroups[cg_id].memory.limit_bytes {
    cgroups[cg_id].memory.failcnt = cgroups[cg_id].memory.failcnt + 1
    return 0  // Would exceed limit
  }

  cgroups[cg_id].memory.current_bytes = cgroups[cg_id].memory.current_bytes + bytes

  // Update max usage
  if cgroups[cg_id].memory.current_bytes > cgroups[cg_id].memory.max_usage_bytes {
    cgroups[cg_id].memory.max_usage_bytes = cgroups[cg_id].memory.current_bytes
  }

  // Propagate to parent
  if cgroups[cg_id].parent != 0xFFFFFFFF {
    return cgroup_memory_charge(cgroups[cg_id].parent, bytes)
  }

  return 1
}

// Memory controller: uncharge memory
export fn cgroup_memory_uncharge(cg_id: u32, bytes: u64) {
  if cg_id >= cgroup_count { return }

  if cgroups[cg_id].memory.current_bytes >= bytes {
    cgroups[cg_id].memory.current_bytes = cgroups[cg_id].memory.current_bytes - bytes
  } else {
    cgroups[cg_id].memory.current_bytes = 0
  }

  // Propagate to parent
  if cgroups[cg_id].parent != 0xFFFFFFFF {
    cgroup_memory_uncharge(cgroups[cg_id].parent, bytes)
  }
}

// Memory controller: check if under memory pressure
export fn cgroup_memory_under_pressure(cg_id: u32): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_MEMORY) == 0 { return 0 }

  if cgroups[cg_id].memory.current_bytes > cgroups[cg_id].memory.high_bytes {
    return 1
  }

  return 0
}

// I/O controller: set weight
export fn cgroup_set_io_weight(cg_id: u32, weight: u32): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_IO) == 0 { return 0 }

  cgroups[cg_id].io.weight = weight
  return 1
}

// I/O controller: set max bandwidth
export fn cgroup_set_io_max(cg_id: u32, rbps: u64, wbps: u64, riops: u64, wiops: u64): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_IO) == 0 { return 0 }

  cgroups[cg_id].io.max_rbps = rbps
  cgroups[cg_id].io.max_wbps = wbps
  cgroups[cg_id].io.max_riops = riops
  cgroups[cg_id].io.max_wiops = wiops

  return 1
}

// I/O controller: charge I/O
export fn cgroup_io_charge(cg_id: u32, read_bytes: u64, write_bytes: u64, read_ios: u64, write_ios: u64) {
  if cg_id >= cgroup_count { return }

  cgroups[cg_id].io.read_bytes = cgroups[cg_id].io.read_bytes + read_bytes
  cgroups[cg_id].io.write_bytes = cgroups[cg_id].io.write_bytes + write_bytes
  cgroups[cg_id].io.read_ios = cgroups[cg_id].io.read_ios + read_ios
  cgroups[cg_id].io.write_ios = cgroups[cg_id].io.write_ios + write_ios

  // Propagate to parent
  if cgroups[cg_id].parent != 0xFFFFFFFF {
    cgroup_io_charge(cgroups[cg_id].parent, read_bytes, write_bytes, read_ios, write_ios)
  }
}

// PIDs controller: set limit
export fn cgroup_set_pids_max(cg_id: u32, max_pids: u32): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_PIDS) == 0 { return 0 }

  cgroups[cg_id].pids.max = max_pids
  return 1
}

// Devices controller: add device rule
export fn cgroup_devices_add(cg_id: u32, dev_type: u8, major: u32, minor: u32, permissions: u32): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_DEVICES) == 0 { return 0 }
  if cgroups[cg_id].devices.device_count >= MAX_DEVICES { return 0 }

  var idx: u32 = cgroups[cg_id].devices.device_count
  cgroups[cg_id].devices.devices[idx].dev_type = dev_type
  cgroups[cg_id].devices.devices[idx].major = major
  cgroups[cg_id].devices.devices[idx].minor = minor
  cgroups[cg_id].devices.devices[idx].permissions = permissions
  cgroups[cg_id].devices.devices[idx].valid = 1

  cgroups[cg_id].devices.device_count = cgroups[cg_id].devices.device_count + 1

  return 1
}

// Devices controller: check access
export fn cgroup_devices_check(cg_id: u32, dev_type: u8, major: u32, minor: u32, access: u32): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_DEVICES) == 0 { return 1 }

  // Check against device list
  var i: u32 = 0
  while i < cgroups[cg_id].devices.device_count {
    if cgroups[cg_id].devices.devices[i].valid == 1 {
      var d: DeviceEntry = cgroups[cg_id].devices.devices[i]

      // Check if rule matches
      var type_match: u32 = d.dev_type == DEV_TYPE_ALL || d.dev_type == dev_type
      var major_match: u32 = d.major == 0xFFFFFFFF || d.major == major
      var minor_match: u32 = d.minor == 0xFFFFFFFF || d.minor == minor

      if type_match == 1 && major_match == 1 && minor_match == 1 {
        if (d.permissions & access) == access {
          return 1  // Access allowed
        }
      }
    }
    i = i + 1
  }

  // Fall back to default policy
  return cgroups[cg_id].devices.default_allow
}

// Freezer controller: freeze cgroup
export fn cgroup_freeze(cg_id: u32): u32 {
  if cg_id >= cgroup_count { return 0 }
  if cg_id == 0 { return 0 }  // Cannot freeze root
  if (cgroups[cg_id].enabled_controllers & CGROUP_FREEZER) == 0 { return 0 }

  cgroups[cg_id].freezer.self_freezing = 1
  cgroups[cg_id].freezer.state = FREEZER_FREEZING

  // In real implementation, signal all processes to freeze

  cgroups[cg_id].freezer.state = FREEZER_FROZEN

  // Propagate to children
  var i: u32 = 0
  while i < cgroups[cg_id].child_count {
    var child: u32 = cgroups[cg_id].children[i]
    cgroups[child].freezer.parent_freezing = 1
    cgroup_freeze(child)
    i = i + 1
  }

  foundation.serial_write_string("[Cgroups] Frozen: ")
  foundation.serial_write_string(@ptrFromInt(cgroups[cg_id].name))
  foundation.serial_write_string("\n")

  return 1
}

// Freezer controller: thaw cgroup
export fn cgroup_thaw(cg_id: u32): u32 {
  if cg_id >= cgroup_count { return 0 }
  if (cgroups[cg_id].enabled_controllers & CGROUP_FREEZER) == 0 { return 0 }

  cgroups[cg_id].freezer.self_freezing = 0

  // Only thaw if parent is not frozen
  if cgroups[cg_id].freezer.parent_freezing == 0 {
    cgroups[cg_id].freezer.state = FREEZER_THAWED

    // In real implementation, signal all processes to resume

    cgroups[cg_id].freezer.state = FREEZER_RUNNING

    // Propagate to children
    var i: u32 = 0
    while i < cgroups[cg_id].child_count {
      var child: u32 = cgroups[cg_id].children[i]
      cgroups[child].freezer.parent_freezing = 0
      if cgroups[child].freezer.self_freezing == 0 {
        cgroup_thaw(child)
      }
      i = i + 1
    }
  }

  foundation.serial_write_string("[Cgroups] Thawed: ")
  foundation.serial_write_string(@ptrFromInt(cgroups[cg_id].name))
  foundation.serial_write_string("\n")

  return 1
}

// Enable/disable subtree controllers
export fn cgroup_set_subtree_control(cg_id: u32, enable: u32, disable: u32): u32 {
  if cg_id >= cgroup_count { return 0 }

  // Can only enable controllers that parent has enabled
  var available: u32 = cgroups[cg_id].enabled_controllers
  var new_enable: u32 = enable & available

  cgroups[cg_id].subtree_control = (cgroups[cg_id].subtree_control | new_enable) & ~disable

  return 1
}

// Find cgroup by path
export fn cgroup_find(path: u64): u32 {
  var i: u32 = 0
  while i < cgroup_count {
    if cgroups[i].active == 1 {
      if cgroup_strcmp(cgroups[i].name, path) == 1 {
        return i
      }
    }
    i = i + 1
  }

  return 0xFFFFFFFF
}

// Destroy cgroup
export fn cgroup_destroy(cg_id: u32): u32 {
  if cg_id >= cgroup_count { return 0 }
  if cg_id == 0 { return 0 }  // Cannot destroy root
  if cgroups[cg_id].process_count > 0 { return 0 }  // Must be empty
  if cgroups[cg_id].child_count > 0 { return 0 }  // Must have no children

  // Remove from parent's children
  var parent: u32 = cgroups[cg_id].parent
  if parent != 0xFFFFFFFF {
    var i: u32 = 0
    while i < cgroups[parent].child_count {
      if cgroups[parent].children[i] == cg_id {
        var j: u32 = i
        while j < cgroups[parent].child_count - 1 {
          cgroups[parent].children[j] = cgroups[parent].children[j + 1]
          j = j + 1
        }
        cgroups[parent].child_count = cgroups[parent].child_count - 1
        break
      }
      i = i + 1
    }
  }

  cgroups[cg_id].active = 0
  cg_stats.total_destroyed = cg_stats.total_destroyed + 1

  foundation.serial_write_string("[Cgroups] Destroyed: ")
  foundation.serial_write_string(@ptrFromInt(cgroups[cg_id].name))
  foundation.serial_write_string("\n")

  return 1
}

// Get cgroup statistics
export fn cgroup_get_stats(cg_id: u32, stats_out: u64): u32 {
  if cg_id >= cgroup_count { return 0 }

  // Copy CPU stats
  @intToPtr(stats_out, u64) = cgroups[cg_id].cpu.usage_usec
  @intToPtr(stats_out + 8, u64) = cgroups[cg_id].cpu.user_usec
  @intToPtr(stats_out + 16, u64) = cgroups[cg_id].cpu.system_usec
  @intToPtr(stats_out + 24, u64) = cgroups[cg_id].cpu.nr_throttled
  @intToPtr(stats_out + 32, u64) = cgroups[cg_id].cpu.throttled_usec

  // Copy memory stats
  @intToPtr(stats_out + 40, u64) = cgroups[cg_id].memory.current_bytes
  @intToPtr(stats_out + 48, u64) = cgroups[cg_id].memory.max_usage_bytes
  @intToPtr(stats_out + 56, u64) = cgroups[cg_id].memory.limit_bytes
  @intToPtr(stats_out + 64, u64) = cgroups[cg_id].memory.failcnt
  @intToPtr(stats_out + 72, u64) = cgroups[cg_id].memory.oom_kill

  // Copy I/O stats
  @intToPtr(stats_out + 80, u64) = cgroups[cg_id].io.read_bytes
  @intToPtr(stats_out + 88, u64) = cgroups[cg_id].io.write_bytes
  @intToPtr(stats_out + 96, u64) = cgroups[cg_id].io.read_ios
  @intToPtr(stats_out + 104, u64) = cgroups[cg_id].io.write_ios

  // Copy PIDs stats
  @intToPtr(stats_out + 112, u32) = cgroups[cg_id].pids.current
  @intToPtr(stats_out + 116, u32) = cgroups[cg_id].pids.max

  return 1
}

// Get cgroup count
export fn cgroup_get_count(): u32 {
  return cgroup_count
}

// Get global statistics
export fn cgroup_get_global_stats(stats_out: u64): u32 {
  @intToPtr(stats_out, u64) = cg_stats.total_created
  @intToPtr(stats_out + 8, u64) = cg_stats.total_destroyed
  @intToPtr(stats_out + 16, u32) = cg_stats.max_depth
  @intToPtr(stats_out + 20, u32) = cg_stats.total_processes

  return 1
}

// Helper: count total pids including descendants
fn cgroup_count_pids(cg_id: u32): u32 {
  if cg_id >= cgroup_count { return 0 }

  var count: u32 = cgroups[cg_id].process_count

  var i: u32 = 0
  while i < cgroups[cg_id].child_count {
    count = count + cgroup_count_pids(cgroups[cg_id].children[i])
    i = i + 1
  }

  return count
}

// Helper: get cgroup depth
fn cgroup_get_depth(cg_id: u32): u32 {
  if cg_id >= cgroup_count { return 0 }
  if cgroups[cg_id].parent == 0xFFFFFFFF { return 0 }

  return 1 + cgroup_get_depth(cgroups[cg_id].parent)
}

// Helper: set cgroup name
fn cgroup_set_name(cg_id: u32, name: u64, len: u32) {
  var max_len: u32 = len
  if max_len > 255 { max_len = 255 }

  var i: u32 = 0
  while i < max_len {
    cgroups[cg_id].name[i] = @intToPtr(name + i, u8)
    i = i + 1
  }
  cgroups[cg_id].name[i] = 0
}

// Helper: compare strings
fn cgroup_strcmp(s1: [u8; 256], s2: u64): u32 {
  var i: u32 = 0
  while i < 256 {
    var c1: u8 = s1[i]
    var c2: u8 = @intToPtr(s2 + i, u8)

    if c1 != c2 { return 0 }
    if c1 == 0 { return 1 }

    i = i + 1
  }
  return 0
}

// Helper: notify on release
fn cgroup_notify_release(cg_id: u32) {
  // In real implementation, invoke release_agent
  foundation.serial_write_string("[Cgroups] Release notification for ")
  foundation.serial_write_string(@ptrFromInt(cgroups[cg_id].name))
  foundation.serial_write_string("\n")
}

// Helper: convert i64 to u64 safely
fn @intToU64(val: i64): u64 {
  if val < 0 { return 0 }
  return @bitCast(val, u64)
}
