// home-os Kernel - OverlayFS
// Union filesystem for container image layers

import "../core/foundation.home" as foundation
import "../core/filesystem.home" as filesystem

const MAX_LAYERS: u32 = 128
const MAX_OVERLAYS: u32 = 64

struct OverlayLayer {
  path: [u8; 256],
  readonly: u32
}

struct Overlay {
  name: [u8; 128],
  layers: [OverlayLayer; 128],
  layer_count: u32,
  upperdir: [u8; 256],
  workdir: [u8; 256],
  merged: [u8; 256],
  active: u32
}

var overlays: [Overlay; 64]
var overlay_count: u32 = 0

export fn overlayfs_init() {
  overlay_count = 0
  foundation.serial_write_string("[OverlayFS] Initialized\n")
}

export fn overlayfs_create(name: u64, upperdir: u64, workdir: u64, merged: u64): u32 {
  if overlay_count >= MAX_OVERLAYS { return 0xFFFFFFFF }
  
  var overlay_id: u32 = overlay_count
  
  // Copy name
  var i: u32 = 0
  while i < 127 {
    var ch: u8 = @intToPtr(name + i, u8)
    overlays[overlay_id].name[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  
  // Copy paths
  overlayfs_copy_string(@ptrFromInt(overlays[overlay_id].upperdir), upperdir, 256)
  overlayfs_copy_string(@ptrFromInt(overlays[overlay_id].workdir), workdir, 256)
  overlayfs_copy_string(@ptrFromInt(overlays[overlay_id].merged), merged, 256)
  
  overlays[overlay_id].layer_count = 0
  overlays[overlay_id].active = 1
  
  overlay_count = overlay_count + 1
  
  foundation.serial_write_string("[OverlayFS] Created overlay: ")
  foundation.serial_write_string(name)
  foundation.serial_write_string("\n")
  
  return overlay_id
}

fn overlayfs_copy_string(dest: u64, src: u64, max_len: u32) {
  var i: u32 = 0
  while i < max_len - 1 {
    var ch: u8 = @intToPtr(src + i, u8)
    @intToPtr(dest + i, u8) = ch
    if ch == 0 { break }
    i = i + 1
  }
  @intToPtr(dest + i, u8) = 0
}

export fn overlayfs_add_layer(overlay_id: u32, layer_path: u64, readonly: u32): u32 {
  if overlay_id >= overlay_count { return 0 }
  if overlays[overlay_id].layer_count >= MAX_LAYERS { return 0 }
  
  var layer_idx: u32 = overlays[overlay_id].layer_count
  
  overlayfs_copy_string(@ptrFromInt(overlays[overlay_id].layers[layer_idx].path), layer_path, 256)
  overlays[overlay_id].layers[layer_idx].readonly = readonly
  
  overlays[overlay_id].layer_count = overlays[overlay_id].layer_count + 1
  
  return 1
}

export fn overlayfs_mount(overlay_id: u32): u32 {
  if overlay_id >= overlay_count { return 0 }
  
  foundation.serial_write_string("[OverlayFS] Mounting ")
  foundation.serial_write_string(@ptrFromInt(overlays[overlay_id].name))
  foundation.serial_write_string("\n")
  
  // Create merged directory
  filesystem.vfs_mkdir(@ptrFromInt(overlays[overlay_id].merged), 0x1ED)
  
  // Mount overlay
  // This would integrate with VFS to create union view
  
  return 1
}

export fn overlayfs_unmount(overlay_id: u32): u32 {
  if overlay_id >= overlay_count { return 0 }
  
  foundation.serial_write_string("[OverlayFS] Unmounting ")
  foundation.serial_write_string(@ptrFromInt(overlays[overlay_id].name))
  foundation.serial_write_string("\n")
  
  return 1
}

export fn overlayfs_read(overlay_id: u32, path: u64, buffer: u64, size: u32): u32 {
  if overlay_id >= overlay_count { return 0 }
  
  // Try upperdir first
  var full_path: [u8; 512]
  overlayfs_build_path(@ptrFromInt(full_path), @ptrFromInt(overlays[overlay_id].upperdir), path)
  
  var fd: u32 = filesystem.vfs_open(@ptrFromInt(full_path), 0x0000, 0)
  if fd != 0xFFFFFFFF {
    var bytes: u32 = filesystem.vfs_read(fd, buffer, size)
    filesystem.vfs_close(fd)
    return bytes
  }
  
  // Try layers from top to bottom
  var i: u32 = overlays[overlay_id].layer_count
  while i > 0 {
    i = i - 1
    
    overlayfs_build_path(@ptrFromInt(full_path), @ptrFromInt(overlays[overlay_id].layers[i].path), path)
    
    fd = filesystem.vfs_open(@ptrFromInt(full_path), 0x0000, 0)
    if fd != 0xFFFFFFFF {
      var bytes: u32 = filesystem.vfs_read(fd, buffer, size)
      filesystem.vfs_close(fd)
      return bytes
    }
  }
  
  return 0
}

fn overlayfs_build_path(dest: u64, base: u64, path: u64) {
  var i: u32 = 0
  
  // Copy base
  while @intToPtr(base + i, u8) != 0 {
    @intToPtr(dest + i, u8) = @intToPtr(base + i, u8)
    i = i + 1
  }
  
  // Add separator if needed
  if i > 0 and @intToPtr(dest + i - 1, u8) != '/' {
    @intToPtr(dest + i, u8) = '/'
    i = i + 1
  }
  
  // Copy path
  var j: u32 = 0
  while @intToPtr(path + j, u8) != 0 {
    @intToPtr(dest + i, u8) = @intToPtr(path + j, u8)
    i = i + 1
    j = j + 1
  }
  
  @intToPtr(dest + i, u8) = 0
}

export fn overlayfs_write(overlay_id: u32, path: u64, buffer: u64, size: u32): u32 {
  if overlay_id >= overlay_count { return 0 }
  
  // Always write to upperdir
  var full_path: [u8; 512]
  overlayfs_build_path(@ptrFromInt(full_path), @ptrFromInt(overlays[overlay_id].upperdir), path)
  
  var fd: u32 = filesystem.vfs_open(@ptrFromInt(full_path), 0x0242, 0x1B6)
  if fd == 0xFFFFFFFF { return 0 }
  
  var bytes: u32 = filesystem.vfs_write(fd, buffer, size)
  filesystem.vfs_close(fd)
  
  return bytes
}

export fn overlayfs_get_count(): u32 {
  return overlay_count
}
