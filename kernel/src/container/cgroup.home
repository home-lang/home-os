// home-os Control Groups
// Resource limiting and accounting

import "../core/foundation.home" as foundation

const CGROUP_CPU: u32 = 0
const CGROUP_MEMORY: u32 = 1
const CGROUP_IO: u32 = 2

const MAX_CGROUPS: u32 = 32

struct Cgroup {
  name: [u8; 64],
  type: u32,
  limit: u64,
  usage: u64,
  in_use: u32
}

var cgroups: [Cgroup; 32]
var cgroup_count: u32 = 0

export fn cgroup_init() {
  cgroup_count = 0
  foundation.serial_write_string("[Cgroup] Control groups initialized\n")
}

export fn cgroup_create(name: u64, type: u32, limit: u64) -> u32 {
  if cgroup_count >= MAX_CGROUPS { return 0xFFFFFFFF }
  
  var i: u32 = 0
  while i < 64 {
    cgroups[cgroup_count].name[i] = @intToPtr(name + i, u8)
    if cgroups[cgroup_count].name[i] == 0 { break }
    i = i + 1
  }
  
  cgroups[cgroup_count].type = type
  cgroups[cgroup_count].limit = limit
  cgroups[cgroup_count].usage = 0
  cgroups[cgroup_count].in_use = 1
  
  var id: u32 = cgroup_count
  cgroup_count = cgroup_count + 1
  
  foundation.serial_write_string("[Cgroup] Created: ")
  foundation.serial_write_string(name)
  foundation.serial_write_string("\n")
  
  return id
}

export fn cgroup_add_process(cgroup_id: u32, process_id: u32) -> u32 {
  if cgroup_id >= cgroup_count { return 1 }
  return 0
}

export fn cgroup_get_usage(cgroup_id: u32) -> u64 {
  if cgroup_id >= cgroup_count { return 0 }
  return cgroups[cgroup_id].usage
}

export fn cgroup_check_limit(cgroup_id: u32, amount: u64) -> u32 {
  if cgroup_id >= cgroup_count { return 0 }
  
  if cgroups[cgroup_id].usage + amount > cgroups[cgroup_id].limit {
    return 0  // Would exceed limit
  }
  
  return 1  // Within limit
}
