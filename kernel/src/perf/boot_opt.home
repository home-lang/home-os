// home-os Kernel - Boot Optimization
// Fast boot path with parallel initialization

import "../core/foundation.home" as foundation

const MAX_INIT_TASKS: u32 = 64

struct InitTask {
  name: [u8; 64],
  func: u64,
  priority: u32,
  parallel: u32,
  completed: u32,
  start_time: u64,
  end_time: u64
}

var init_tasks: [InitTask; 64]
var task_count: u32 = 0
var boot_start_time: u64 = 0
var boot_opt_initialized: u32 = 0

export fn boot_opt_init() {
  if boot_opt_initialized == 1 { return }
  
  boot_start_time = foundation.timer_get_ticks()
  task_count = 0
  
  boot_opt_initialized = 1
  foundation.serial_write_string("[BootOpt] Fast boot enabled\n")
}

export fn boot_opt_register_task(name: u64, func: u64, priority: u32, parallel: u32) -> u32 {
  if task_count >= MAX_INIT_TASKS { return 0 }
  
  var i: u32 = 0
  while i < 64 {
    var ch: u8 = @intToPtr(name + i, u8)
    init_tasks[task_count].name[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  
  init_tasks[task_count].func = func
  init_tasks[task_count].priority = priority
  init_tasks[task_count].parallel = parallel
  init_tasks[task_count].completed = 0
  init_tasks[task_count].start_time = 0
  init_tasks[task_count].end_time = 0
  
  task_count = task_count + 1
  return task_count - 1
}

export fn boot_opt_run_tasks() {
  foundation.serial_write_string("[BootOpt] Running ")
  foundation.serial_write_hex(task_count)
  foundation.serial_write_string(" init tasks\n")
  
  // Sort tasks by priority
  boot_opt_sort_tasks()
  
  // Run tasks
  var current_priority: u32 = 0
  
  while boot_opt_has_pending_tasks() == 1 {
    // Find highest priority
    current_priority = boot_opt_get_next_priority()
    
    // Run all tasks at this priority level in parallel
    boot_opt_run_parallel_tasks(current_priority)
  }
  
  var boot_time: u64 = foundation.timer_get_ticks() - boot_start_time
  foundation.serial_write_string("[BootOpt] Boot completed in ")
  foundation.serial_write_hex(@truncate(boot_time, u32))
  foundation.serial_write_string(" ms\n")
  
  boot_opt_print_report()
}

fn boot_opt_sort_tasks() {
  // Bubble sort by priority
  var i: u32 = 0
  while i < task_count - 1 {
    var j: u32 = 0
    while j < task_count - i - 1 {
      if init_tasks[j].priority > init_tasks[j + 1].priority {
        boot_opt_swap_tasks(j, j + 1)
      }
      j = j + 1
    }
    i = i + 1
  }
}

fn boot_opt_swap_tasks(i: u32, j: u32) {
  var temp: InitTask = init_tasks[i]
  init_tasks[i] = init_tasks[j]
  init_tasks[j] = temp
}

fn boot_opt_has_pending_tasks() -> u32 {
  var i: u32 = 0
  while i < task_count {
    if init_tasks[i].completed == 0 {
      return 1
    }
    i = i + 1
  }
  return 0
}

fn boot_opt_get_next_priority() -> u32 {
  var i: u32 = 0
  while i < task_count {
    if init_tasks[i].completed == 0 {
      return init_tasks[i].priority
    }
    i = i + 1
  }
  return 0xFFFFFFFF
}

fn boot_opt_run_parallel_tasks(priority: u32) {
  var i: u32 = 0
  
  // Start all parallel tasks at this priority
  while i < task_count {
    if init_tasks[i].priority == priority and init_tasks[i].completed == 0 {
      if init_tasks[i].parallel == 1 {
        // Start task in parallel
        init_tasks[i].start_time = foundation.timer_get_ticks()
        foundation.spawn_kernel_thread(init_tasks[i].func, 0)
      }
    }
    i = i + 1
  }
  
  // Run sequential tasks
  i = 0
  while i < task_count {
    if init_tasks[i].priority == priority and init_tasks[i].completed == 0 {
      if init_tasks[i].parallel == 0 {
        init_tasks[i].start_time = foundation.timer_get_ticks()
        foundation.call_function(init_tasks[i].func, 0)
        init_tasks[i].end_time = foundation.timer_get_ticks()
        init_tasks[i].completed = 1
      }
    }
    i = i + 1
  }
  
  // Wait for parallel tasks to complete
  boot_opt_wait_parallel_tasks(priority)
}

fn boot_opt_wait_parallel_tasks(priority: u32) {
  var all_done: u32 = 0
  
  while all_done == 0 {
    all_done = 1
    
    var i: u32 = 0
    while i < task_count {
      if init_tasks[i].priority == priority and init_tasks[i].parallel == 1 {
        if init_tasks[i].completed == 0 {
          all_done = 0
        }
      }
      i = i + 1
    }
    
    if all_done == 0 {
      foundation.cpu_relax()
    }
  }
}

export fn boot_opt_task_complete(task_id: u32) {
  if task_id >= task_count { return }
  
  init_tasks[task_id].end_time = foundation.timer_get_ticks()
  init_tasks[task_id].completed = 1
}

fn boot_opt_print_report() {
  foundation.serial_write_string("\n=== Boot Time Report ===\n\n")
  foundation.serial_write_string("Task                          Priority  Time(ms)  Parallel\n")
  foundation.serial_write_string("----------------------------------------------------------------\n")
  
  var i: u32 = 0
  while i < task_count {
    foundation.serial_write_string(@ptrFromInt(init_tasks[i].name))
    
    var name_len: u32 = 0
    while init_tasks[i].name[name_len] != 0 { name_len = name_len + 1 }
    var j: u32 = name_len
    while j < 30 {
      foundation.serial_write_string(" ")
      j = j + 1
    }
    
    foundation.serial_write_hex(init_tasks[i].priority)
    foundation.serial_write_string("        ")
    
    var elapsed: u64 = init_tasks[i].end_time - init_tasks[i].start_time
    foundation.serial_write_hex(@truncate(elapsed, u32))
    foundation.serial_write_string("      ")
    
    if init_tasks[i].parallel == 1 {
      foundation.serial_write_string("Yes")
    } else {
      foundation.serial_write_string("No")
    }
    
    foundation.serial_write_string("\n")
    i = i + 1
  }
  
  foundation.serial_write_string("\n")
}

export fn boot_opt_get_boot_time() -> u64 {
  return foundation.timer_get_ticks() - boot_start_time
}
