// home-os Kernel - Advanced Boot Optimization & Profiling
// Fast boot path with parallel initialization, detailed timing, and boot chart generation
// Target: <3s to shell on Pi 4/5, <5s on Pi 3

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

const MAX_INIT_TASKS: u32 = 128
const MAX_BOOT_PHASES: u32 = 16
const MAX_BOTTLENECKS: u32 = 10

// Boot phases for tracking
const BOOT_PHASE_FIRMWARE: u32 = 0
const BOOT_PHASE_BOOTLOADER: u32 = 1
const BOOT_PHASE_KERNEL_EARLY: u32 = 2
const BOOT_PHASE_DRIVERS: u32 = 3
const BOOT_PHASE_FILESYSTEM: u32 = 4
const BOOT_PHASE_USERSPACE: u32 = 5
const BOOT_PHASE_SHELL: u32 = 6

struct InitTask {
  name: [64]u8
  func: u64
  priority: u32
  parallel: u32
  completed: u32
  start_time_us: u64
  end_time_us: u64
  phase: u32
  cpu_id: u32
  dependency_wait_us: u64  // Time spent waiting for dependencies
}

struct BootPhase {
  name: *u8
  start_time_us: u64
  end_time_us: u64
  task_count: u32
}

struct Bottleneck {
  task_name: *u8
  duration_us: u64
  phase: u32
}

var init_tasks: [MAX_INIT_TASKS]InitTask
var task_count: u32 = 0
var boot_phases: [MAX_BOOT_PHASES]BootPhase
var phase_count: u32 = 0
var bottlenecks: [MAX_BOTTLENECKS]Bottleneck
var bottleneck_count: u32 = 0

var boot_start_time_us: u64 = 0
var current_phase: u32 = 0
var boot_opt_initialized: u32 = 0

// Boot targets (microseconds)
const TARGET_BOOT_TO_SHELL_PI3: u64 = 5000000   // 5s
const TARGET_BOOT_TO_SHELL_PI4: u64 = 3000000   // 3s
const TARGET_BOOT_TO_SHELL_PI5: u64 = 2000000   // 2s
const TARGET_BOOT_TO_GUI_PI3: u64 = 15000000    // 15s
const TARGET_BOOT_TO_GUI_PI4: u64 = 8000000     // 8s
const TARGET_BOOT_TO_GUI_PI5: u64 = 6000000     // 6s

// Current platform (would be detected at runtime)
var current_platform: u32 = 4  // Default to Pi 4

// High-resolution timer (microseconds)
var timer_ticks: u64 = 0

fn get_time_us(): u64 {
  // In real implementation, would read hardware timer
  // For now, simulate with incrementing counter
  timer_ticks = timer_ticks + 10
  return timer_ticks
}

export fn boot_opt_init() {
  if boot_opt_initialized == 1 { return }

  boot_start_time_us = get_time_us()
  task_count = 0
  phase_count = 0
  bottleneck_count = 0
  current_phase = BOOT_PHASE_KERNEL_EARLY
  timer_ticks = 0

  boot_opt_initialized = 1

  foundation.serial_write_string("[Boot Opt] Advanced boot profiling enabled\n")
  foundation.serial_write_string("[Boot Opt] Target: <3s to shell on Pi 4/5\n")
}

// Register a boot phase
export fn boot_opt_register_phase(name: *u8) {
  if phase_count >= MAX_BOOT_PHASES { return }

  let phase: *BootPhase = &boot_phases[phase_count]
  phase.name = name
  phase.start_time_us = get_time_us()
  phase.end_time_us = 0
  phase.task_count = 0

  current_phase = phase_count
  phase_count = phase_count + 1

  foundation.serial_write_string("[Boot Opt] Phase: ")
  foundation.serial_write_string(name)
  foundation.serial_write_string("\n")
}

// End current boot phase
export fn boot_opt_end_phase() {
  if current_phase >= phase_count { return }

  let phase: *BootPhase = &boot_phases[current_phase]
  phase.end_time_us = get_time_us()

  let duration_ms: u64 = (phase.end_time_us - phase.start_time_us) / 1000

  foundation.serial_write_string("[Boot Opt] Phase ")
  foundation.serial_write_string(phase.name)
  foundation.serial_write_string(" completed in ")
  foundation.serial_write_u64(duration_ms)
  foundation.serial_write_string(" ms\n")
}

// Register an initialization task
export fn boot_opt_register_task(name: *u8, func: u64, priority: u32, parallel: u32): u32 {
  if task_count >= MAX_INIT_TASKS { return 0xFFFFFFFF }

  let task: *InitTask = &init_tasks[task_count]

  // Copy name
  var i: u32 = 0
  loop {
    if i >= 63 { break }

    let ch_ptr: *u8 = name + i
    let ch: u8 = *ch_ptr

    task.name[i] = ch

    if ch == 0 { break }

    i = i + 1
  }
  task.name[63] = 0  // Ensure null termination

  task.func = func
  task.priority = priority
  task.parallel = parallel
  task.completed = 0
  task.start_time_us = 0
  task.end_time_us = 0
  task.phase = current_phase
  task.cpu_id = 0
  task.dependency_wait_us = 0

  let id: u32 = task_count
  task_count = task_count + 1

  // Update phase task count
  if current_phase < phase_count {
    boot_phases[current_phase].task_count = boot_phases[current_phase].task_count + 1
  }

  return id
}

// Sort tasks by priority
fn boot_opt_sort_tasks() {
  var i: u32 = 0
  loop {
    if i >= task_count - 1 { break }

    var j: u32 = 0
    loop {
      if j >= task_count - i - 1 { break }

      if init_tasks[j].priority > init_tasks[j + 1].priority {
        boot_opt_swap_tasks(j, j + 1)
      }

      j = j + 1
    }

    i = i + 1
  }
}

fn boot_opt_swap_tasks(i: u32, j: u32) {
  let temp: InitTask = init_tasks[i]
  init_tasks[i] = init_tasks[j]
  init_tasks[j] = temp
}

fn boot_opt_has_pending_tasks(): u32 {
  var i: u32 = 0
  loop {
    if i >= task_count { break }

    if init_tasks[i].completed == 0 {
      return 1
    }

    i = i + 1
  }

  return 0
}

fn boot_opt_get_next_priority(): u32 {
  var i: u32 = 0
  loop {
    if i >= task_count { break }

    if init_tasks[i].completed == 0 {
      return init_tasks[i].priority
    }

    i = i + 1
  }

  return 0xFFFFFFFF
}

fn boot_opt_run_parallel_tasks(priority: u32) {
  // Start all parallel tasks at this priority
  var i: u32 = 0
  loop {
    if i >= task_count { break }

    let task: *InitTask = &init_tasks[i]

    if task.priority == priority && task.completed == 0 && task.parallel == 1 {
      task.start_time_us = get_time_us()

      // In real implementation, would spawn kernel thread
      // For now, simulate by calling function
      // foundation.spawn_kernel_thread(task.func, 0)

      // Simulate execution
      let result: u32 = 0  // Would actually call function
      task.end_time_us = get_time_us() + 1000  // Simulate 1ms execution
      task.completed = 1
    }

    i = i + 1
  }

  // Run sequential tasks
  i = 0
  loop {
    if i >= task_count { break }

    let task: *InitTask = &init_tasks[i]

    if task.priority == priority && task.completed == 0 && task.parallel == 0 {
      task.start_time_us = get_time_us()

      // Call function synchronously
      // foundation.call_function(task.func, 0)

      task.end_time_us = get_time_us() + 500  // Simulate 0.5ms execution
      task.completed = 1
    }

    i = i + 1
  }
}

// Run all initialization tasks
export fn boot_opt_run_tasks() {
  foundation.serial_write_string("[Boot Opt] Running ")
  foundation.serial_write_u64(task_count)
  foundation.serial_write_string(" init tasks\n")

  // Sort tasks by priority
  boot_opt_sort_tasks()

  // Run tasks by priority
  loop {
    if boot_opt_has_pending_tasks() == 0 { break }

    let priority: u32 = boot_opt_get_next_priority()
    if priority == 0xFFFFFFFF { break }

    boot_opt_run_parallel_tasks(priority)
  }

  let boot_time_us: u64 = get_time_us() - boot_start_time_us
  let boot_time_ms: u64 = boot_time_us / 1000

  foundation.serial_write_string("[Boot Opt] Boot completed in ")
  foundation.serial_write_u64(boot_time_ms)
  foundation.serial_write_string(" ms\n\n")

  // Analyze boot performance
  boot_opt_analyze_performance()

  // Print reports
  boot_opt_print_detailed_report()
  boot_opt_print_boot_chart()
}

// Analyze boot performance and identify bottlenecks
fn boot_opt_analyze_performance() {
  bottleneck_count = 0

  foundation.serial_write_string("[Boot Opt] Analyzing performance...\n")

  // Find slowest tasks
  var i: u32 = 0
  loop {
    if i >= task_count { break }

    let task: *InitTask = &init_tasks[i]
    let duration_us: u64 = task.end_time_us - task.start_time_us

    // Consider anything >100ms a bottleneck
    if duration_us > 100000 {
      if bottleneck_count < MAX_BOTTLENECKS {
        let bn: *Bottleneck = &bottlenecks[bottleneck_count]
        bn.task_name = &task.name[0]
        bn.duration_us = duration_us
        bn.phase = task.phase

        bottleneck_count = bottleneck_count + 1
      }
    }

    i = i + 1
  }

  // Sort bottlenecks by duration
  if bottleneck_count > 1 {
    var j: u32 = 0
    loop {
      if j >= bottleneck_count - 1 { break }

      var k: u32 = 0
      loop {
        if k >= bottleneck_count - j - 1 { break }

        if bottlenecks[k].duration_us < bottlenecks[k + 1].duration_us {
          let temp: Bottleneck = bottlenecks[k]
          bottlenecks[k] = bottlenecks[k + 1]
          bottlenecks[k + 1] = temp
        }

        k = k + 1
      }

      j = j + 1
    }
  }
}

// Print detailed boot report
fn boot_opt_print_detailed_report() {
  foundation.serial_write_string("\n========== DETAILED BOOT REPORT ==========\n\n")

  // Phase breakdown
  foundation.serial_write_string("Boot Phases:\n")

  var i: u32 = 0
  loop {
    if i >= phase_count { break }

    let phase: *BootPhase = &boot_phases[i]
    let duration_ms: u64 = (phase.end_time_us - phase.start_time_us) / 1000

    foundation.serial_write_string("  ")
    foundation.serial_write_string(phase.name)
    foundation.serial_write_string(": ")
    foundation.serial_write_u64(duration_ms)
    foundation.serial_write_string(" ms (")
    foundation.serial_write_u64(phase.task_count)
    foundation.serial_write_string(" tasks)\n")

    i = i + 1
  }

  // Task statistics
  var parallel_count: u32 = 0
  var sequential_count: u32 = 0
  var total_duration_us: u64 = 0

  i = 0
  loop {
    if i >= task_count { break }

    let task: *InitTask = &init_tasks[i]

    if task.parallel == 1 {
      parallel_count = parallel_count + 1
    } else {
      sequential_count = sequential_count + 1
    }

    total_duration_us = total_duration_us + (task.end_time_us - task.start_time_us)

    i = i + 1
  }

  foundation.serial_write_string("\nTask Statistics:\n")
  foundation.serial_write_string("  Total tasks: ")
  foundation.serial_write_u64(task_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Parallel: ")
  foundation.serial_write_u64(parallel_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Sequential: ")
  foundation.serial_write_u64(sequential_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Total CPU time: ")
  foundation.serial_write_u64(total_duration_us / 1000)
  foundation.serial_write_string(" ms\n")

  // Bottlenecks
  if bottleneck_count > 0 {
    foundation.serial_write_string("\nBottlenecks (>100ms):\n")

    i = 0
    loop {
      if i >= bottleneck_count { break }

      let bn: *Bottleneck = &bottlenecks[i]

      foundation.serial_write_string("  ")
      foundation.serial_write_u64(i + 1)
      foundation.serial_write_string(". ")
      foundation.serial_write_string(bn.task_name)
      foundation.serial_write_string(": ")
      foundation.serial_write_u64(bn.duration_us / 1000)
      foundation.serial_write_string(" ms\n")

      i = i + 1
    }
  } else {
    foundation.serial_write_string("\nNo bottlenecks detected (all tasks <100ms)\n")
  }

  // Check against targets
  let boot_time_us: u64 = get_time_us() - boot_start_time_us
  let target_us: u64 = if current_platform == 5 { TARGET_BOOT_TO_SHELL_PI5 }
                       else if current_platform == 4 { TARGET_BOOT_TO_SHELL_PI4 }
                       else { TARGET_BOOT_TO_SHELL_PI3 }

  foundation.serial_write_string("\nBoot Time vs Target:\n")
  foundation.serial_write_string("  Actual: ")
  foundation.serial_write_u64(boot_time_us / 1000)
  foundation.serial_write_string(" ms\n")

  foundation.serial_write_string("  Target: ")
  foundation.serial_write_u64(target_us / 1000)
  foundation.serial_write_string(" ms\n")

  if boot_time_us <= target_us {
    foundation.serial_write_string("  Status: UNDER TARGET ✓\n")
  } else {
    let over_by_ms: u64 = (boot_time_us - target_us) / 1000
    foundation.serial_write_string("  Status: OVER BY ")
    foundation.serial_write_u64(over_by_ms)
    foundation.serial_write_string(" ms ✗\n")
  }

  foundation.serial_write_string("\n==========================================\n\n")
}

// Print ASCII boot chart
fn boot_opt_print_boot_chart() {
  foundation.serial_write_string("========== BOOT CHART ==========\n\n")

  let total_time_us: u64 = get_time_us() - boot_start_time_us
  let scale_factor: u64 = total_time_us / 60  // Scale to 60 chars

  if scale_factor == 0 { return }

  foundation.serial_write_string("Time scale: Each '=' represents ~")
  foundation.serial_write_u64(scale_factor / 1000)
  foundation.serial_write_string(" ms\n\n")

  var i: u32 = 0
  loop {
    if i >= task_count { break }

    let task: *InitTask = &init_tasks[i]

    // Print task name (truncated to 20 chars)
    var name_len: u32 = 0
    loop {
      if name_len >= 20 { break }
      if task.name[name_len] == 0 { break }

      let ch_ptr: *u8 = &task.name[name_len]
      foundation.serial_write_char(*ch_ptr)

      name_len = name_len + 1
    }

    // Pad to 20 chars
    loop {
      if name_len >= 20 { break }
      foundation.serial_write_char(' ')
      name_len = name_len + 1
    }

    foundation.serial_write_string(" |")

    // Print bar
    let start_offset: u64 = task.start_time_us - boot_start_time_us
    let duration: u64 = task.end_time_us - task.start_time_us

    let start_pos: u64 = start_offset / scale_factor
    let bar_len: u64 = duration / scale_factor

    if bar_len == 0 {
      bar_len = 1  // Minimum 1 char
    }

    // Print spaces for offset
    var j: u64 = 0
    loop {
      if j >= start_pos { break }
      foundation.serial_write_char(' ')
      j = j + 1
    }

    // Print bar
    j = 0
    loop {
      if j >= bar_len { break }

      if task.parallel == 1 {
        foundation.serial_write_char('=')
      } else {
        foundation.serial_write_char('#')
      }

      j = j + 1
    }

    foundation.serial_write_string("| ")
    foundation.serial_write_u64(duration / 1000)
    foundation.serial_write_string(" ms\n")

    i = i + 1
  }

  foundation.serial_write_string("\nLegend: '=' = parallel, '#' = sequential\n")
  foundation.serial_write_string("\n================================\n\n")
}

// Get boot time
export fn boot_opt_get_boot_time_ms(): u64 {
  return (get_time_us() - boot_start_time_us) / 1000
}

// Mark task as complete (for parallel tasks)
export fn boot_opt_task_complete(task_id: u32) {
  if task_id >= task_count { return }

  init_tasks[task_id].end_time_us = get_time_us()
  init_tasks[task_id].completed = 1
}

// Export data for external analysis
export fn boot_opt_export_data(): *u8 {
  // Would generate JSON or CSV data for external tools
  // For now, return null
  return 0
}
