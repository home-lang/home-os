// home-os Kernel - Advanced Boot Optimization & Profiling
// Fast boot path with parallel initialization, detailed timing, and boot chart generation
// Target: <3s to shell on Pi 4/5, <5s on Pi 3

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

const MAX_INIT_TASKS: u32 = 128
const MAX_BOOT_PHASES: u32 = 16
const MAX_BOTTLENECKS: u32 = 10

// Boot phases for tracking
const BOOT_PHASE_FIRMWARE: u32 = 0
const BOOT_PHASE_BOOTLOADER: u32 = 1
const BOOT_PHASE_KERNEL_EARLY: u32 = 2
const BOOT_PHASE_DRIVERS: u32 = 3
const BOOT_PHASE_FILESYSTEM: u32 = 4
const BOOT_PHASE_USERSPACE: u32 = 5
const BOOT_PHASE_SHELL: u32 = 6

struct InitTask {
  name: [64]u8
  func: u64
  priority: u32
  parallel: u32
  completed: u32
  start_time_us: u64
  end_time_us: u64
  phase: u32
  cpu_id: u32
  dependency_wait_us: u64  // Time spent waiting for dependencies
}

struct BootPhase {
  name: *u8
  start_time_us: u64
  end_time_us: u64
  task_count: u32
}

struct Bottleneck {
  task_name: *u8
  duration_us: u64
  phase: u32
}

var init_tasks: [MAX_INIT_TASKS]InitTask
var task_count: u32 = 0
var boot_phases: [MAX_BOOT_PHASES]BootPhase
var phase_count: u32 = 0
var bottlenecks: [MAX_BOTTLENECKS]Bottleneck
var bottleneck_count: u32 = 0

var boot_start_time_us: u64 = 0
var current_phase: u32 = 0
var boot_opt_initialized: u32 = 0

// Boot targets (microseconds)
const TARGET_BOOT_TO_SHELL_PI3: u64 = 5000000   // 5s
const TARGET_BOOT_TO_SHELL_PI4: u64 = 3000000   // 3s
const TARGET_BOOT_TO_SHELL_PI5: u64 = 2000000   // 2s
const TARGET_BOOT_TO_GUI_PI3: u64 = 15000000    // 15s
const TARGET_BOOT_TO_GUI_PI4: u64 = 8000000     // 8s
const TARGET_BOOT_TO_GUI_PI5: u64 = 6000000     // 6s

// Current platform (would be detected at runtime)
var current_platform: u32 = 4  // Default to Pi 4

// High-resolution timer (microseconds)
var timer_ticks: u64 = 0

fn get_time_us(): u64 {
  // In real implementation, would read hardware timer
  // For now, simulate with incrementing counter
  timer_ticks = timer_ticks + 10
  return timer_ticks
}

export fn boot_opt_init() {
  if boot_opt_initialized == 1 { return }

  boot_start_time_us = get_time_us()
  task_count = 0
  phase_count = 0
  bottleneck_count = 0
  current_phase = BOOT_PHASE_KERNEL_EARLY
  timer_ticks = 0

  boot_opt_initialized = 1

  foundation.serial_write_string("[Boot Opt] Advanced boot profiling enabled\n")
  foundation.serial_write_string("[Boot Opt] Target: <3s to shell on Pi 4/5\n")
}

// Register a boot phase
export fn boot_opt_register_phase(name: *u8) {
  if phase_count >= MAX_BOOT_PHASES { return }

  let phase: *BootPhase = &boot_phases[phase_count]
  phase.name = name
  phase.start_time_us = get_time_us()
  phase.end_time_us = 0
  phase.task_count = 0

  current_phase = phase_count
  phase_count = phase_count + 1

  foundation.serial_write_string("[Boot Opt] Phase: ")
  foundation.serial_write_string(name)
  foundation.serial_write_string("\n")
}

// End current boot phase
export fn boot_opt_end_phase() {
  if current_phase >= phase_count { return }

  let phase: *BootPhase = &boot_phases[current_phase]
  phase.end_time_us = get_time_us()

  let duration_ms: u64 = (phase.end_time_us - phase.start_time_us) / 1000

  foundation.serial_write_string("[Boot Opt] Phase ")
  foundation.serial_write_string(phase.name)
  foundation.serial_write_string(" completed in ")
  foundation.serial_write_u64(duration_ms)
  foundation.serial_write_string(" ms\n")
}

// Register an initialization task
export fn boot_opt_register_task(name: *u8, func: u64, priority: u32, parallel: u32): u32 {
  if task_count >= MAX_INIT_TASKS { return 0xFFFFFFFF }

  let task: *InitTask = &init_tasks[task_count]

  // Copy name
  var i: u32 = 0
  loop {
    if i >= 63 { break }

    let ch_ptr: *u8 = name + i
    let ch: u8 = *ch_ptr

    task.name[i] = ch

    if ch == 0 { break }

    i = i + 1
  }
  task.name[63] = 0  // Ensure null termination

  task.func = func
  task.priority = priority
  task.parallel = parallel
  task.completed = 0
  task.start_time_us = 0
  task.end_time_us = 0
  task.phase = current_phase
  task.cpu_id = 0
  task.dependency_wait_us = 0

  let id: u32 = task_count
  task_count = task_count + 1

  // Update phase task count
  if current_phase < phase_count {
    boot_phases[current_phase].task_count = boot_phases[current_phase].task_count + 1
  }

  return id
}

// Sort tasks by priority
fn boot_opt_sort_tasks() {
  var i: u32 = 0
  loop {
    if i >= task_count - 1 { break }

    var j: u32 = 0
    loop {
      if j >= task_count - i - 1 { break }

      if init_tasks[j].priority > init_tasks[j + 1].priority {
        boot_opt_swap_tasks(j, j + 1)
      }

      j = j + 1
    }

    i = i + 1
  }
}

fn boot_opt_swap_tasks(i: u32, j: u32) {
  let temp: InitTask = init_tasks[i]
  init_tasks[i] = init_tasks[j]
  init_tasks[j] = temp
}

fn boot_opt_has_pending_tasks(): u32 {
  var i: u32 = 0
  loop {
    if i >= task_count { break }

    if init_tasks[i].completed == 0 {
      return 1
    }

    i = i + 1
  }

  return 0
}

fn boot_opt_get_next_priority(): u32 {
  var i: u32 = 0
  loop {
    if i >= task_count { break }

    if init_tasks[i].completed == 0 {
      return init_tasks[i].priority
    }

    i = i + 1
  }

  return 0xFFFFFFFF
}

fn boot_opt_run_parallel_tasks(priority: u32) {
  // Start all parallel tasks at this priority
  var i: u32 = 0
  loop {
    if i >= task_count { break }

    let task: *InitTask = &init_tasks[i]

    if task.priority == priority && task.completed == 0 && task.parallel == 1 {
      task.start_time_us = get_time_us()

      // In real implementation, would spawn kernel thread
      // For now, simulate by calling function
      // foundation.spawn_kernel_thread(task.func, 0)

      // Simulate execution
      let result: u32 = 0  // Would actually call function
      task.end_time_us = get_time_us() + 1000  // Simulate 1ms execution
      task.completed = 1
    }

    i = i + 1
  }

  // Run sequential tasks
  i = 0
  loop {
    if i >= task_count { break }

    let task: *InitTask = &init_tasks[i]

    if task.priority == priority && task.completed == 0 && task.parallel == 0 {
      task.start_time_us = get_time_us()

      // Call function synchronously
      // foundation.call_function(task.func, 0)

      task.end_time_us = get_time_us() + 500  // Simulate 0.5ms execution
      task.completed = 1
    }

    i = i + 1
  }
}

// Run all initialization tasks
export fn boot_opt_run_tasks() {
  foundation.serial_write_string("[Boot Opt] Running ")
  foundation.serial_write_u64(task_count)
  foundation.serial_write_string(" init tasks\n")

  // Sort tasks by priority
  boot_opt_sort_tasks()

  // Run tasks by priority
  loop {
    if boot_opt_has_pending_tasks() == 0 { break }

    let priority: u32 = boot_opt_get_next_priority()
    if priority == 0xFFFFFFFF { break }

    boot_opt_run_parallel_tasks(priority)
  }

  let boot_time_us: u64 = get_time_us() - boot_start_time_us
  let boot_time_ms: u64 = boot_time_us / 1000

  foundation.serial_write_string("[Boot Opt] Boot completed in ")
  foundation.serial_write_u64(boot_time_ms)
  foundation.serial_write_string(" ms\n\n")

  // Analyze boot performance
  boot_opt_analyze_performance()

  // Print reports
  boot_opt_print_detailed_report()
  boot_opt_print_boot_chart()
}

// Analyze boot performance and identify bottlenecks
fn boot_opt_analyze_performance() {
  bottleneck_count = 0

  foundation.serial_write_string("[Boot Opt] Analyzing performance...\n")

  // Find slowest tasks
  var i: u32 = 0
  loop {
    if i >= task_count { break }

    let task: *InitTask = &init_tasks[i]
    let duration_us: u64 = task.end_time_us - task.start_time_us

    // Consider anything >100ms a bottleneck
    if duration_us > 100000 {
      if bottleneck_count < MAX_BOTTLENECKS {
        let bn: *Bottleneck = &bottlenecks[bottleneck_count]
        bn.task_name = &task.name[0]
        bn.duration_us = duration_us
        bn.phase = task.phase

        bottleneck_count = bottleneck_count + 1
      }
    }

    i = i + 1
  }

  // Sort bottlenecks by duration
  if bottleneck_count > 1 {
    var j: u32 = 0
    loop {
      if j >= bottleneck_count - 1 { break }

      var k: u32 = 0
      loop {
        if k >= bottleneck_count - j - 1 { break }

        if bottlenecks[k].duration_us < bottlenecks[k + 1].duration_us {
          let temp: Bottleneck = bottlenecks[k]
          bottlenecks[k] = bottlenecks[k + 1]
          bottlenecks[k + 1] = temp
        }

        k = k + 1
      }

      j = j + 1
    }
  }
}

// Print detailed boot report
fn boot_opt_print_detailed_report() {
  foundation.serial_write_string("\n========== DETAILED BOOT REPORT ==========\n\n")

  // Phase breakdown
  foundation.serial_write_string("Boot Phases:\n")

  var i: u32 = 0
  loop {
    if i >= phase_count { break }

    let phase: *BootPhase = &boot_phases[i]
    let duration_ms: u64 = (phase.end_time_us - phase.start_time_us) / 1000

    foundation.serial_write_string("  ")
    foundation.serial_write_string(phase.name)
    foundation.serial_write_string(": ")
    foundation.serial_write_u64(duration_ms)
    foundation.serial_write_string(" ms (")
    foundation.serial_write_u64(phase.task_count)
    foundation.serial_write_string(" tasks)\n")

    i = i + 1
  }

  // Task statistics
  var parallel_count: u32 = 0
  var sequential_count: u32 = 0
  var total_duration_us: u64 = 0

  i = 0
  loop {
    if i >= task_count { break }

    let task: *InitTask = &init_tasks[i]

    if task.parallel == 1 {
      parallel_count = parallel_count + 1
    } else {
      sequential_count = sequential_count + 1
    }

    total_duration_us = total_duration_us + (task.end_time_us - task.start_time_us)

    i = i + 1
  }

  foundation.serial_write_string("\nTask Statistics:\n")
  foundation.serial_write_string("  Total tasks: ")
  foundation.serial_write_u64(task_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Parallel: ")
  foundation.serial_write_u64(parallel_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Sequential: ")
  foundation.serial_write_u64(sequential_count)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Total CPU time: ")
  foundation.serial_write_u64(total_duration_us / 1000)
  foundation.serial_write_string(" ms\n")

  // Bottlenecks
  if bottleneck_count > 0 {
    foundation.serial_write_string("\nBottlenecks (>100ms):\n")

    i = 0
    loop {
      if i >= bottleneck_count { break }

      let bn: *Bottleneck = &bottlenecks[i]

      foundation.serial_write_string("  ")
      foundation.serial_write_u64(i + 1)
      foundation.serial_write_string(". ")
      foundation.serial_write_string(bn.task_name)
      foundation.serial_write_string(": ")
      foundation.serial_write_u64(bn.duration_us / 1000)
      foundation.serial_write_string(" ms\n")

      i = i + 1
    }
  } else {
    foundation.serial_write_string("\nNo bottlenecks detected (all tasks <100ms)\n")
  }

  // Check against targets
  let boot_time_us: u64 = get_time_us() - boot_start_time_us
  let target_us: u64 = if current_platform == 5 { TARGET_BOOT_TO_SHELL_PI5 }
                       else if current_platform == 4 { TARGET_BOOT_TO_SHELL_PI4 }
                       else { TARGET_BOOT_TO_SHELL_PI3 }

  foundation.serial_write_string("\nBoot Time vs Target:\n")
  foundation.serial_write_string("  Actual: ")
  foundation.serial_write_u64(boot_time_us / 1000)
  foundation.serial_write_string(" ms\n")

  foundation.serial_write_string("  Target: ")
  foundation.serial_write_u64(target_us / 1000)
  foundation.serial_write_string(" ms\n")

  if boot_time_us <= target_us {
    foundation.serial_write_string("  Status: UNDER TARGET ✓\n")
  } else {
    let over_by_ms: u64 = (boot_time_us - target_us) / 1000
    foundation.serial_write_string("  Status: OVER BY ")
    foundation.serial_write_u64(over_by_ms)
    foundation.serial_write_string(" ms ✗\n")
  }

  foundation.serial_write_string("\n==========================================\n\n")
}

// Print ASCII boot chart
fn boot_opt_print_boot_chart() {
  foundation.serial_write_string("========== BOOT CHART ==========\n\n")

  let total_time_us: u64 = get_time_us() - boot_start_time_us
  let scale_factor: u64 = total_time_us / 60  // Scale to 60 chars

  if scale_factor == 0 { return }

  foundation.serial_write_string("Time scale: Each '=' represents ~")
  foundation.serial_write_u64(scale_factor / 1000)
  foundation.serial_write_string(" ms\n\n")

  var i: u32 = 0
  loop {
    if i >= task_count { break }

    let task: *InitTask = &init_tasks[i]

    // Print task name (truncated to 20 chars)
    var name_len: u32 = 0
    loop {
      if name_len >= 20 { break }
      if task.name[name_len] == 0 { break }

      let ch_ptr: *u8 = &task.name[name_len]
      foundation.serial_write_char(*ch_ptr)

      name_len = name_len + 1
    }

    // Pad to 20 chars
    loop {
      if name_len >= 20 { break }
      foundation.serial_write_char(' ')
      name_len = name_len + 1
    }

    foundation.serial_write_string(" |")

    // Print bar
    let start_offset: u64 = task.start_time_us - boot_start_time_us
    let duration: u64 = task.end_time_us - task.start_time_us

    let start_pos: u64 = start_offset / scale_factor
    let bar_len: u64 = duration / scale_factor

    if bar_len == 0 {
      bar_len = 1  // Minimum 1 char
    }

    // Print spaces for offset
    var j: u64 = 0
    loop {
      if j >= start_pos { break }
      foundation.serial_write_char(' ')
      j = j + 1
    }

    // Print bar
    j = 0
    loop {
      if j >= bar_len { break }

      if task.parallel == 1 {
        foundation.serial_write_char('=')
      } else {
        foundation.serial_write_char('#')
      }

      j = j + 1
    }

    foundation.serial_write_string("| ")
    foundation.serial_write_u64(duration / 1000)
    foundation.serial_write_string(" ms\n")

    i = i + 1
  }

  foundation.serial_write_string("\nLegend: '=' = parallel, '#' = sequential\n")
  foundation.serial_write_string("\n================================\n\n")
}

// Get boot time
export fn boot_opt_get_boot_time_ms(): u64 {
  return (get_time_us() - boot_start_time_us) / 1000
}

// Mark task as complete (for parallel tasks)
export fn boot_opt_task_complete(task_id: u32) {
  if task_id >= task_count { return }

  init_tasks[task_id].end_time_us = get_time_us()
  init_tasks[task_id].completed = 1
}

// Export data for external analysis
export fn boot_opt_export_data(): *u8 {
  // Would generate JSON or CSV data for external tools
  // For now, return null
  return 0
}

// ============================================================================
// Boot Profiles - Headless vs GUI mode selection
// ============================================================================

// Boot profile types
const BOOT_PROFILE_HEADLESS: u32 = 0      // Minimal, text-only, no GUI
const BOOT_PROFILE_SERVER: u32 = 1        // Server mode with networking
const BOOT_PROFILE_DESKTOP: u32 = 2       // Full desktop with Craft GUI
const BOOT_PROFILE_MINIMAL: u32 = 3       // Absolute minimum for recovery

// Current boot profile
var current_boot_profile: u32 = BOOT_PROFILE_HEADLESS
var boot_profile_initialized: u32 = 0

// Feature flags based on profile
struct BootProfileConfig {
  name: [32]u8,
  load_gui: u32,
  load_network: u32,
  load_usb: u32,
  load_storage: u32,
  load_audio: u32,
  load_gpu: u32,
  load_input: u32,
  load_bluetooth: u32,
  load_wifi: u32,
  target_ram_mb: u32,
  target_boot_ms: u32
}

var profile_configs: [4]BootProfileConfig

// Initialize boot profile configurations
export fn boot_profile_init() {
  if boot_profile_initialized == 1 { return }

  // HEADLESS profile - minimal for shell access
  profile_configs[BOOT_PROFILE_HEADLESS].name[0] = 'h'
  profile_configs[BOOT_PROFILE_HEADLESS].name[1] = 'e'
  profile_configs[BOOT_PROFILE_HEADLESS].name[2] = 'a'
  profile_configs[BOOT_PROFILE_HEADLESS].name[3] = 'd'
  profile_configs[BOOT_PROFILE_HEADLESS].name[4] = 'l'
  profile_configs[BOOT_PROFILE_HEADLESS].name[5] = 'e'
  profile_configs[BOOT_PROFILE_HEADLESS].name[6] = 's'
  profile_configs[BOOT_PROFILE_HEADLESS].name[7] = 's'
  profile_configs[BOOT_PROFILE_HEADLESS].name[8] = 0
  profile_configs[BOOT_PROFILE_HEADLESS].load_gui = 0
  profile_configs[BOOT_PROFILE_HEADLESS].load_network = 1
  profile_configs[BOOT_PROFILE_HEADLESS].load_usb = 1
  profile_configs[BOOT_PROFILE_HEADLESS].load_storage = 1
  profile_configs[BOOT_PROFILE_HEADLESS].load_audio = 0
  profile_configs[BOOT_PROFILE_HEADLESS].load_gpu = 0
  profile_configs[BOOT_PROFILE_HEADLESS].load_input = 1
  profile_configs[BOOT_PROFILE_HEADLESS].load_bluetooth = 0
  profile_configs[BOOT_PROFILE_HEADLESS].load_wifi = 1
  profile_configs[BOOT_PROFILE_HEADLESS].target_ram_mb = 64
  profile_configs[BOOT_PROFILE_HEADLESS].target_boot_ms = 2000

  // SERVER profile - networking focus
  profile_configs[BOOT_PROFILE_SERVER].name[0] = 's'
  profile_configs[BOOT_PROFILE_SERVER].name[1] = 'e'
  profile_configs[BOOT_PROFILE_SERVER].name[2] = 'r'
  profile_configs[BOOT_PROFILE_SERVER].name[3] = 'v'
  profile_configs[BOOT_PROFILE_SERVER].name[4] = 'e'
  profile_configs[BOOT_PROFILE_SERVER].name[5] = 'r'
  profile_configs[BOOT_PROFILE_SERVER].name[6] = 0
  profile_configs[BOOT_PROFILE_SERVER].load_gui = 0
  profile_configs[BOOT_PROFILE_SERVER].load_network = 1
  profile_configs[BOOT_PROFILE_SERVER].load_usb = 1
  profile_configs[BOOT_PROFILE_SERVER].load_storage = 1
  profile_configs[BOOT_PROFILE_SERVER].load_audio = 0
  profile_configs[BOOT_PROFILE_SERVER].load_gpu = 0
  profile_configs[BOOT_PROFILE_SERVER].load_input = 1
  profile_configs[BOOT_PROFILE_SERVER].load_bluetooth = 0
  profile_configs[BOOT_PROFILE_SERVER].load_wifi = 1
  profile_configs[BOOT_PROFILE_SERVER].target_ram_mb = 128
  profile_configs[BOOT_PROFILE_SERVER].target_boot_ms = 3000

  // DESKTOP profile - full GUI
  profile_configs[BOOT_PROFILE_DESKTOP].name[0] = 'd'
  profile_configs[BOOT_PROFILE_DESKTOP].name[1] = 'e'
  profile_configs[BOOT_PROFILE_DESKTOP].name[2] = 's'
  profile_configs[BOOT_PROFILE_DESKTOP].name[3] = 'k'
  profile_configs[BOOT_PROFILE_DESKTOP].name[4] = 't'
  profile_configs[BOOT_PROFILE_DESKTOP].name[5] = 'o'
  profile_configs[BOOT_PROFILE_DESKTOP].name[6] = 'p'
  profile_configs[BOOT_PROFILE_DESKTOP].name[7] = 0
  profile_configs[BOOT_PROFILE_DESKTOP].load_gui = 1
  profile_configs[BOOT_PROFILE_DESKTOP].load_network = 1
  profile_configs[BOOT_PROFILE_DESKTOP].load_usb = 1
  profile_configs[BOOT_PROFILE_DESKTOP].load_storage = 1
  profile_configs[BOOT_PROFILE_DESKTOP].load_audio = 1
  profile_configs[BOOT_PROFILE_DESKTOP].load_gpu = 1
  profile_configs[BOOT_PROFILE_DESKTOP].load_input = 1
  profile_configs[BOOT_PROFILE_DESKTOP].load_bluetooth = 1
  profile_configs[BOOT_PROFILE_DESKTOP].load_wifi = 1
  profile_configs[BOOT_PROFILE_DESKTOP].target_ram_mb = 256
  profile_configs[BOOT_PROFILE_DESKTOP].target_boot_ms = 5000

  // MINIMAL profile - recovery/emergency
  profile_configs[BOOT_PROFILE_MINIMAL].name[0] = 'm'
  profile_configs[BOOT_PROFILE_MINIMAL].name[1] = 'i'
  profile_configs[BOOT_PROFILE_MINIMAL].name[2] = 'n'
  profile_configs[BOOT_PROFILE_MINIMAL].name[3] = 'i'
  profile_configs[BOOT_PROFILE_MINIMAL].name[4] = 'm'
  profile_configs[BOOT_PROFILE_MINIMAL].name[5] = 'a'
  profile_configs[BOOT_PROFILE_MINIMAL].name[6] = 'l'
  profile_configs[BOOT_PROFILE_MINIMAL].name[7] = 0
  profile_configs[BOOT_PROFILE_MINIMAL].load_gui = 0
  profile_configs[BOOT_PROFILE_MINIMAL].load_network = 0
  profile_configs[BOOT_PROFILE_MINIMAL].load_usb = 0
  profile_configs[BOOT_PROFILE_MINIMAL].load_storage = 1
  profile_configs[BOOT_PROFILE_MINIMAL].load_audio = 0
  profile_configs[BOOT_PROFILE_MINIMAL].load_gpu = 0
  profile_configs[BOOT_PROFILE_MINIMAL].load_input = 1
  profile_configs[BOOT_PROFILE_MINIMAL].load_bluetooth = 0
  profile_configs[BOOT_PROFILE_MINIMAL].load_wifi = 0
  profile_configs[BOOT_PROFILE_MINIMAL].target_ram_mb = 32
  profile_configs[BOOT_PROFILE_MINIMAL].target_boot_ms = 1000

  boot_profile_initialized = 1
  foundation.serial_write_string("[Boot Profile] Profiles initialized\n")
}

// Set boot profile from kernel cmdline
export fn boot_profile_set(profile: u32) {
  if profile > BOOT_PROFILE_MINIMAL {
    profile = BOOT_PROFILE_HEADLESS
  }

  current_boot_profile = profile

  foundation.serial_write_string("[Boot Profile] Selected: ")
  foundation.serial_write_string(&profile_configs[profile].name[0])
  foundation.serial_write_string("\n")

  foundation.serial_write_string("[Boot Profile] Target RAM: ")
  foundation.serial_write_hex(profile_configs[profile].target_ram_mb)
  foundation.serial_write_string(" MB\n")

  foundation.serial_write_string("[Boot Profile] Target boot: ")
  foundation.serial_write_hex(profile_configs[profile].target_boot_ms)
  foundation.serial_write_string(" ms\n")
}

// Parse profile from cmdline string (e.g., "profile=headless")
export fn boot_profile_parse_cmdline(cmdline: u64) {
  // Look for "profile=" in cmdline
  var ptr: u64 = cmdline
  var found: u32 = 0

  // Simple search for "profile="
  loop {
    var c: u8 = @ptrLoad(ptr, u8)
    if c == 0 { break }

    if c == 'p' {
      // Check for "profile="
      if @ptrLoad(ptr + 1, u8) == 'r' and
         @ptrLoad(ptr + 2, u8) == 'o' and
         @ptrLoad(ptr + 3, u8) == 'f' and
         @ptrLoad(ptr + 4, u8) == 'i' and
         @ptrLoad(ptr + 5, u8) == 'l' and
         @ptrLoad(ptr + 6, u8) == 'e' and
         @ptrLoad(ptr + 7, u8) == '=' {
        // Found it, parse value
        ptr = ptr + 8
        var value_char: u8 = @ptrLoad(ptr, u8)

        if value_char == 'h' {
          boot_profile_set(BOOT_PROFILE_HEADLESS)
        } else if value_char == 's' {
          boot_profile_set(BOOT_PROFILE_SERVER)
        } else if value_char == 'd' {
          boot_profile_set(BOOT_PROFILE_DESKTOP)
        } else if value_char == 'm' {
          boot_profile_set(BOOT_PROFILE_MINIMAL)
        }
        found = 1
        break
      }
    }
    ptr = ptr + 1
  }

  if found == 0 {
    // Default to headless
    boot_profile_set(BOOT_PROFILE_HEADLESS)
  }
}

// Check if a feature should be loaded
export fn boot_profile_should_load_gui(): u32 {
  return profile_configs[current_boot_profile].load_gui
}

export fn boot_profile_should_load_network(): u32 {
  return profile_configs[current_boot_profile].load_network
}

export fn boot_profile_should_load_usb(): u32 {
  return profile_configs[current_boot_profile].load_usb
}

export fn boot_profile_should_load_storage(): u32 {
  return profile_configs[current_boot_profile].load_storage
}

export fn boot_profile_should_load_audio(): u32 {
  return profile_configs[current_boot_profile].load_audio
}

export fn boot_profile_should_load_gpu(): u32 {
  return profile_configs[current_boot_profile].load_gpu
}

export fn boot_profile_should_load_input(): u32 {
  return profile_configs[current_boot_profile].load_input
}

export fn boot_profile_should_load_bluetooth(): u32 {
  return profile_configs[current_boot_profile].load_bluetooth
}

export fn boot_profile_should_load_wifi(): u32 {
  return profile_configs[current_boot_profile].load_wifi
}

// Get current profile
export fn boot_profile_get_current(): u32 {
  return current_boot_profile
}

// Get target RAM for current profile
export fn boot_profile_get_target_ram_mb(): u32 {
  return profile_configs[current_boot_profile].target_ram_mb
}

// Get target boot time for current profile
export fn boot_profile_get_target_boot_ms(): u32 {
  return profile_configs[current_boot_profile].target_boot_ms
}

// Print current profile configuration
export fn boot_profile_print_config() {
  var config: *BootProfileConfig = &profile_configs[current_boot_profile]

  foundation.serial_write_string("\n[Boot Profile] Current configuration:\n")
  foundation.serial_write_string("  Profile: ")
  foundation.serial_write_string(&config.name[0])
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  GUI:       ")
  if config.load_gui == 1 { foundation.serial_write_string("YES\n") }
  else { foundation.serial_write_string("NO\n") }

  foundation.serial_write_string("  Network:   ")
  if config.load_network == 1 { foundation.serial_write_string("YES\n") }
  else { foundation.serial_write_string("NO\n") }

  foundation.serial_write_string("  USB:       ")
  if config.load_usb == 1 { foundation.serial_write_string("YES\n") }
  else { foundation.serial_write_string("NO\n") }

  foundation.serial_write_string("  Storage:   ")
  if config.load_storage == 1 { foundation.serial_write_string("YES\n") }
  else { foundation.serial_write_string("NO\n") }

  foundation.serial_write_string("  Audio:     ")
  if config.load_audio == 1 { foundation.serial_write_string("YES\n") }
  else { foundation.serial_write_string("NO\n") }

  foundation.serial_write_string("  GPU:       ")
  if config.load_gpu == 1 { foundation.serial_write_string("YES\n") }
  else { foundation.serial_write_string("NO\n") }

  foundation.serial_write_string("  Input:     ")
  if config.load_input == 1 { foundation.serial_write_string("YES\n") }
  else { foundation.serial_write_string("NO\n") }

  foundation.serial_write_string("  Bluetooth: ")
  if config.load_bluetooth == 1 { foundation.serial_write_string("YES\n") }
  else { foundation.serial_write_string("NO\n") }

  foundation.serial_write_string("  WiFi:      ")
  if config.load_wifi == 1 { foundation.serial_write_string("YES\n") }
  else { foundation.serial_write_string("NO\n") }

  foundation.serial_write_string("  Target RAM:  ")
  foundation.serial_write_hex(config.target_ram_mb)
  foundation.serial_write_string(" MB\n")

  foundation.serial_write_string("  Target boot: ")
  foundation.serial_write_hex(config.target_boot_ms)
  foundation.serial_write_string(" ms\n\n")
}

// ============================================================================
// /proc/boot_timing - Export boot timing data
// ============================================================================

// Generate /proc/boot_timing content
export fn boot_timing_generate_proc(buffer: u64, max_size: u32): u32 {
  var offset: u32 = 0

  // Write header
  var header: [64]u8 = "# HomeOS Boot Timing Report\n# Generated at boot\n\n"
  var i: u32 = 0
  loop {
    if header[i] == 0 { break }
    if offset >= max_size { break }
    @ptrStore(buffer + offset, u8, header[i])
    offset = offset + 1
    i = i + 1
  }

  // Write total boot time
  var total_time_ms: u64 = (get_time_us() - boot_start_time_us) / 1000

  var line: [64]u8 = "total_boot_ms: "
  i = 0
  loop {
    if line[i] == 0 { break }
    if offset >= max_size { break }
    @ptrStore(buffer + offset, u8, line[i])
    offset = offset + 1
    i = i + 1
  }

  // Write number (simplified)
  offset = boot_timing_write_number(buffer, offset, max_size, total_time_ms)

  @ptrStore(buffer + offset, u8, '\n')
  offset = offset + 1

  // Write phase data
  var p: u32 = 0
  loop {
    if p >= phase_count { break }

    var phase: *BootPhase = &boot_phases[p]
    var duration_ms: u64 = (phase.end_time_us - phase.start_time_us) / 1000

    // Write phase name and duration
    var phase_prefix: [16]u8 = "phase_"
    i = 0
    loop {
      if phase_prefix[i] == 0 { break }
      if offset >= max_size { break }
      @ptrStore(buffer + offset, u8, phase_prefix[i])
      offset = offset + 1
      i = i + 1
    }

    // Write phase number
    @ptrStore(buffer + offset, u8, '0' + p)
    offset = offset + 1

    @ptrStore(buffer + offset, u8, '_')
    offset = offset + 1

    @ptrStore(buffer + offset, u8, 'm')
    offset = offset + 1

    @ptrStore(buffer + offset, u8, 's')
    offset = offset + 1

    @ptrStore(buffer + offset, u8, ':')
    offset = offset + 1

    @ptrStore(buffer + offset, u8, ' ')
    offset = offset + 1

    offset = boot_timing_write_number(buffer, offset, max_size, duration_ms)

    @ptrStore(buffer + offset, u8, '\n')
    offset = offset + 1

    p = p + 1
  }

  // Null terminate
  if offset < max_size {
    @ptrStore(buffer + offset, u8, 0)
  }

  return offset
}

fn boot_timing_write_number(buffer: u64, offset: u32, max_size: u32, value: u64): u32 {
  var digits: [20]u8
  var count: u32 = 0

  if value == 0 {
    if offset < max_size {
      @ptrStore(buffer + offset, u8, '0')
    }
    return offset + 1
  }

  var temp: u64 = value
  loop {
    if temp == 0 { break }
    digits[count] = '0' + (temp % 10)
    temp = temp / 10
    count = count + 1
  }

  // Write in reverse
  var new_offset: u32 = offset
  loop {
    if count == 0 { break }
    count = count - 1
    if new_offset < max_size {
      @ptrStore(buffer + new_offset, u8, digits[count])
    }
    new_offset = new_offset + 1
  }

  return new_offset
}
