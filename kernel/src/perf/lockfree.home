// home-os Kernel - Lock-Free Data Structures
// Lock-free queue, stack, and hash table implementations

import "../core/foundation.home" as foundation

// Lock-free queue
const QUEUE_SIZE: u32 = 1024

struct LockFreeQueue {
  data: [u64; 1024],
  head: u32,
  tail: u32
}

export fn lockfree_queue_init(queue: u64) {
  @intToPtr(queue, u32) = 0  // head
  @intToPtr(queue + 4, u32) = 0  // tail
}

export fn lockfree_queue_enqueue(queue: u64, value: u64) -> u32 {
  var tail: u32 = @intToPtr(queue + 4, u32)
  var next_tail: u32 = (tail + 1) % QUEUE_SIZE
  var head: u32 = @intToPtr(queue, u32)
  
  if next_tail == head {
    return 0  // Queue full
  }
  
  var data_ptr: u64 = queue + 8 + (tail * 8)
  @intToPtr(data_ptr, u64) = value
  
  // Atomic update of tail
  foundation.atomic_store_u32(queue + 4, next_tail)
  
  return 1
}

export fn lockfree_queue_dequeue(queue: u64, value_out: u64) -> u32 {
  var head: u32 = @intToPtr(queue, u32)
  var tail: u32 = @intToPtr(queue + 4, u32)
  
  if head == tail {
    return 0  // Queue empty
  }
  
  var data_ptr: u64 = queue + 8 + (head * 8)
  @intToPtr(value_out, u64) = @intToPtr(data_ptr, u64)
  
  var next_head: u32 = (head + 1) % QUEUE_SIZE
  
  // Atomic update of head
  foundation.atomic_store_u32(queue, next_head)
  
  return 1
}

// Lock-free stack
const STACK_SIZE: u32 = 1024

struct LockFreeStack {
  data: [u64; 1024],
  top: u32
}

export fn lockfree_stack_init(stack: u64) {
  @intToPtr(stack, u32) = 0  // top
}

export fn lockfree_stack_push(stack: u64, value: u64) -> u32 {
  var top: u32 = @intToPtr(stack, u32)
  
  if top >= STACK_SIZE {
    return 0  // Stack full
  }
  
  var data_ptr: u64 = stack + 4 + (top * 8)
  @intToPtr(data_ptr, u64) = value
  
  // Atomic increment of top
  foundation.atomic_add_u32(stack, 1)
  
  return 1
}

export fn lockfree_stack_pop(stack: u64, value_out: u64) -> u32 {
  var top: u32 = @intToPtr(stack, u32)
  
  if top == 0 {
    return 0  // Stack empty
  }
  
  // Atomic decrement of top
  var new_top: u32 = foundation.atomic_sub_u32(stack, 1)
  
  var data_ptr: u64 = stack + 4 + (new_top * 8)
  @intToPtr(value_out, u64) = @intToPtr(data_ptr, u64)
  
  return 1
}

// Lock-free hash table (simplified)
const HASH_TABLE_SIZE: u32 = 256

struct HashEntry {
  key: u64,
  value: u64,
  next: u32
}

export fn lockfree_hash_init(table: u64) {
  var i: u32 = 0
  while i < HASH_TABLE_SIZE {
    @intToPtr(table + (i * 4), u32) = 0xFFFFFFFF
    i = i + 1
  }
}

fn lockfree_hash_function(key: u64) -> u32 {
  return @truncate(key % HASH_TABLE_SIZE, u32)
}

export fn lockfree_hash_insert(table: u64, entries: u64, key: u64, value: u64) -> u32 {
  var hash: u32 = lockfree_hash_function(key)
  var bucket_ptr: u64 = table + (hash * 4)
  
  // Find free entry
  var entry_idx: u32 = 0
  while entry_idx < 1000 {
    var entry_ptr: u64 = entries + (entry_idx * 24)
    var entry_key: u64 = @intToPtr(entry_ptr, u64)
    
    if entry_key == 0 {
      // Free entry found
      @intToPtr(entry_ptr, u64) = key
      @intToPtr(entry_ptr + 8, u64) = value
      
      var old_head: u32 = @intToPtr(bucket_ptr, u32)
      @intToPtr(entry_ptr + 16, u32) = old_head
      
      // Atomic update of bucket head
      foundation.atomic_store_u32(bucket_ptr, entry_idx)
      
      return 1
    }
    
    entry_idx = entry_idx + 1
  }
  
  return 0
}

export fn lockfree_hash_lookup(table: u64, entries: u64, key: u64, value_out: u64) -> u32 {
  var hash: u32 = lockfree_hash_function(key)
  var bucket_ptr: u64 = table + (hash * 4)
  
  var entry_idx: u32 = @intToPtr(bucket_ptr, u32)
  
  while entry_idx != 0xFFFFFFFF {
    var entry_ptr: u64 = entries + (entry_idx * 24)
    var entry_key: u64 = @intToPtr(entry_ptr, u64)
    
    if entry_key == key {
      @intToPtr(value_out, u64) = @intToPtr(entry_ptr + 8, u64)
      return 1
    }
    
    entry_idx = @intToPtr(entry_ptr + 16, u32)
  }
  
  return 0
}

// Atomic operations helpers
export fn lockfree_cas_u64(ptr: u64, expected: u64, desired: u64) -> u32 {
  return foundation.atomic_cas_u64(ptr, expected, desired)
}

export fn lockfree_cas_u32(ptr: u64, expected: u32, desired: u32) -> u32 {
  return foundation.atomic_cas_u32(ptr, expected, desired)
}

export fn lockfree_fetch_add_u64(ptr: u64, value: u64) -> u64 {
  return foundation.atomic_fetch_add_u64(ptr, value)
}

export fn lockfree_fetch_add_u32(ptr: u64, value: u32) -> u32 {
  return foundation.atomic_fetch_add_u32(ptr, value)
}
