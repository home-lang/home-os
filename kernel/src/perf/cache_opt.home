// home-os Kernel - Cache Optimization
// Cache-friendly data structures and prefetching

import "../core/foundation.home" as foundation

// Cache line size (typically 64 bytes on x86-64)
const CACHE_LINE_SIZE: u32 = 64

// Prefetch hints
const PREFETCH_T0: u32 = 1  // Temporal data, all cache levels
const PREFETCH_T1: u32 = 2  // Temporal data, L2 and L3
const PREFETCH_T2: u32 = 3  // Temporal data, L3 only
const PREFETCH_NTA: u32 = 0  // Non-temporal data

var cache_opt_initialized: u32 = 0
var cache_line_size: u32 = 64
var l1_cache_size: u32 = 32768  // 32KB
var l2_cache_size: u32 = 262144  // 256KB
var l3_cache_size: u32 = 8388608  // 8MB

export fn cache_opt_init() {
  if cache_opt_initialized == 1 { return }
  
  // Detect cache sizes via CPUID
  cache_detect_sizes()
  
  cache_opt_initialized = 1
  foundation.serial_write_string("[CacheOpt] Initialized - L1: ")
  foundation.serial_write_hex(l1_cache_size)
  foundation.serial_write_string(" L2: ")
  foundation.serial_write_hex(l2_cache_size)
  foundation.serial_write_string(" L3: ")
  foundation.serial_write_hex(l3_cache_size)
  foundation.serial_write_string("\n")
}

fn cache_detect_sizes() {
  // CPUID leaf 0x04 for cache information
  var eax: u32 = 0x04
  var ecx: u32 = 0
  
  // Query L1 data cache
  var cache_info: u32 = foundation.cpuid_eax_ecx(eax, ecx)
  
  // Parse cache size from CPUID
  // Simplified - real implementation would parse all fields
}

export fn cache_prefetch(addr: u64, hint: u32) {
  // Prefetch data into cache
  if hint == PREFETCH_T0 {
    foundation.asm_prefetcht0(addr)
  } else if hint == PREFETCH_T1 {
    foundation.asm_prefetcht1(addr)
  } else if hint == PREFETCH_T2 {
    foundation.asm_prefetcht2(addr)
  } else {
    foundation.asm_prefetchnta(addr)
  }
}

export fn cache_align_size(size: u32) -> u32 {
  // Align size to cache line boundary
  return (size + CACHE_LINE_SIZE - 1) & ~(CACHE_LINE_SIZE - 1)
}

export fn cache_is_aligned(addr: u64) -> u32 {
  if (addr % CACHE_LINE_SIZE) == 0 {
    return 1
  }
  return 0
}

export fn cache_flush_line(addr: u64) {
  // Flush cache line containing address
  foundation.asm_clflush(addr)
}

export fn cache_flush_range(start: u64, size: u64) {
  var addr: u64 = start & ~(CACHE_LINE_SIZE - 1)
  var end: u64 = start + size
  
  while addr < end {
    cache_flush_line(addr)
    addr = addr + CACHE_LINE_SIZE
  }
}

export fn cache_get_line_size() -> u32 {
  return cache_line_size
}

export fn cache_get_l1_size() -> u32 {
  return l1_cache_size
}

export fn cache_get_l2_size() -> u32 {
  return l2_cache_size
}

export fn cache_get_l3_size() -> u32 {
  return l3_cache_size
}

// Prevent false sharing by padding structures
export fn cache_pad_size(size: u32) -> u32 {
  // Pad to multiple of cache line size
  return cache_align_size(size)
}
