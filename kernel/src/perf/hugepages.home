// home-os Kernel - Huge Page Support
// Transparent huge pages for improved TLB performance

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

// Page sizes
const PAGE_SIZE_4K: u32 = 4096
const PAGE_SIZE_2M: u32 = 2097152
const PAGE_SIZE_1G: u32 = 1073741824

// Huge page flags
const HP_ENABLED: u32 = 1 << 0
const HP_TRANSPARENT: u32 = 1 << 1
const HP_ALWAYS: u32 = 1 << 2
const HP_MADVISE: u32 = 1 << 3

var hugepage_enabled: u32 = 1
var hugepage_mode: u32 = HP_TRANSPARENT
var hugepage_2m_count: u32 = 0
var hugepage_1g_count: u32 = 0
var hugepage_initialized: u32 = 0

export fn hugepage_init() {
  if hugepage_initialized == 1 { return }
  
  // Check CPU support for huge pages
  if hugepage_check_support() == 0 {
    hugepage_enabled = 0
    foundation.serial_write_string("[HugePages] Not supported by CPU\n")
    return
  }
  
  hugepage_enabled = 1
  hugepage_mode = HP_TRANSPARENT | HP_ALWAYS
  
  hugepage_initialized = 1
  foundation.serial_write_string("[HugePages] Initialized - mode: transparent\n")
}

fn hugepage_check_support() -> u32 {
  // Check CPUID for PSE (Page Size Extension) and PSE-36
  var edx: u32 = foundation.cpuid_edx(1)
  
  if (edx & (1 << 3)) != 0 {  // PSE bit
    return 1
  }
  
  return 0
}

export fn hugepage_alloc_2m() -> u64 {
  if hugepage_enabled == 0 { return 0 }
  
  // Allocate 2MB huge page
  var addr: u64 = memory.memory_alloc_aligned(PAGE_SIZE_2M, PAGE_SIZE_2M)
  
  if addr != 0 {
    hugepage_2m_count = hugepage_2m_count + 1
    
    // Set huge page bit in page table
    hugepage_set_pte_2m(addr)
  }
  
  return addr
}

export fn hugepage_alloc_1g() -> u64 {
  if hugepage_enabled == 0 { return 0 }
  
  // Allocate 1GB huge page
  var addr: u64 = memory.memory_alloc_aligned(PAGE_SIZE_1G, PAGE_SIZE_1G)
  
  if addr != 0 {
    hugepage_1g_count = hugepage_1g_count + 1
    
    // Set huge page bit in page table
    hugepage_set_pte_1g(addr)
  }
  
  return addr
}

fn hugepage_set_pte_2m(addr: u64) {
  var pte: u64 = memory.memory_get_pte(addr)
  
  // Set PS (Page Size) bit in PDE
  pte = pte | (1 << 7)
  
  memory.memory_set_pte(addr, pte)
}

fn hugepage_set_pte_1g(addr: u64) {
  var pte: u64 = memory.memory_get_pte(addr)
  
  // Set PS bit in PDPE
  pte = pte | (1 << 7)
  
  memory.memory_set_pte(addr, pte)
}

export fn hugepage_free_2m(addr: u64) {
  if addr == 0 { return }
  
  memory.memory_free(addr, PAGE_SIZE_2M)
  hugepage_2m_count = hugepage_2m_count - 1
}

export fn hugepage_free_1g(addr: u64) {
  if addr == 0 { return }
  
  memory.memory_free(addr, PAGE_SIZE_1G)
  hugepage_1g_count = hugepage_1g_count - 1
}

export fn hugepage_try_collapse(addr: u64, size: u64) -> u32 {
  if hugepage_enabled == 0 { return 0 }
  if (hugepage_mode & HP_TRANSPARENT) == 0 { return 0 }
  
  // Try to collapse 512 4K pages into one 2M page
  if size >= PAGE_SIZE_2M and (addr % PAGE_SIZE_2M) == 0 {
    // Check if all pages are contiguous and allocated
    if hugepage_can_collapse(addr, PAGE_SIZE_2M) == 1 {
      hugepage_set_pte_2m(addr)
      hugepage_2m_count = hugepage_2m_count + 1
      return 1
    }
  }
  
  return 0
}

fn hugepage_can_collapse(addr: u64, size: u64) -> u32 {
  var current: u64 = addr
  var end: u64 = addr + size
  
  while current < end {
    var pte: u64 = memory.memory_get_pte(current)
    
    if (pte & 0x1) == 0 {  // Page not present
      return 0
    }
    
    current = current + PAGE_SIZE_4K
  }
  
  return 1
}

export fn hugepage_split_2m(addr: u64) -> u32 {
  if addr == 0 { return 0 }
  
  // Split 2MB page into 512 4K pages
  var pte: u64 = memory.memory_get_pte(addr)
  
  // Clear PS bit
  pte = pte & ~(1 << 7)
  
  memory.memory_set_pte(addr, pte)
  
  hugepage_2m_count = hugepage_2m_count - 1
  
  return 1
}

export fn hugepage_is_enabled() -> u32 {
  return hugepage_enabled
}

export fn hugepage_get_2m_count() -> u32 {
  return hugepage_2m_count
}

export fn hugepage_get_1g_count() -> u32 {
  return hugepage_1g_count
}

export fn hugepage_set_mode(mode: u32) {
  hugepage_mode = mode
}

export fn hugepage_get_mode() -> u32 {
  return hugepage_mode
}
