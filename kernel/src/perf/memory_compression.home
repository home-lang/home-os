// home-os Kernel - Memory Compression (zswap-like)
// Compress inactive pages to reduce memory pressure

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

const MAX_COMPRESSED_PAGES: u32 = 10000
const COMPRESSION_THRESHOLD: u32 = 50  // Compress if >50% savings

struct CompressedPage {
  original_addr: u64,
  compressed_data: u64,
  original_size: u32,
  compressed_size: u32,
  in_use: u32
}

var compressed_pages: [CompressedPage; 10000]
var compressed_count: u32 = 0
var compression_enabled: u32 = 1
var compression_initialized: u32 = 0
var total_saved_bytes: u64 = 0

export fn memory_compression_init() {
  if compression_initialized == 1 { return }
  
  compressed_count = 0
  compression_enabled = 1
  total_saved_bytes = 0
  
  compression_initialized = 1
  foundation.serial_write_string("[MemCompress] Initialized\n")
}

export fn memory_compress_page(addr: u64, size: u32) -> u32 {
  if compression_enabled == 0 { return 0 }
  if compressed_count >= MAX_COMPRESSED_PAGES { return 0 }
  
  // Allocate buffer for compressed data
  var compressed_buf: u64 = memory.memory_alloc(size)
  if compressed_buf == 0 { return 0 }
  
  // Simple RLE compression
  var compressed_size: u32 = memory_compress_rle(addr, compressed_buf, size)
  
  // Check if compression is worthwhile
  var savings: u32 = ((size - compressed_size) * 100) / size
  if savings < COMPRESSION_THRESHOLD {
    memory.memory_free(compressed_buf, size)
    return 0
  }
  
  compressed_pages[compressed_count].original_addr = addr
  compressed_pages[compressed_count].compressed_data = compressed_buf
  compressed_pages[compressed_count].original_size = size
  compressed_pages[compressed_count].compressed_size = compressed_size
  compressed_pages[compressed_count].in_use = 1
  
  total_saved_bytes = total_saved_bytes + (size - compressed_size)
  compressed_count = compressed_count + 1
  
  return 1
}

fn memory_compress_rle(input: u64, output: u64, size: u32) -> u32 {
  // Run-Length Encoding compression
  var in_pos: u32 = 0
  var out_pos: u32 = 0
  
  while in_pos < size {
    var current: u8 = @intToPtr(input + in_pos, u8)
    var run_length: u32 = 1
    
    // Count consecutive identical bytes
    while in_pos + run_length < size and run_length < 255 {
      if @intToPtr(input + in_pos + run_length, u8) == current {
        run_length = run_length + 1
      } else {
        break
      }
    }
    
    // Write run
    @intToPtr(output + out_pos, u8) = @truncate(run_length, u8)
    @intToPtr(output + out_pos + 1, u8) = current
    
    out_pos = out_pos + 2
    in_pos = in_pos + run_length
  }
  
  return out_pos
}

export fn memory_decompress_page(addr: u64) -> u32 {
  var i: u32 = 0
  while i < compressed_count {
    if compressed_pages[i].original_addr == addr and compressed_pages[i].in_use == 1 {
      // Decompress
      memory_decompress_rle(
        compressed_pages[i].compressed_data,
        addr,
        compressed_pages[i].compressed_size,
        compressed_pages[i].original_size
      )
      
      // Free compressed data
      memory.memory_free(compressed_pages[i].compressed_data, compressed_pages[i].original_size)
      
      total_saved_bytes = total_saved_bytes - (compressed_pages[i].original_size - compressed_pages[i].compressed_size)
      compressed_pages[i].in_use = 0
      
      return 1
    }
    i = i + 1
  }
  
  return 0
}

fn memory_decompress_rle(input: u64, output: u64, compressed_size: u32, original_size: u32) {
  var in_pos: u32 = 0
  var out_pos: u32 = 0
  
  while in_pos < compressed_size and out_pos < original_size {
    var run_length: u8 = @intToPtr(input + in_pos, u8)
    var value: u8 = @intToPtr(input + in_pos + 1, u8)
    
    var j: u32 = 0
    while j < run_length and out_pos < original_size {
      @intToPtr(output + out_pos, u8) = value
      out_pos = out_pos + 1
      j = j + 1
    }
    
    in_pos = in_pos + 2
  }
}

export fn memory_compression_enable() {
  compression_enabled = 1
}

export fn memory_compression_disable() {
  compression_enabled = 0
}

export fn memory_compression_get_count() -> u32 {
  return compressed_count
}

export fn memory_compression_get_saved() -> u64 {
  return total_saved_bytes
}

export fn memory_compression_get_ratio() -> u32 {
  if compressed_count == 0 { return 0 }
  
  var total_original: u64 = 0
  var total_compressed: u64 = 0
  
  var i: u32 = 0
  while i < compressed_count {
    if compressed_pages[i].in_use == 1 {
      total_original = total_original + compressed_pages[i].original_size
      total_compressed = total_compressed + compressed_pages[i].compressed_size
    }
    i = i + 1
  }
  
  if total_original == 0 { return 0 }
  
  return @truncate((total_compressed * 100) / total_original, u32)
}
