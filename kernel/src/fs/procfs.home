// home-os Kernel - ProcFS
// Process filesystem (/proc) - Virtual filesystem for process and kernel information

import "../core/foundation.home" as foundation

// Entry types
const PROCFS_FILE: u32 = 0
const PROCFS_DIR: u32 = 1
const PROCFS_SYMLINK: u32 = 2

// Read permissions
const PROCFS_READ_ONLY: u32 = 0o444
const PROCFS_READ_WRITE: u32 = 0o644
const PROCFS_DIR_PERM: u32 = 0o555

const MAX_PROC_ENTRIES: u32 = 1024
const MAX_PID_ENTRIES: u32 = 256
const MAX_PATH_LEN: u32 = 256
const MAX_VALUE_LEN: u32 = 4096

// Function pointer types for dynamic content
struct ProcHandler {
  read_fn: u64,       // fn(buffer: u64, size: u32, offset: u64): u32
  write_fn: u64,      // fn(buffer: u64, size: u32): u32
  data: u64           // Opaque data for handler
}

// Proc entry structure
struct ProcEntry {
  name: [u8; 64],
  path: [u8; 256],
  entry_type: u32,
  permissions: u32,
  handler: ProcHandler,
  parent: u32,
  size: u64,
  in_use: u32
}

// Per-process entry info
struct ProcessProcEntry {
  pid: u32,
  ppid: u32,
  uid: u32,
  gid: u32,
  state: u8,
  comm: [u8; 64],
  cmdline: [u8; 256],
  cwd: [u8; 256],
  exe: [u8; 256],
  vm_size: u64,
  vm_rss: u64,
  vm_data: u64,
  vm_stack: u64,
  vm_exe: u64,
  vm_lib: u64,
  threads: u32,
  start_time: u64,
  utime: u64,
  stime: u64,
  priority: i32,
  nice: i32,
  in_use: u32
}

// CPU information
struct CpuInfo {
  vendor_id: [u8; 32],
  model_name: [u8; 64],
  cpu_family: u32,
  model: u32,
  stepping: u32,
  cpu_mhz: u32,
  cache_size: u32,
  physical_id: u32,
  siblings: u32,
  core_id: u32,
  cpu_cores: u32,
  flags: [u8; 256]
}

// Memory information
struct MemInfo {
  mem_total: u64,
  mem_free: u64,
  mem_available: u64,
  buffers: u64,
  cached: u64,
  swap_cached: u64,
  active: u64,
  inactive: u64,
  active_anon: u64,
  inactive_anon: u64,
  active_file: u64,
  inactive_file: u64,
  unevictable: u64,
  mlocked: u64,
  swap_total: u64,
  swap_free: u64,
  dirty: u64,
  writeback: u64,
  anon_pages: u64,
  mapped: u64,
  shmem: u64,
  slab: u64,
  s_reclaimable: u64,
  s_unreclaim: u64,
  kernel_stack: u64,
  page_tables: u64,
  nfs_unstable: u64,
  bounce: u64,
  writeback_tmp: u64,
  commit_limit: u64,
  committed_as: u64,
  vmalloc_total: u64,
  vmalloc_used: u64,
  vmalloc_chunk: u64,
  hardware_corrupted: u64,
  anon_huge_pages: u64,
  huge_pages_total: u64,
  huge_pages_free: u64,
  huge_pages_rsvd: u64,
  huge_pages_surp: u64,
  hugepagesize: u64
}

// Load average
struct LoadAvg {
  load_1: u32,    // Fixed point: divide by 65536
  load_5: u32,
  load_15: u32,
  nr_running: u32,
  nr_threads: u32,
  last_pid: u32
}

// Uptime
struct Uptime {
  total_sec: u64,
  total_usec: u32,
  idle_sec: u64,
  idle_usec: u32
}

// Mount info
struct MountInfo {
  mount_id: u32,
  parent_id: u32,
  major: u32,
  minor: u32,
  root: [u8; 128],
  mount_point: [u8; 128],
  mount_options: [u8; 64],
  fs_type: [u8; 32],
  source: [u8; 128],
  super_options: [u8; 64],
  in_use: u32
}

// Disk stats
struct DiskStats {
  major: u32,
  minor: u32,
  name: [u8; 32],
  reads_completed: u64,
  reads_merged: u64,
  sectors_read: u64,
  time_reading: u64,
  writes_completed: u64,
  writes_merged: u64,
  sectors_written: u64,
  time_writing: u64,
  ios_in_progress: u32,
  time_io: u64,
  weighted_time: u64,
  in_use: u32
}

var proc_entries: [ProcEntry; 1024]
var proc_entry_count: u32 = 0

var process_entries: [ProcessProcEntry; 256]
var process_entry_count: u32 = 0

var cpu_info: [CpuInfo; 64]
var cpu_count: u32 = 0

var mem_info: MemInfo
var load_avg: LoadAvg
var uptime: Uptime

var mount_entries: [MountInfo; 64]
var mount_count: u32 = 0

var disk_stats: [DiskStats; 32]
var disk_count: u32 = 0

var kernel_version: [u8; 128]
var kernel_cmdline: [u8; 512]

var procfs_initialized: u32 = 0

export fn procfs_init() {
  if procfs_initialized == 1 { return }

  proc_entry_count = 0
  process_entry_count = 0
  cpu_count = 0
  mount_count = 0
  disk_count = 0

  // Initialize kernel version
  procfs_set_string(kernel_version, "home-os 0.1.0 (Home Language OS)", 128)

  // Initialize command line
  procfs_set_string(kernel_cmdline, "console=ttyS0 root=/dev/sda1 rw", 512)

  // Initialize memory info with defaults
  mem_info.mem_total = 0
  mem_info.mem_free = 0
  mem_info.mem_available = 0
  mem_info.buffers = 0
  mem_info.cached = 0
  mem_info.swap_total = 0
  mem_info.swap_free = 0

  // Initialize load average
  load_avg.load_1 = 0
  load_avg.load_5 = 0
  load_avg.load_15 = 0
  load_avg.nr_running = 0
  load_avg.nr_threads = 0
  load_avg.last_pid = 0

  // Initialize uptime
  uptime.total_sec = 0
  uptime.total_usec = 0
  uptime.idle_sec = 0
  uptime.idle_usec = 0

  // Register core entries
  procfs_register_core_entries()

  procfs_initialized = 1
  foundation.serial_write_string("[ProcFS] Process filesystem initialized\n")
}

fn procfs_register_core_entries() {
  // Register static entries
  procfs_create_entry("", "/proc", PROCFS_DIR, PROCFS_DIR_PERM)
  procfs_create_entry("self", "/proc/self", PROCFS_SYMLINK, PROCFS_READ_ONLY)
  procfs_create_entry("cpuinfo", "/proc/cpuinfo", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("meminfo", "/proc/meminfo", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("uptime", "/proc/uptime", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("loadavg", "/proc/loadavg", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("version", "/proc/version", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("cmdline", "/proc/cmdline", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("stat", "/proc/stat", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("filesystems", "/proc/filesystems", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("mounts", "/proc/mounts", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("partitions", "/proc/partitions", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("diskstats", "/proc/diskstats", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("interrupts", "/proc/interrupts", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("devices", "/proc/devices", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("modules", "/proc/modules", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("vmstat", "/proc/vmstat", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("zoneinfo", "/proc/zoneinfo", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("buddyinfo", "/proc/buddyinfo", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("pagetypeinfo", "/proc/pagetypeinfo", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("slabinfo", "/proc/slabinfo", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("cgroups", "/proc/cgroups", PROCFS_FILE, PROCFS_READ_ONLY)

  // Create /proc/net directory
  procfs_create_entry("net", "/proc/net", PROCFS_DIR, PROCFS_DIR_PERM)
  procfs_create_entry("dev", "/proc/net/dev", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("tcp", "/proc/net/tcp", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("udp", "/proc/net/udp", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("unix", "/proc/net/unix", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("route", "/proc/net/route", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("arp", "/proc/net/arp", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("sockstat", "/proc/net/sockstat", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("netstat", "/proc/net/netstat", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("protocols", "/proc/net/protocols", PROCFS_FILE, PROCFS_READ_ONLY)

  // Create /proc/sys directory (sysctl interface)
  procfs_create_entry("sys", "/proc/sys", PROCFS_DIR, PROCFS_DIR_PERM)
  procfs_create_entry("kernel", "/proc/sys/kernel", PROCFS_DIR, PROCFS_DIR_PERM)
  procfs_create_entry("vm", "/proc/sys/vm", PROCFS_DIR, PROCFS_DIR_PERM)
  procfs_create_entry("net", "/proc/sys/net", PROCFS_DIR, PROCFS_DIR_PERM)
  procfs_create_entry("fs", "/proc/sys/fs", PROCFS_DIR, PROCFS_DIR_PERM)

  // Kernel sysctl entries
  procfs_create_entry("hostname", "/proc/sys/kernel/hostname", PROCFS_FILE, PROCFS_READ_WRITE)
  procfs_create_entry("domainname", "/proc/sys/kernel/domainname", PROCFS_FILE, PROCFS_READ_WRITE)
  procfs_create_entry("osrelease", "/proc/sys/kernel/osrelease", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("ostype", "/proc/sys/kernel/ostype", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("version", "/proc/sys/kernel/version", PROCFS_FILE, PROCFS_READ_ONLY)
  procfs_create_entry("pid_max", "/proc/sys/kernel/pid_max", PROCFS_FILE, PROCFS_READ_WRITE)
  procfs_create_entry("threads-max", "/proc/sys/kernel/threads-max", PROCFS_FILE, PROCFS_READ_WRITE)
  procfs_create_entry("random", "/proc/sys/kernel/random", PROCFS_DIR, PROCFS_DIR_PERM)

  // VM sysctl entries
  procfs_create_entry("swappiness", "/proc/sys/vm/swappiness", PROCFS_FILE, PROCFS_READ_WRITE)
  procfs_create_entry("overcommit_memory", "/proc/sys/vm/overcommit_memory", PROCFS_FILE, PROCFS_READ_WRITE)
  procfs_create_entry("overcommit_ratio", "/proc/sys/vm/overcommit_ratio", PROCFS_FILE, PROCFS_READ_WRITE)
  procfs_create_entry("dirty_ratio", "/proc/sys/vm/dirty_ratio", PROCFS_FILE, PROCFS_READ_WRITE)
  procfs_create_entry("dirty_background_ratio", "/proc/sys/vm/dirty_background_ratio", PROCFS_FILE, PROCFS_READ_WRITE)
  procfs_create_entry("min_free_kbytes", "/proc/sys/vm/min_free_kbytes", PROCFS_FILE, PROCFS_READ_WRITE)
  procfs_create_entry("vfs_cache_pressure", "/proc/sys/vm/vfs_cache_pressure", PROCFS_FILE, PROCFS_READ_WRITE)
}

// Create a proc entry
fn procfs_create_entry(name: u64, path: u64, entry_type: u32, permissions: u32): u32 {
  if proc_entry_count >= MAX_PROC_ENTRIES { return 0xFFFFFFFF }

  var entry_id: u32 = proc_entry_count

  // Copy name
  var i: u32 = 0
  while i < 63 {
    var ch: u8 = @intToPtr(name + i, u8)
    proc_entries[entry_id].name[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  proc_entries[entry_id].name[i] = 0

  // Copy path
  i = 0
  while i < 255 {
    var ch: u8 = @intToPtr(path + i, u8)
    proc_entries[entry_id].path[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  proc_entries[entry_id].path[i] = 0

  proc_entries[entry_id].entry_type = entry_type
  proc_entries[entry_id].permissions = permissions
  proc_entries[entry_id].handler.read_fn = 0
  proc_entries[entry_id].handler.write_fn = 0
  proc_entries[entry_id].handler.data = 0
  proc_entries[entry_id].parent = 0xFFFFFFFF
  proc_entries[entry_id].size = 0
  proc_entries[entry_id].in_use = 1

  proc_entry_count = proc_entry_count + 1

  return entry_id
}

// Register a proc entry with handler
export fn procfs_register(name: u64, path: u64, read_fn: u64, write_fn: u64): u32 {
  var entry_id: u32 = procfs_create_entry(name, path, PROCFS_FILE, PROCFS_READ_ONLY)
  if entry_id == 0xFFFFFFFF { return entry_id }

  proc_entries[entry_id].handler.read_fn = read_fn
  proc_entries[entry_id].handler.write_fn = write_fn

  if write_fn != 0 {
    proc_entries[entry_id].permissions = PROCFS_READ_WRITE
  }

  return entry_id
}

// Unregister a proc entry
export fn procfs_unregister(entry_id: u32): u32 {
  if entry_id >= proc_entry_count { return 0 }

  proc_entries[entry_id].in_use = 0
  return 1
}

// Register a process
export fn procfs_register_process(pid: u32, ppid: u32, uid: u32, gid: u32, comm: u64): u32 {
  if process_entry_count >= MAX_PID_ENTRIES { return 0xFFFFFFFF }

  var entry_id: u32 = process_entry_count

  process_entries[entry_id].pid = pid
  process_entries[entry_id].ppid = ppid
  process_entries[entry_id].uid = uid
  process_entries[entry_id].gid = gid
  process_entries[entry_id].state = 'R'  // Running

  // Copy comm
  var i: u32 = 0
  while i < 63 {
    var ch: u8 = @intToPtr(comm + i, u8)
    process_entries[entry_id].comm[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  process_entries[entry_id].comm[i] = 0

  // Initialize other fields
  process_entries[entry_id].vm_size = 0
  process_entries[entry_id].vm_rss = 0
  process_entries[entry_id].threads = 1
  process_entries[entry_id].start_time = 0
  process_entries[entry_id].utime = 0
  process_entries[entry_id].stime = 0
  process_entries[entry_id].priority = 20
  process_entries[entry_id].nice = 0
  process_entries[entry_id].in_use = 1

  process_entry_count = process_entry_count + 1

  return entry_id
}

// Update process state
export fn procfs_update_process_state(pid: u32, state: u8) {
  var i: u32 = 0
  while i < process_entry_count {
    if process_entries[i].in_use == 1 && process_entries[i].pid == pid {
      process_entries[i].state = state
      return
    }
    i = i + 1
  }
}

// Update process memory info
export fn procfs_update_process_memory(pid: u32, vm_size: u64, vm_rss: u64, vm_data: u64, vm_stack: u64) {
  var i: u32 = 0
  while i < process_entry_count {
    if process_entries[i].in_use == 1 && process_entries[i].pid == pid {
      process_entries[i].vm_size = vm_size
      process_entries[i].vm_rss = vm_rss
      process_entries[i].vm_data = vm_data
      process_entries[i].vm_stack = vm_stack
      return
    }
    i = i + 1
  }
}

// Update process CPU time
export fn procfs_update_process_time(pid: u32, utime: u64, stime: u64) {
  var i: u32 = 0
  while i < process_entry_count {
    if process_entries[i].in_use == 1 && process_entries[i].pid == pid {
      process_entries[i].utime = utime
      process_entries[i].stime = stime
      return
    }
    i = i + 1
  }
}

// Unregister a process
export fn procfs_unregister_process(pid: u32): u32 {
  var i: u32 = 0
  while i < process_entry_count {
    if process_entries[i].in_use == 1 && process_entries[i].pid == pid {
      process_entries[i].in_use = 0
      return 1
    }
    i = i + 1
  }
  return 0
}

// Read from a proc entry
export fn procfs_read(path: u64, buffer: u64, size: u32, offset: u64): u32 {
  // Check for specific paths
  if procfs_strcmp(path, "/proc/cpuinfo") == 1 {
    return procfs_read_cpuinfo(buffer, size, offset)
  }
  if procfs_strcmp(path, "/proc/meminfo") == 1 {
    return procfs_read_meminfo(buffer, size, offset)
  }
  if procfs_strcmp(path, "/proc/uptime") == 1 {
    return procfs_read_uptime(buffer, size, offset)
  }
  if procfs_strcmp(path, "/proc/loadavg") == 1 {
    return procfs_read_loadavg(buffer, size, offset)
  }
  if procfs_strcmp(path, "/proc/version") == 1 {
    return procfs_read_version(buffer, size, offset)
  }
  if procfs_strcmp(path, "/proc/cmdline") == 1 {
    return procfs_read_cmdline(buffer, size, offset)
  }
  if procfs_strcmp(path, "/proc/stat") == 1 {
    return procfs_read_stat(buffer, size, offset)
  }
  if procfs_strcmp(path, "/proc/mounts") == 1 {
    return procfs_read_mounts(buffer, size, offset)
  }
  if procfs_strcmp(path, "/proc/diskstats") == 1 {
    return procfs_read_diskstats(buffer, size, offset)
  }
  if procfs_strcmp(path, "/proc/filesystems") == 1 {
    return procfs_read_filesystems(buffer, size, offset)
  }

  // Check for /proc/[pid]/... paths
  if procfs_is_pid_path(path) == 1 {
    return procfs_read_pid_entry(path, buffer, size, offset)
  }

  // Look for registered entry with custom handler
  var i: u32 = 0
  while i < proc_entry_count {
    if proc_entries[i].in_use == 1 {
      if procfs_path_match(proc_entries[i].path, path) == 1 {
        if proc_entries[i].handler.read_fn != 0 {
          // Call custom read handler (stub)
          return 0
        }
      }
    }
    i = i + 1
  }

  return 0
}

// Write to a proc entry
export fn procfs_write(path: u64, buffer: u64, size: u32): u32 {
  // Look for registered entry with write handler
  var i: u32 = 0
  while i < proc_entry_count {
    if proc_entries[i].in_use == 1 {
      if procfs_path_match(proc_entries[i].path, path) == 1 {
        if proc_entries[i].handler.write_fn != 0 {
          // Call custom write handler (stub)
          return 0
        }
      }
    }
    i = i + 1
  }

  return 0
}

// List directory contents
export fn procfs_readdir(path: u64, buffer: u64, size: u32): u32 {
  var written: u32 = 0
  var offset: u32 = 0

  // Root /proc directory
  if procfs_strcmp(path, "/proc") == 1 {
    // Add PID directories
    var i: u32 = 0
    while i < process_entry_count && offset < size {
      if process_entries[i].in_use == 1 {
        var len: u32 = procfs_write_u32_to_str(buffer + offset, process_entries[i].pid)
        offset = offset + len
        @intToPtr(buffer + offset, u8) = '\n'
        offset = offset + 1
      }
      i = i + 1
    }

    // Add static entries
    var entries: [u8; 512] = "self\ncpuinfo\nmeminfo\nuptime\nloadavg\nversion\ncmdline\nstat\nmounts\nfilesystems\ndiskstats\nnet\nsys\n"
    i = 0
    while entries[i] != 0 && offset < size {
      @intToPtr(buffer + offset, u8) = entries[i]
      offset = offset + 1
      i = i + 1
    }

    return offset
  }

  return 0
}

// Read /proc/cpuinfo
fn procfs_read_cpuinfo(buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 1024]
  var len: u32 = 0

  // Generate cpuinfo content
  var i: u32 = 0
  while i < cpu_count {
    len = len + procfs_sprintf(content, len, "processor\t: ")
    len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, i)
    len = len + procfs_sprintf(content, len, "\nvendor_id\t: ")
    len = len + procfs_copy_str(@ptrFromInt(content) + len, @ptrFromInt(cpu_info[i].vendor_id))
    len = len + procfs_sprintf(content, len, "\nmodel name\t: ")
    len = len + procfs_copy_str(@ptrFromInt(content) + len, @ptrFromInt(cpu_info[i].model_name))
    len = len + procfs_sprintf(content, len, "\ncpu MHz\t\t: ")
    len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, cpu_info[i].cpu_mhz)
    len = len + procfs_sprintf(content, len, "\ncache size\t: ")
    len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, cpu_info[i].cache_size)
    len = len + procfs_sprintf(content, len, " KB\n\n")
    i = i + 1
  }

  // If no CPUs registered, provide default
  if cpu_count == 0 {
    len = procfs_sprintf(content, 0, "processor\t: 0\nvendor_id\t: HomeOS\nmodel name\t: Home Virtual CPU\ncpu MHz\t\t: 1000\ncache size\t: 4096 KB\n")
  }

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Read /proc/meminfo
fn procfs_read_meminfo(buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 2048]
  var len: u32 = 0

  len = len + procfs_sprintf(content, len, "MemTotal:       ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, mem_info.mem_total / 1024)
  len = len + procfs_sprintf(content, len, " kB\nMemFree:        ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, mem_info.mem_free / 1024)
  len = len + procfs_sprintf(content, len, " kB\nMemAvailable:   ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, mem_info.mem_available / 1024)
  len = len + procfs_sprintf(content, len, " kB\nBuffers:        ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, mem_info.buffers / 1024)
  len = len + procfs_sprintf(content, len, " kB\nCached:         ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, mem_info.cached / 1024)
  len = len + procfs_sprintf(content, len, " kB\nSwapCached:     ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, mem_info.swap_cached / 1024)
  len = len + procfs_sprintf(content, len, " kB\nActive:         ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, mem_info.active / 1024)
  len = len + procfs_sprintf(content, len, " kB\nInactive:       ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, mem_info.inactive / 1024)
  len = len + procfs_sprintf(content, len, " kB\nSwapTotal:      ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, mem_info.swap_total / 1024)
  len = len + procfs_sprintf(content, len, " kB\nSwapFree:       ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, mem_info.swap_free / 1024)
  len = len + procfs_sprintf(content, len, " kB\nDirty:          ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, mem_info.dirty / 1024)
  len = len + procfs_sprintf(content, len, " kB\nSlab:           ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, mem_info.slab / 1024)
  len = len + procfs_sprintf(content, len, " kB\n")

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Read /proc/uptime
fn procfs_read_uptime(buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 64]
  var len: u32 = 0

  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, uptime.total_sec)
  len = len + procfs_sprintf(content, len, ".")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, uptime.total_usec / 10000)
  len = len + procfs_sprintf(content, len, " ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, uptime.idle_sec)
  len = len + procfs_sprintf(content, len, ".")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, uptime.idle_usec / 10000)
  len = len + procfs_sprintf(content, len, "\n")

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Read /proc/loadavg
fn procfs_read_loadavg(buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 128]
  var len: u32 = 0

  // Format: load1 load5 load15 running/total last_pid
  len = len + procfs_write_fixed_point(@ptrFromInt(content) + len, load_avg.load_1)
  len = len + procfs_sprintf(content, len, " ")
  len = len + procfs_write_fixed_point(@ptrFromInt(content) + len, load_avg.load_5)
  len = len + procfs_sprintf(content, len, " ")
  len = len + procfs_write_fixed_point(@ptrFromInt(content) + len, load_avg.load_15)
  len = len + procfs_sprintf(content, len, " ")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, load_avg.nr_running)
  len = len + procfs_sprintf(content, len, "/")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, load_avg.nr_threads)
  len = len + procfs_sprintf(content, len, " ")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, load_avg.last_pid)
  len = len + procfs_sprintf(content, len, "\n")

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Read /proc/version
fn procfs_read_version(buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 256]
  var len: u32 = 0

  len = len + procfs_copy_str(@ptrFromInt(content), @ptrFromInt(kernel_version))
  content[len] = '\n'
  len = len + 1

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Read /proc/cmdline
fn procfs_read_cmdline(buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 512]
  var len: u32 = 0

  len = len + procfs_copy_str(@ptrFromInt(content), @ptrFromInt(kernel_cmdline))
  content[len] = '\n'
  len = len + 1

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Read /proc/stat
fn procfs_read_stat(buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 512]
  var len: u32 = 0

  len = len + procfs_sprintf(content, len, "cpu  0 0 0 0 0 0 0 0 0 0\n")
  len = len + procfs_sprintf(content, len, "intr 0\n")
  len = len + procfs_sprintf(content, len, "ctxt 0\n")
  len = len + procfs_sprintf(content, len, "btime ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, 0)
  len = len + procfs_sprintf(content, len, "\n")
  len = len + procfs_sprintf(content, len, "processes ")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, load_avg.last_pid)
  len = len + procfs_sprintf(content, len, "\n")
  len = len + procfs_sprintf(content, len, "procs_running ")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, load_avg.nr_running)
  len = len + procfs_sprintf(content, len, "\n")
  len = len + procfs_sprintf(content, len, "procs_blocked 0\n")

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Read /proc/mounts
fn procfs_read_mounts(buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 2048]
  var len: u32 = 0

  var i: u32 = 0
  while i < mount_count {
    if mount_entries[i].in_use == 1 {
      len = len + procfs_copy_str(@ptrFromInt(content) + len, @ptrFromInt(mount_entries[i].source))
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_copy_str(@ptrFromInt(content) + len, @ptrFromInt(mount_entries[i].mount_point))
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_copy_str(@ptrFromInt(content) + len, @ptrFromInt(mount_entries[i].fs_type))
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_copy_str(@ptrFromInt(content) + len, @ptrFromInt(mount_entries[i].mount_options))
      len = len + procfs_sprintf(content, len, " 0 0\n")
    }
    i = i + 1
  }

  // Add default root mount if none
  if mount_count == 0 {
    len = procfs_sprintf(content, 0, "rootfs / rootfs rw 0 0\nproc /proc proc rw,nosuid,nodev,noexec 0 0\nsys /sys sysfs rw,nosuid,nodev,noexec 0 0\ndevfs /dev devfs rw 0 0\n")
  }

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Read /proc/diskstats
fn procfs_read_diskstats(buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 2048]
  var len: u32 = 0

  var i: u32 = 0
  while i < disk_count {
    if disk_stats[i].in_use == 1 {
      len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, disk_stats[i].major)
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, disk_stats[i].minor)
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_copy_str(@ptrFromInt(content) + len, @ptrFromInt(disk_stats[i].name))
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, disk_stats[i].reads_completed)
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, disk_stats[i].reads_merged)
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, disk_stats[i].sectors_read)
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, disk_stats[i].time_reading)
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, disk_stats[i].writes_completed)
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, disk_stats[i].writes_merged)
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, disk_stats[i].sectors_written)
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, disk_stats[i].time_writing)
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, disk_stats[i].ios_in_progress)
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, disk_stats[i].time_io)
      len = len + procfs_sprintf(content, len, " ")
      len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, disk_stats[i].weighted_time)
      len = len + procfs_sprintf(content, len, "\n")
    }
    i = i + 1
  }

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Read /proc/filesystems
fn procfs_read_filesystems(buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 512]
  var len: u32 = 0

  len = procfs_sprintf(content, 0, "nodev\tproc\nnodev\tsysfs\nnodev\tdevfs\nnodev\ttmpfs\n\text2\n\text3\n\text4\n\tfat\n\tvfat\n\texfat\n\tntfs\n\tbtrfs\n\txfs\n\tiso9660\n")

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Read per-process entry
fn procfs_read_pid_entry(path: u64, buffer: u64, size: u32, offset: u64): u32 {
  // Extract PID from path
  var pid: u32 = procfs_extract_pid(path)
  if pid == 0xFFFFFFFF { return 0 }

  // Find process entry
  var proc_idx: u32 = 0xFFFFFFFF
  var i: u32 = 0
  while i < process_entry_count {
    if process_entries[i].in_use == 1 && process_entries[i].pid == pid {
      proc_idx = i
      break
    }
    i = i + 1
  }

  if proc_idx == 0xFFFFFFFF { return 0 }

  // Check which file is requested
  if procfs_path_ends_with(path, "/stat") == 1 {
    return procfs_read_pid_stat(proc_idx, buffer, size, offset)
  }
  if procfs_path_ends_with(path, "/status") == 1 {
    return procfs_read_pid_status(proc_idx, buffer, size, offset)
  }
  if procfs_path_ends_with(path, "/statm") == 1 {
    return procfs_read_pid_statm(proc_idx, buffer, size, offset)
  }
  if procfs_path_ends_with(path, "/cmdline") == 1 {
    return procfs_read_pid_cmdline(proc_idx, buffer, size, offset)
  }
  if procfs_path_ends_with(path, "/comm") == 1 {
    return procfs_read_pid_comm(proc_idx, buffer, size, offset)
  }

  return 0
}

// Read /proc/[pid]/stat
fn procfs_read_pid_stat(idx: u32, buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 512]
  var len: u32 = 0

  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, process_entries[idx].pid)
  len = len + procfs_sprintf(content, len, " (")
  len = len + procfs_copy_str(@ptrFromInt(content) + len, @ptrFromInt(process_entries[idx].comm))
  len = len + procfs_sprintf(content, len, ") ")
  content[len] = process_entries[idx].state
  len = len + 1
  len = len + procfs_sprintf(content, len, " ")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, process_entries[idx].ppid)
  len = len + procfs_sprintf(content, len, " 0 0 0 0 0 0 0 0 0 ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, process_entries[idx].utime)
  len = len + procfs_sprintf(content, len, " ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, process_entries[idx].stime)
  len = len + procfs_sprintf(content, len, " 0 0 ")
  len = len + procfs_write_i32_to_str(@ptrFromInt(content) + len, process_entries[idx].priority)
  len = len + procfs_sprintf(content, len, " ")
  len = len + procfs_write_i32_to_str(@ptrFromInt(content) + len, process_entries[idx].nice)
  len = len + procfs_sprintf(content, len, " ")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, process_entries[idx].threads)
  len = len + procfs_sprintf(content, len, " 0 ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, process_entries[idx].start_time)
  len = len + procfs_sprintf(content, len, " ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, process_entries[idx].vm_size)
  len = len + procfs_sprintf(content, len, " ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, process_entries[idx].vm_rss / 4096)
  len = len + procfs_sprintf(content, len, "\n")

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Read /proc/[pid]/status
fn procfs_read_pid_status(idx: u32, buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 1024]
  var len: u32 = 0

  len = len + procfs_sprintf(content, len, "Name:\t")
  len = len + procfs_copy_str(@ptrFromInt(content) + len, @ptrFromInt(process_entries[idx].comm))
  len = len + procfs_sprintf(content, len, "\nState:\t")
  content[len] = process_entries[idx].state
  len = len + 1
  len = len + procfs_sprintf(content, len, "\nPid:\t")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, process_entries[idx].pid)
  len = len + procfs_sprintf(content, len, "\nPPid:\t")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, process_entries[idx].ppid)
  len = len + procfs_sprintf(content, len, "\nUid:\t")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, process_entries[idx].uid)
  len = len + procfs_sprintf(content, len, "\nGid:\t")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, process_entries[idx].gid)
  len = len + procfs_sprintf(content, len, "\nThreads:\t")
  len = len + procfs_write_u32_to_str(@ptrFromInt(content) + len, process_entries[idx].threads)
  len = len + procfs_sprintf(content, len, "\nVmSize:\t")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, process_entries[idx].vm_size / 1024)
  len = len + procfs_sprintf(content, len, " kB\nVmRSS:\t")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, process_entries[idx].vm_rss / 1024)
  len = len + procfs_sprintf(content, len, " kB\nVmData:\t")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, process_entries[idx].vm_data / 1024)
  len = len + procfs_sprintf(content, len, " kB\nVmStk:\t")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, process_entries[idx].vm_stack / 1024)
  len = len + procfs_sprintf(content, len, " kB\n")

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Read /proc/[pid]/statm
fn procfs_read_pid_statm(idx: u32, buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 128]
  var len: u32 = 0

  // size resident shared text lib data dt (all in pages)
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, process_entries[idx].vm_size / 4096)
  len = len + procfs_sprintf(content, len, " ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, process_entries[idx].vm_rss / 4096)
  len = len + procfs_sprintf(content, len, " 0 ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, process_entries[idx].vm_exe / 4096)
  len = len + procfs_sprintf(content, len, " 0 ")
  len = len + procfs_write_u64_to_str(@ptrFromInt(content) + len, process_entries[idx].vm_data / 4096)
  len = len + procfs_sprintf(content, len, " 0\n")

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Read /proc/[pid]/cmdline
fn procfs_read_pid_cmdline(idx: u32, buffer: u64, size: u32, offset: u64): u32 {
  var len: u32 = 0
  while process_entries[idx].cmdline[len] != 0 && len < 256 {
    len = len + 1
  }
  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(process_entries[idx].cmdline), len)
}

// Read /proc/[pid]/comm
fn procfs_read_pid_comm(idx: u32, buffer: u64, size: u32, offset: u64): u32 {
  var content: [u8; 68]
  var len: u32 = 0

  len = procfs_copy_str(@ptrFromInt(content), @ptrFromInt(process_entries[idx].comm))
  content[len] = '\n'
  len = len + 1

  return procfs_copy_to_buffer(buffer, size, offset, @ptrFromInt(content), len)
}

// Update memory info
export fn procfs_update_meminfo(total: u64, free: u64, available: u64, cached: u64, buffers: u64, swap_total: u64, swap_free: u64) {
  mem_info.mem_total = total
  mem_info.mem_free = free
  mem_info.mem_available = available
  mem_info.cached = cached
  mem_info.buffers = buffers
  mem_info.swap_total = swap_total
  mem_info.swap_free = swap_free
}

// Update load average
export fn procfs_update_loadavg(load1: u32, load5: u32, load15: u32, running: u32, threads: u32, last_pid: u32) {
  load_avg.load_1 = load1
  load_avg.load_5 = load5
  load_avg.load_15 = load15
  load_avg.nr_running = running
  load_avg.nr_threads = threads
  load_avg.last_pid = last_pid
}

// Update uptime
export fn procfs_update_uptime(total_sec: u64, total_usec: u32, idle_sec: u64, idle_usec: u32) {
  uptime.total_sec = total_sec
  uptime.total_usec = total_usec
  uptime.idle_sec = idle_sec
  uptime.idle_usec = idle_usec
}

// Register CPU info
export fn procfs_register_cpu(vendor: u64, model: u64, mhz: u32, cache_kb: u32): u32 {
  if cpu_count >= 64 { return 0xFFFFFFFF }

  var idx: u32 = cpu_count

  procfs_copy_to_array(cpu_info[idx].vendor_id, vendor, 32)
  procfs_copy_to_array(cpu_info[idx].model_name, model, 64)
  cpu_info[idx].cpu_mhz = mhz
  cpu_info[idx].cache_size = cache_kb

  cpu_count = cpu_count + 1

  return idx
}

// Register mount
export fn procfs_register_mount(source: u64, target: u64, fstype: u64, options: u64): u32 {
  if mount_count >= 64 { return 0xFFFFFFFF }

  var idx: u32 = mount_count

  procfs_copy_to_array(mount_entries[idx].source, source, 128)
  procfs_copy_to_array(mount_entries[idx].mount_point, target, 128)
  procfs_copy_to_array(mount_entries[idx].fs_type, fstype, 32)
  procfs_copy_to_array(mount_entries[idx].mount_options, options, 64)
  mount_entries[idx].in_use = 1

  mount_count = mount_count + 1

  return idx
}

// Register disk stats
export fn procfs_register_disk(major: u32, minor: u32, name: u64): u32 {
  if disk_count >= 32 { return 0xFFFFFFFF }

  var idx: u32 = disk_count

  disk_stats[idx].major = major
  disk_stats[idx].minor = minor
  procfs_copy_to_array(disk_stats[idx].name, name, 32)
  disk_stats[idx].reads_completed = 0
  disk_stats[idx].writes_completed = 0
  disk_stats[idx].in_use = 1

  disk_count = disk_count + 1

  return idx
}

// Update disk stats
export fn procfs_update_disk_stats(idx: u32, reads: u64, writes: u64, sectors_read: u64, sectors_written: u64) {
  if idx >= disk_count { return }

  disk_stats[idx].reads_completed = reads
  disk_stats[idx].writes_completed = writes
  disk_stats[idx].sectors_read = sectors_read
  disk_stats[idx].sectors_written = sectors_written
}

// Get entry count
export fn procfs_get_entry_count(): u32 {
  return proc_entry_count
}

// Get process count
export fn procfs_get_process_count(): u32 {
  return process_entry_count
}

// Helper: copy to buffer with offset
fn procfs_copy_to_buffer(buffer: u64, size: u32, offset: u64, content: u64, content_len: u32): u32 {
  if offset >= content_len { return 0 }

  var remaining: u32 = content_len - @truncate(offset, u32)
  var to_copy: u32 = remaining
  if to_copy > size { to_copy = size }

  var i: u32 = 0
  while i < to_copy {
    @intToPtr(buffer + i, u8) = @intToPtr(content + @truncate(offset, u32) + i, u8)
    i = i + 1
  }

  return to_copy
}

// Helper: copy string to array
fn procfs_copy_to_array(arr: [u8; 128], src: u64, max_len: u32) {
  var i: u32 = 0
  while i < max_len - 1 {
    var ch: u8 = @intToPtr(src + i, u8)
    arr[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  arr[i] = 0
}

// Helper: sprintf-like (just copies string)
fn procfs_sprintf(arr: [u8; 2048], offset: u32, str: u64): u32 {
  var i: u32 = 0
  while offset + i < 2047 {
    var ch: u8 = @intToPtr(str + i, u8)
    if ch == 0 { break }
    arr[offset + i] = ch
    i = i + 1
  }
  return i
}

// Helper: copy string, return length
fn procfs_copy_str(dest: u64, src: u64): u32 {
  var i: u32 = 0
  while 1 == 1 {
    var ch: u8 = @intToPtr(src + i, u8)
    @intToPtr(dest + i, u8) = ch
    if ch == 0 { break }
    i = i + 1
  }
  return i
}

// Helper: write u32 to string
fn procfs_write_u32_to_str(dest: u64, val: u32): u32 {
  if val == 0 {
    @intToPtr(dest, u8) = '0'
    return 1
  }

  var temp: [u8; 16]
  var len: u32 = 0
  var v: u32 = val

  while v > 0 {
    temp[len] = '0' + @truncate(v % 10, u8)
    v = v / 10
    len = len + 1
  }

  // Reverse
  var i: u32 = 0
  while i < len {
    @intToPtr(dest + i, u8) = temp[len - 1 - i]
    i = i + 1
  }

  return len
}

// Helper: write u64 to string
fn procfs_write_u64_to_str(dest: u64, val: u64): u32 {
  if val == 0 {
    @intToPtr(dest, u8) = '0'
    return 1
  }

  var temp: [u8; 24]
  var len: u32 = 0
  var v: u64 = val

  while v > 0 {
    temp[len] = '0' + @truncate(v % 10, u8)
    v = v / 10
    len = len + 1
  }

  // Reverse
  var i: u32 = 0
  while i < len {
    @intToPtr(dest + i, u8) = temp[len - 1 - i]
    i = i + 1
  }

  return len
}

// Helper: write i32 to string
fn procfs_write_i32_to_str(dest: u64, val: i32): u32 {
  if val < 0 {
    @intToPtr(dest, u8) = '-'
    return 1 + procfs_write_u32_to_str(dest + 1, @bitCast(-val, u32))
  }
  return procfs_write_u32_to_str(dest, @bitCast(val, u32))
}

// Helper: write fixed point number (divide by 65536)
fn procfs_write_fixed_point(dest: u64, val: u32): u32 {
  var integer: u32 = val / 65536
  var frac: u32 = ((val % 65536) * 100) / 65536

  var len: u32 = procfs_write_u32_to_str(dest, integer)
  @intToPtr(dest + len, u8) = '.'
  len = len + 1

  if frac < 10 {
    @intToPtr(dest + len, u8) = '0'
    len = len + 1
  }
  len = len + procfs_write_u32_to_str(dest + len, frac)

  return len
}

// Helper: compare strings
fn procfs_strcmp(s1: u64, s2: u64): u32 {
  var i: u32 = 0
  while 1 == 1 {
    var c1: u8 = @intToPtr(s1 + i, u8)
    var c2: u8 = @intToPtr(s2 + i, u8)
    if c1 != c2 { return 0 }
    if c1 == 0 { return 1 }
    i = i + 1
  }
  return 0
}

// Helper: check if path matches
fn procfs_path_match(arr: [u8; 256], path: u64): u32 {
  var i: u32 = 0
  while i < 256 {
    var c1: u8 = arr[i]
    var c2: u8 = @intToPtr(path + i, u8)
    if c1 != c2 { return 0 }
    if c1 == 0 { return 1 }
    i = i + 1
  }
  return 0
}

// Helper: check if path is /proc/[pid]/...
fn procfs_is_pid_path(path: u64): u32 {
  // Check for /proc/
  if @intToPtr(path + 0, u8) != '/' { return 0 }
  if @intToPtr(path + 1, u8) != 'p' { return 0 }
  if @intToPtr(path + 2, u8) != 'r' { return 0 }
  if @intToPtr(path + 3, u8) != 'o' { return 0 }
  if @intToPtr(path + 4, u8) != 'c' { return 0 }
  if @intToPtr(path + 5, u8) != '/' { return 0 }

  // Check for digit after /proc/
  var ch: u8 = @intToPtr(path + 6, u8)
  if ch >= '0' && ch <= '9' { return 1 }

  return 0
}

// Helper: extract PID from path
fn procfs_extract_pid(path: u64): u32 {
  var pid: u32 = 0
  var i: u32 = 6  // Start after /proc/

  while 1 == 1 {
    var ch: u8 = @intToPtr(path + i, u8)
    if ch >= '0' && ch <= '9' {
      pid = pid * 10 + (ch - '0')
    } else {
      break
    }
    i = i + 1
  }

  return pid
}

// Helper: check if path ends with string
fn procfs_path_ends_with(path: u64, suffix: u64): u32 {
  // Find path length
  var path_len: u32 = 0
  while @intToPtr(path + path_len, u8) != 0 && path_len < 256 {
    path_len = path_len + 1
  }

  // Find suffix length
  var suffix_len: u32 = 0
  while @intToPtr(suffix + suffix_len, u8) != 0 && suffix_len < 64 {
    suffix_len = suffix_len + 1
  }

  if suffix_len > path_len { return 0 }

  // Compare
  var i: u32 = 0
  while i < suffix_len {
    if @intToPtr(path + path_len - suffix_len + i, u8) != @intToPtr(suffix + i, u8) {
      return 0
    }
    i = i + 1
  }

  return 1
}

// Helper: set string
fn procfs_set_string(arr: [u8; 128], str: u64, max_len: u32) {
  var i: u32 = 0
  while i < max_len - 1 {
    var ch: u8 = @intToPtr(str + i, u8)
    arr[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  arr[i] = 0
}
