// home-os ProcFS
// Process filesystem (/proc)

import "../core/foundation.home" as foundation
import "../core/process.home" as process
import "../core/memory.home" as memory

const PROCFS_MAX_ENTRIES: u32 = 256

struct ProcEntry {
  name: [u8; 64],
  type: u32,
  read_fn: u64,
  in_use: u32
}

var proc_entries: [ProcEntry; 256]
var proc_entry_count: u32 = 0

export fn procfs_init() {
  proc_entry_count = 0
  foundation.serial_write_string("[ProcFS] Initialized\n")
}

export fn procfs_register(name: u64, read_fn: u64) -> u32 {
  if proc_entry_count >= PROCFS_MAX_ENTRIES { return 0xFFFFFFFF }
  
  var i: u32 = 0
  while i < 64 {
    proc_entries[proc_entry_count].name[i] = @intToPtr(name + i, u8)
    if proc_entries[proc_entry_count].name[i] == 0 { break }
    i = i + 1
  }
  
  proc_entries[proc_entry_count].read_fn = read_fn
  proc_entries[proc_entry_count].in_use = 1
  
  var id: u32 = proc_entry_count
  proc_entry_count = proc_entry_count + 1
  return id
}

export fn procfs_read(path: u64, buffer: u64, size: u32) -> u32 {
  var i: u32 = 0
  while i < proc_entry_count {
    if proc_entries[i].in_use == 1 {
      var match: u32 = 1
      var j: u32 = 0
      while j < 64 {
        if proc_entries[i].name[j] != @intToPtr(path + j, u8) {
          match = 0
          break
        }
        if proc_entries[i].name[j] == 0 { break }
        j = j + 1
      }
      
      if match == 1 and proc_entries[i].read_fn != 0 {
        // Call read function (stub)
        return 0
      }
    }
    i = i + 1
  }
  
  return 0
}
