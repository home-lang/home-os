// home-os FAT32 Filesystem Driver
// Real FAT32 implementation

import "../core/foundation.home" as foundation
import "../drivers/ata.home" as ata

struct FAT32BootSector {
  jmp: [u8; 3],
  oem: [u8; 8],
  bytes_per_sector: u16,
  sectors_per_cluster: u8,
  reserved_sectors: u16,
  fat_count: u8,
  root_entries: u16,
  total_sectors_16: u16,
  media_type: u8,
  sectors_per_fat_16: u16,
  sectors_per_track: u16,
  heads: u16,
  hidden_sectors: u32,
  total_sectors_32: u32,
  sectors_per_fat_32: u32,
  flags: u16,
  version: u16,
  root_cluster: u32
}

var fat32_initialized: u32 = 0
var boot_sector: FAT32BootSector
var fat_start: u32 = 0
var data_start: u32 = 0

export fn fat32_init() {
  if fat32_initialized == 1 { return }
  
  var buffer: [u8; 512]
  ata.ata_read_sector(0, 0, @ptrFromInt(buffer))
  
  boot_sector = @intToPtr(@ptrFromInt(buffer), FAT32BootSector)
  
  fat_start = boot_sector.reserved_sectors
  data_start = fat_start + (boot_sector.fat_count * boot_sector.sectors_per_fat_32)
  
  fat32_initialized = 1
  foundation.serial_write_string("[FAT32] Initialized\n")
}

export fn fat32_read_cluster(cluster: u32, buffer: u64) -> u32 {
  if fat32_initialized == 0 { return 1 }
  
  var first_sector: u32 = data_start + ((cluster - 2) * boot_sector.sectors_per_cluster)
  
  var i: u32 = 0
  while i < boot_sector.sectors_per_cluster {
    ata.ata_read_sector(0, first_sector + i, buffer + (i * 512))
    i = i + 1
  }
  
  return 0
}

export fn fat32_get_next_cluster(cluster: u32) -> u32 {
  if fat32_initialized == 0 { return 0xFFFFFFFF }
  
  var fat_offset: u32 = cluster * 4
  var fat_sector: u32 = fat_start + (fat_offset / 512)
  var entry_offset: u32 = fat_offset % 512
  
  var buffer: [u8; 512]
  ata.ata_read_sector(0, fat_sector, @ptrFromInt(buffer))
  
  var next: u32 = @intToPtr(@ptrFromInt(buffer) + entry_offset, u32)
  return next & 0x0FFFFFFF
}
