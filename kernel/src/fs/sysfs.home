// home-os Kernel - SysFS
// System filesystem (/sys) - Virtual filesystem for device and kernel information

import "../core/foundation.home" as foundation

// Entry types
const SYSFS_FILE: u32 = 0
const SYSFS_DIR: u32 = 1
const SYSFS_SYMLINK: u32 = 2
const SYSFS_BIN_ATTR: u32 = 3

// Permissions
const SYSFS_READ_ONLY: u32 = 0o444
const SYSFS_READ_WRITE: u32 = 0o644
const SYSFS_DIR_PERM: u32 = 0o755

const MAX_SYSFS_ENTRIES: u32 = 2048
const MAX_PATH_LEN: u32 = 256
const MAX_VALUE_LEN: u32 = 4096
const MAX_DEVICES: u32 = 256
const MAX_CLASSES: u32 = 64
const MAX_BUSES: u32 = 32
const MAX_MODULES: u32 = 128
const MAX_BLOCK_DEVICES: u32 = 32

// Sysfs attribute handler
struct SysfsHandler {
  show_fn: u64,      // fn(buffer: u64, size: u32): u32
  store_fn: u64,     // fn(buffer: u64, size: u32): u32
  data: u64          // Opaque data
}

// Sysfs entry
struct SysfsEntry {
  name: [u8; 64],
  path: [u8; 256],
  entry_type: u32,
  permissions: u32,
  handler: SysfsHandler,
  parent: u32,
  value: [u8; 256],   // Static value (if no handler)
  size: u32,
  in_use: u32
}

// Device info for /sys/devices hierarchy
struct SysfsDevice {
  name: [u8; 64],
  path: [u8; 256],
  subsystem: [u8; 32],
  driver: [u8; 64],
  bus: [u8; 32],
  class: [u8; 32],
  vendor_id: u32,
  device_id: u32,
  parent: u32,
  in_use: u32
}

// Device class for /sys/class hierarchy
struct SysfsClass {
  name: [u8; 64],
  device_count: u32,
  devices: [u32; 64],  // Device indices
  in_use: u32
}

// Bus type for /sys/bus hierarchy
struct SysfsBus {
  name: [u8; 64],
  driver_count: u32,
  device_count: u32,
  in_use: u32
}

// Module info for /sys/module hierarchy
struct SysfsModule {
  name: [u8; 64],
  version: [u8; 32],
  refcount: u32,
  state: u32,  // 0=live, 1=loading, 2=unloading
  size: u64,
  in_use: u32
}

// Block device for /sys/block hierarchy
struct SysfsBlockDevice {
  name: [u8; 32],
  major: u32,
  minor: u32,
  size_sectors: u64,
  sector_size: u32,
  removable: u32,
  readonly: u32,
  device_idx: u32,  // Index into devices array
  in_use: u32
}

// Power state for /sys/power
struct SysfsPower {
  state: [u8; 16],       // mem, disk, standby, freeze
  disk_mode: [u8; 16],   // platform, shutdown, reboot, suspend
  pm_async: u32,
  wakeup_count: u64,
  image_size: u64
}

// Kernel info for /sys/kernel
struct SysfsKernel {
  hostname: [u8; 64],
  domainname: [u8; 64],
  ostype: [u8; 32],
  osrelease: [u8; 64],
  version: [u8; 128],
  debug: u32,
  profiling: u32
}

var sysfs_entries: [SysfsEntry; 2048]
var sysfs_entry_count: u32 = 0

var devices: [SysfsDevice; 256]
var device_count: u32 = 0

var classes: [SysfsClass; 64]
var class_count: u32 = 0

var buses: [SysfsBus; 32]
var bus_count: u32 = 0

var modules: [SysfsModule; 128]
var module_count: u32 = 0

var block_devices: [SysfsBlockDevice; 32]
var block_count: u32 = 0

var power_state: SysfsPower
var kernel_info: SysfsKernel

var sysfs_initialized: u32 = 0

export fn sysfs_init() {
  if sysfs_initialized == 1 { return }

  sysfs_entry_count = 0
  device_count = 0
  class_count = 0
  bus_count = 0
  module_count = 0
  block_count = 0

  // Initialize power state
  sysfs_set_string(power_state.state, "mem", 16)
  sysfs_set_string(power_state.disk_mode, "platform", 16)
  power_state.pm_async = 1
  power_state.wakeup_count = 0
  power_state.image_size = 0

  // Initialize kernel info
  sysfs_set_string(kernel_info.hostname, "home-os", 64)
  sysfs_set_string(kernel_info.domainname, "local", 64)
  sysfs_set_string(kernel_info.ostype, "HomeOS", 32)
  sysfs_set_string(kernel_info.osrelease, "0.1.0", 64)
  sysfs_set_string(kernel_info.version, "#1 SMP Home Language OS", 128)
  kernel_info.debug = 0
  kernel_info.profiling = 0

  // Create directory structure
  sysfs_create_hierarchy()

  // Register core buses
  sysfs_register_bus("pci")
  sysfs_register_bus("usb")
  sysfs_register_bus("platform")
  sysfs_register_bus("i2c")
  sysfs_register_bus("spi")
  sysfs_register_bus("scsi")

  // Register core classes
  sysfs_register_class("block")
  sysfs_register_class("net")
  sysfs_register_class("tty")
  sysfs_register_class("input")
  sysfs_register_class("sound")
  sysfs_register_class("dmi")
  sysfs_register_class("power_supply")
  sysfs_register_class("thermal")
  sysfs_register_class("hwmon")

  sysfs_initialized = 1
  foundation.serial_write_string("[SysFS] System filesystem initialized\n")
}

fn sysfs_create_hierarchy() {
  // Root directories
  sysfs_create_dir("", "/sys")
  sysfs_create_dir("devices", "/sys/devices")
  sysfs_create_dir("class", "/sys/class")
  sysfs_create_dir("bus", "/sys/bus")
  sysfs_create_dir("block", "/sys/block")
  sysfs_create_dir("module", "/sys/module")
  sysfs_create_dir("power", "/sys/power")
  sysfs_create_dir("kernel", "/sys/kernel")
  sysfs_create_dir("firmware", "/sys/firmware")
  sysfs_create_dir("fs", "/sys/fs")
  sysfs_create_dir("hypervisor", "/sys/hypervisor")

  // /sys/devices subdirs
  sysfs_create_dir("system", "/sys/devices/system")
  sysfs_create_dir("pci0000:00", "/sys/devices/pci0000:00")
  sysfs_create_dir("platform", "/sys/devices/platform")
  sysfs_create_dir("virtual", "/sys/devices/virtual")

  // /sys/devices/system subdirs
  sysfs_create_dir("cpu", "/sys/devices/system/cpu")
  sysfs_create_dir("memory", "/sys/devices/system/memory")
  sysfs_create_dir("node", "/sys/devices/system/node")
  sysfs_create_dir("clocksource", "/sys/devices/system/clocksource")

  // /sys/power files
  sysfs_create_file("state", "/sys/power/state", SYSFS_READ_WRITE)
  sysfs_set_file_value("/sys/power/state", "mem")
  sysfs_create_file("disk", "/sys/power/disk", SYSFS_READ_WRITE)
  sysfs_set_file_value("/sys/power/disk", "[platform] shutdown reboot suspend")
  sysfs_create_file("pm_async", "/sys/power/pm_async", SYSFS_READ_WRITE)
  sysfs_set_file_value("/sys/power/pm_async", "1")
  sysfs_create_file("wakeup_count", "/sys/power/wakeup_count", SYSFS_READ_ONLY)
  sysfs_set_file_value("/sys/power/wakeup_count", "0")
  sysfs_create_file("image_size", "/sys/power/image_size", SYSFS_READ_WRITE)
  sysfs_set_file_value("/sys/power/image_size", "0")

  // /sys/kernel files
  sysfs_create_dir("debug", "/sys/kernel/debug")
  sysfs_create_dir("tracing", "/sys/kernel/tracing")
  sysfs_create_dir("security", "/sys/kernel/security")
  sysfs_create_dir("config", "/sys/kernel/config")
  sysfs_create_file("uevent_seqnum", "/sys/kernel/uevent_seqnum", SYSFS_READ_ONLY)
  sysfs_set_file_value("/sys/kernel/uevent_seqnum", "0")
  sysfs_create_file("profiling", "/sys/kernel/profiling", SYSFS_READ_WRITE)
  sysfs_set_file_value("/sys/kernel/profiling", "0")
  sysfs_create_file("kexec_loaded", "/sys/kernel/kexec_loaded", SYSFS_READ_ONLY)
  sysfs_set_file_value("/sys/kernel/kexec_loaded", "0")
  sysfs_create_file("kexec_crash_loaded", "/sys/kernel/kexec_crash_loaded", SYSFS_READ_ONLY)
  sysfs_set_file_value("/sys/kernel/kexec_crash_loaded", "0")

  // /sys/fs
  sysfs_create_dir("cgroup", "/sys/fs/cgroup")
  sysfs_create_dir("ext4", "/sys/fs/ext4")
  sysfs_create_dir("fuse", "/sys/fs/fuse")
  sysfs_create_dir("pstore", "/sys/fs/pstore")

  // /sys/firmware
  sysfs_create_dir("acpi", "/sys/firmware/acpi")
  sysfs_create_dir("dmi", "/sys/firmware/dmi")
  sysfs_create_dir("efi", "/sys/firmware/efi")
}

// Create a directory entry
fn sysfs_create_dir(name: u64, path: u64): u32 {
  if sysfs_entry_count >= MAX_SYSFS_ENTRIES { return 0xFFFFFFFF }

  var entry_id: u32 = sysfs_entry_count

  sysfs_copy_name(sysfs_entries[entry_id].name, name, 64)
  sysfs_copy_path(sysfs_entries[entry_id].path, path, 256)

  sysfs_entries[entry_id].entry_type = SYSFS_DIR
  sysfs_entries[entry_id].permissions = SYSFS_DIR_PERM
  sysfs_entries[entry_id].handler.show_fn = 0
  sysfs_entries[entry_id].handler.store_fn = 0
  sysfs_entries[entry_id].handler.data = 0
  sysfs_entries[entry_id].parent = 0xFFFFFFFF
  sysfs_entries[entry_id].size = 0
  sysfs_entries[entry_id].in_use = 1

  sysfs_entry_count = sysfs_entry_count + 1

  return entry_id
}

// Create a file entry
fn sysfs_create_file(name: u64, path: u64, permissions: u32): u32 {
  if sysfs_entry_count >= MAX_SYSFS_ENTRIES { return 0xFFFFFFFF }

  var entry_id: u32 = sysfs_entry_count

  sysfs_copy_name(sysfs_entries[entry_id].name, name, 64)
  sysfs_copy_path(sysfs_entries[entry_id].path, path, 256)

  sysfs_entries[entry_id].entry_type = SYSFS_FILE
  sysfs_entries[entry_id].permissions = permissions
  sysfs_entries[entry_id].handler.show_fn = 0
  sysfs_entries[entry_id].handler.store_fn = 0
  sysfs_entries[entry_id].handler.data = 0
  sysfs_entries[entry_id].parent = 0xFFFFFFFF
  sysfs_entries[entry_id].size = 0
  sysfs_entries[entry_id].value[0] = 0
  sysfs_entries[entry_id].in_use = 1

  sysfs_entry_count = sysfs_entry_count + 1

  return entry_id
}

// Set static value for a file
fn sysfs_set_file_value(path: u64, value: u64) {
  var i: u32 = 0
  while i < sysfs_entry_count {
    if sysfs_entries[i].in_use == 1 && sysfs_entries[i].entry_type == SYSFS_FILE {
      if sysfs_path_match(sysfs_entries[i].path, path) == 1 {
        var j: u32 = 0
        while j < 255 {
          var ch: u8 = @intToPtr(value + j, u8)
          sysfs_entries[i].value[j] = ch
          if ch == 0 { break }
          j = j + 1
        }
        sysfs_entries[i].value[j] = 0
        sysfs_entries[i].size = j
        return
      }
    }
    i = i + 1
  }
}

// Register a file with handlers
export fn sysfs_register(name: u64, path: u64, show_fn: u64, store_fn: u64): u32 {
  var perms: u32 = SYSFS_READ_ONLY
  if store_fn != 0 { perms = SYSFS_READ_WRITE }

  var entry_id: u32 = sysfs_create_file(name, path, perms)
  if entry_id == 0xFFFFFFFF { return entry_id }

  sysfs_entries[entry_id].handler.show_fn = show_fn
  sysfs_entries[entry_id].handler.store_fn = store_fn

  return entry_id
}

// Unregister an entry
export fn sysfs_unregister(entry_id: u32): u32 {
  if entry_id >= sysfs_entry_count { return 0 }

  sysfs_entries[entry_id].in_use = 0
  return 1
}

// Register a bus type
export fn sysfs_register_bus(name: u64): u32 {
  if bus_count >= MAX_BUSES { return 0xFFFFFFFF }

  var bus_id: u32 = bus_count

  sysfs_copy_name(buses[bus_id].name, name, 64)
  buses[bus_id].driver_count = 0
  buses[bus_id].device_count = 0
  buses[bus_id].in_use = 1

  // Create bus directory structure
  var path: [u8; 256]
  sysfs_build_path(path, "/sys/bus/", name, 256)
  sysfs_create_dir(name, @ptrFromInt(path))

  // Create subdirs
  var subpath: [u8; 256]
  sysfs_build_path(subpath, @ptrFromInt(path), "/devices", 256)
  sysfs_create_dir("devices", @ptrFromInt(subpath))

  sysfs_build_path(subpath, @ptrFromInt(path), "/drivers", 256)
  sysfs_create_dir("drivers", @ptrFromInt(subpath))

  bus_count = bus_count + 1

  return bus_id
}

// Register a device class
export fn sysfs_register_class(name: u64): u32 {
  if class_count >= MAX_CLASSES { return 0xFFFFFFFF }

  var class_id: u32 = class_count

  sysfs_copy_name(classes[class_id].name, name, 64)
  classes[class_id].device_count = 0
  classes[class_id].in_use = 1

  // Create class directory
  var path: [u8; 256]
  sysfs_build_path(path, "/sys/class/", name, 256)
  sysfs_create_dir(name, @ptrFromInt(path))

  class_count = class_count + 1

  return class_id
}

// Register a device
export fn sysfs_register_device(name: u64, path: u64, subsystem: u64, bus: u64): u32 {
  if device_count >= MAX_DEVICES { return 0xFFFFFFFF }

  var dev_id: u32 = device_count

  sysfs_copy_name(devices[dev_id].name, name, 64)
  sysfs_copy_path(devices[dev_id].path, path, 256)
  sysfs_copy_name(devices[dev_id].subsystem, subsystem, 32)
  sysfs_copy_name(devices[dev_id].bus, bus, 32)
  devices[dev_id].driver[0] = 0
  devices[dev_id].class[0] = 0
  devices[dev_id].vendor_id = 0
  devices[dev_id].device_id = 0
  devices[dev_id].parent = 0xFFFFFFFF
  devices[dev_id].in_use = 1

  // Create device directory
  sysfs_create_dir(name, path)

  // Create common device attributes
  var attr_path: [u8; 256]

  sysfs_build_path(attr_path, path, "/uevent", 256)
  sysfs_create_file("uevent", @ptrFromInt(attr_path), SYSFS_READ_WRITE)

  sysfs_build_path(attr_path, path, "/subsystem", 256)
  sysfs_create_symlink("subsystem", @ptrFromInt(attr_path), subsystem)

  sysfs_build_path(attr_path, path, "/power", 256)
  sysfs_create_dir("power", @ptrFromInt(attr_path))

  device_count = device_count + 1

  return dev_id
}

// Register a block device
export fn sysfs_register_block_device(name: u64, major: u32, minor: u32, size_sectors: u64): u32 {
  if block_count >= MAX_BLOCK_DEVICES { return 0xFFFFFFFF }

  var blk_id: u32 = block_count

  sysfs_copy_name(block_devices[blk_id].name, name, 32)
  block_devices[blk_id].major = major
  block_devices[blk_id].minor = minor
  block_devices[blk_id].size_sectors = size_sectors
  block_devices[blk_id].sector_size = 512
  block_devices[blk_id].removable = 0
  block_devices[blk_id].readonly = 0
  block_devices[blk_id].device_idx = 0xFFFFFFFF
  block_devices[blk_id].in_use = 1

  // Create block device directory
  var path: [u8; 256]
  sysfs_build_path(path, "/sys/block/", name, 256)
  sysfs_create_dir(name, @ptrFromInt(path))

  // Create block device attributes
  var attr_path: [u8; 256]
  var val_str: [u8; 32]

  // size
  sysfs_build_path(attr_path, @ptrFromInt(path), "/size", 256)
  sysfs_create_file("size", @ptrFromInt(attr_path), SYSFS_READ_ONLY)
  sysfs_u64_to_str(val_str, size_sectors)
  sysfs_set_file_value(@ptrFromInt(attr_path), @ptrFromInt(val_str))

  // removable
  sysfs_build_path(attr_path, @ptrFromInt(path), "/removable", 256)
  sysfs_create_file("removable", @ptrFromInt(attr_path), SYSFS_READ_ONLY)
  sysfs_set_file_value(@ptrFromInt(attr_path), "0")

  // ro
  sysfs_build_path(attr_path, @ptrFromInt(path), "/ro", 256)
  sysfs_create_file("ro", @ptrFromInt(attr_path), SYSFS_READ_ONLY)
  sysfs_set_file_value(@ptrFromInt(attr_path), "0")

  // Create queue subdirectory
  sysfs_build_path(attr_path, @ptrFromInt(path), "/queue", 256)
  sysfs_create_dir("queue", @ptrFromInt(attr_path))

  // Queue attributes
  var queue_path: [u8; 256]
  sysfs_build_path(queue_path, @ptrFromInt(attr_path), "/logical_block_size", 256)
  sysfs_create_file("logical_block_size", @ptrFromInt(queue_path), SYSFS_READ_ONLY)
  sysfs_set_file_value(@ptrFromInt(queue_path), "512")

  sysfs_build_path(queue_path, @ptrFromInt(attr_path), "/physical_block_size", 256)
  sysfs_create_file("physical_block_size", @ptrFromInt(queue_path), SYSFS_READ_ONLY)
  sysfs_set_file_value(@ptrFromInt(queue_path), "512")

  sysfs_build_path(queue_path, @ptrFromInt(attr_path), "/scheduler", 256)
  sysfs_create_file("scheduler", @ptrFromInt(queue_path), SYSFS_READ_WRITE)
  sysfs_set_file_value(@ptrFromInt(queue_path), "[none] mq-deadline")

  block_count = block_count + 1

  return blk_id
}

// Register a kernel module
export fn sysfs_register_module(name: u64, version: u64, size: u64): u32 {
  if module_count >= MAX_MODULES { return 0xFFFFFFFF }

  var mod_id: u32 = module_count

  sysfs_copy_name(modules[mod_id].name, name, 64)
  sysfs_copy_name(modules[mod_id].version, version, 32)
  modules[mod_id].refcount = 0
  modules[mod_id].state = 0  // live
  modules[mod_id].size = size
  modules[mod_id].in_use = 1

  // Create module directory
  var path: [u8; 256]
  sysfs_build_path(path, "/sys/module/", name, 256)
  sysfs_create_dir(name, @ptrFromInt(path))

  // Create module attributes
  var attr_path: [u8; 256]

  sysfs_build_path(attr_path, @ptrFromInt(path), "/refcnt", 256)
  sysfs_create_file("refcnt", @ptrFromInt(attr_path), SYSFS_READ_ONLY)
  sysfs_set_file_value(@ptrFromInt(attr_path), "0")

  sysfs_build_path(attr_path, @ptrFromInt(path), "/srcversion", 256)
  sysfs_create_file("srcversion", @ptrFromInt(attr_path), SYSFS_READ_ONLY)

  sysfs_build_path(attr_path, @ptrFromInt(path), "/version", 256)
  sysfs_create_file("version", @ptrFromInt(attr_path), SYSFS_READ_ONLY)
  sysfs_set_file_value(@ptrFromInt(attr_path), version)

  // Create parameters directory
  sysfs_build_path(attr_path, @ptrFromInt(path), "/parameters", 256)
  sysfs_create_dir("parameters", @ptrFromInt(attr_path))

  module_count = module_count + 1

  return mod_id
}

// Create a symlink entry
fn sysfs_create_symlink(name: u64, path: u64, target: u64): u32 {
  if sysfs_entry_count >= MAX_SYSFS_ENTRIES { return 0xFFFFFFFF }

  var entry_id: u32 = sysfs_entry_count

  sysfs_copy_name(sysfs_entries[entry_id].name, name, 64)
  sysfs_copy_path(sysfs_entries[entry_id].path, path, 256)

  sysfs_entries[entry_id].entry_type = SYSFS_SYMLINK
  sysfs_entries[entry_id].permissions = SYSFS_READ_ONLY

  // Store target in value
  sysfs_copy_path(sysfs_entries[entry_id].value, target, 256)

  sysfs_entries[entry_id].handler.show_fn = 0
  sysfs_entries[entry_id].handler.store_fn = 0
  sysfs_entries[entry_id].handler.data = 0
  sysfs_entries[entry_id].parent = 0xFFFFFFFF
  sysfs_entries[entry_id].size = 0
  sysfs_entries[entry_id].in_use = 1

  sysfs_entry_count = sysfs_entry_count + 1

  return entry_id
}

// Read from a sysfs entry
export fn sysfs_read(path: u64, buffer: u64, size: u32): u32 {
  var i: u32 = 0
  while i < sysfs_entry_count {
    if sysfs_entries[i].in_use == 1 {
      if sysfs_path_match(sysfs_entries[i].path, path) == 1 {
        if sysfs_entries[i].entry_type == SYSFS_FILE {
          // Check for custom handler
          if sysfs_entries[i].handler.show_fn != 0 {
            // Call show handler (stub)
            return 0
          }

          // Return static value
          var j: u32 = 0
          while j < size && j < 255 && sysfs_entries[i].value[j] != 0 {
            @intToPtr(buffer + j, u8) = sysfs_entries[i].value[j]
            j = j + 1
          }
          // Add newline
          if j < size {
            @intToPtr(buffer + j, u8) = '\n'
            j = j + 1
          }
          return j
        } else if sysfs_entries[i].entry_type == SYSFS_SYMLINK {
          // Return symlink target
          var j: u32 = 0
          while j < size && j < 255 && sysfs_entries[i].value[j] != 0 {
            @intToPtr(buffer + j, u8) = sysfs_entries[i].value[j]
            j = j + 1
          }
          return j
        }
      }
    }
    i = i + 1
  }

  return 0
}

// Write to a sysfs entry
export fn sysfs_write(path: u64, buffer: u64, size: u32): u32 {
  var i: u32 = 0
  while i < sysfs_entry_count {
    if sysfs_entries[i].in_use == 1 {
      if sysfs_path_match(sysfs_entries[i].path, path) == 1 {
        if sysfs_entries[i].entry_type == SYSFS_FILE {
          // Check permissions
          if (sysfs_entries[i].permissions & 0o200) == 0 {
            return 0  // Read-only
          }

          // Check for custom handler
          if sysfs_entries[i].handler.store_fn != 0 {
            // Call store handler (stub)
            return 0
          }

          // Update static value
          var j: u32 = 0
          var max_size: u32 = size
          if max_size > 255 { max_size = 255 }

          while j < max_size {
            var ch: u8 = @intToPtr(buffer + j, u8)
            if ch == '\n' || ch == 0 { break }
            sysfs_entries[i].value[j] = ch
            j = j + 1
          }
          sysfs_entries[i].value[j] = 0
          sysfs_entries[i].size = j

          return j
        }
      }
    }
    i = i + 1
  }

  return 0
}

// List directory contents
export fn sysfs_readdir(path: u64, buffer: u64, size: u32): u32 {
  var offset: u32 = 0

  var i: u32 = 0
  while i < sysfs_entry_count && offset < size {
    if sysfs_entries[i].in_use == 1 {
      // Check if this entry is a child of the given path
      if sysfs_is_child_of(sysfs_entries[i].path, path) == 1 {
        // Copy name
        var j: u32 = 0
        while sysfs_entries[i].name[j] != 0 && offset < size {
          @intToPtr(buffer + offset, u8) = sysfs_entries[i].name[j]
          offset = offset + 1
          j = j + 1
        }
        if offset < size {
          @intToPtr(buffer + offset, u8) = '\n'
          offset = offset + 1
        }
      }
    }
    i = i + 1
  }

  return offset
}

// Get entry type
export fn sysfs_get_type(path: u64): u32 {
  var i: u32 = 0
  while i < sysfs_entry_count {
    if sysfs_entries[i].in_use == 1 {
      if sysfs_path_match(sysfs_entries[i].path, path) == 1 {
        return sysfs_entries[i].entry_type
      }
    }
    i = i + 1
  }

  return 0xFFFFFFFF  // Not found
}

// Check if entry exists
export fn sysfs_exists(path: u64): u32 {
  var i: u32 = 0
  while i < sysfs_entry_count {
    if sysfs_entries[i].in_use == 1 {
      if sysfs_path_match(sysfs_entries[i].path, path) == 1 {
        return 1
      }
    }
    i = i + 1
  }

  return 0
}

// Get device info
export fn sysfs_get_device(device_id: u32, name_out: u64, path_out: u64, subsystem_out: u64): u32 {
  if device_id >= device_count { return 0 }
  if devices[device_id].in_use == 0 { return 0 }

  sysfs_copy_path_out(name_out, devices[device_id].name, 64)
  sysfs_copy_path_out(path_out, devices[device_id].path, 256)
  sysfs_copy_path_out(subsystem_out, devices[device_id].subsystem, 32)

  return 1
}

// Set device driver
export fn sysfs_set_device_driver(device_id: u32, driver: u64) {
  if device_id >= device_count { return }
  if devices[device_id].in_use == 0 { return }

  sysfs_copy_name(devices[device_id].driver, driver, 64)

  // Create driver symlink
  var link_path: [u8; 256]
  sysfs_build_path(link_path, devices[device_id].path, "/driver", 256)
  sysfs_create_symlink("driver", @ptrFromInt(link_path), driver)
}

// Set device vendor/device IDs
export fn sysfs_set_device_ids(device_id: u32, vendor_id: u32, dev_id: u32) {
  if device_id >= device_count { return }
  if devices[device_id].in_use == 0 { return }

  devices[device_id].vendor_id = vendor_id
  devices[device_id].device_id = dev_id

  // Create ID files
  var attr_path: [u8; 256]
  var val_str: [u8; 16]

  sysfs_build_path(attr_path, devices[device_id].path, "/vendor", 256)
  sysfs_create_file("vendor", @ptrFromInt(attr_path), SYSFS_READ_ONLY)
  sysfs_u32_to_hex(val_str, vendor_id)
  sysfs_set_file_value(@ptrFromInt(attr_path), @ptrFromInt(val_str))

  sysfs_build_path(attr_path, devices[device_id].path, "/device", 256)
  sysfs_create_file("device", @ptrFromInt(attr_path), SYSFS_READ_ONLY)
  sysfs_u32_to_hex(val_str, dev_id)
  sysfs_set_file_value(@ptrFromInt(attr_path), @ptrFromInt(val_str))
}

// Update module refcount
export fn sysfs_update_module_refcount(module_id: u32, refcount: u32) {
  if module_id >= module_count { return }
  if modules[module_id].in_use == 0 { return }

  modules[module_id].refcount = refcount

  // Update refcnt file
  var path: [u8; 256]
  sysfs_build_path(path, "/sys/module/", @ptrFromInt(modules[module_id].name), 256)

  var refcnt_path: [u8; 256]
  sysfs_build_path(refcnt_path, @ptrFromInt(path), "/refcnt", 256)

  var val_str: [u8; 16]
  sysfs_u32_to_str(val_str, refcount)
  sysfs_set_file_value(@ptrFromInt(refcnt_path), @ptrFromInt(val_str))
}

// Get statistics
export fn sysfs_get_stats(entries_out: u64, devices_out: u64, classes_out: u64, buses_out: u64): u32 {
  @intToPtr(entries_out, u32) = sysfs_entry_count
  @intToPtr(devices_out, u32) = device_count
  @intToPtr(classes_out, u32) = class_count
  @intToPtr(buses_out, u32) = bus_count

  return 1
}

// Get entry count
export fn sysfs_get_entry_count(): u32 {
  return sysfs_entry_count
}

// Get device count
export fn sysfs_get_device_count(): u32 {
  return device_count
}

// Get module count
export fn sysfs_get_module_count(): u32 {
  return module_count
}

// Get block device count
export fn sysfs_get_block_count(): u32 {
  return block_count
}

// Helper: copy name to array
fn sysfs_copy_name(dest: [u8; 64], src: u64, max_len: u32) {
  var i: u32 = 0
  while i < max_len - 1 {
    var ch: u8 = @intToPtr(src + i, u8)
    dest[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  dest[i] = 0
}

// Helper: copy path to array
fn sysfs_copy_path(dest: [u8; 256], src: u64, max_len: u32) {
  var i: u32 = 0
  while i < max_len - 1 {
    var ch: u8 = @intToPtr(src + i, u8)
    dest[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  dest[i] = 0
}

// Helper: copy path out
fn sysfs_copy_path_out(dest: u64, src: [u8; 64], max_len: u32) {
  var i: u32 = 0
  while i < max_len {
    @intToPtr(dest + i, u8) = src[i]
    if src[i] == 0 { break }
    i = i + 1
  }
}

// Helper: check if paths match
fn sysfs_path_match(arr: [u8; 256], path: u64): u32 {
  var i: u32 = 0
  while i < 256 {
    var c1: u8 = arr[i]
    var c2: u8 = @intToPtr(path + i, u8)
    if c1 != c2 { return 0 }
    if c1 == 0 { return 1 }
    i = i + 1
  }
  return 0
}

// Helper: check if path is child of parent
fn sysfs_is_child_of(child: [u8; 256], parent: u64): u32 {
  // Check if child path starts with parent path
  var i: u32 = 0
  while i < 256 {
    var p: u8 = @intToPtr(parent + i, u8)
    if p == 0 {
      // Parent path ended, check if next char in child is '/'
      if child[i] == '/' {
        // Make sure there's no more '/' (direct child only)
        var j: u32 = i + 1
        while child[j] != 0 && j < 256 {
          if child[j] == '/' { return 0 }  // Not direct child
          j = j + 1
        }
        return 1
      }
      return 0
    }
    if child[i] != p { return 0 }
    i = i + 1
  }
  return 0
}

// Helper: build path from parts
fn sysfs_build_path(dest: [u8; 256], prefix: u64, suffix: u64, max_len: u32) {
  var i: u32 = 0

  // Copy prefix
  while i < max_len - 1 {
    var ch: u8 = @intToPtr(prefix + i, u8)
    if ch == 0 { break }
    dest[i] = ch
    i = i + 1
  }

  // Copy suffix
  var j: u32 = 0
  while i < max_len - 1 {
    var ch: u8 = @intToPtr(suffix + j, u8)
    if ch == 0 { break }
    dest[i] = ch
    i = i + 1
    j = j + 1
  }

  dest[i] = 0
}

// Helper: set string
fn sysfs_set_string(arr: [u8; 64], str: u64, max_len: u32) {
  var i: u32 = 0
  while i < max_len - 1 {
    var ch: u8 = @intToPtr(str + i, u8)
    arr[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  arr[i] = 0
}

// Helper: u32 to string
fn sysfs_u32_to_str(dest: [u8; 16], val: u32) {
  if val == 0 {
    dest[0] = '0'
    dest[1] = 0
    return
  }

  var temp: [u8; 16]
  var len: u32 = 0
  var v: u32 = val

  while v > 0 {
    temp[len] = '0' + @truncate(v % 10, u8)
    v = v / 10
    len = len + 1
  }

  // Reverse
  var i: u32 = 0
  while i < len {
    dest[i] = temp[len - 1 - i]
    i = i + 1
  }
  dest[len] = 0
}

// Helper: u64 to string
fn sysfs_u64_to_str(dest: [u8; 32], val: u64) {
  if val == 0 {
    dest[0] = '0'
    dest[1] = 0
    return
  }

  var temp: [u8; 24]
  var len: u32 = 0
  var v: u64 = val

  while v > 0 {
    temp[len] = '0' + @truncate(v % 10, u8)
    v = v / 10
    len = len + 1
  }

  // Reverse
  var i: u32 = 0
  while i < len {
    dest[i] = temp[len - 1 - i]
    i = i + 1
  }
  dest[len] = 0
}

// Helper: u32 to hex string (with 0x prefix)
fn sysfs_u32_to_hex(dest: [u8; 16], val: u32) {
  var hex_chars: [u8; 16] = "0123456789abcdef"

  dest[0] = '0'
  dest[1] = 'x'

  var i: u32 = 0
  while i < 4 {
    var nibble: u8 = @truncate((val >> ((3 - i) * 8 + 4)) & 0xF, u8)
    dest[2 + i * 2] = hex_chars[nibble]

    nibble = @truncate((val >> ((3 - i) * 8)) & 0xF, u8)
    dest[3 + i * 2] = hex_chars[nibble]

    i = i + 1
  }
  dest[10] = 0
}
