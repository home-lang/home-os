// IDT (Interrupt Descriptor Table) for home-os
// Handles CPU exceptions and hardware interrupts
// Based on Home's kernel package: ~/Code/home/packages/kernel/src/interrupts.zig

import serial from "./serial.home"
import cpu from "./os/cpu.home"

// IDT Entry (Interrupt Gate Descriptor) - 16 bytes, 128 bits
packed struct IDTEntry: u128 {
    offset_low: u16,      // Offset bits 0-15
    selector: u16,        // Code segment selector (0x08 for kernel code)
    ist: u3,              // Interrupt Stack Table offset (0-7)
    reserved1: u5,        // Must be zero
    gate_type: u4,        // Gate type (0xE = interrupt gate)
    zero: u1,             // Must be zero
    dpl: u2,              // Descriptor Privilege Level (0 = kernel)
    present: u1,          // Present flag (1 = valid)
    offset_mid: u16,      // Offset bits 16-31
    offset_high: u32,     // Offset bits 32-63
    reserved2: u32,       // Must be zero
}

// IDT Pointer structure for LIDT instruction
packed struct IDTPointer {
    limit: u16,           // Size of IDT - 1
    base: u64,            // Address of IDT
}

// IDT with 256 entries (aligned to 4KB page boundary)
let idt: [256]IDTEntry align(4096) = undefined

// Exception names for debugging
let exception_names = [
    "Division By Zero",
    "Debug",
    "Non-Maskable Interrupt",
    "Breakpoint",
    "Overflow",
    "Bound Range Exceeded",
    "Invalid Opcode",
    "Device Not Available",
    "Double Fault",
    "Coprocessor Segment Overrun",
    "Invalid TSS",
    "Segment Not Present",
    "Stack-Segment Fault",
    "General Protection Fault",
    "Page Fault",
    "Reserved",
    "x87 Floating-Point Exception",
    "Alignment Check",
    "Machine Check",
    "SIMD Floating-Point Exception",
    "Virtualization Exception",
    "Control Protection Exception",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Hypervisor Injection Exception",
    "VMM Communication Exception",
    "Security Exception",
    "Reserved",
]

// Create an interrupt gate entry
fn createInterruptGate(handler: usize, selector: u16, dpl: u2, ist: u3): IDTEntry {
    return IDTEntry {
        offset_low: @truncate(handler),
        selector: selector,
        ist: ist,
        reserved1: 0,
        gate_type: 0xE,  // 64-bit interrupt gate
        zero: 0,
        dpl: dpl,
        present: 1,
        offset_mid: @truncate(handler >> 16),
        offset_high: @truncate(handler >> 32),
        reserved2: 0,
    }
}

// Set an IDT entry
fn setGate(index: u8, handler: u64, selector: u16, dpl: u2) {
    idt[index] = createInterruptGate(handler, selector, dpl, 0)
}

// Generic exception handler
export fn exceptionHandler(vector: u64, error_code: u64, rip: u64, cs: u64, rflags: u64, rsp: u64, ss: u64) callconv(.C) {
    serial.writeString("\n\n*** EXCEPTION ***\n")
    serial.writeString("Vector: ")
    serial.writeDec(vector)

    if vector < exception_names.len {
        serial.writeString(" (")
        serial.writeString(exception_names[vector])
        serial.writeString(")")
    }
    serial.writeString("\n")

    serial.writeString("Error code: ")
    serial.writeHex(error_code)
    serial.writeString("\n")

    serial.writeString("RIP: ")
    serial.writeHex(rip)
    serial.writeString("\n")

    serial.writeString("CS: ")
    serial.writeHex(cs)
    serial.writeString("\n")

    serial.writeString("RFLAGS: ")
    serial.writeHex(rflags)
    serial.writeString("\n")

    serial.writeString("RSP: ")
    serial.writeHex(rsp)
    serial.writeString("\n")

    serial.writeString("SS: ")
    serial.writeHex(ss)
    serial.writeString("\n")

    // Halt forever
    loop {
        cpu.hlt()
    }
}

// ISR stubs (defined in idt_stubs.s)
extern fn isr0()
extern fn isr1()
extern fn isr2()
extern fn isr3()
extern fn isr4()
extern fn isr5()
extern fn isr6()
extern fn isr7()
extern fn isr8()
extern fn isr9()
extern fn isr10()
extern fn isr11()
extern fn isr12()
extern fn isr13()
extern fn isr14()
extern fn isr15()
extern fn isr16()
extern fn isr17()
extern fn isr18()
extern fn isr19()
extern fn isr20()
extern fn isr21()
extern fn isr30()
extern fn isr31()

// Initialize IDT
export fn init() {
    serial.writeString("Initializing IDT...\n")

    // Zero out the entire IDT first
    let i = 0
    loop {
        if i >= 256 {
            break
        }
        idt[i] = IDTEntry {
            offset_low: 0,
            selector: 0,
            ist: 0,
            reserved1: 0,
            gate_type: 0,
            zero: 0,
            dpl: 0,
            present: 0,
            offset_mid: 0,
            offset_high: 0,
            reserved2: 0,
        }
        i = i + 1
    }

    // Set up exception handlers (0-31)
    // DPL=0 (kernel only), selector=0x08 (kernel code segment)
    serial.writeString("Setting exception handlers...\n")

    setGate(0, @intFromPtr(&isr0), 0x08, 0)
    setGate(1, @intFromPtr(&isr1), 0x08, 0)
    setGate(2, @intFromPtr(&isr2), 0x08, 0)
    setGate(3, @intFromPtr(&isr3), 0x08, 0)
    setGate(4, @intFromPtr(&isr4), 0x08, 0)
    setGate(5, @intFromPtr(&isr5), 0x08, 0)
    setGate(6, @intFromPtr(&isr6), 0x08, 0)
    setGate(7, @intFromPtr(&isr7), 0x08, 0)
    setGate(8, @intFromPtr(&isr8), 0x08, 0)
    setGate(9, @intFromPtr(&isr9), 0x08, 0)
    setGate(10, @intFromPtr(&isr10), 0x08, 0)
    setGate(11, @intFromPtr(&isr11), 0x08, 0)
    setGate(12, @intFromPtr(&isr12), 0x08, 0)
    setGate(13, @intFromPtr(&isr13), 0x08, 0)
    setGate(14, @intFromPtr(&isr14), 0x08, 0)
    setGate(15, @intFromPtr(&isr15), 0x08, 0)
    setGate(16, @intFromPtr(&isr16), 0x08, 0)
    setGate(17, @intFromPtr(&isr17), 0x08, 0)
    setGate(18, @intFromPtr(&isr18), 0x08, 0)
    setGate(19, @intFromPtr(&isr19), 0x08, 0)
    setGate(20, @intFromPtr(&isr20), 0x08, 0)
    setGate(21, @intFromPtr(&isr21), 0x08, 0)
    setGate(30, @intFromPtr(&isr30), 0x08, 0)
    setGate(31, @intFromPtr(&isr31), 0x08, 0)

    serial.writeString("Exception handlers set\n")

    // Create IDT pointer
    let idt_ptr = IDTPointer {
        limit: @sizeOf(@TypeOf(idt)) - 1,
        base: @intFromPtr(&idt),
    }

    serial.writeString("IDT address: ")
    serial.writeHex(idt_ptr.base)
    serial.writeString("\n")
    serial.writeString("IDT size: ")
    serial.writeDec(idt_ptr.limit)
    serial.writeString("\n")

    // Load IDT using CPU instruction
    serial.writeString("Loading IDT with LIDT instruction...\n")
    cpu.lidt(&idt_ptr)

    serial.writeString("IDT loaded successfully!\n")
}

// Test exception by dividing by zero
export fn testDivideByZero() {
    serial.writeString("Testing divide by zero exception...\n")
    let x: u32 = 42
    let y: u32 = 0
    let z: u32 = x / y  // This will trigger exception 0
    _ = z
}
