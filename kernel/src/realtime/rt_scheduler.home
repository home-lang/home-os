// home-os Kernel - Real-Time Scheduler
// Deterministic scheduling for real-time tasks

import "../core/foundation.home" as foundation
import "../core/process.home" as process

const MAX_RT_TASKS: u32 = 64

// Scheduling policies
const SCHED_FIFO: u32 = 1
const SCHED_RR: u32 = 2
const SCHED_DEADLINE: u32 = 3

struct RTTask {
  pid: u32,
  policy: u32,
  priority: u32,
  deadline: u64,
  period: u64,
  runtime: u64,
  last_run: u64,
  active: u32
}

var rt_tasks: [RTTask; 64]
var rt_task_count: u32 = 0
var rt_enabled: u32 = 0

export fn rt_scheduler_init() {
  rt_task_count = 0
  rt_enabled = 1
  
  foundation.serial_write_string("[RT-Scheduler] Real-time scheduler initialized\n")
}

export fn rt_task_create(pid: u32, policy: u32, priority: u32, deadline: u64, period: u64) -> u32 {
  if rt_task_count >= MAX_RT_TASKS { return 0xFFFFFFFF }
  
  var task_id: u32 = rt_task_count
  
  rt_tasks[task_id].pid = pid
  rt_tasks[task_id].policy = policy
  rt_tasks[task_id].priority = priority
  rt_tasks[task_id].deadline = deadline
  rt_tasks[task_id].period = period
  rt_tasks[task_id].runtime = 0
  rt_tasks[task_id].last_run = 0
  rt_tasks[task_id].active = 1
  
  rt_task_count = rt_task_count + 1
  
  foundation.serial_write_string("[RT-Scheduler] Real-time task created: PID ")
  foundation.serial_write_hex(pid)
  foundation.serial_write_string(" Priority ")
  foundation.serial_write_hex(priority)
  foundation.serial_write_string("\n")
  
  return task_id
}

export fn rt_schedule() -> u32 {
  if rt_enabled == 0 { return 0xFFFFFFFF }
  
  var current_time: u64 = foundation.timer_get_ticks()
  var next_task: u32 = 0xFFFFFFFF
  var highest_priority: u32 = 0
  var earliest_deadline: u64 = 0xFFFFFFFFFFFFFFFF
  
  // Find next task to run
  var i: u32 = 0
  while i < rt_task_count {
    if rt_tasks[i].active == 0 {
      i = i + 1
      continue
    }
    
    if rt_tasks[i].policy == SCHED_FIFO or rt_tasks[i].policy == SCHED_RR {
      // Priority-based scheduling
      if rt_tasks[i].priority > highest_priority {
        highest_priority = rt_tasks[i].priority
        next_task = i
      }
    } else if rt_tasks[i].policy == SCHED_DEADLINE {
      // Earliest deadline first
      if rt_tasks[i].deadline < earliest_deadline {
        earliest_deadline = rt_tasks[i].deadline
        next_task = i
      }
    }
    
    i = i + 1
  }
  
  if next_task == 0xFFFFFFFF { return 0xFFFFFFFF }
  
  // Update task stats
  rt_tasks[next_task].last_run = current_time
  
  return rt_tasks[next_task].pid
}

export fn rt_task_set_priority(task_id: u32, priority: u32) -> u32 {
  if task_id >= rt_task_count { return 0 }
  
  rt_tasks[task_id].priority = priority
  
  return 1
}

export fn rt_task_set_deadline(task_id: u32, deadline: u64) -> u32 {
  if task_id >= rt_task_count { return 0 }
  
  rt_tasks[task_id].deadline = deadline
  
  return 1
}

export fn rt_check_deadlines() {
  var current_time: u64 = foundation.timer_get_ticks()
  
  var i: u32 = 0
  while i < rt_task_count {
    if rt_tasks[i].active == 1 and rt_tasks[i].policy == SCHED_DEADLINE {
      if current_time > rt_tasks[i].deadline {
        foundation.serial_write_string("[RT-Scheduler] Deadline missed for PID ")
        foundation.serial_write_hex(rt_tasks[i].pid)
        foundation.serial_write_string("\n")
        
        // Handle deadline miss
        rt_handle_deadline_miss(i)
      }
    }
    i = i + 1
  }
}

fn rt_handle_deadline_miss(task_id: u32) {
  // Log deadline miss
  // Optionally kill task or adjust priority
}

export fn rt_task_stats() {
  foundation.serial_write_string("\n[RT-Scheduler] Real-time tasks:\n")
  foundation.serial_write_string("PID   Policy    Priority  Deadline  Period\n")
  foundation.serial_write_string("--------------------------------------------\n")
  
  var i: u32 = 0
  while i < rt_task_count {
    if rt_tasks[i].active == 1 {
      foundation.serial_write_hex(rt_tasks[i].pid)
      foundation.serial_write_string("  ")
      
      if rt_tasks[i].policy == SCHED_FIFO {
        foundation.serial_write_string("FIFO     ")
      } else if rt_tasks[i].policy == SCHED_RR {
        foundation.serial_write_string("RR       ")
      } else if rt_tasks[i].policy == SCHED_DEADLINE {
        foundation.serial_write_string("DEADLINE ")
      }
      
      foundation.serial_write_hex(rt_tasks[i].priority)
      foundation.serial_write_string("        ")
      foundation.serial_write_hex(@truncate(rt_tasks[i].deadline, u32))
      foundation.serial_write_string("  ")
      foundation.serial_write_hex(@truncate(rt_tasks[i].period, u32))
      foundation.serial_write_string("\n")
    }
    i = i + 1
  }
}

export fn rt_enable() {
  rt_enabled = 1
  foundation.serial_write_string("[RT-Scheduler] Enabled\n")
}

export fn rt_disable() {
  rt_enabled = 0
  foundation.serial_write_string("[RT-Scheduler] Disabled\n")
}
