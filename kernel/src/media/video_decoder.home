// home-os Kernel - Video Decoder
// H.264/H.265 and VP8/VP9 video decoding

import "../core/foundation.home" as foundation

// Video codecs
const CODEC_H264: u32 = 1
const CODEC_H265: u32 = 2
const CODEC_VP8: u32 = 3
const CODEC_VP9: u32 = 4

// Container formats
const CONTAINER_MP4: u32 = 1
const CONTAINER_MKV: u32 = 2
const CONTAINER_WEBM: u32 = 3

const MAX_DECODERS: u32 = 8

struct VideoDecoder {
  codec: u32,
  width: u32,
  height: u32,
  fps: u32,
  bitrate: u32,
  hw_accel: u32,
  active: u32
}

var decoders: [VideoDecoder; 8]
var decoder_count: u32 = 0

export fn video_decoder_init() {
  decoder_count = 0
  foundation.serial_write_string("[Video] Decoder initialized\n")
}

export fn video_decoder_create(codec: u32, width: u32, height: u32, fps: u32) -> u32 {
  if decoder_count >= MAX_DECODERS { return 0xFFFFFFFF }
  
  var decoder_id: u32 = decoder_count
  
  decoders[decoder_id].codec = codec
  decoders[decoder_id].width = width
  decoders[decoder_id].height = height
  decoders[decoder_id].fps = fps
  decoders[decoder_id].hw_accel = video_check_hw_accel(codec)
  decoders[decoder_id].active = 1
  
  decoder_count = decoder_count + 1
  
  foundation.serial_write_string("[Video] Created decoder: ")
  foundation.serial_write_hex(width)
  foundation.serial_write_string("x")
  foundation.serial_write_hex(height)
  foundation.serial_write_string(" @ ")
  foundation.serial_write_hex(fps)
  foundation.serial_write_string(" fps\n")
  
  return decoder_id
}

fn video_check_hw_accel(codec: u32) -> u32 {
  // Check for hardware acceleration support
  if codec == CODEC_H264 or codec == CODEC_H265 {
    return 1  // Most GPUs support H.264/H.265
  }
  return 0
}

export fn video_decode_frame(decoder_id: u32, input: u64, input_size: u32, output: u64) -> u32 {
  if decoder_id >= decoder_count { return 0 }
  
  if decoders[decoder_id].hw_accel == 1 {
    return video_decode_hw(decoder_id, input, input_size, output)
  } else {
    return video_decode_sw(decoder_id, input, input_size, output)
  }
}

fn video_decode_hw(decoder_id: u32, input: u64, input_size: u32, output: u64) -> u32 {
  // Hardware-accelerated decoding
  foundation.gpu_decode_frame(input, input_size, output)
  return 1
}

fn video_decode_sw(decoder_id: u32, input: u64, input_size: u32, output: u64) -> u32 {
  // Software decoding (simplified)
  var codec: u32 = decoders[decoder_id].codec
  
  if codec == CODEC_H264 {
    return video_decode_h264(input, input_size, output)
  } else if codec == CODEC_H265 {
    return video_decode_h265(input, input_size, output)
  } else if codec == CODEC_VP8 {
    return video_decode_vp8(input, input_size, output)
  } else if codec == CODEC_VP9 {
    return video_decode_vp9(input, input_size, output)
  }
  
  return 0
}

fn video_decode_h264(input: u64, input_size: u32, output: u64) -> u32 {
  // H.264 decoding implementation
  return 1
}

fn video_decode_h265(input: u64, input_size: u32, output: u64) -> u32 {
  // H.265/HEVC decoding implementation
  return 1
}

fn video_decode_vp8(input: u64, input_size: u32, output: u64) -> u32 {
  // VP8 decoding implementation
  return 1
}

fn video_decode_vp9(input: u64, input_size: u32, output: u64) -> u32 {
  // VP9 decoding implementation
  return 1
}

export fn video_decoder_destroy(decoder_id: u32) -> u32 {
  if decoder_id >= decoder_count { return 0 }
  
  decoders[decoder_id].active = 0
  return 1
}

export fn video_get_info(decoder_id: u32, width_out: u64, height_out: u64, fps_out: u64) -> u32 {
  if decoder_id >= decoder_count { return 0 }
  
  @intToPtr(width_out, u32) = decoders[decoder_id].width
  @intToPtr(height_out, u32) = decoders[decoder_id].height
  @intToPtr(fps_out, u32) = decoders[decoder_id].fps
  
  return 1
}
