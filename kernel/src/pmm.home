// Physical Memory Manager (PMM) for home-os
// Manages physical page frames using a bitmap allocator
// Full Multiboot2 memory map parsing implementation
// Written in Home language

import basics/os/serial
import basics/os/cpu

// Page size constants
const PAGE_SIZE: u64 = 4096
const PAGE_SHIFT: u32 = 12

// Memory bitmap (1 bit per page frame)
// For 4GB RAM: 4GB / 4KB = 1,048,576 pages = 131,072 bytes bitmap
const MAX_PAGES: u64 = 1048576
const BITMAP_SIZE: u64 = MAX_PAGES / 8

// Bitmap stored in .bss section (will be zero-initialized)
var bitmap: [131072]u8 = undefined
var total_pages: u64 = 0
var used_pages: u64 = 0
var free_pages: u64 = 0
var total_memory: u64 = 0
var usable_memory: u64 = 0

// ============================================================================
// MULTIBOOT2 STRUCTURES
// ============================================================================

// Multiboot2 information structure header
struct Multiboot2Info {
    total_size: u32,
    reserved: u32,
}

// Multiboot2 tag header (all tags start with this)
struct Multiboot2Tag {
    type: u32,
    size: u32,
}

// Multiboot2 tag types
const MULTIBOOT2_TAG_END: u32 = 0
const MULTIBOOT2_TAG_CMDLINE: u32 = 1
const MULTIBOOT2_TAG_BOOT_LOADER_NAME: u32 = 2
const MULTIBOOT2_TAG_MODULE: u32 = 3
const MULTIBOOT2_TAG_BASIC_MEMINFO: u32 = 4
const MULTIBOOT2_TAG_BOOTDEV: u32 = 5
const MULTIBOOT2_TAG_MMAP: u32 = 6
const MULTIBOOT2_TAG_VBE: u32 = 7
const MULTIBOOT2_TAG_FRAMEBUFFER: u32 = 8
const MULTIBOOT2_TAG_ELF_SECTIONS: u32 = 9
const MULTIBOOT2_TAG_APM: u32 = 10
const MULTIBOOT2_TAG_EFI32: u32 = 11
const MULTIBOOT2_TAG_EFI64: u32 = 12
const MULTIBOOT2_TAG_SMBIOS: u32 = 13
const MULTIBOOT2_TAG_ACPI_OLD: u32 = 14
const MULTIBOOT2_TAG_ACPI_NEW: u32 = 15
const MULTIBOOT2_TAG_NETWORK: u32 = 16
const MULTIBOOT2_TAG_EFI_MMAP: u32 = 17
const MULTIBOOT2_TAG_EFI_BS: u32 = 18
const MULTIBOOT2_TAG_EFI32_IH: u32 = 19
const MULTIBOOT2_TAG_EFI64_IH: u32 = 20
const MULTIBOOT2_TAG_LOAD_BASE_ADDR: u32 = 21

// Memory map tag
struct Multiboot2MmapTag {
    type: u32,
    size: u32,
    entry_size: u32,
    entry_version: u32,
}

// Memory map entry
struct Multiboot2MmapEntry {
    base_addr: u64,
    length: u64,
    type: u32,
    reserved: u32,
}

// Memory region types
const MEMORY_AVAILABLE: u32 = 1
const MEMORY_RESERVED: u32 = 2
const MEMORY_ACPI_RECLAIMABLE: u32 = 3
const MEMORY_NVS: u32 = 4
const MEMORY_BADRAM: u32 = 5

// Basic memory info tag
struct Multiboot2BasicMeminfo {
    type: u32,
    size: u32,
    mem_lower: u32,  // Memory below 1MB in KB
    mem_upper: u32,  // Memory above 1MB in KB
}

// ============================================================================
// MEMORY REGION TRACKING
// ============================================================================

const MAX_MEMORY_REGIONS: u32 = 32

struct MemoryRegion {
    base: u64,
    length: u64,
    type: u32,
    name: [16]u8,
}

var memory_regions: [32]MemoryRegion = undefined
var region_count: u32 = 0

// Reserved regions (kernel, bootloader data, etc.)
struct ReservedRegion {
    base: u64,
    length: u64,
    name: [32]u8,
}

var reserved_regions: [16]ReservedRegion = undefined
var reserved_count: u32 = 0

// ============================================================================
// INITIALIZATION
// ============================================================================

/// Initialize physical memory manager from Multiboot2 memory map
export fn init(mboot_info_addr: u32) {
    serial.write("[PMM] Initializing Physical Memory Manager...\n")

    // Mark all pages as used initially
    let i: u64 = 0
    loop {
        if i >= BITMAP_SIZE {
            break
        }
        bitmap[i] = 0xFF
        i = i + 1
    }

    total_pages = 0
    used_pages = 0
    free_pages = 0
    total_memory = 0
    usable_memory = 0
    region_count = 0
    reserved_count = 0

    // Parse Multiboot2 information
    serial.write("[PMM] Parsing Multiboot2 info at 0x")
    serial.write_hex(mboot_info_addr)
    serial.write("\n")

    if mboot_info_addr != 0 {
        parse_multiboot2(mboot_info_addr)
    } else {
        // Fallback: assume 128MB usable RAM starting at 2MB
        serial.write("[PMM] WARNING: No multiboot info, using fallback memory map\n")
        add_memory_region(0x200000, 128 * 1024 * 1024, MEMORY_AVAILABLE)
    }

    // Reserve kernel memory (first 2MB)
    reserve_region(0, 0x200000, "Kernel & Boot")

    // Apply reserved regions
    apply_reserved_regions()

    // Print memory summary
    print_memory_map()

    serial.write("[PMM] Initialization complete\n")
}

/// Parse Multiboot2 information structure
fn parse_multiboot2(addr: u32) {
    let info: *Multiboot2Info = @ptrFromInt(addr)
    let total_size = info.total_size

    serial.write("[PMM] Multiboot2 info size: ")
    serial.write_hex(total_size)
    serial.write(" bytes\n")

    // Start parsing tags (after the header)
    var tag_addr: u64 = addr + 8  // Skip header
    let end_addr: u64 = addr + total_size

    loop {
        if tag_addr >= end_addr {
            break
        }

        // Align to 8 bytes
        tag_addr = (tag_addr + 7) & ~@as(u64, 7)

        let tag: *Multiboot2Tag = @ptrFromInt(tag_addr)

        if tag.type == MULTIBOOT2_TAG_END {
            break
        }

        // Process tag based on type
        if tag.type == MULTIBOOT2_TAG_MMAP {
            parse_mmap_tag(tag_addr)
        } else if tag.type == MULTIBOOT2_TAG_BASIC_MEMINFO {
            parse_basic_meminfo_tag(tag_addr)
        } else if tag.type == MULTIBOOT2_TAG_MODULE {
            parse_module_tag(tag_addr)
        } else if tag.type == MULTIBOOT2_TAG_FRAMEBUFFER {
            parse_framebuffer_tag(tag_addr)
        }

        // Move to next tag (aligned to 8 bytes)
        tag_addr = tag_addr + tag.size
    }

    // Apply memory regions to bitmap
    apply_memory_regions()
}

/// Parse memory map tag
fn parse_mmap_tag(tag_addr: u64) {
    let mmap_tag: *Multiboot2MmapTag = @ptrFromInt(tag_addr)

    serial.write("[PMM] Memory map (entry_size=")
    serial.write_hex(mmap_tag.entry_size)
    serial.write(", version=")
    serial.write_hex(mmap_tag.entry_version)
    serial.write("):\n")

    let entries_start = tag_addr + 16  // After mmap tag header
    let entries_end = tag_addr + mmap_tag.size
    var entry_addr = entries_start

    loop {
        if entry_addr >= entries_end {
            break
        }

        let entry: *Multiboot2MmapEntry = @ptrFromInt(entry_addr)

        // Add to memory regions
        add_memory_region(entry.base_addr, entry.length, entry.type)

        // Track total memory
        total_memory = total_memory + entry.length

        // Print entry
        serial.write("  0x")
        serial.write_hex(entry.base_addr)
        serial.write(" - 0x")
        serial.write_hex(entry.base_addr + entry.length)
        serial.write(" (")
        serial.write_hex(entry.length / (1024 * 1024))
        serial.write(" MB) type=")
        print_memory_type(entry.type)
        serial.write("\n")

        entry_addr = entry_addr + mmap_tag.entry_size
    }
}

/// Parse basic memory info tag
fn parse_basic_meminfo_tag(tag_addr: u64) {
    let meminfo: *Multiboot2BasicMeminfo = @ptrFromInt(tag_addr)

    serial.write("[PMM] Basic memory info:\n")
    serial.write("  Lower memory: ")
    serial.write_hex(meminfo.mem_lower)
    serial.write(" KB\n")
    serial.write("  Upper memory: ")
    serial.write_hex(meminfo.mem_upper)
    serial.write(" KB (")
    serial.write_hex(meminfo.mem_upper / 1024)
    serial.write(" MB)\n")

    // If no memory map was provided, use basic meminfo as fallback
    if region_count == 0 {
        // Lower memory (below 1MB)
        add_memory_region(0, @as(u64, meminfo.mem_lower) * 1024, MEMORY_AVAILABLE)

        // Upper memory (above 1MB)
        let upper_base: u64 = 0x100000  // 1MB
        let upper_size: u64 = @as(u64, meminfo.mem_upper) * 1024
        add_memory_region(upper_base, upper_size, MEMORY_AVAILABLE)
    }
}

/// Parse module tag (to reserve module memory)
fn parse_module_tag(tag_addr: u64) {
    // Module tag: type, size, mod_start, mod_end, string...
    let mod_start: *u32 = @ptrFromInt(tag_addr + 8)
    let mod_end: *u32 = @ptrFromInt(tag_addr + 12)

    let start = @as(u64, mod_start.*)
    let end = @as(u64, mod_end.*)

    serial.write("[PMM] Module at 0x")
    serial.write_hex(start)
    serial.write(" - 0x")
    serial.write_hex(end)
    serial.write("\n")

    reserve_region(start, end - start, "Boot Module")
}

/// Parse framebuffer tag (to reserve framebuffer memory)
fn parse_framebuffer_tag(tag_addr: u64) {
    // Framebuffer tag: type, size, addr (8 bytes), pitch, width, height, bpp...
    let fb_addr: *u64 = @ptrFromInt(tag_addr + 8)
    let fb_pitch: *u32 = @ptrFromInt(tag_addr + 16)
    let fb_height: *u32 = @ptrFromInt(tag_addr + 24)

    let addr = fb_addr.*
    let pitch = fb_pitch.*
    let height = fb_height.*
    let size = @as(u64, pitch) * @as(u64, height)

    serial.write("[PMM] Framebuffer at 0x")
    serial.write_hex(addr)
    serial.write(" (")
    serial.write_hex(size / 1024)
    serial.write(" KB)\n")

    reserve_region(addr, size, "Framebuffer")
}

/// Add a memory region
fn add_memory_region(base: u64, length: u64, mem_type: u32) {
    if region_count >= MAX_MEMORY_REGIONS {
        serial.write("[PMM] WARNING: Too many memory regions\n")
        return
    }

    memory_regions[region_count].base = base
    memory_regions[region_count].length = length
    memory_regions[region_count].type = mem_type

    // Set name based on type
    set_region_name(region_count, mem_type)

    region_count = region_count + 1
}

/// Set region name based on type
fn set_region_name(idx: u32, mem_type: u32) {
    if mem_type == MEMORY_AVAILABLE {
        memory_regions[idx].name[0] = 'A'
        memory_regions[idx].name[1] = 'v'
        memory_regions[idx].name[2] = 'a'
        memory_regions[idx].name[3] = 'i'
        memory_regions[idx].name[4] = 'l'
        memory_regions[idx].name[5] = 0
    } else if mem_type == MEMORY_RESERVED {
        memory_regions[idx].name[0] = 'R'
        memory_regions[idx].name[1] = 'e'
        memory_regions[idx].name[2] = 's'
        memory_regions[idx].name[3] = 'e'
        memory_regions[idx].name[4] = 'r'
        memory_regions[idx].name[5] = 'v'
        memory_regions[idx].name[6] = 0
    } else if mem_type == MEMORY_ACPI_RECLAIMABLE {
        memory_regions[idx].name[0] = 'A'
        memory_regions[idx].name[1] = 'C'
        memory_regions[idx].name[2] = 'P'
        memory_regions[idx].name[3] = 'I'
        memory_regions[idx].name[4] = 0
    } else if mem_type == MEMORY_NVS {
        memory_regions[idx].name[0] = 'N'
        memory_regions[idx].name[1] = 'V'
        memory_regions[idx].name[2] = 'S'
        memory_regions[idx].name[3] = 0
    } else if mem_type == MEMORY_BADRAM {
        memory_regions[idx].name[0] = 'B'
        memory_regions[idx].name[1] = 'a'
        memory_regions[idx].name[2] = 'd'
        memory_regions[idx].name[3] = 0
    } else {
        memory_regions[idx].name[0] = '?'
        memory_regions[idx].name[1] = 0
    }
}

/// Reserve a memory region (kernel, modules, framebuffer, etc.)
fn reserve_region(base: u64, length: u64, name_ptr: *u8) {
    if reserved_count >= 16 {
        serial.write("[PMM] WARNING: Too many reserved regions\n")
        return
    }

    reserved_regions[reserved_count].base = base
    reserved_regions[reserved_count].length = length

    // Copy name
    let i: u32 = 0
    loop {
        if i >= 31 or name_ptr[i] == 0 {
            break
        }
        reserved_regions[reserved_count].name[i] = name_ptr[i]
        i = i + 1
    }
    reserved_regions[reserved_count].name[i] = 0

    reserved_count = reserved_count + 1

    serial.write("[PMM] Reserved: 0x")
    serial.write_hex(base)
    serial.write(" - 0x")
    serial.write_hex(base + length)
    serial.write(" (")
    serial.write_string(name_ptr)
    serial.write(")\n")
}

/// Apply memory regions to bitmap (mark available regions as free)
fn apply_memory_regions() {
    let i: u32 = 0
    loop {
        if i >= region_count {
            break
        }

        if memory_regions[i].type == MEMORY_AVAILABLE {
            mark_region_free(memory_regions[i].base, memory_regions[i].length)
            usable_memory = usable_memory + memory_regions[i].length
        }

        i = i + 1
    }
}

/// Apply reserved regions (mark as used)
fn apply_reserved_regions() {
    let i: u32 = 0
    loop {
        if i >= reserved_count {
            break
        }

        mark_region_used(reserved_regions[i].base, reserved_regions[i].length)

        i = i + 1
    }
}

/// Print memory type name
fn print_memory_type(mem_type: u32) {
    if mem_type == MEMORY_AVAILABLE {
        serial.write("Available")
    } else if mem_type == MEMORY_RESERVED {
        serial.write("Reserved")
    } else if mem_type == MEMORY_ACPI_RECLAIMABLE {
        serial.write("ACPI Reclaimable")
    } else if mem_type == MEMORY_NVS {
        serial.write("NVS")
    } else if mem_type == MEMORY_BADRAM {
        serial.write("Bad RAM")
    } else {
        serial.write("Unknown(")
        serial.write_hex(mem_type)
        serial.write(")")
    }
}

// ============================================================================
// BITMAP OPERATIONS
// ============================================================================

/// Mark a physical memory region as free
fn mark_region_free(base_addr: u64, length: u64) {
    // Align base up to page boundary
    let aligned_base = (base_addr + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1)
    // Align length down
    let aligned_length = length - (aligned_base - base_addr)

    if aligned_length <= 0 {
        return
    }

    let page_start = aligned_base >> PAGE_SHIFT
    let page_count = aligned_length >> PAGE_SHIFT

    let i: u64 = 0
    loop {
        if i >= page_count {
            break
        }

        let page = page_start + i
        if page < MAX_PAGES {
            clear_bit(page)
            free_pages = free_pages + 1
            total_pages = total_pages + 1
        }

        i = i + 1
    }
}

/// Mark a physical memory region as used
fn mark_region_used(base_addr: u64, length: u64) {
    // Align base down to page boundary
    let aligned_base = base_addr & ~(PAGE_SIZE - 1)
    // Align end up
    let end_addr = base_addr + length
    let aligned_end = (end_addr + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1)
    let aligned_length = aligned_end - aligned_base

    let page_start = aligned_base >> PAGE_SHIFT
    let page_count = aligned_length >> PAGE_SHIFT

    let i: u64 = 0
    loop {
        if i >= page_count {
            break
        }

        let page = page_start + i
        if page < MAX_PAGES {
            if !is_bit_set(page) {
                set_bit(page)
                if free_pages > 0 {
                    free_pages = free_pages - 1
                }
                used_pages = used_pages + 1
            }
        }

        i = i + 1
    }
}

/// Set a bit in the bitmap (mark page as used)
fn set_bit(page: u64) {
    if page >= MAX_PAGES {
        return
    }

    let byte_index = page / 8
    let bit_index = page % 8
    let mask: u8 = 1 << @truncate(bit_index)
    bitmap[byte_index] = bitmap[byte_index] | mask
}

/// Clear a bit in the bitmap (mark page as free)
fn clear_bit(page: u64) {
    if page >= MAX_PAGES {
        return
    }

    let byte_index = page / 8
    let bit_index = page % 8
    let mask: u8 = 1 << @truncate(bit_index)
    bitmap[byte_index] = bitmap[byte_index] & (~mask)
}

/// Check if a bit is set (page is used)
fn is_bit_set(page: u64): bool {
    if page >= MAX_PAGES {
        return true
    }

    let byte_index = page / 8
    let bit_index = page % 8
    let mask: u8 = 1 << @truncate(bit_index)
    return (bitmap[byte_index] & mask) != 0
}

// ============================================================================
// ALLOCATION
// ============================================================================

/// Allocate a single physical page frame
export fn alloc_page(): u64 {
    // Find first free page
    let byte_index: u64 = 0
    loop {
        if byte_index >= BITMAP_SIZE {
            break
        }

        if bitmap[byte_index] != 0xFF {
            // Found a byte with at least one free page
            let bit_index: u8 = 0
            loop {
                if bit_index >= 8 {
                    break
                }

                let mask: u8 = 1 << bit_index
                if (bitmap[byte_index] & mask) == 0 {
                    // Found free page
                    bitmap[byte_index] = bitmap[byte_index] | mask
                    let page = (byte_index * 8) + @as(u64, bit_index)
                    free_pages = free_pages - 1
                    used_pages = used_pages + 1
                    return page << PAGE_SHIFT
                }

                bit_index = bit_index + 1
            }
        }

        byte_index = byte_index + 1
    }

    // Out of memory
    serial.write("[PMM] ERROR: Out of physical memory!\n")
    return 0
}

/// Allocate contiguous physical pages
export fn alloc_pages(count: u64): u64 {
    if count == 0 {
        return 0
    }

    if count == 1 {
        return alloc_page()
    }

    // Find contiguous free pages
    let page: u64 = 0
    loop {
        if page + count >= MAX_PAGES {
            break
        }

        // Check if this range is free
        var all_free = true
        let i: u64 = 0
        loop {
            if i >= count {
                break
            }
            if is_bit_set(page + i) {
                all_free = false
                break
            }
            i = i + 1
        }

        if all_free {
            // Mark all pages as used
            let j: u64 = 0
            loop {
                if j >= count {
                    break
                }
                set_bit(page + j)
                j = j + 1
            }

            free_pages = free_pages - count
            used_pages = used_pages + count

            return page << PAGE_SHIFT
        }

        page = page + 1
    }

    serial.write("[PMM] ERROR: Cannot allocate ")
    serial.write_hex(count)
    serial.write(" contiguous pages!\n")
    return 0
}

/// Allocate pages aligned to a specific boundary (power of 2)
export fn alloc_pages_aligned(count: u64, alignment: u64): u64 {
    if count == 0 or alignment == 0 {
        return 0
    }

    // Alignment must be power of 2
    let align_pages = alignment / PAGE_SIZE
    if align_pages == 0 {
        return alloc_pages(count)
    }

    // Find aligned contiguous free pages
    let page: u64 = 0
    loop {
        if page + count >= MAX_PAGES {
            break
        }

        // Skip to next aligned page
        if (page % align_pages) != 0 {
            page = (page + align_pages) & ~(align_pages - 1)
            continue
        }

        // Check if this range is free
        var all_free = true
        let i: u64 = 0
        loop {
            if i >= count {
                break
            }
            if is_bit_set(page + i) {
                all_free = false
                break
            }
            i = i + 1
        }

        if all_free {
            // Mark all pages as used
            let j: u64 = 0
            loop {
                if j >= count {
                    break
                }
                set_bit(page + j)
                j = j + 1
            }

            free_pages = free_pages - count
            used_pages = used_pages + count

            return page << PAGE_SHIFT
        }

        page = page + align_pages
    }

    return 0
}

/// Free a physical page frame
export fn free_page(phys_addr: u64) {
    let page = phys_addr >> PAGE_SHIFT

    if page >= MAX_PAGES {
        serial.write("[PMM] ERROR: Attempt to free invalid page: 0x")
        serial.write_hex(phys_addr)
        serial.write("\n")
        return
    }

    if !is_bit_set(page) {
        serial.write("[PMM] WARNING: Double free of page: 0x")
        serial.write_hex(phys_addr)
        serial.write("\n")
        return
    }

    clear_bit(page)
    free_pages = free_pages + 1
    if used_pages > 0 {
        used_pages = used_pages - 1
    }
}

/// Free contiguous physical pages
export fn free_pages(phys_addr: u64, count: u64) {
    let page = phys_addr >> PAGE_SHIFT

    let i: u64 = 0
    loop {
        if i >= count {
            break
        }

        let p = page + i
        if p < MAX_PAGES and is_bit_set(p) {
            clear_bit(p)
            free_pages = free_pages + 1
            if used_pages > 0 {
                used_pages = used_pages - 1
            }
        }

        i = i + 1
    }
}

// ============================================================================
// QUERY FUNCTIONS
// ============================================================================

/// Check if a page is free
export fn is_page_free(phys_addr: u64): bool {
    let page = phys_addr >> PAGE_SHIFT
    if page >= MAX_PAGES {
        return false
    }
    return !is_bit_set(page)
}

/// Get free page count
export fn get_free_pages(): u64 {
    return free_pages
}

/// Get used page count
export fn get_used_pages(): u64 {
    return used_pages
}

/// Get total page count
export fn get_total_pages(): u64 {
    return total_pages
}

/// Get free memory in bytes
export fn get_free_memory(): u64 {
    return free_pages * PAGE_SIZE
}

/// Get used memory in bytes
export fn get_used_memory(): u64 {
    return used_pages * PAGE_SIZE
}

/// Get total memory in bytes
export fn get_total_memory(): u64 {
    return total_memory
}

/// Get usable memory in bytes
export fn get_usable_memory(): u64 {
    return usable_memory
}

// ============================================================================
// STATISTICS AND DEBUGGING
// ============================================================================

/// Print memory map
fn print_memory_map() {
    serial.write("\n=== Physical Memory Map ===\n")

    let i: u32 = 0
    loop {
        if i >= region_count {
            break
        }

        serial.write("  Region ")
        serial.write_hex(i)
        serial.write(": 0x")
        serial.write_hex(memory_regions[i].base)
        serial.write(" - 0x")
        serial.write_hex(memory_regions[i].base + memory_regions[i].length)
        serial.write(" (")
        serial.write_hex(memory_regions[i].length / (1024 * 1024))
        serial.write(" MB) ")
        print_memory_type(memory_regions[i].type)
        serial.write("\n")

        i = i + 1
    }

    serial.write("===========================\n\n")
}

/// Get memory statistics
export fn get_stats() {
    serial.write("\n=== Physical Memory Statistics ===\n")
    serial.write("Total memory:  ")
    serial.write_hex(total_memory / (1024 * 1024))
    serial.write(" MB\n")

    serial.write("Usable memory: ")
    serial.write_hex(usable_memory / (1024 * 1024))
    serial.write(" MB\n")

    serial.write("Total pages:   ")
    serial.write_hex(total_pages)
    serial.write(" (")
    serial.write_hex((total_pages * PAGE_SIZE) / (1024 * 1024))
    serial.write(" MB)\n")

    serial.write("Used pages:    ")
    serial.write_hex(used_pages)
    serial.write(" (")
    serial.write_hex((used_pages * PAGE_SIZE) / (1024 * 1024))
    serial.write(" MB)\n")

    serial.write("Free pages:    ")
    serial.write_hex(free_pages)
    serial.write(" (")
    serial.write_hex((free_pages * PAGE_SIZE) / (1024 * 1024))
    serial.write(" MB)\n")

    // Calculate percentage
    if total_pages > 0 {
        let used_pct = (used_pages * 100) / total_pages
        let free_pct = (free_pages * 100) / total_pages
        serial.write("Usage: ")
        serial.write_hex(used_pct)
        serial.write("% used, ")
        serial.write_hex(free_pct)
        serial.write("% free\n")
    }

    serial.write("==================================\n\n")
}

/// Dump bitmap (for debugging)
export fn dump_bitmap(start_page: u64, count: u64) {
    serial.write("[PMM] Bitmap dump (page ")
    serial.write_hex(start_page)
    serial.write(" - ")
    serial.write_hex(start_page + count)
    serial.write("):\n")

    let i: u64 = 0
    loop {
        if i >= count {
            break
        }

        if (i % 64) == 0 {
            serial.write("\n  0x")
            serial.write_hex((start_page + i) << PAGE_SHIFT)
            serial.write(": ")
        }

        let page = start_page + i
        if page < MAX_PAGES {
            if is_bit_set(page) {
                serial.write("X")
            } else {
                serial.write(".")
            }
        }

        i = i + 1
    }
    serial.write("\n")
}

/// Get region information
export fn get_region_count(): u32 {
    return region_count
}

export fn get_region(idx: u32, base: *u64, length: *u64, mem_type: *u32): bool {
    if idx >= region_count {
        return false
    }

    base.* = memory_regions[idx].base
    length.* = memory_regions[idx].length
    mem_type.* = memory_regions[idx].type

    return true
}

/// Self-test
export fn self_test(): bool {
    serial.write("[PMM] Running self-test...\n")

    // Allocate a page
    let page1 = alloc_page()
    if page1 == 0 {
        serial.write("[PMM] FAIL: Could not allocate page\n")
        return false
    }
    serial.write("[PMM] Allocated page at 0x")
    serial.write_hex(page1)
    serial.write("\n")

    // Allocate another page
    let page2 = alloc_page()
    if page2 == 0 {
        serial.write("[PMM] FAIL: Could not allocate second page\n")
        return false
    }

    // They should be different
    if page1 == page2 {
        serial.write("[PMM] FAIL: Got same page twice\n")
        return false
    }

    // Free first page
    free_page(page1)

    // Allocate again - might get same page back
    let page3 = alloc_page()
    if page3 == 0 {
        serial.write("[PMM] FAIL: Could not allocate after free\n")
        return false
    }

    // Allocate contiguous pages
    let pages = alloc_pages(4)
    if pages == 0 {
        serial.write("[PMM] FAIL: Could not allocate contiguous pages\n")
        return false
    }
    serial.write("[PMM] Allocated 4 contiguous pages at 0x")
    serial.write_hex(pages)
    serial.write("\n")

    // Free everything
    free_page(page2)
    free_page(page3)
    free_pages(pages, 4)

    serial.write("[PMM] Self-test PASSED\n")
    return true
}
