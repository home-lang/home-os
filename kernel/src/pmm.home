// Physical Memory Manager (PMM) for home-os
// Manages physical page frames using a bitmap allocator
// Written in Home language

import basics/os/serial
import basics/os/cpu

// Page size constants
const PAGE_SIZE = 4096
const PAGE_SHIFT = 12

// Memory bitmap (1 bit per page frame)
// For 4GB RAM: 4GB / 4KB = 1,048,576 pages = 131,072 bytes bitmap
const MAX_PAGES = 1048576
const BITMAP_SIZE = MAX_PAGES / 8

// Bitmap stored in .bss section (will be zero-initialized)
let bitmap: [BITMAP_SIZE]u8 = undefined
let total_pages: u64 = 0
let used_pages: u64 = 0
let free_pages: u64 = 0

// Multiboot2 memory map tag
struct MultibootMemoryMap {
  type: u32,
  size: u32,
  entry_size: u32,
  entry_version: u32
}

struct MultibootMemoryEntry {
  base_addr: u64,
  length: u64,
  type: u32,
  reserved: u32
}

// Memory region types
const MEMORY_AVAILABLE = 1
const MEMORY_RESERVED = 2
const MEMORY_ACPI_RECLAIMABLE = 3
const MEMORY_NVS = 4
const MEMORY_BADRAM = 5

/// Initialize physical memory manager from Multiboot2 memory map
export fn init(mboot_info_addr: u32) {
  serial.write("Initializing Physical Memory Manager...\n")

  // Mark all pages as used initially
  let i: u64 = 0
  loop {
    if i >= BITMAP_SIZE {
      break
    }
    bitmap[i] = 0xFF
    i = i + 1
  }

  // Parse Multiboot2 memory map
  // TODO: Implement once we have proper multiboot2 parsing
  serial.write("Parsing Multiboot2 memory map at 0x")
  serial.write_hex(mboot_info_addr)
  serial.write("\n")

  // For now, assume we have 128MB usable RAM starting at 2MB
  // (First 2MB reserved for kernel and boot structures)
  mark_region_free(0x200000, 128 * 1024 * 1024)

  serial.write("PMM initialized\n")
  serial.write("Total pages: ")
  serial.write_hex(total_pages)
  serial.write("\n")
  serial.write("Free pages: ")
  serial.write_hex(free_pages)
  serial.write("\n")
}

/// Mark a physical memory region as free
fn mark_region_free(base_addr: u64, length: u64) {
  let page_start = base_addr >> PAGE_SHIFT
  let page_count = length >> PAGE_SHIFT

  serial.write("Marking region free: 0x")
  serial.write_hex(base_addr)
  serial.write(" - 0x")
  serial.write_hex(base_addr + length)
  serial.write(" (")
  serial.write_hex(page_count)
  serial.write(" pages)\n")

  let i: u64 = 0
  loop {
    if i >= page_count {
      break
    }

    let page = page_start + i
    if page < MAX_PAGES {
      clear_bit(page)
      free_pages = free_pages + 1
      total_pages = total_pages + 1
    }

    i = i + 1
  }
}

/// Mark a physical memory region as used
fn mark_region_used(base_addr: u64, length: u64) {
  let page_start = base_addr >> PAGE_SHIFT
  let page_count = length >> PAGE_SHIFT

  let i: u64 = 0
  loop {
    if i >= page_count {
      break
    }

    let page = page_start + i
    if page < MAX_PAGES {
      set_bit(page)
      if free_pages > 0 {
        free_pages = free_pages - 1
      }
      used_pages = used_pages + 1
    }

    i = i + 1
  }
}

/// Allocate a physical page frame
export fn alloc_page() -> u64 {
  // Find first free page
  let byte_index: u64 = 0
  loop {
    if byte_index >= BITMAP_SIZE {
      break
    }

    if bitmap[byte_index] != 0xFF {
      // Found a byte with at least one free page
      let bit_index: u8 = 0
      loop {
        if bit_index >= 8 {
          break
        }

        let mask: u8 = 1 << bit_index
        if (bitmap[byte_index] & mask) == 0 {
          // Found free page
          bitmap[byte_index] = bitmap[byte_index] | mask
          let page = (byte_index * 8) + bit_index
          free_pages = free_pages - 1
          used_pages = used_pages + 1
          return page << PAGE_SHIFT
        }

        bit_index = bit_index + 1
      }
    }

    byte_index = byte_index + 1
  }

  // Out of memory
  serial.write("[PMM] ERROR: Out of physical memory!\n")
  return 0
}

/// Free a physical page frame
export fn free_page(phys_addr: u64) {
  let page = phys_addr >> PAGE_SHIFT

  if page >= MAX_PAGES {
    serial.write("[PMM] ERROR: Attempt to free invalid page: 0x")
    serial.write_hex(phys_addr)
    serial.write("\n")
    return
  }

  clear_bit(page)
  free_pages = free_pages + 1
  if used_pages > 0 {
    used_pages = used_pages - 1
  }
}

/// Set a bit in the bitmap (mark page as used)
fn set_bit(page: u64) {
  if page >= MAX_PAGES {
    return
  }

  let byte_index = page / 8
  let bit_index = page % 8
  let mask: u8 = 1 << bit_index
  bitmap[byte_index] = bitmap[byte_index] | mask
}

/// Clear a bit in the bitmap (mark page as free)
fn clear_bit(page: u64) {
  if page >= MAX_PAGES {
    return
  }

  let byte_index = page / 8
  let bit_index = page % 8
  let mask: u8 = 1 << bit_index
  bitmap[byte_index] = bitmap[byte_index] & (~mask)
}

/// Check if a bit is set (page is used)
fn is_bit_set(page: u64) -> bool {
  if page >= MAX_PAGES {
    return true
  }

  let byte_index = page / 8
  let bit_index = page % 8
  let mask: u8 = 1 << bit_index
  return (bitmap[byte_index] & mask) != 0
}

/// Get memory statistics
export fn get_stats() {
  serial.write("\n=== Physical Memory Statistics ===\n")
  serial.write("Total pages: ")
  serial.write_hex(total_pages)
  serial.write(" (")
  serial.write_hex((total_pages * PAGE_SIZE) / (1024 * 1024))
  serial.write(" MB)\n")

  serial.write("Used pages:  ")
  serial.write_hex(used_pages)
  serial.write(" (")
  serial.write_hex((used_pages * PAGE_SIZE) / (1024 * 1024))
  serial.write(" MB)\n")

  serial.write("Free pages:  ")
  serial.write_hex(free_pages)
  serial.write(" (")
  serial.write_hex((free_pages * PAGE_SIZE) / (1024 * 1024))
  serial.write(" MB)\n")
  serial.write("================================\n\n")
}
