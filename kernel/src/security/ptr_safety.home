// HomeOS Pointer Safety Module
// Provides bounds-checking wrappers and validation for raw pointer operations
// Part of the kernel security hardening effort

const serial = @import("../drivers/serial.home")

// ============================================================================
// Memory Region Validation
// ============================================================================

// Known valid memory regions
const KERNEL_START: u64 = 0xFFFFFFFF80000000  // Kernel virtual address start
const KERNEL_END: u64 = 0xFFFFFFFFFFFFFFFF    // Kernel virtual address end
const USER_START: u64 = 0x0000000000000000    // User space start
const USER_END: u64 = 0x00007FFFFFFFFFFF      // User space end (48-bit canonical)
const MMIO_START: u64 = 0xFE000000            // MMIO region start (Pi)
const MMIO_END: u64 = 0xFF000000              // MMIO region end

// Heap bounds (set during init)
var heap_start: u64 = 0
var heap_end: u64 = 0
var stack_start: u64 = 0
var stack_end: u64 = 0

// Safety statistics
var null_ptr_checks: u64 = 0
var bounds_checks: u64 = 0
var alignment_checks: u64 = 0
var violations_caught: u64 = 0

// ============================================================================
// Initialization
// ============================================================================

export fn ptr_safety_init(h_start: u64, h_end: u64, s_start: u64, s_end: u64) void {
    heap_start = h_start
    heap_end = h_end
    stack_start = s_start
    stack_end = s_end

    serial.write_string("[PTR_SAFETY] Initialized\n")
    serial.write_string("  Heap: 0x")
    serial.write_hex(@as(u32, @truncate(heap_start)))
    serial.write_string(" - 0x")
    serial.write_hex(@as(u32, @truncate(heap_end)))
    serial.write_string("\n")
}

// ============================================================================
// Null Pointer Checking
// ============================================================================

// Check if pointer is null
export fn ptr_is_null(ptr: u64) u32 {
    null_ptr_checks += 1
    if (ptr == 0) {
        return 1
    }
    return 0
}

// Safe dereference with null check - returns default on null
export fn ptr_safe_read_u8(ptr: u64, default: u8) u8 {
    if (ptr == 0) {
        violations_caught += 1
        return default
    }
    var p: *u8 = @ptrFromInt(ptr)
    return p.*
}

export fn ptr_safe_read_u32(ptr: u64, default: u32) u32 {
    if (ptr == 0) {
        violations_caught += 1
        return default
    }
    var p: *u32 = @ptrFromInt(ptr)
    return p.*
}

export fn ptr_safe_read_u64(ptr: u64, default: u64) u64 {
    if (ptr == 0) {
        violations_caught += 1
        return default
    }
    var p: *u64 = @ptrFromInt(ptr)
    return p.*
}

// Safe write with null check - returns 0 on success, 1 on null
export fn ptr_safe_write_u8(ptr: u64, value: u8) u32 {
    if (ptr == 0) {
        violations_caught += 1
        return 1
    }
    var p: *u8 = @ptrFromInt(ptr)
    p.* = value
    return 0
}

export fn ptr_safe_write_u32(ptr: u64, value: u32) u32 {
    if (ptr == 0) {
        violations_caught += 1
        return 1
    }
    var p: *u32 = @ptrFromInt(ptr)
    p.* = value
    return 0
}

export fn ptr_safe_write_u64(ptr: u64, value: u64) u32 {
    if (ptr == 0) {
        violations_caught += 1
        return 1
    }
    var p: *u64 = @ptrFromInt(ptr)
    p.* = value
    return 0
}

// ============================================================================
// Bounds Checking
// ============================================================================

// Check if pointer is within valid kernel range
export fn ptr_is_kernel(ptr: u64) u32 {
    bounds_checks += 1
    if (ptr >= KERNEL_START and ptr <= KERNEL_END) {
        return 1
    }
    return 0
}

// Check if pointer is within valid user space range
export fn ptr_is_user(ptr: u64) u32 {
    bounds_checks += 1
    if (ptr >= USER_START and ptr <= USER_END) {
        return 1
    }
    return 0
}

// Check if pointer is within heap bounds
export fn ptr_is_heap(ptr: u64) u32 {
    bounds_checks += 1
    if (heap_start != 0 and ptr >= heap_start and ptr < heap_end) {
        return 1
    }
    return 0
}

// Check if pointer is within stack bounds
export fn ptr_is_stack(ptr: u64) u32 {
    bounds_checks += 1
    if (stack_start != 0 and ptr >= stack_start and ptr < stack_end) {
        return 1
    }
    return 0
}

// Check if pointer is in MMIO region
export fn ptr_is_mmio(ptr: u64) u32 {
    bounds_checks += 1
    if (ptr >= MMIO_START and ptr < MMIO_END) {
        return 1
    }
    return 0
}

// Validate pointer range for buffer access
export fn ptr_check_range(ptr: u64, size: u64) u32 {
    bounds_checks += 1

    if (ptr == 0) {
        violations_caught += 1
        return 0
    }

    // Check for overflow
    if (ptr + size < ptr) {
        violations_caught += 1
        return 0
    }

    // Check if entirely within kernel space
    if (ptr >= KERNEL_START and (ptr + size) <= KERNEL_END) {
        return 1
    }

    // Check if entirely within user space
    if (ptr >= USER_START and (ptr + size) <= USER_END) {
        return 1
    }

    // Check if entirely within heap
    if (heap_start != 0 and ptr >= heap_start and (ptr + size) <= heap_end) {
        return 1
    }

    violations_caught += 1
    return 0
}

// ============================================================================
// Alignment Checking
// ============================================================================

// Check pointer alignment
export fn ptr_is_aligned(ptr: u64, alignment: u64) u32 {
    alignment_checks += 1
    if ((ptr & (alignment - 1)) == 0) {
        return 1
    }
    return 0
}

// Check if aligned for u16 access
export fn ptr_is_aligned_u16(ptr: u64) u32 {
    return ptr_is_aligned(ptr, 2)
}

// Check if aligned for u32 access
export fn ptr_is_aligned_u32(ptr: u64) u32 {
    return ptr_is_aligned(ptr, 4)
}

// Check if aligned for u64 access
export fn ptr_is_aligned_u64(ptr: u64) u32 {
    return ptr_is_aligned(ptr, 8)
}

// Check if page aligned
export fn ptr_is_page_aligned(ptr: u64) u32 {
    return ptr_is_aligned(ptr, 4096)
}

// ============================================================================
// Safe Memory Operations
// ============================================================================

// Safe memcpy with bounds checking
export fn ptr_safe_memcpy(dest: u64, src: u64, size: u64) u32 {
    // Validate both pointers and ranges
    if (ptr_check_range(dest, size) == 0) {
        serial.write_string("[PTR_SAFETY] memcpy: invalid dest range\n")
        return 1
    }

    if (ptr_check_range(src, size) == 0) {
        serial.write_string("[PTR_SAFETY] memcpy: invalid src range\n")
        return 1
    }

    // Check for overlap (if overlapping, use memmove semantics)
    var d: *u8 = @ptrFromInt(dest)
    var s: *u8 = @ptrFromInt(src)

    var i: u64 = 0
    while (i < size) {
        d[i] = s[i]
        i += 1
    }

    return 0
}

// Safe memset with bounds checking
export fn ptr_safe_memset(dest: u64, value: u8, size: u64) u32 {
    if (ptr_check_range(dest, size) == 0) {
        serial.write_string("[PTR_SAFETY] memset: invalid dest range\n")
        return 1
    }

    var d: *u8 = @ptrFromInt(dest)
    var i: u64 = 0
    while (i < size) {
        d[i] = value
        i += 1
    }

    return 0
}

// Safe string copy with length limit
export fn ptr_safe_strcpy(dest: u64, src: u64, max_len: u64) u32 {
    if (dest == 0 or src == 0) {
        violations_caught += 1
        return 1
    }

    var d: *u8 = @ptrFromInt(dest)
    var s: *u8 = @ptrFromInt(src)

    var i: u64 = 0
    while (i < max_len - 1) {
        if (s[i] == 0) {
            d[i] = 0
            return 0
        }
        d[i] = s[i]
        i += 1
    }

    // Ensure null termination
    d[max_len - 1] = 0
    return 0
}

// Safe string length with maximum
export fn ptr_safe_strlen(str: u64, max_len: u64) u64 {
    if (str == 0) {
        violations_caught += 1
        return 0
    }

    var s: *u8 = @ptrFromInt(str)
    var i: u64 = 0

    while (i < max_len) {
        if (s[i] == 0) {
            return i
        }
        i += 1
    }

    return max_len  // Hit limit without finding null
}

// ============================================================================
// User/Kernel Boundary Safety
// ============================================================================

// Copy from user space with validation
export fn ptr_copy_from_user(kernel_dest: u64, user_src: u64, size: u64) u32 {
    // Validate user pointer
    if (ptr_is_user(user_src) == 0) {
        serial.write_string("[PTR_SAFETY] copy_from_user: invalid user address\n")
        violations_caught += 1
        return 1
    }

    // Validate kernel pointer
    if (ptr_is_kernel(kernel_dest) == 0 and ptr_is_heap(kernel_dest) == 0) {
        serial.write_string("[PTR_SAFETY] copy_from_user: invalid kernel address\n")
        violations_caught += 1
        return 1
    }

    // Check range doesn't overflow
    if (user_src + size < user_src or user_src + size > USER_END) {
        serial.write_string("[PTR_SAFETY] copy_from_user: range overflow\n")
        violations_caught += 1
        return 1
    }

    return ptr_safe_memcpy(kernel_dest, user_src, size)
}

// Copy to user space with validation
export fn ptr_copy_to_user(user_dest: u64, kernel_src: u64, size: u64) u32 {
    // Validate user pointer
    if (ptr_is_user(user_dest) == 0) {
        serial.write_string("[PTR_SAFETY] copy_to_user: invalid user address\n")
        violations_caught += 1
        return 1
    }

    // Validate kernel pointer
    if (ptr_is_kernel(kernel_src) == 0 and ptr_is_heap(kernel_src) == 0) {
        serial.write_string("[PTR_SAFETY] copy_to_user: invalid kernel address\n")
        violations_caught += 1
        return 1
    }

    // Check range doesn't overflow
    if (user_dest + size < user_dest or user_dest + size > USER_END) {
        serial.write_string("[PTR_SAFETY] copy_to_user: range overflow\n")
        violations_caught += 1
        return 1
    }

    return ptr_safe_memcpy(user_dest, kernel_src, size)
}

// ============================================================================
// Array Access Safety
// ============================================================================

// Safe array access with bounds check
export fn ptr_array_get_u8(array: u64, index: u64, array_len: u64) u8 {
    if (array == 0 or index >= array_len) {
        violations_caught += 1
        return 0
    }

    var a: *u8 = @ptrFromInt(array)
    return a[index]
}

export fn ptr_array_get_u32(array: u64, index: u64, array_len: u64) u32 {
    if (array == 0 or index >= array_len) {
        violations_caught += 1
        return 0
    }

    var a: *u32 = @ptrFromInt(array)
    return a[index]
}

export fn ptr_array_set_u8(array: u64, index: u64, array_len: u64, value: u8) u32 {
    if (array == 0 or index >= array_len) {
        violations_caught += 1
        return 1
    }

    var a: *u8 = @ptrFromInt(array)
    a[index] = value
    return 0
}

export fn ptr_array_set_u32(array: u64, index: u64, array_len: u64, value: u32) u32 {
    if (array == 0 or index >= array_len) {
        violations_caught += 1
        return 1
    }

    var a: *u32 = @ptrFromInt(array)
    a[index] = value
    return 0
}

// ============================================================================
// Audit and Statistics
// ============================================================================

export fn ptr_safety_print_stats() void {
    serial.write_string("\n[PTR_SAFETY] Statistics:\n")

    serial.write_string("  Null pointer checks: ")
    serial.write_u64(null_ptr_checks)
    serial.write_string("\n")

    serial.write_string("  Bounds checks: ")
    serial.write_u64(bounds_checks)
    serial.write_string("\n")

    serial.write_string("  Alignment checks: ")
    serial.write_u64(alignment_checks)
    serial.write_string("\n")

    serial.write_string("  Violations caught: ")
    serial.write_u64(violations_caught)
    serial.write_string("\n")
}

export fn ptr_safety_get_violations() u64 {
    return violations_caught
}

export fn ptr_safety_reset_stats() void {
    null_ptr_checks = 0
    bounds_checks = 0
    alignment_checks = 0
    violations_caught = 0
}

// ============================================================================
// Debug Helpers
// ============================================================================

// Dump pointer info for debugging
export fn ptr_debug_info(ptr: u64) void {
    serial.write_string("[PTR_DEBUG] Address: 0x")
    serial.write_hex(@as(u32, @truncate(ptr >> 32)))
    serial.write_hex(@as(u32, @truncate(ptr)))
    serial.write_string("\n")

    serial.write_string("  Null: ")
    if (ptr_is_null(ptr) == 1) {
        serial.write_string("YES\n")
        return
    }
    serial.write_string("NO\n")

    serial.write_string("  Region: ")
    if (ptr_is_kernel(ptr) == 1) {
        serial.write_string("KERNEL\n")
    } else if (ptr_is_user(ptr) == 1) {
        serial.write_string("USER\n")
    } else if (ptr_is_mmio(ptr) == 1) {
        serial.write_string("MMIO\n")
    } else if (ptr_is_heap(ptr) == 1) {
        serial.write_string("HEAP\n")
    } else if (ptr_is_stack(ptr) == 1) {
        serial.write_string("STACK\n")
    } else {
        serial.write_string("UNKNOWN\n")
    }

    serial.write_string("  Aligned (8): ")
    if (ptr_is_aligned_u64(ptr) == 1) {
        serial.write_string("YES\n")
    } else {
        serial.write_string("NO\n")
    }
}

// ============================================================================
// Common Unsafe Pattern Detection
// ============================================================================

// Patterns to look for in code review:
// 1. @ptrFromInt(0) - null pointer dereference
// 2. @ptrFromInt(user_input) without validation
// 3. array[index] without bounds check
// 4. memcpy without size validation
// 5. buffer access beyond allocated size

// This function can be called to validate common patterns
export fn ptr_validate_access_pattern(ptr: u64, size: u64, is_write: u32) u32 {
    // Check null
    if (ptr == 0) {
        serial.write_string("[PTR_SAFETY] VIOLATION: null pointer access\n")
        violations_caught += 1
        return 0
    }

    // Check alignment for multi-byte access
    if (size >= 2 and ptr_is_aligned(ptr, 2) == 0) {
        serial.write_string("[PTR_SAFETY] WARNING: unaligned 2-byte access\n")
    }
    if (size >= 4 and ptr_is_aligned(ptr, 4) == 0) {
        serial.write_string("[PTR_SAFETY] WARNING: unaligned 4-byte access\n")
    }
    if (size >= 8 and ptr_is_aligned(ptr, 8) == 0) {
        serial.write_string("[PTR_SAFETY] WARNING: unaligned 8-byte access\n")
    }

    // Check range
    if (ptr_check_range(ptr, size) == 0) {
        serial.write_string("[PTR_SAFETY] VIOLATION: out-of-bounds access\n")
        return 0
    }

    return 1
}
