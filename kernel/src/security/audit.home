// home-os Kernel - Audit Logging
// Security event logging and monitoring

import "../core/foundation.home" as foundation
import "../core/filesystem.home" as filesystem

// Audit event types
const AUDIT_SYSCALL: u32 = 1
const AUDIT_FILE_ACCESS: u32 = 2
const AUDIT_NETWORK: u32 = 3
const AUDIT_PROCESS: u32 = 4
const AUDIT_AUTH: u32 = 5
const AUDIT_CAPABILITY: u32 = 6
const AUDIT_SECURITY: u32 = 7

// Audit log buffer
const MAX_AUDIT_ENTRIES: u32 = 10000
const AUDIT_LOG_PATH: u64 = @ptrFromInt("/var/log/audit.log")

struct AuditEntry {
  timestamp: u64,
  event_type: u32,
  pid: u32,
  uid: u32,
  syscall_nr: u32,
  result: i32,
  data: [u8; 256]
}

var audit_buffer: [AuditEntry; 10000]
var audit_head: u32 = 0
var audit_tail: u32 = 0
var audit_count: u32 = 0
var audit_enabled: u32 = 1
var audit_initialized: u32 = 0
var audit_dropped: u64 = 0

export fn audit_init() {
  if audit_initialized == 1 { return }
  
  audit_head = 0
  audit_tail = 0
  audit_count = 0
  audit_enabled = 1
  
  audit_initialized = 1
  foundation.serial_write_string("[Audit] Initialized\n")
}

export fn audit_log_syscall(pid: u32, uid: u32, syscall_nr: u32, result: i32) {
  if audit_enabled == 0 { return }
  
  var entry: AuditEntry
  entry.timestamp = foundation.timer_get_ticks()
  entry.event_type = AUDIT_SYSCALL
  entry.pid = pid
  entry.uid = uid
  entry.syscall_nr = syscall_nr
  entry.result = result
  
  audit_add_entry(entry)
}

export fn audit_log_file_access(pid: u32, uid: u32, path: u64, flags: u32, result: i32) {
  if audit_enabled == 0 { return }
  
  var entry: AuditEntry
  entry.timestamp = foundation.timer_get_ticks()
  entry.event_type = AUDIT_FILE_ACCESS
  entry.pid = pid
  entry.uid = uid
  entry.syscall_nr = flags
  entry.result = result
  
  // Copy path to data
  var i: u32 = 0
  while i < 255 {
    var ch: u8 = @intToPtr(path + i, u8)
    entry.data[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  entry.data[i] = 0
  
  audit_add_entry(entry)
}

export fn audit_log_network(pid: u32, uid: u32, addr: u64, port: u32, result: i32) {
  if audit_enabled == 0 { return }
  
  var entry: AuditEntry
  entry.timestamp = foundation.timer_get_ticks()
  entry.event_type = AUDIT_NETWORK
  entry.pid = pid
  entry.uid = uid
  entry.syscall_nr = port
  entry.result = result
  
  audit_add_entry(entry)
}

export fn audit_log_process(pid: u32, uid: u32, action: u32, target_pid: u32, result: i32) {
  if audit_enabled == 0 { return }
  
  var entry: AuditEntry
  entry.timestamp = foundation.timer_get_ticks()
  entry.event_type = AUDIT_PROCESS
  entry.pid = pid
  entry.uid = uid
  entry.syscall_nr = action
  entry.result = result
  
  audit_add_entry(entry)
}

export fn audit_log_auth(pid: u32, uid: u32, action: u32, result: i32) {
  if audit_enabled == 0 { return }
  
  var entry: AuditEntry
  entry.timestamp = foundation.timer_get_ticks()
  entry.event_type = AUDIT_AUTH
  entry.pid = pid
  entry.uid = uid
  entry.syscall_nr = action
  entry.result = result
  
  audit_add_entry(entry)
  
  // Always log auth events to serial
  foundation.serial_write_string("[Audit] AUTH: PID=")
  foundation.serial_write_hex(pid)
  foundation.serial_write_string(" UID=")
  foundation.serial_write_hex(uid)
  foundation.serial_write_string(" action=")
  foundation.serial_write_hex(action)
  foundation.serial_write_string(" result=")
  foundation.serial_write_hex(@bitCast(result, u32))
  foundation.serial_write_string("\n")
}

export fn audit_log_capability(pid: u32, uid: u32, cap: u64, result: i32) {
  if audit_enabled == 0 { return }
  
  var entry: AuditEntry
  entry.timestamp = foundation.timer_get_ticks()
  entry.event_type = AUDIT_CAPABILITY
  entry.pid = pid
  entry.uid = uid
  entry.syscall_nr = @truncate(cap, u32)
  entry.result = result
  
  audit_add_entry(entry)
}

export fn audit_log_security(pid: u32, uid: u32, event: u32, data: u64) {
  if audit_enabled == 0 { return }
  
  var entry: AuditEntry
  entry.timestamp = foundation.timer_get_ticks()
  entry.event_type = AUDIT_SECURITY
  entry.pid = pid
  entry.uid = uid
  entry.syscall_nr = event
  entry.result = 0
  
  // Copy data
  var i: u32 = 0
  while i < 255 {
    var ch: u8 = @intToPtr(data + i, u8)
    entry.data[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  entry.data[i] = 0
  
  audit_add_entry(entry)
  
  // Always log security events to serial
  foundation.serial_write_string("[Audit] SECURITY: PID=")
  foundation.serial_write_hex(pid)
  foundation.serial_write_string(" event=")
  foundation.serial_write_hex(event)
  foundation.serial_write_string(" data=")
  foundation.serial_write_string(data)
  foundation.serial_write_string("\n")
}

fn audit_add_entry(entry: AuditEntry) {
  if audit_count >= MAX_AUDIT_ENTRIES {
    // Buffer full, drop oldest entry
    audit_tail = (audit_tail + 1) % MAX_AUDIT_ENTRIES
    audit_dropped = audit_dropped + 1
  } else {
    audit_count = audit_count + 1
  }
  
  audit_buffer[audit_head] = entry
  audit_head = (audit_head + 1) % MAX_AUDIT_ENTRIES
}

export fn audit_flush_to_disk() -> u32 {
  if audit_count == 0 { return 0 }
  
  // Open audit log file
  var fd: u32 = filesystem.vfs_open(AUDIT_LOG_PATH, 0x0401, 0x1B6)  // O_WRONLY | O_APPEND | O_CREAT
  if fd == 0xFFFFFFFF {
    foundation.serial_write_string("[Audit] Failed to open log file\n")
    return 0
  }
  
  // Write entries
  var written: u32 = 0
  var idx: u32 = audit_tail
  
  while written < audit_count {
    var entry: AuditEntry = audit_buffer[idx]
    
    // Format entry as text
    var line: [u8; 512]
    audit_format_entry(entry, @ptrFromInt(line))
    
    // Write to file
    var line_len: u32 = 0
    while line[line_len] != 0 and line_len < 512 {
      line_len = line_len + 1
    }
    
    filesystem.vfs_write(fd, @ptrFromInt(line), line_len)
    
    idx = (idx + 1) % MAX_AUDIT_ENTRIES
    written = written + 1
  }
  
  filesystem.vfs_close(fd)
  
  // Clear buffer
  audit_count = 0
  audit_head = 0
  audit_tail = 0
  
  foundation.serial_write_string("[Audit] Flushed ")
  foundation.serial_write_hex(written)
  foundation.serial_write_string(" entries to disk\n")
  
  return written
}

fn audit_format_entry(entry: AuditEntry, buffer: u64) {
  // Format: timestamp type pid uid syscall result data\n
  var offset: u32 = 0
  
  // Timestamp
  audit_append_hex(buffer, offset, entry.timestamp)
  offset = offset + 16
  @intToPtr(buffer + offset, u8) = ' '
  offset = offset + 1
  
  // Type
  audit_append_hex(buffer, offset, entry.event_type)
  offset = offset + 8
  @intToPtr(buffer + offset, u8) = ' '
  offset = offset + 1
  
  // PID
  audit_append_hex(buffer, offset, entry.pid)
  offset = offset + 8
  @intToPtr(buffer + offset, u8) = ' '
  offset = offset + 1
  
  // UID
  audit_append_hex(buffer, offset, entry.uid)
  offset = offset + 8
  @intToPtr(buffer + offset, u8) = ' '
  offset = offset + 1
  
  // Syscall
  audit_append_hex(buffer, offset, entry.syscall_nr)
  offset = offset + 8
  @intToPtr(buffer + offset, u8) = ' '
  offset = offset + 1
  
  // Result
  audit_append_hex(buffer, offset, @bitCast(entry.result, u32))
  offset = offset + 8
  @intToPtr(buffer + offset, u8) = ' '
  offset = offset + 1
  
  // Data
  var i: u32 = 0
  while i < 255 and entry.data[i] != 0 {
    @intToPtr(buffer + offset, u8) = entry.data[i]
    offset = offset + 1
    i = i + 1
  }
  
  @intToPtr(buffer + offset, u8) = '\n'
  offset = offset + 1
  @intToPtr(buffer + offset, u8) = 0
}

fn audit_append_hex(buffer: u64, offset: u32, value: u64) {
  var i: u32 = 0
  while i < 16 {
    var nibble: u8 = @truncate((value >> ((15 - i) * 4)) & 0xF, u8)
    if nibble < 10 {
      @intToPtr(buffer + offset + i, u8) = '0' + nibble
    } else {
      @intToPtr(buffer + offset + i, u8) = 'a' + (nibble - 10)
    }
    i = i + 1
  }
}

export fn audit_enable() {
  audit_enabled = 1
  foundation.serial_write_string("[Audit] Enabled\n")
}

export fn audit_disable() {
  audit_enabled = 0
  foundation.serial_write_string("[Audit] Disabled\n")
}

export fn audit_is_enabled() -> u32 {
  return audit_enabled
}

export fn audit_get_count() -> u32 {
  return audit_count
}

export fn audit_get_dropped() -> u64 {
  return audit_dropped
}

export fn audit_clear() {
  audit_count = 0
  audit_head = 0
  audit_tail = 0
  foundation.serial_write_string("[Audit] Buffer cleared\n")
}
