// home-os Kernel - Stack Protection
// Stack canaries and overflow detection to prevent buffer overflow attacks

import "../core/foundation.home" as foundation
import "random.home" as random

const STACK_CANARY_ENABLED: u32 = 1
const STACK_GUARD_PAGE_ENABLED: u32 = 1

// Stack canary value (randomized at boot)
var stack_canary: u64 = 0
var stack_protection_initialized: u32 = 0

// Statistics
var canary_violations: u64 = 0
var stack_overflows: u64 = 0

export fn stack_protection_init() {
  if stack_protection_initialized == 1 { return }
  
  // Initialize random number generator
  random.random_init()
  
  // Generate random stack canary
  stack_canary = random.random_get_u64()
  
  // Ensure canary is not zero or all 0xFF
  if stack_canary == 0 or stack_canary == 0xFFFFFFFFFFFFFFFF {
    stack_canary = 0xDEADBEEFCAFEBABE
  }
  
  stack_protection_initialized = 1
  
  foundation.serial_write_string("[StackProtection] Initialized with canary: 0x")
  foundation.serial_write_hex(@truncate(stack_canary, u32))
  foundation.serial_write_string("\n")
}

export fn stack_protection_get_canary(): u64 {
  if stack_protection_initialized == 0 {
    stack_protection_init()
  }
  return stack_canary
}

export fn stack_protection_check_canary(canary_value: u64): u32 {
  if canary_value != stack_canary {
    canary_violations = canary_violations + 1
    
    foundation.serial_write_string("[StackProtection] CANARY VIOLATION DETECTED!\n")
    foundation.serial_write_string("  Expected: 0x")
    foundation.serial_write_hex(@truncate(stack_canary, u32))
    foundation.serial_write_string("\n  Got: 0x")
    foundation.serial_write_hex(@truncate(canary_value, u32))
    foundation.serial_write_string("\n")
    
    // Trigger kernel panic
    foundation.panic("Stack canary violation - buffer overflow detected!")
    
    return 0  // Failed
  }
  
  return 1  // Success
}

// Place canary on stack (called by compiler-generated code)
export fn stack_protection_place_canary(stack_ptr: u64) {
  @intToPtr(stack_ptr, u64) = stack_canary
}

// Verify canary on stack (called before function return)
export fn stack_protection_verify_canary(stack_ptr: u64) {
  var canary_value: u64 = @intToPtr(stack_ptr, u64)
  stack_protection_check_canary(canary_value)
}

// Stack guard pages
export fn stack_protection_setup_guard_page(stack_base: u64, stack_size: u64): u32 {
  if STACK_GUARD_PAGE_ENABLED == 0 { return 1 }
  
  // Place a guard page at the bottom of the stack
  var guard_page: u64 = stack_base - 4096
  
  // Mark page as non-accessible (will cause page fault on overflow)
  // TODO: Call memory management to mark page as PROT_NONE
  
  foundation.serial_write_string("[StackProtection] Guard page at: 0x")
  foundation.serial_write_hex(@truncate(guard_page, u32))
  foundation.serial_write_string("\n")
  
  return 1
}

// Handle stack overflow (called by page fault handler)
export fn stack_protection_handle_overflow(fault_addr: u64) {
  stack_overflows = stack_overflows + 1
  
  foundation.serial_write_string("[StackProtection] STACK OVERFLOW DETECTED!\n")
  foundation.serial_write_string("  Fault address: 0x")
  foundation.serial_write_hex(@truncate(fault_addr, u32))
  foundation.serial_write_string("\n")
  
  // Trigger kernel panic
  foundation.panic("Stack overflow detected!")
}

// Shadow stack support (for return address protection)
const SHADOW_STACK_SIZE: u32 = 4096
var shadow_stack: [u64; 512]  // 4096 bytes / 8 bytes per entry
var shadow_stack_ptr: u32 = 0

export fn stack_protection_shadow_push(return_addr: u64) {
  if shadow_stack_ptr >= 512 {
    foundation.panic("Shadow stack overflow!")
  }
  
  shadow_stack[shadow_stack_ptr] = return_addr
  shadow_stack_ptr = shadow_stack_ptr + 1
}

export fn stack_protection_shadow_pop(): u64 {
  if shadow_stack_ptr == 0 {
    foundation.panic("Shadow stack underflow!")
  }
  
  shadow_stack_ptr = shadow_stack_ptr - 1
  return shadow_stack[shadow_stack_ptr]
}

export fn stack_protection_shadow_verify(return_addr: u64): u32 {
  if shadow_stack_ptr == 0 {
    foundation.serial_write_string("[StackProtection] Shadow stack underflow!\n")
    return 0
  }
  
  var expected: u64 = shadow_stack[shadow_stack_ptr - 1]
  
  if expected != return_addr {
    foundation.serial_write_string("[StackProtection] RETURN ADDRESS MISMATCH!\n")
    foundation.serial_write_string("  Expected: 0x")
    foundation.serial_write_hex(@truncate(expected, u32))
    foundation.serial_write_string("\n  Got: 0x")
    foundation.serial_write_hex(@truncate(return_addr, u32))
    foundation.serial_write_string("\n")
    
    foundation.panic("Return address corruption detected!")
    return 0
  }
  
  return 1
}

// Stack bounds checking
export fn stack_protection_check_bounds(stack_ptr: u64, stack_base: u64, stack_size: u64): u32 {
  var stack_top: u64 = stack_base
  var stack_bottom: u64 = stack_base - stack_size
  
  if stack_ptr < stack_bottom or stack_ptr > stack_top {
    foundation.serial_write_string("[StackProtection] Stack pointer out of bounds!\n")
    foundation.serial_write_string("  Stack ptr: 0x")
    foundation.serial_write_hex(@truncate(stack_ptr, u32))
    foundation.serial_write_string("\n  Stack base: 0x")
    foundation.serial_write_hex(@truncate(stack_base, u32))
    foundation.serial_write_string("\n  Stack size: 0x")
    foundation.serial_write_hex(@truncate(stack_size, u32))
    foundation.serial_write_string("\n")
    
    return 0  // Out of bounds
  }
  
  return 1  // Within bounds
}

// Statistics
export fn stack_protection_get_canary_violations(): u64 {
  return canary_violations
}

export fn stack_protection_get_stack_overflows(): u64 {
  return stack_overflows
}

export fn stack_protection_is_enabled(): u32 {
  return STACK_CANARY_ENABLED
}

export fn stack_protection_is_guard_page_enabled(): u32 {
  return STACK_GUARD_PAGE_ENABLED
}

// Per-thread canary support
const MAX_THREADS: u32 = 256
var thread_canaries: [u64; 256]

export fn stack_protection_set_thread_canary(thread_id: u32, canary: u64) {
  if thread_id >= MAX_THREADS { return }
  thread_canaries[thread_id] = canary
}

export fn stack_protection_get_thread_canary(thread_id: u32): u64 {
  if thread_id >= MAX_THREADS { return stack_canary }
  
  var canary: u64 = thread_canaries[thread_id]
  if canary == 0 {
    // Generate new canary for this thread
    canary = random.random_get_u64()
    thread_canaries[thread_id] = canary
  }
  
  return canary
}

// Stack smashing detection
export fn stack_protection_detect_smashing(stack_base: u64, stack_size: u64): u32 {
  // Check for common stack smashing patterns
  var stack_bottom: u64 = stack_base - stack_size
  
  // Check for repeated patterns (common in buffer overflows)
  var i: u32 = 0
  var pattern: u64 = @intToPtr(stack_bottom, u64)
  var smashing_detected: u32 = 0
  
  while i < 16 {
    var value: u64 = @intToPtr(stack_bottom + (i * 8), u64)
    if value == pattern and pattern != 0 {
      smashing_detected = smashing_detected + 1
    }
    i = i + 1
  }
  
  if smashing_detected > 8 {
    foundation.serial_write_string("[StackProtection] Stack smashing pattern detected!\n")
    return 1  // Smashing detected
  }
  
  return 0  // No smashing
}
