// home-os Kernel - Capability-Based Security
// Fine-grained permissions system with audit integration

const serial = @import("../drivers/serial.home")
const audit = @import("audit.home")

// Capability bits
const CAP_CHOWN: u64 = 1 << 0
const CAP_DAC_OVERRIDE: u64 = 1 << 1
const CAP_DAC_READ_SEARCH: u64 = 1 << 2
const CAP_FOWNER: u64 = 1 << 3
const CAP_FSETID: u64 = 1 << 4
const CAP_KILL: u64 = 1 << 5
const CAP_SETGID: u64 = 1 << 6
const CAP_SETUID: u64 = 1 << 7
const CAP_SETPCAP: u64 = 1 << 8
const CAP_LINUX_IMMUTABLE: u64 = 1 << 9
const CAP_NET_BIND_SERVICE: u64 = 1 << 10
const CAP_NET_BROADCAST: u64 = 1 << 11
const CAP_NET_ADMIN: u64 = 1 << 12
const CAP_NET_RAW: u64 = 1 << 13
const CAP_IPC_LOCK: u64 = 1 << 14
const CAP_IPC_OWNER: u64 = 1 << 15
const CAP_SYS_MODULE: u64 = 1 << 16
const CAP_SYS_RAWIO: u64 = 1 << 17
const CAP_SYS_CHROOT: u64 = 1 << 18
const CAP_SYS_PTRACE: u64 = 1 << 19
const CAP_SYS_PACCT: u64 = 1 << 20
const CAP_SYS_ADMIN: u64 = 1 << 21
const CAP_SYS_BOOT: u64 = 1 << 22
const CAP_SYS_NICE: u64 = 1 << 23
const CAP_SYS_RESOURCE: u64 = 1 << 24
const CAP_SYS_TIME: u64 = 1 << 25
const CAP_SYS_TTY_CONFIG: u64 = 1 << 26
const CAP_MKNOD: u64 = 1 << 27
const CAP_LEASE: u64 = 1 << 28
const CAP_AUDIT_WRITE: u64 = 1 << 29
const CAP_AUDIT_CONTROL: u64 = 1 << 30
const CAP_SETFCAP: u64 = 1 << 31
const CAP_MAC_OVERRIDE: u64 = 1 << 32
const CAP_MAC_ADMIN: u64 = 1 << 33
const CAP_SYSLOG: u64 = 1 << 34
const CAP_WAKE_ALARM: u64 = 1 << 35
const CAP_BLOCK_SUSPEND: u64 = 1 << 36
const CAP_AUDIT_READ: u64 = 1 << 37

// All capabilities
const CAP_ALL: u64 = 0xFFFFFFFFFFFFFFFF

// Capability sets per process
const MAX_PROCESSES: u32 = 256

struct CapabilitySet {
  effective: u64,
  permitted: u64,
  inheritable: u64,
  bounding: u64,
  ambient: u64
}

var process_capabilities: [CapabilitySet; 256]
var capabilities_initialized: u32 = 0

export fn capabilities_init() {
  if capabilities_initialized == 1 { return }
  
  // Initialize all processes with no capabilities
  var i: u32 = 0
  while i < MAX_PROCESSES {
    process_capabilities[i].effective = 0
    process_capabilities[i].permitted = 0
    process_capabilities[i].inheritable = 0
    process_capabilities[i].bounding = CAP_ALL
    process_capabilities[i].ambient = 0
    i = i + 1
  }
  
  // Process 0 (init) gets all capabilities
  process_capabilities[0].effective = CAP_ALL
  process_capabilities[0].permitted = CAP_ALL
  process_capabilities[0].inheritable = CAP_ALL
  
  capabilities_initialized = 1
  foundation.serial_write_string("[Capabilities] Initialized\n")
}

// Audit control: which events to log
var audit_cap_checks: u32 = 1       // Log capability check failures
var audit_cap_changes: u32 = 1      // Log capability modifications
var audit_cap_grants: u32 = 0       // Log successful capability grants (verbose)

// Statistics
var cap_check_count: u64 = 0
var cap_denial_count: u64 = 0

export fn cap_has_capability(pid: u32, cap: u64): u32 {
    if (pid >= MAX_PROCESSES) return 0

    cap_check_count += 1

    if ((process_capabilities[pid].effective & cap) != 0) {
        return 1
    }
    return 0
}

export fn cap_check_capability(pid: u32, cap: u64) u32 {
    if (cap_has_capability(pid, cap) == 0) {
        cap_denial_count += 1

        // Log to serial
        serial.write_string("[CAPS] Permission denied: PID=")
        serial.write_u32(pid)
        serial.write_string(" cap=0x")
        serial.write_hex(@as(u32, @truncate(cap)))
        serial.write_string("\n")

        // Log to audit system
        if (audit_cap_checks == 1) {
            audit.audit_log_capability(pid, get_uid_for_pid(pid), cap, -1)
        }

        return 0
    }

    // Optionally log successful checks (verbose mode)
    if (audit_cap_grants == 1) {
        audit.audit_log_capability(pid, get_uid_for_pid(pid), cap, 0)
    }

    return 1
}

// Get UID for a process (would integrate with process module)
fn get_uid_for_pid(pid: u32) u32 {
    // Placeholder: would look up from process table
    // For now, return 0 for PID 0-1, and pid for others
    if (pid <= 1) return 0
    return pid
}

export fn cap_add_capability(pid: u32, cap: u64) u32 {
    if (pid >= MAX_PROCESSES) return 0

    // Can only add if in permitted set
    if ((process_capabilities[pid].permitted & cap) == 0) {
        // Log failed attempt
        if (audit_cap_changes == 1) {
            audit.audit_log_capability(pid, get_uid_for_pid(pid), cap, -1)
        }
        return 0
    }

    process_capabilities[pid].effective = process_capabilities[pid].effective | cap

    // Log capability grant
    if (audit_cap_changes == 1) {
        audit.audit_log_capability(pid, get_uid_for_pid(pid), cap, 1)
    }

    return 1
}

export fn cap_remove_capability(pid: u32, cap: u64) u32 {
    if (pid >= MAX_PROCESSES) return 0

    process_capabilities[pid].effective = process_capabilities[pid].effective & ~cap

    // Log capability removal
    if (audit_cap_changes == 1) {
        audit.audit_log_capability(pid, get_uid_for_pid(pid), cap, 2)  // 2 = removed
    }

    return 1
}

export fn cap_set_permitted(pid: u32, caps: u64) u32 {
    if (pid >= MAX_PROCESSES) return 0

    var old_caps: u64 = process_capabilities[pid].permitted

    // Can only set capabilities within bounding set
    var new_caps: u64 = caps & process_capabilities[pid].bounding

    process_capabilities[pid].permitted = new_caps

    // Log significant changes
    if (audit_cap_changes == 1 and old_caps != new_caps) {
        audit.audit_log_capability(pid, get_uid_for_pid(pid), new_caps, 3)  // 3 = permitted changed
    }

    return 1
}

export fn cap_set_inheritable(pid: u32, caps: u64) u32 {
    if (pid >= MAX_PROCESSES) return 0

    var old_caps: u64 = process_capabilities[pid].inheritable
    process_capabilities[pid].inheritable = caps

    // Log changes
    if (audit_cap_changes == 1 and old_caps != caps) {
        audit.audit_log_capability(pid, get_uid_for_pid(pid), caps, 4)  // 4 = inheritable changed
    }

    return 1
}

export fn cap_set_bounding(pid: u32, caps: u64) u32 {
    if (pid >= MAX_PROCESSES) return 0

    var old_bounding: u64 = process_capabilities[pid].bounding

    // Bounding set can only be reduced
    process_capabilities[pid].bounding = process_capabilities[pid].bounding & caps

    // Log bounding set reduction
    if (audit_cap_changes == 1 and old_bounding != process_capabilities[pid].bounding) {
        audit.audit_log_capability(pid, get_uid_for_pid(pid), process_capabilities[pid].bounding, 5)  // 5 = bounding changed
    }

    return 1
}

export fn cap_set_ambient(pid: u32, caps: u64) u32 {
    if (pid >= MAX_PROCESSES) return 0

    // Ambient must be subset of permitted and inheritable
    var new_ambient: u64 = caps & process_capabilities[pid].permitted
    new_ambient = new_ambient & process_capabilities[pid].inheritable

    var old_ambient: u64 = process_capabilities[pid].ambient
    process_capabilities[pid].ambient = new_ambient

    // Log changes
    if (audit_cap_changes == 1 and old_ambient != new_ambient) {
        audit.audit_log_capability(pid, get_uid_for_pid(pid), new_ambient, 6)  // 6 = ambient changed
    }

    return 1
}

export fn cap_get_effective(pid: u32): u64 {
  if pid >= MAX_PROCESSES { return 0 }
  return process_capabilities[pid].effective
}

export fn cap_get_permitted(pid: u32): u64 {
  if pid >= MAX_PROCESSES { return 0 }
  return process_capabilities[pid].permitted
}

export fn cap_get_inheritable(pid: u32): u64 {
  if pid >= MAX_PROCESSES { return 0 }
  return process_capabilities[pid].inheritable
}

export fn cap_fork(parent_pid: u32, child_pid: u32): u32 {
  if parent_pid >= MAX_PROCESSES or child_pid >= MAX_PROCESSES { return 0 }
  
  // Child inherits parent's capabilities
  process_capabilities[child_pid].effective = process_capabilities[parent_pid].effective
  process_capabilities[child_pid].permitted = process_capabilities[parent_pid].permitted
  process_capabilities[child_pid].inheritable = process_capabilities[parent_pid].inheritable
  process_capabilities[child_pid].bounding = process_capabilities[parent_pid].bounding
  process_capabilities[child_pid].ambient = process_capabilities[parent_pid].ambient
  
  return 1
}

export fn cap_exec(pid: u32): u32 {
  if pid >= MAX_PROCESSES { return 0 }
  
  // On exec, effective = permitted & inheritable | ambient
  var new_effective: u64 = process_capabilities[pid].permitted & process_capabilities[pid].inheritable
  new_effective = new_effective | process_capabilities[pid].ambient
  
  process_capabilities[pid].effective = new_effective
  
  return 1
}

export fn cap_drop_all(pid: u32) u32 {
    if (pid >= MAX_PROCESSES) return 0

    var old_effective: u64 = process_capabilities[pid].effective

    process_capabilities[pid].effective = 0
    process_capabilities[pid].permitted = 0
    process_capabilities[pid].inheritable = 0
    process_capabilities[pid].ambient = 0

    // Log capability drop (significant security event)
    if (audit_cap_changes == 1 and old_effective != 0) {
        audit.audit_log_capability(pid, get_uid_for_pid(pid), 0, 7)  // 7 = all dropped
    }

    return 1
}

export fn cap_is_privileged(pid: u32) u32 {
    if (pid >= MAX_PROCESSES) return 0

    // Process is privileged if it has any capabilities
    if (process_capabilities[pid].effective != 0) {
        return 1
    }
    return 0
}

export fn cap_print_capabilities(pid: u32) void {
    if (pid >= MAX_PROCESSES) return

    serial.write_string("[CAPS] PID ")
    serial.write_u32(pid)
    serial.write_string(":\n")
    serial.write_string("  Effective: 0x")
    serial.write_hex(@as(u32, @truncate(process_capabilities[pid].effective)))
    serial.write_string("\n  Permitted: 0x")
    serial.write_hex(@as(u32, @truncate(process_capabilities[pid].permitted)))
    serial.write_string("\n  Inheritable: 0x")
    serial.write_hex(@as(u32, @truncate(process_capabilities[pid].inheritable)))
    serial.write_string("\n  Bounding: 0x")
    serial.write_hex(@as(u32, @truncate(process_capabilities[pid].bounding)))
    serial.write_string("\n  Ambient: 0x")
    serial.write_hex(@as(u32, @truncate(process_capabilities[pid].ambient)))
    serial.write_string("\n")
}

// ============================================================================
// Audit Control Functions
// ============================================================================

export fn cap_set_audit_checks(enabled: u32) void {
    audit_cap_checks = enabled
}

export fn cap_set_audit_changes(enabled: u32) void {
    audit_cap_changes = enabled
}

export fn cap_set_audit_grants(enabled: u32) void {
    audit_cap_grants = enabled
}

// ============================================================================
// Statistics Functions
// ============================================================================

export fn cap_get_check_count() u64 {
    return cap_check_count
}

export fn cap_get_denial_count() u64 {
    return cap_denial_count
}

export fn cap_print_stats() void {
    serial.write_string("\n[CAPS] Statistics:\n")
    serial.write_string("  Total checks: ")
    serial.write_u64(cap_check_count)
    serial.write_string("\n")
    serial.write_string("  Denials: ")
    serial.write_u64(cap_denial_count)
    serial.write_string("\n")
    serial.write_string("  Denial rate: ")
    if (cap_check_count > 0) {
        var rate: u64 = (cap_denial_count * 100) / cap_check_count
        serial.write_u64(rate)
        serial.write_string("%")
    } else {
        serial.write_string("N/A")
    }
    serial.write_string("\n")
    serial.write_string("  Audit checks: ")
    serial.write_string(if (audit_cap_checks == 1) "ON" else "OFF")
    serial.write_string("\n")
    serial.write_string("  Audit changes: ")
    serial.write_string(if (audit_cap_changes == 1) "ON" else "OFF")
    serial.write_string("\n")
    serial.write_string("  Audit grants: ")
    serial.write_string(if (audit_cap_grants == 1) "ON" else "OFF")
    serial.write_string("\n")
}
