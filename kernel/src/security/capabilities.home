// home-os Kernel - Capability-Based Security
// Fine-grained permissions system

import "../core/foundation.home" as foundation

// Capability bits
const CAP_CHOWN: u64 = 1 << 0
const CAP_DAC_OVERRIDE: u64 = 1 << 1
const CAP_DAC_READ_SEARCH: u64 = 1 << 2
const CAP_FOWNER: u64 = 1 << 3
const CAP_FSETID: u64 = 1 << 4
const CAP_KILL: u64 = 1 << 5
const CAP_SETGID: u64 = 1 << 6
const CAP_SETUID: u64 = 1 << 7
const CAP_SETPCAP: u64 = 1 << 8
const CAP_LINUX_IMMUTABLE: u64 = 1 << 9
const CAP_NET_BIND_SERVICE: u64 = 1 << 10
const CAP_NET_BROADCAST: u64 = 1 << 11
const CAP_NET_ADMIN: u64 = 1 << 12
const CAP_NET_RAW: u64 = 1 << 13
const CAP_IPC_LOCK: u64 = 1 << 14
const CAP_IPC_OWNER: u64 = 1 << 15
const CAP_SYS_MODULE: u64 = 1 << 16
const CAP_SYS_RAWIO: u64 = 1 << 17
const CAP_SYS_CHROOT: u64 = 1 << 18
const CAP_SYS_PTRACE: u64 = 1 << 19
const CAP_SYS_PACCT: u64 = 1 << 20
const CAP_SYS_ADMIN: u64 = 1 << 21
const CAP_SYS_BOOT: u64 = 1 << 22
const CAP_SYS_NICE: u64 = 1 << 23
const CAP_SYS_RESOURCE: u64 = 1 << 24
const CAP_SYS_TIME: u64 = 1 << 25
const CAP_SYS_TTY_CONFIG: u64 = 1 << 26
const CAP_MKNOD: u64 = 1 << 27
const CAP_LEASE: u64 = 1 << 28
const CAP_AUDIT_WRITE: u64 = 1 << 29
const CAP_AUDIT_CONTROL: u64 = 1 << 30
const CAP_SETFCAP: u64 = 1 << 31
const CAP_MAC_OVERRIDE: u64 = 1 << 32
const CAP_MAC_ADMIN: u64 = 1 << 33
const CAP_SYSLOG: u64 = 1 << 34
const CAP_WAKE_ALARM: u64 = 1 << 35
const CAP_BLOCK_SUSPEND: u64 = 1 << 36
const CAP_AUDIT_READ: u64 = 1 << 37

// All capabilities
const CAP_ALL: u64 = 0xFFFFFFFFFFFFFFFF

// Capability sets per process
const MAX_PROCESSES: u32 = 256

struct CapabilitySet {
  effective: u64,
  permitted: u64,
  inheritable: u64,
  bounding: u64,
  ambient: u64
}

var process_capabilities: [CapabilitySet; 256]
var capabilities_initialized: u32 = 0

export fn capabilities_init() {
  if capabilities_initialized == 1 { return }
  
  // Initialize all processes with no capabilities
  var i: u32 = 0
  while i < MAX_PROCESSES {
    process_capabilities[i].effective = 0
    process_capabilities[i].permitted = 0
    process_capabilities[i].inheritable = 0
    process_capabilities[i].bounding = CAP_ALL
    process_capabilities[i].ambient = 0
    i = i + 1
  }
  
  // Process 0 (init) gets all capabilities
  process_capabilities[0].effective = CAP_ALL
  process_capabilities[0].permitted = CAP_ALL
  process_capabilities[0].inheritable = CAP_ALL
  
  capabilities_initialized = 1
  foundation.serial_write_string("[Capabilities] Initialized\n")
}

export fn cap_has_capability(pid: u32, cap: u64): u32 {
  if pid >= MAX_PROCESSES { return 0 }
  
  if (process_capabilities[pid].effective & cap) != 0 {
    return 1
  }
  return 0
}

export fn cap_check_capability(pid: u32, cap: u64): u32 {
  if cap_has_capability(pid, cap) == 0 {
    foundation.serial_write_string("[Capabilities] Permission denied for PID ")
    foundation.serial_write_hex(pid)
    foundation.serial_write_string(" capability 0x")
    foundation.serial_write_hex(@truncate(cap, u32))
    foundation.serial_write_string("\n")
    return 0
  }
  return 1
}

export fn cap_add_capability(pid: u32, cap: u64): u32 {
  if pid >= MAX_PROCESSES { return 0 }
  
  // Can only add if in permitted set
  if (process_capabilities[pid].permitted & cap) == 0 {
    return 0
  }
  
  process_capabilities[pid].effective = process_capabilities[pid].effective | cap
  return 1
}

export fn cap_remove_capability(pid: u32, cap: u64): u32 {
  if pid >= MAX_PROCESSES { return 0 }
  
  process_capabilities[pid].effective = process_capabilities[pid].effective & ~cap
  return 1
}

export fn cap_set_permitted(pid: u32, caps: u64): u32 {
  if pid >= MAX_PROCESSES { return 0 }
  
  // Can only set capabilities within bounding set
  caps = caps & process_capabilities[pid].bounding
  
  process_capabilities[pid].permitted = caps
  return 1
}

export fn cap_set_inheritable(pid: u32, caps: u64): u32 {
  if pid >= MAX_PROCESSES { return 0 }
  
  process_capabilities[pid].inheritable = caps
  return 1
}

export fn cap_set_bounding(pid: u32, caps: u64): u32 {
  if pid >= MAX_PROCESSES { return 0 }
  
  // Bounding set can only be reduced
  process_capabilities[pid].bounding = process_capabilities[pid].bounding & caps
  return 1
}

export fn cap_set_ambient(pid: u32, caps: u64): u32 {
  if pid >= MAX_PROCESSES { return 0 }
  
  // Ambient must be subset of permitted and inheritable
  caps = caps & process_capabilities[pid].permitted
  caps = caps & process_capabilities[pid].inheritable
  
  process_capabilities[pid].ambient = caps
  return 1
}

export fn cap_get_effective(pid: u32): u64 {
  if pid >= MAX_PROCESSES { return 0 }
  return process_capabilities[pid].effective
}

export fn cap_get_permitted(pid: u32): u64 {
  if pid >= MAX_PROCESSES { return 0 }
  return process_capabilities[pid].permitted
}

export fn cap_get_inheritable(pid: u32): u64 {
  if pid >= MAX_PROCESSES { return 0 }
  return process_capabilities[pid].inheritable
}

export fn cap_fork(parent_pid: u32, child_pid: u32): u32 {
  if parent_pid >= MAX_PROCESSES or child_pid >= MAX_PROCESSES { return 0 }
  
  // Child inherits parent's capabilities
  process_capabilities[child_pid].effective = process_capabilities[parent_pid].effective
  process_capabilities[child_pid].permitted = process_capabilities[parent_pid].permitted
  process_capabilities[child_pid].inheritable = process_capabilities[parent_pid].inheritable
  process_capabilities[child_pid].bounding = process_capabilities[parent_pid].bounding
  process_capabilities[child_pid].ambient = process_capabilities[parent_pid].ambient
  
  return 1
}

export fn cap_exec(pid: u32): u32 {
  if pid >= MAX_PROCESSES { return 0 }
  
  // On exec, effective = permitted & inheritable | ambient
  var new_effective: u64 = process_capabilities[pid].permitted & process_capabilities[pid].inheritable
  new_effective = new_effective | process_capabilities[pid].ambient
  
  process_capabilities[pid].effective = new_effective
  
  return 1
}

export fn cap_drop_all(pid: u32): u32 {
  if pid >= MAX_PROCESSES { return 0 }
  
  process_capabilities[pid].effective = 0
  process_capabilities[pid].permitted = 0
  process_capabilities[pid].inheritable = 0
  process_capabilities[pid].ambient = 0
  
  return 1
}

export fn cap_is_privileged(pid: u32): u32 {
  if pid >= MAX_PROCESSES { return 0 }
  
  // Process is privileged if it has any capabilities
  if process_capabilities[pid].effective != 0 {
    return 1
  }
  return 0
}

export fn cap_print_capabilities(pid: u32) {
  if pid >= MAX_PROCESSES { return }
  
  foundation.serial_write_string("[Capabilities] PID ")
  foundation.serial_write_hex(pid)
  foundation.serial_write_string(":\n")
  foundation.serial_write_string("  Effective: 0x")
  foundation.serial_write_hex(@truncate(process_capabilities[pid].effective, u32))
  foundation.serial_write_string("\n  Permitted: 0x")
  foundation.serial_write_hex(@truncate(process_capabilities[pid].permitted, u32))
  foundation.serial_write_string("\n  Inheritable: 0x")
  foundation.serial_write_hex(@truncate(process_capabilities[pid].inheritable, u32))
  foundation.serial_write_string("\n  Bounding: 0x")
  foundation.serial_write_hex(@truncate(process_capabilities[pid].bounding, u32))
  foundation.serial_write_string("\n  Ambient: 0x")
  foundation.serial_write_hex(@truncate(process_capabilities[pid].ambient, u32))
  foundation.serial_write_string("\n")
}
