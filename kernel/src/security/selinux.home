// home-os SELinux-style Security
// Mandatory Access Control with Type Enforcement

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

// SELinux modes
const SELINUX_DISABLED: u32 = 0
const SELINUX_PERMISSIVE: u32 = 1
const SELINUX_ENFORCING: u32 = 2

// Security classes (object types)
const SECCLASS_FILE: u32 = 1
const SECCLASS_DIR: u32 = 2
const SECCLASS_SOCKET: u32 = 3
const SECCLASS_PROCESS: u32 = 4
const SECCLASS_SYSTEM: u32 = 5
const SECCLASS_CAPABILITY: u32 = 6
const SECCLASS_NODE: u32 = 7
const SECCLASS_NETIF: u32 = 8
const SECCLASS_MSGQ: u32 = 9
const SECCLASS_SEM: u32 = 10
const SECCLASS_SHM: u32 = 11
const SECCLASS_BLK_FILE: u32 = 12
const SECCLASS_CHR_FILE: u32 = 13
const SECCLASS_LNK_FILE: u32 = 14
const SECCLASS_FIFO_FILE: u32 = 15
const SECCLASS_SOCK_FILE: u32 = 16
const SECCLASS_FD: u32 = 17
const SECCLASS_TCP_SOCKET: u32 = 18
const SECCLASS_UDP_SOCKET: u32 = 19
const SECCLASS_RAWIP_SOCKET: u32 = 20

// File permissions (bit flags)
const FILE_PERM_READ: u32 = 0x00000001
const FILE_PERM_WRITE: u32 = 0x00000002
const FILE_PERM_EXECUTE: u32 = 0x00000004
const FILE_PERM_APPEND: u32 = 0x00000008
const FILE_PERM_CREATE: u32 = 0x00000010
const FILE_PERM_UNLINK: u32 = 0x00000020
const FILE_PERM_RENAME: u32 = 0x00000040
const FILE_PERM_SETATTR: u32 = 0x00000080
const FILE_PERM_GETATTR: u32 = 0x00000100
const FILE_PERM_LOCK: u32 = 0x00000200
const FILE_PERM_IOCTL: u32 = 0x00000400
const FILE_PERM_RELABELFROM: u32 = 0x00000800
const FILE_PERM_RELABELTO: u32 = 0x00001000
const FILE_PERM_ENTRYPOINT: u32 = 0x00002000
const FILE_PERM_EXECMOD: u32 = 0x00004000

// Process permissions
const PROC_PERM_FORK: u32 = 0x00000001
const PROC_PERM_TRANSITION: u32 = 0x00000002
const PROC_PERM_SIGCHLD: u32 = 0x00000004
const PROC_PERM_SIGKILL: u32 = 0x00000008
const PROC_PERM_SIGSTOP: u32 = 0x00000010
const PROC_PERM_SIGNAL: u32 = 0x00000020
const PROC_PERM_PTRACE: u32 = 0x00000040
const PROC_PERM_GETSCHED: u32 = 0x00000080
const PROC_PERM_SETSCHED: u32 = 0x00000100
const PROC_PERM_GETSESSION: u32 = 0x00000200
const PROC_PERM_GETPGID: u32 = 0x00000400
const PROC_PERM_SETPGID: u32 = 0x00000800
const PROC_PERM_GETCAP: u32 = 0x00001000
const PROC_PERM_SETCAP: u32 = 0x00002000
const PROC_PERM_SHARE: u32 = 0x00004000
const PROC_PERM_GETATTR: u32 = 0x00008000
const PROC_PERM_SETEXEC: u32 = 0x00010000
const PROC_PERM_SETFSCREATE: u32 = 0x00020000
const PROC_PERM_SETCURRENT: u32 = 0x00040000
const PROC_PERM_EXECMEM: u32 = 0x00080000
const PROC_PERM_DYNTRANSITION: u32 = 0x00100000
const PROC_PERM_SETKEYCREATE: u32 = 0x00200000
const PROC_PERM_SETSOCKCREATE: u32 = 0x00400000

// Socket permissions
const SOCK_PERM_CREATE: u32 = 0x00000001
const SOCK_PERM_CONNECT: u32 = 0x00000002
const SOCK_PERM_LISTEN: u32 = 0x00000004
const SOCK_PERM_ACCEPT: u32 = 0x00000008
const SOCK_PERM_SEND: u32 = 0x00000010
const SOCK_PERM_RECV: u32 = 0x00000020
const SOCK_PERM_BIND: u32 = 0x00000040
const SOCK_PERM_SHUTDOWN: u32 = 0x00000080
const SOCK_PERM_GETATTR: u32 = 0x00000100
const SOCK_PERM_SETATTR: u32 = 0x00000200
const SOCK_PERM_NAME_BIND: u32 = 0x00000400
const SOCK_PERM_NAME_CONNECT: u32 = 0x00000800

// Maximum sizes
const MAX_CONTEXT_LEN: u32 = 256
const MAX_TYPE_LEN: u32 = 64
const MAX_TYPES: u32 = 256
const MAX_RULES: u32 = 1024
const MAX_TRANSITIONS: u32 = 256
const MAX_BOOLEANS: u32 = 64

// Security context (SELinux label)
struct SecurityContext {
    user: [MAX_TYPE_LEN]u8,      // e.g., "system_u"
    role: [MAX_TYPE_LEN]u8,      // e.g., "system_r"
    type_: [MAX_TYPE_LEN]u8,     // e.g., "kernel_t"
    level: [MAX_TYPE_LEN]u8,     // MLS level, e.g., "s0"
    valid: u32
}

// Security Identifier (cached context)
struct SID {
    sid: u32,
    context: SecurityContext,
    refcount: u32
}

// Access Vector Cache entry
struct AvcEntry {
    ssid: u32,                   // Source SID
    tsid: u32,                   // Target SID
    tclass: u32,                 // Target class
    allowed: u32,                // Allowed permissions
    denied: u32,                 // Denied permissions (audit)
    auditallow: u32,             // Audit on allow
    auditdeny: u32,              // Audit on deny
    hits: u64,
    last_access: u64
}

// Type enforcement rule
struct TERule {
    source_type: [MAX_TYPE_LEN]u8,
    target_type: [MAX_TYPE_LEN]u8,
    tclass: u32,
    allowed: u32,
    valid: u32
}

// Type transition rule
struct TypeTransition {
    source_type: [MAX_TYPE_LEN]u8,
    target_type: [MAX_TYPE_LEN]u8,
    tclass: u32,
    new_type: [MAX_TYPE_LEN]u8,
    valid: u32
}

// Policy boolean
struct PolicyBoolean {
    name: [MAX_TYPE_LEN]u8,
    value: u32,
    pending: u32
}

// SELinux state
struct SELinuxState {
    mode: u32,                   // Disabled/Permissive/Enforcing
    initialized: u32,
    policy_loaded: u32,

    // SID table
    sids: [256]SID,
    next_sid: u32,

    // AVC cache
    avc: [512]AvcEntry,
    avc_hits: u64,
    avc_misses: u64,

    // Policy rules
    rules: [MAX_RULES]TERule,
    rule_count: u32,

    // Transitions
    transitions: [MAX_TRANSITIONS]TypeTransition,
    transition_count: u32,

    // Booleans
    booleans: [MAX_BOOLEANS]PolicyBoolean,
    boolean_count: u32,

    // Statistics
    denials: u64,
    grants: u64,

    // Initial SIDs
    kernel_sid: u32,
    init_sid: u32,
    unlabeled_sid: u32,
    file_sid: u32,
    security_sid: u32
}

// Global state
var selinux_state: SELinuxState = undefined

// String comparison
fn str_equals(a: [*]u8, b: [*]u8): u32 {
    var i: u32 = 0
    while i < MAX_TYPE_LEN {
        if a[i] != b[i] {
            return 0
        }
        if a[i] == 0 {
            return 1
        }
        i = i + 1
    }
    return 1
}

// Copy string
fn str_copy(dst: [*]u8, src: [*]u8) {
    var i: u32 = 0
    while i < MAX_TYPE_LEN - 1 {
        dst[i] = src[i]
        if src[i] == 0 {
            break
        }
        i = i + 1
    }
    dst[i] = 0
}

// Hash for AVC lookup
fn avc_hash(ssid: u32, tsid: u32, tclass: u32): u32 {
    return (ssid ^ tsid ^ tclass) % 512
}

// Allocate a new SID
fn alloc_sid(ctx: *SecurityContext): u32 {
    if selinux_state.next_sid >= 256 {
        return 0
    }

    var sid: u32 = selinux_state.next_sid
    selinux_state.next_sid = selinux_state.next_sid + 1

    selinux_state.sids[sid].sid = sid
    selinux_state.sids[sid].context = @ptrDeref(ctx)
    selinux_state.sids[sid].refcount = 1

    return sid
}

// Look up SID by context
fn context_to_sid(ctx: *SecurityContext): u32 {
    var i: u32 = 1
    while i < selinux_state.next_sid {
        var s: *SID = &selinux_state.sids[i]
        if str_equals(&s.context.user[0], &ctx.user[0]) != 0 and
           str_equals(&s.context.role[0], &ctx.role[0]) != 0 and
           str_equals(&s.context.type_[0], &ctx.type_[0]) != 0 {
            s.refcount = s.refcount + 1
            return i
        }
        i = i + 1
    }

    // Create new SID
    return alloc_sid(ctx)
}

// Look up context by SID
fn sid_to_context(sid: u32, ctx: *SecurityContext): u32 {
    if sid == 0 or sid >= selinux_state.next_sid {
        return 1
    }

    @ptrDeref(ctx) = selinux_state.sids[sid].context
    return 0
}

// Check AVC cache
fn avc_lookup(ssid: u32, tsid: u32, tclass: u32, perms: *u32): u32 {
    var hash: u32 = avc_hash(ssid, tsid, tclass)

    var entry: *AvcEntry = &selinux_state.avc[hash]
    if entry.ssid == ssid and entry.tsid == tsid and entry.tclass == tclass {
        selinux_state.avc_hits = selinux_state.avc_hits + 1
        entry.hits = entry.hits + 1
        entry.last_access = foundation.get_ticks()
        @ptrDeref(perms) = entry.allowed
        return 0
    }

    selinux_state.avc_misses = selinux_state.avc_misses + 1
    return 1
}

// Insert into AVC
fn avc_insert(ssid: u32, tsid: u32, tclass: u32, allowed: u32, denied: u32) {
    var hash: u32 = avc_hash(ssid, tsid, tclass)

    var entry: *AvcEntry = &selinux_state.avc[hash]
    entry.ssid = ssid
    entry.tsid = tsid
    entry.tclass = tclass
    entry.allowed = allowed
    entry.denied = denied
    entry.auditallow = 0
    entry.auditdeny = denied
    entry.hits = 0
    entry.last_access = foundation.get_ticks()
}

// Find matching rule
fn find_rule(source_type: [*]u8, target_type: [*]u8, tclass: u32): u32 {
    var i: u32 = 0
    while i < selinux_state.rule_count {
        var rule: *TERule = &selinux_state.rules[i]
        if rule.valid != 0 and rule.tclass == tclass {
            if str_equals(&rule.source_type[0], source_type) != 0 and
               str_equals(&rule.target_type[0], target_type) != 0 {
                return rule.allowed
            }
        }
        i = i + 1
    }
    return 0
}

// Compute access decision
fn compute_av(ssid: u32, tsid: u32, tclass: u32): u32 {
    if ssid >= selinux_state.next_sid or tsid >= selinux_state.next_sid {
        return 0
    }

    var scontext: *SecurityContext = &selinux_state.sids[ssid].context
    var tcontext: *SecurityContext = &selinux_state.sids[tsid].context

    // Look up in policy rules
    var allowed: u32 = find_rule(&scontext.type_[0], &tcontext.type_[0], tclass)

    return allowed
}

// Check access (main entry point)
export fn selinux_check_access(ssid: u32, tsid: u32, tclass: u32, requested: u32): u32 {
    if selinux_state.mode == SELINUX_DISABLED {
        return 0  // Allow all
    }

    // Check AVC cache
    var allowed: u32 = 0
    if avc_lookup(ssid, tsid, tclass, &allowed) == 0 {
        // Cache hit
        if (requested & allowed) == requested {
            selinux_state.grants = selinux_state.grants + 1
            return 0
        }
    } else {
        // Cache miss - compute decision
        allowed = compute_av(ssid, tsid, tclass)
        var denied: u32 = requested & ~allowed
        avc_insert(ssid, tsid, tclass, allowed, denied)
    }

    // Check if all requested permissions are allowed
    if (requested & allowed) == requested {
        selinux_state.grants = selinux_state.grants + 1
        return 0
    }

    // Denied
    selinux_state.denials = selinux_state.denials + 1

    // Log denial
    foundation.serial_write_string("[SELinux] avc: denied { ")
    // Would log permission names
    foundation.serial_write_string("} for ssid=")
    foundation.serial_write_dec(ssid)
    foundation.serial_write_string(" tsid=")
    foundation.serial_write_dec(tsid)
    foundation.serial_write_string(" tclass=")
    foundation.serial_write_dec(tclass)
    foundation.serial_write_string("\n")

    if selinux_state.mode == SELINUX_PERMISSIVE {
        return 0  // Log but don't deny
    }

    return 1  // Deny in enforcing mode
}

// Check file access
export fn selinux_file_permission(task_sid: u32, file_sid: u32, requested: u32): u32 {
    return selinux_check_access(task_sid, file_sid, SECCLASS_FILE, requested)
}

// Check socket access
export fn selinux_socket_permission(task_sid: u32, sock_sid: u32, requested: u32): u32 {
    return selinux_check_access(task_sid, sock_sid, SECCLASS_SOCKET, requested)
}

// Check process access
export fn selinux_process_permission(task_sid: u32, target_sid: u32, requested: u32): u32 {
    return selinux_check_access(task_sid, target_sid, SECCLASS_PROCESS, requested)
}

// Create new file SID
export fn selinux_create_file_sid(task_sid: u32, parent_sid: u32): u32 {
    // Check for type transition
    var scontext: *SecurityContext = &selinux_state.sids[task_sid].context
    var pcontext: *SecurityContext = &selinux_state.sids[parent_sid].context

    var i: u32 = 0
    while i < selinux_state.transition_count {
        var trans: *TypeTransition = &selinux_state.transitions[i]
        if trans.valid != 0 and trans.tclass == SECCLASS_FILE {
            if str_equals(&trans.source_type[0], &scontext.type_[0]) != 0 and
               str_equals(&trans.target_type[0], &pcontext.type_[0]) != 0 {
                // Apply transition
                var new_ctx: SecurityContext = undefined
                str_copy(&new_ctx.user[0], &scontext.user[0])
                str_copy(&new_ctx.role[0], "object_r")
                str_copy(&new_ctx.type_[0], &trans.new_type[0])
                str_copy(&new_ctx.level[0], &scontext.level[0])
                new_ctx.valid = 1
                return context_to_sid(&new_ctx)
            }
        }
        i = i + 1
    }

    // Default: inherit from parent
    return parent_sid
}

// Execute transition
export fn selinux_compute_exec_sid(task_sid: u32, file_sid: u32): u32 {
    var scontext: *SecurityContext = &selinux_state.sids[task_sid].context
    var fcontext: *SecurityContext = &selinux_state.sids[file_sid].context

    var i: u32 = 0
    while i < selinux_state.transition_count {
        var trans: *TypeTransition = &selinux_state.transitions[i]
        if trans.valid != 0 and trans.tclass == SECCLASS_PROCESS {
            if str_equals(&trans.source_type[0], &scontext.type_[0]) != 0 and
               str_equals(&trans.target_type[0], &fcontext.type_[0]) != 0 {
                var new_ctx: SecurityContext = undefined
                str_copy(&new_ctx.user[0], &scontext.user[0])
                str_copy(&new_ctx.role[0], &scontext.role[0])
                str_copy(&new_ctx.type_[0], &trans.new_type[0])
                str_copy(&new_ctx.level[0], &scontext.level[0])
                new_ctx.valid = 1
                return context_to_sid(&new_ctx)
            }
        }
        i = i + 1
    }

    // No transition, stay in current domain
    return task_sid
}

// Add policy rule
export fn selinux_add_rule(source: [*]u8, target: [*]u8, tclass: u32, allowed: u32): u32 {
    if selinux_state.rule_count >= MAX_RULES {
        return 1
    }

    var rule: *TERule = &selinux_state.rules[selinux_state.rule_count]
    str_copy(&rule.source_type[0], source)
    str_copy(&rule.target_type[0], target)
    rule.tclass = tclass
    rule.allowed = allowed
    rule.valid = 1

    selinux_state.rule_count = selinux_state.rule_count + 1
    return 0
}

// Add type transition
export fn selinux_add_transition(source: [*]u8, target: [*]u8, tclass: u32, new_type: [*]u8): u32 {
    if selinux_state.transition_count >= MAX_TRANSITIONS {
        return 1
    }

    var trans: *TypeTransition = &selinux_state.transitions[selinux_state.transition_count]
    str_copy(&trans.source_type[0], source)
    str_copy(&trans.target_type[0], target)
    trans.tclass = tclass
    str_copy(&trans.new_type[0], new_type)
    trans.valid = 1

    selinux_state.transition_count = selinux_state.transition_count + 1
    return 0
}

// Set/get boolean
export fn selinux_set_boolean(name: [*]u8, value: u32): u32 {
    var i: u32 = 0
    while i < selinux_state.boolean_count {
        if str_equals(&selinux_state.booleans[i].name[0], name) != 0 {
            selinux_state.booleans[i].pending = value
            return 0
        }
        i = i + 1
    }
    return 1
}

export fn selinux_get_boolean(name: [*]u8): u32 {
    var i: u32 = 0
    while i < selinux_state.boolean_count {
        if str_equals(&selinux_state.booleans[i].name[0], name) != 0 {
            return selinux_state.booleans[i].value
        }
        i = i + 1
    }
    return 0
}

// Commit pending booleans
export fn selinux_commit_booleans() {
    var i: u32 = 0
    while i < selinux_state.boolean_count {
        selinux_state.booleans[i].value = selinux_state.booleans[i].pending
        i = i + 1
    }

    // Invalidate AVC
    selinux_avc_reset()
}

// Reset AVC
export fn selinux_avc_reset() {
    var i: u32 = 0
    while i < 512 {
        selinux_state.avc[i].ssid = 0
        selinux_state.avc[i].tsid = 0
        selinux_state.avc[i].tclass = 0
        i = i + 1
    }
}

// Set mode
export fn selinux_set_mode(mode: u32) {
    if mode > SELINUX_ENFORCING {
        return
    }

    var old_mode: u32 = selinux_state.mode
    selinux_state.mode = mode

    var mode_str: [*]u8 = "disabled"
    if mode == SELINUX_PERMISSIVE {
        mode_str = "permissive"
    } else if mode == SELINUX_ENFORCING {
        mode_str = "enforcing"
    }

    foundation.serial_write_string("[SELinux] Mode changed to ")
    foundation.serial_write_string(mode_str)
    foundation.serial_write_string("\n")
}

// Get mode
export fn selinux_get_mode(): u32 {
    return selinux_state.mode
}

// Create initial SIDs
fn create_initial_sids() {
    // Kernel SID
    var kernel_ctx: SecurityContext = undefined
    str_copy(&kernel_ctx.user[0], "system_u")
    str_copy(&kernel_ctx.role[0], "system_r")
    str_copy(&kernel_ctx.type_[0], "kernel_t")
    str_copy(&kernel_ctx.level[0], "s0")
    kernel_ctx.valid = 1
    selinux_state.kernel_sid = alloc_sid(&kernel_ctx)

    // Init SID
    var init_ctx: SecurityContext = undefined
    str_copy(&init_ctx.user[0], "system_u")
    str_copy(&init_ctx.role[0], "system_r")
    str_copy(&init_ctx.type_[0], "init_t")
    str_copy(&init_ctx.level[0], "s0")
    init_ctx.valid = 1
    selinux_state.init_sid = alloc_sid(&init_ctx)

    // Unlabeled SID
    var unlabeled_ctx: SecurityContext = undefined
    str_copy(&unlabeled_ctx.user[0], "system_u")
    str_copy(&unlabeled_ctx.role[0], "object_r")
    str_copy(&unlabeled_ctx.type_[0], "unlabeled_t")
    str_copy(&unlabeled_ctx.level[0], "s0")
    unlabeled_ctx.valid = 1
    selinux_state.unlabeled_sid = alloc_sid(&unlabeled_ctx)

    // File SID
    var file_ctx: SecurityContext = undefined
    str_copy(&file_ctx.user[0], "system_u")
    str_copy(&file_ctx.role[0], "object_r")
    str_copy(&file_ctx.type_[0], "file_t")
    str_copy(&file_ctx.level[0], "s0")
    file_ctx.valid = 1
    selinux_state.file_sid = alloc_sid(&file_ctx)

    // Security SID (for /selinux pseudo-fs)
    var security_ctx: SecurityContext = undefined
    str_copy(&security_ctx.user[0], "system_u")
    str_copy(&security_ctx.role[0], "object_r")
    str_copy(&security_ctx.type_[0], "security_t")
    str_copy(&security_ctx.level[0], "s0")
    security_ctx.valid = 1
    selinux_state.security_sid = alloc_sid(&security_ctx)
}

// Load default policy
fn load_default_policy() {
    // Allow kernel to do everything
    selinux_add_rule("kernel_t", "file_t", SECCLASS_FILE, 0xFFFFFFFF)
    selinux_add_rule("kernel_t", "kernel_t", SECCLASS_PROCESS, 0xFFFFFFFF)

    // Allow init basic operations
    selinux_add_rule("init_t", "file_t", SECCLASS_FILE,
                     FILE_PERM_READ | FILE_PERM_WRITE | FILE_PERM_EXECUTE |
                     FILE_PERM_GETATTR | FILE_PERM_CREATE | FILE_PERM_UNLINK)
    selinux_add_rule("init_t", "init_t", SECCLASS_PROCESS,
                     PROC_PERM_FORK | PROC_PERM_SIGNAL | PROC_PERM_GETATTR)

    // Transition init to shell on shell exec
    selinux_add_transition("init_t", "shell_exec_t", SECCLASS_PROCESS, "shell_t")

    selinux_state.policy_loaded = 1
}

// Initialize SELinux
export fn selinux_init() {
    foundation.serial_write_string("[SELinux] Initializing...\n")

    // Clear state
    selinux_state.mode = SELINUX_PERMISSIVE
    selinux_state.initialized = 0
    selinux_state.policy_loaded = 0
    selinux_state.next_sid = 1  // 0 is invalid
    selinux_state.rule_count = 0
    selinux_state.transition_count = 0
    selinux_state.boolean_count = 0
    selinux_state.denials = 0
    selinux_state.grants = 0
    selinux_state.avc_hits = 0
    selinux_state.avc_misses = 0

    // Clear AVC
    selinux_avc_reset()

    // Create initial SIDs
    create_initial_sids()

    // Load default policy
    load_default_policy()

    selinux_state.initialized = 1

    foundation.serial_write_string("[SELinux] Initialized in permissive mode\n")
    foundation.serial_write_string("[SELinux] Kernel SID=")
    foundation.serial_write_dec(selinux_state.kernel_sid)
    foundation.serial_write_string(" Init SID=")
    foundation.serial_write_dec(selinux_state.init_sid)
    foundation.serial_write_string("\n")
}

// Get kernel SID
export fn selinux_kernel_sid(): u32 {
    return selinux_state.kernel_sid
}

// Get unlabeled SID
export fn selinux_unlabeled_sid(): u32 {
    return selinux_state.unlabeled_sid
}

// Get file SID
export fn selinux_file_sid(): u32 {
    return selinux_state.file_sid
}

// Get statistics
export fn selinux_get_stats(grants: *u64, denials: *u64, avc_hits: *u64, avc_misses: *u64) {
    @ptrDeref(grants) = selinux_state.grants
    @ptrDeref(denials) = selinux_state.denials
    @ptrDeref(avc_hits) = selinux_state.avc_hits
    @ptrDeref(avc_misses) = selinux_state.avc_misses
}

// Validate context string
export fn selinux_validate_context(context: [*]u8): u32 {
    // Parse user:role:type:level format
    var colon_count: u32 = 0
    var i: u32 = 0
    while context[i] != 0 and i < MAX_CONTEXT_LEN {
        if context[i] == ':' {
            colon_count = colon_count + 1
        }
        i = i + 1
    }

    // Should have exactly 3 colons (4 fields)
    if colon_count != 3 {
        return 1
    }

    return 0
}

// Parse context string to structure
export fn selinux_string_to_context(str: [*]u8, ctx: *SecurityContext): u32 {
    var i: u32 = 0
    var field: u32 = 0
    var field_start: u32 = 0

    while str[i] != 0 and i < MAX_CONTEXT_LEN {
        if str[i] == ':' or str[i] == 0 {
            var len: u32 = i - field_start
            if len >= MAX_TYPE_LEN {
                len = MAX_TYPE_LEN - 1
            }

            if field == 0 {
                memory.memcpy(&ctx.user[0], &str[field_start], len)
                ctx.user[len] = 0
            } else if field == 1 {
                memory.memcpy(&ctx.role[0], &str[field_start], len)
                ctx.role[len] = 0
            } else if field == 2 {
                memory.memcpy(&ctx.type_[0], &str[field_start], len)
                ctx.type_[len] = 0
            } else if field == 3 {
                memory.memcpy(&ctx.level[0], &str[field_start], len)
                ctx.level[len] = 0
            }

            field = field + 1
            field_start = i + 1
        }
        i = i + 1
    }

    // Handle last field
    if field == 3 {
        var len: u32 = i - field_start
        if len >= MAX_TYPE_LEN {
            len = MAX_TYPE_LEN - 1
        }
        memory.memcpy(&ctx.level[0], &str[field_start], len)
        ctx.level[len] = 0
    }

    ctx.valid = 1
    return 0
}

// Context to string
export fn selinux_context_to_string(ctx: *SecurityContext, str: [*]u8, max_len: u32) {
    var pos: u32 = 0
    var i: u32 = 0

    // User
    while ctx.user[i] != 0 and pos < max_len - 4 {
        str[pos] = ctx.user[i]
        pos = pos + 1
        i = i + 1
    }
    str[pos] = ':'
    pos = pos + 1

    // Role
    i = 0
    while ctx.role[i] != 0 and pos < max_len - 3 {
        str[pos] = ctx.role[i]
        pos = pos + 1
        i = i + 1
    }
    str[pos] = ':'
    pos = pos + 1

    // Type
    i = 0
    while ctx.type_[i] != 0 and pos < max_len - 2 {
        str[pos] = ctx.type_[i]
        pos = pos + 1
        i = i + 1
    }
    str[pos] = ':'
    pos = pos + 1

    // Level
    i = 0
    while ctx.level[i] != 0 and pos < max_len - 1 {
        str[pos] = ctx.level[i]
        pos = pos + 1
        i = i + 1
    }
    str[pos] = 0
}
