// HomeOS Pointer Safety Migration Module
// Provides higher-level abstractions for migrating raw pointer patterns
// to safe equivalents throughout the kernel codebase
//
// This module wraps ptr_safety.home with more ergonomic APIs and
// additional safety patterns for common kernel operations.

const ptr_safety = @import("ptr_safety.home")
const serial = @import("../drivers/serial.home")

// ============================================================================
// Safe Pointer Types
// ============================================================================

// A validated pointer that has passed safety checks
// Use these wrapper functions to create validated pointers
pub const ValidatedPtr = struct {
    addr: u64,
    size: u64,
    region: u32,  // REGION_* constant
    validated: u32,
}

// Region types
pub const REGION_UNKNOWN: u32 = 0
pub const REGION_KERNEL: u32 = 1
pub const REGION_USER: u32 = 2
pub const REGION_HEAP: u32 = 3
pub const REGION_STACK: u32 = 4
pub const REGION_MMIO: u32 = 5

// ============================================================================
// Validated Pointer Creation
// ============================================================================

// Create a validated kernel pointer
export fn make_kernel_ptr(addr: u64, size: u64) ValidatedPtr {
    var vp: ValidatedPtr = ValidatedPtr{
        .addr = addr,
        .size = size,
        .region = REGION_UNKNOWN,
        .validated = 0,
    }

    if (addr == 0) {
        return vp
    }

    if (ptr_safety.ptr_is_kernel(addr) == 1 and ptr_safety.ptr_check_range(addr, size) == 1) {
        vp.region = REGION_KERNEL
        vp.validated = 1
    }

    return vp
}

// Create a validated user pointer
export fn make_user_ptr(addr: u64, size: u64) ValidatedPtr {
    var vp: ValidatedPtr = ValidatedPtr{
        .addr = addr,
        .size = size,
        .region = REGION_UNKNOWN,
        .validated = 0,
    }

    if (addr == 0) {
        return vp
    }

    if (ptr_safety.ptr_is_user(addr) == 1 and ptr_safety.ptr_check_range(addr, size) == 1) {
        vp.region = REGION_USER
        vp.validated = 1
    }

    return vp
}

// Create a validated heap pointer
export fn make_heap_ptr(addr: u64, size: u64) ValidatedPtr {
    var vp: ValidatedPtr = ValidatedPtr{
        .addr = addr,
        .size = size,
        .region = REGION_UNKNOWN,
        .validated = 0,
    }

    if (addr == 0) {
        return vp
    }

    if (ptr_safety.ptr_is_heap(addr) == 1 and ptr_safety.ptr_check_range(addr, size) == 1) {
        vp.region = REGION_HEAP
        vp.validated = 1
    }

    return vp
}

// Create a validated MMIO pointer
export fn make_mmio_ptr(addr: u64, size: u64) ValidatedPtr {
    var vp: ValidatedPtr = ValidatedPtr{
        .addr = addr,
        .size = size,
        .region = REGION_UNKNOWN,
        .validated = 0,
    }

    if (addr == 0) {
        return vp
    }

    if (ptr_safety.ptr_is_mmio(addr) == 1) {
        vp.region = REGION_MMIO
        vp.validated = 1
    }

    return vp
}

// ============================================================================
// Safe Read Operations
// ============================================================================

// Read u8 from validated pointer
export fn safe_read_u8(vp: *ValidatedPtr, offset: u64) u8 {
    if (vp.validated == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: Reading from unvalidated pointer\n")
        return 0
    }

    if (offset >= vp.size) {
        serial.write_string("[PTR_MIGRATE] ERROR: Read offset out of bounds\n")
        return 0
    }

    return ptr_safety.ptr_safe_read_u8(vp.addr + offset, 0)
}

// Read u16 from validated pointer (with alignment check)
export fn safe_read_u16(vp: *ValidatedPtr, offset: u64) u16 {
    if (vp.validated == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: Reading from unvalidated pointer\n")
        return 0
    }

    if (offset + 2 > vp.size) {
        serial.write_string("[PTR_MIGRATE] ERROR: Read offset out of bounds\n")
        return 0
    }

    var addr: u64 = vp.addr + offset
    if (ptr_safety.ptr_is_aligned_u16(addr) == 0) {
        serial.write_string("[PTR_MIGRATE] WARNING: Unaligned u16 read\n")
    }

    var p: *u16 = @ptrFromInt(addr)
    return p.*
}

// Read u32 from validated pointer (with alignment check)
export fn safe_read_u32(vp: *ValidatedPtr, offset: u64) u32 {
    if (vp.validated == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: Reading from unvalidated pointer\n")
        return 0
    }

    if (offset + 4 > vp.size) {
        serial.write_string("[PTR_MIGRATE] ERROR: Read offset out of bounds\n")
        return 0
    }

    var addr: u64 = vp.addr + offset
    if (ptr_safety.ptr_is_aligned_u32(addr) == 0) {
        serial.write_string("[PTR_MIGRATE] WARNING: Unaligned u32 read\n")
    }

    return ptr_safety.ptr_safe_read_u32(addr, 0)
}

// Read u64 from validated pointer (with alignment check)
export fn safe_read_u64(vp: *ValidatedPtr, offset: u64) u64 {
    if (vp.validated == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: Reading from unvalidated pointer\n")
        return 0
    }

    if (offset + 8 > vp.size) {
        serial.write_string("[PTR_MIGRATE] ERROR: Read offset out of bounds\n")
        return 0
    }

    var addr: u64 = vp.addr + offset
    if (ptr_safety.ptr_is_aligned_u64(addr) == 0) {
        serial.write_string("[PTR_MIGRATE] WARNING: Unaligned u64 read\n")
    }

    return ptr_safety.ptr_safe_read_u64(addr, 0)
}

// ============================================================================
// Safe Write Operations
// ============================================================================

// Write u8 to validated pointer
export fn safe_write_u8(vp: *ValidatedPtr, offset: u64, value: u8) u32 {
    if (vp.validated == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: Writing to unvalidated pointer\n")
        return 1
    }

    if (offset >= vp.size) {
        serial.write_string("[PTR_MIGRATE] ERROR: Write offset out of bounds\n")
        return 1
    }

    return ptr_safety.ptr_safe_write_u8(vp.addr + offset, value)
}

// Write u16 to validated pointer
export fn safe_write_u16(vp: *ValidatedPtr, offset: u64, value: u16) u32 {
    if (vp.validated == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: Writing to unvalidated pointer\n")
        return 1
    }

    if (offset + 2 > vp.size) {
        serial.write_string("[PTR_MIGRATE] ERROR: Write offset out of bounds\n")
        return 1
    }

    var addr: u64 = vp.addr + offset
    if (ptr_safety.ptr_is_aligned_u16(addr) == 0) {
        serial.write_string("[PTR_MIGRATE] WARNING: Unaligned u16 write\n")
    }

    var p: *u16 = @ptrFromInt(addr)
    p.* = value
    return 0
}

// Write u32 to validated pointer
export fn safe_write_u32(vp: *ValidatedPtr, offset: u64, value: u32) u32 {
    if (vp.validated == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: Writing to unvalidated pointer\n")
        return 1
    }

    if (offset + 4 > vp.size) {
        serial.write_string("[PTR_MIGRATE] ERROR: Write offset out of bounds\n")
        return 1
    }

    var addr: u64 = vp.addr + offset
    if (ptr_safety.ptr_is_aligned_u32(addr) == 0) {
        serial.write_string("[PTR_MIGRATE] WARNING: Unaligned u32 write\n")
    }

    return ptr_safety.ptr_safe_write_u32(addr, value)
}

// Write u64 to validated pointer
export fn safe_write_u64(vp: *ValidatedPtr, offset: u64, value: u64) u32 {
    if (vp.validated == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: Writing to unvalidated pointer\n")
        return 1
    }

    if (offset + 8 > vp.size) {
        serial.write_string("[PTR_MIGRATE] ERROR: Write offset out of bounds\n")
        return 1
    }

    var addr: u64 = vp.addr + offset
    if (ptr_safety.ptr_is_aligned_u64(addr) == 0) {
        serial.write_string("[PTR_MIGRATE] WARNING: Unaligned u64 write\n")
    }

    return ptr_safety.ptr_safe_write_u64(addr, value)
}

// ============================================================================
// Safe Memory Operations
// ============================================================================

// Safe memcpy between validated pointers
export fn safe_memcpy(dest: *ValidatedPtr, src: *ValidatedPtr, size: u64) u32 {
    if (dest.validated == 0 or src.validated == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: memcpy with unvalidated pointer\n")
        return 1
    }

    if (size > dest.size or size > src.size) {
        serial.write_string("[PTR_MIGRATE] ERROR: memcpy size exceeds bounds\n")
        return 1
    }

    return ptr_safety.ptr_safe_memcpy(dest.addr, src.addr, size)
}

// Safe memset on validated pointer
export fn safe_memset(dest: *ValidatedPtr, value: u8, size: u64) u32 {
    if (dest.validated == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: memset on unvalidated pointer\n")
        return 1
    }

    if (size > dest.size) {
        serial.write_string("[PTR_MIGRATE] ERROR: memset size exceeds bounds\n")
        return 1
    }

    return ptr_safety.ptr_safe_memset(dest.addr, value, size)
}

// ============================================================================
// User/Kernel Boundary Operations
// ============================================================================

// Safe copy from user space to kernel
export fn safe_copy_from_user(kernel_dest: *ValidatedPtr, user_addr: u64, size: u64) u32 {
    if (kernel_dest.validated == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: copy_from_user to unvalidated dest\n")
        return 1
    }

    if (kernel_dest.region != REGION_KERNEL and kernel_dest.region != REGION_HEAP) {
        serial.write_string("[PTR_MIGRATE] ERROR: copy_from_user dest not kernel/heap\n")
        return 1
    }

    if (size > kernel_dest.size) {
        serial.write_string("[PTR_MIGRATE] ERROR: copy_from_user size exceeds dest\n")
        return 1
    }

    return ptr_safety.ptr_copy_from_user(kernel_dest.addr, user_addr, size)
}

// Safe copy to user space from kernel
export fn safe_copy_to_user(user_addr: u64, kernel_src: *ValidatedPtr, size: u64) u32 {
    if (kernel_src.validated == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: copy_to_user from unvalidated src\n")
        return 1
    }

    if (kernel_src.region != REGION_KERNEL and kernel_src.region != REGION_HEAP) {
        serial.write_string("[PTR_MIGRATE] ERROR: copy_to_user src not kernel/heap\n")
        return 1
    }

    if (size > kernel_src.size) {
        serial.write_string("[PTR_MIGRATE] ERROR: copy_to_user size exceeds src\n")
        return 1
    }

    return ptr_safety.ptr_copy_to_user(user_addr, kernel_src.addr, size)
}

// ============================================================================
// Safe Array Operations
// ============================================================================

// Safe array type for compile-time known sizes
pub const SafeArray = struct {
    base: u64,
    elem_size: u64,
    count: u64,
    validated: u32,
}

// Create a safe array wrapper
export fn make_safe_array(base: u64, elem_size: u64, count: u64) SafeArray {
    var sa: SafeArray = SafeArray{
        .base = base,
        .elem_size = elem_size,
        .count = count,
        .validated = 0,
    }

    if (base == 0) {
        return sa
    }

    var total_size: u64 = elem_size * count
    if (ptr_safety.ptr_check_range(base, total_size) == 1) {
        sa.validated = 1
    }

    return sa
}

// Get element from safe array (bounds checked)
export fn safe_array_get_u8(sa: *SafeArray, index: u64) u8 {
    if (sa.validated == 0 or index >= sa.count) {
        return 0
    }
    return ptr_safety.ptr_array_get_u8(sa.base, index, sa.count)
}

export fn safe_array_get_u32(sa: *SafeArray, index: u64) u32 {
    if (sa.validated == 0 or index >= sa.count) {
        return 0
    }
    return ptr_safety.ptr_array_get_u32(sa.base, index, sa.count)
}

// Set element in safe array (bounds checked)
export fn safe_array_set_u8(sa: *SafeArray, index: u64, value: u8) u32 {
    if (sa.validated == 0 or index >= sa.count) {
        return 1
    }
    return ptr_safety.ptr_array_set_u8(sa.base, index, sa.count, value)
}

export fn safe_array_set_u32(sa: *SafeArray, index: u64, value: u32) u32 {
    if (sa.validated == 0 or index >= sa.count) {
        return 1
    }
    return ptr_safety.ptr_array_set_u32(sa.base, index, sa.count, value)
}

// ============================================================================
// Page Table Operations (Special case for VMM)
// ============================================================================

// Page table entry operations with validation
const PAGE_SIZE: u64 = 4096
const PAGE_PRESENT: u64 = 0x1
const PAGE_WRITABLE: u64 = 0x2
const PAGE_USER: u64 = 0x4

// Safe page table entry read
export fn safe_read_pte(table_addr: u64, index: u64) u64 {
    if (index >= 512) {
        serial.write_string("[PTR_MIGRATE] ERROR: PTE index out of bounds\n")
        return 0
    }

    if (ptr_safety.ptr_is_page_aligned(table_addr) == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: Page table not aligned\n")
        return 0
    }

    var entry_addr: u64 = table_addr + (index * 8)
    return ptr_safety.ptr_safe_read_u64(entry_addr, 0)
}

// Safe page table entry write
export fn safe_write_pte(table_addr: u64, index: u64, value: u64) u32 {
    if (index >= 512) {
        serial.write_string("[PTR_MIGRATE] ERROR: PTE index out of bounds\n")
        return 1
    }

    if (ptr_safety.ptr_is_page_aligned(table_addr) == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: Page table not aligned\n")
        return 1
    }

    var entry_addr: u64 = table_addr + (index * 8)
    return ptr_safety.ptr_safe_write_u64(entry_addr, value)
}

// ============================================================================
// MMIO Operations (For Device Drivers)
// ============================================================================

// Safe MMIO read (volatile semantics assumed by hardware)
export fn safe_mmio_read_u32(base: u64, offset: u64) u32 {
    var addr: u64 = base + offset

    if (ptr_safety.ptr_is_mmio(addr) == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: MMIO read outside MMIO region\n")
        return 0
    }

    if (ptr_safety.ptr_is_aligned_u32(addr) == 0) {
        serial.write_string("[PTR_MIGRATE] WARNING: Unaligned MMIO read\n")
    }

    var p: *volatile u32 = @ptrFromInt(addr)
    return p.*
}

// Safe MMIO write (volatile semantics)
export fn safe_mmio_write_u32(base: u64, offset: u64, value: u32) u32 {
    var addr: u64 = base + offset

    if (ptr_safety.ptr_is_mmio(addr) == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: MMIO write outside MMIO region\n")
        return 1
    }

    if (ptr_safety.ptr_is_aligned_u32(addr) == 0) {
        serial.write_string("[PTR_MIGRATE] WARNING: Unaligned MMIO write\n")
    }

    var p: *volatile u32 = @ptrFromInt(addr)
    p.* = value
    return 0
}

// ============================================================================
// Physical Memory Operations (For PMM)
// ============================================================================

// Mark physical page in bitmap safely
export fn safe_bitmap_set(bitmap_addr: u64, bit_index: u64, bitmap_size: u64) u32 {
    var byte_index: u64 = bit_index / 8
    var bit_offset: u64 = bit_index % 8

    if (byte_index >= bitmap_size) {
        serial.write_string("[PTR_MIGRATE] ERROR: Bitmap index out of bounds\n")
        return 1
    }

    var current: u8 = ptr_safety.ptr_safe_read_u8(bitmap_addr + byte_index, 0)
    var new_val: u8 = current | @as(u8, @truncate(1 << bit_offset))
    return ptr_safety.ptr_safe_write_u8(bitmap_addr + byte_index, new_val)
}

// Clear physical page in bitmap safely
export fn safe_bitmap_clear(bitmap_addr: u64, bit_index: u64, bitmap_size: u64) u32 {
    var byte_index: u64 = bit_index / 8
    var bit_offset: u64 = bit_index % 8

    if (byte_index >= bitmap_size) {
        serial.write_string("[PTR_MIGRATE] ERROR: Bitmap index out of bounds\n")
        return 1
    }

    var current: u8 = ptr_safety.ptr_safe_read_u8(bitmap_addr + byte_index, 0)
    var new_val: u8 = current & @as(u8, @truncate(~(1 << bit_offset)))
    return ptr_safety.ptr_safe_write_u8(bitmap_addr + byte_index, new_val)
}

// Test physical page in bitmap safely
export fn safe_bitmap_test(bitmap_addr: u64, bit_index: u64, bitmap_size: u64) u32 {
    var byte_index: u64 = bit_index / 8
    var bit_offset: u64 = bit_index % 8

    if (byte_index >= bitmap_size) {
        return 0
    }

    var current: u8 = ptr_safety.ptr_safe_read_u8(bitmap_addr + byte_index, 0)
    if ((current & @as(u8, @truncate(1 << bit_offset))) != 0) {
        return 1
    }
    return 0
}

// ============================================================================
// String Operations
// ============================================================================

// Safe string copy with validation
export fn safe_strcpy(dest: *ValidatedPtr, src_addr: u64, max_len: u64) u32 {
    if (dest.validated == 0) {
        serial.write_string("[PTR_MIGRATE] ERROR: strcpy to unvalidated dest\n")
        return 1
    }

    var copy_len: u64 = max_len
    if (copy_len > dest.size) {
        copy_len = dest.size
    }

    return ptr_safety.ptr_safe_strcpy(dest.addr, src_addr, copy_len)
}

// Safe string length with bounds
export fn safe_strlen(str_addr: u64, max_len: u64) u64 {
    return ptr_safety.ptr_safe_strlen(str_addr, max_len)
}

// ============================================================================
// Migration Statistics
// ============================================================================

var migrations_completed: u64 = 0
var migrations_failed: u64 = 0

export fn migration_record_success() void {
    migrations_completed += 1
}

export fn migration_record_failure() void {
    migrations_failed += 1
}

export fn migration_print_stats() void {
    serial.write_string("\n[PTR_MIGRATE] Migration Statistics:\n")
    serial.write_string("  Successful migrations: ")
    serial.write_u64(migrations_completed)
    serial.write_string("\n")
    serial.write_string("  Failed migrations: ")
    serial.write_u64(migrations_failed)
    serial.write_string("\n")

    // Also print underlying safety stats
    ptr_safety.ptr_safety_print_stats()
}

// ============================================================================
// Debug Validation
// ============================================================================

// Validate that a pointer pattern has been migrated correctly
export fn validate_migrated_ptr(vp: *ValidatedPtr, expected_region: u32) u32 {
    if (vp.validated == 0) {
        serial.write_string("[PTR_MIGRATE] VALIDATION FAILED: Pointer not validated\n")
        return 0
    }

    if (vp.region != expected_region) {
        serial.write_string("[PTR_MIGRATE] VALIDATION FAILED: Wrong region\n")
        return 0
    }

    return 1
}
