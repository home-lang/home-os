// home-os Kernel - CPU Security Features
// SMEP, SMAP (x86-64) and PAN, PXN (ARM64) enforcement

import "../core/foundation.home" as foundation
import "../os/cpu.home" as cpu

// ============================================================================
// x86-64 CPU Security Features
// ============================================================================

// CR4 bit positions
const CR4_SMEP: u64 = 1 << 20    // Supervisor Mode Execution Prevention
const CR4_SMAP: u64 = 1 << 21    // Supervisor Mode Access Prevention
const CR4_PKE: u64 = 1 << 22     // Protection Key Enable
const CR4_CET: u64 = 1 << 23     // Control-flow Enforcement Technology
const CR4_UMIP: u64 = 1 << 11    // User-Mode Instruction Prevention

// CPUID feature bits
const CPUID_SMEP_BIT: u32 = 7    // EBX bit 7 in CPUID leaf 7
const CPUID_SMAP_BIT: u32 = 20   // EBX bit 20 in CPUID leaf 7

// Security status
var smep_enabled: u32 = 0
var smap_enabled: u32 = 0
var umip_enabled: u32 = 0
var cpu_security_initialized: u32 = 0

// Read CR4 register
fn read_cr4(): u64 {
  var value: u64 = 0
  // In Home, would be: asm volatile ("mov %%cr4, %0" : "=r"(value))
  // For now, simulate read
  return value
}

// Write CR4 register
fn write_cr4(value: u64) {
  // In Home, would be: asm volatile ("mov %0, %%cr4" :: "r"(value))
  foundation.serial_write_string("[CPU Sec] Writing CR4: 0x")
  foundation.serial_write_hex(@truncate(value, u32))
  foundation.serial_write_string("\n")
}

// Check if SMEP is supported via CPUID
fn cpuid_supports_smep(): u32 {
  // CPUID leaf 7, check EBX bit 7
  // In Home, would use inline asm for cpuid
  // For now, assume supported on modern CPUs
  return 1
}

// Check if SMAP is supported via CPUID
fn cpuid_supports_smap(): u32 {
  // CPUID leaf 7, check EBX bit 20
  return 1
}

// Check if UMIP is supported
fn cpuid_supports_umip(): u32 {
  // CPUID leaf 7, check ECX bit 2
  return 1
}

// Enable SMEP (Supervisor Mode Execution Prevention)
// Prevents kernel from executing code in user-space pages
export fn smep_enable(): u32 {
  if smep_enabled == 1 {
    return 1
  }

  if cpuid_supports_smep() == 0 {
    foundation.serial_write_string("[CPU Sec] SMEP not supported by CPU\n")
    return 0
  }

  var cr4: u64 = read_cr4()
  cr4 = cr4 | CR4_SMEP
  write_cr4(cr4)

  smep_enabled = 1
  foundation.serial_write_string("[CPU Sec] SMEP enabled - kernel cannot execute user pages\n")
  return 1
}

// Enable SMAP (Supervisor Mode Access Prevention)
// Prevents kernel from accessing user-space pages without explicit STAC/CLAC
export fn smap_enable(): u32 {
  if smap_enabled == 1 {
    return 1
  }

  if cpuid_supports_smap() == 0 {
    foundation.serial_write_string("[CPU Sec] SMAP not supported by CPU\n")
    return 0
  }

  var cr4: u64 = read_cr4()
  cr4 = cr4 | CR4_SMAP
  write_cr4(cr4)

  smap_enabled = 1
  foundation.serial_write_string("[CPU Sec] SMAP enabled - kernel cannot access user pages\n")
  return 1
}

// Enable UMIP (User-Mode Instruction Prevention)
// Prevents user-space from executing SGDT, SIDT, SLDT, SMSW, STR
export fn umip_enable(): u32 {
  if umip_enabled == 1 {
    return 1
  }

  if cpuid_supports_umip() == 0 {
    foundation.serial_write_string("[CPU Sec] UMIP not supported by CPU\n")
    return 0
  }

  var cr4: u64 = read_cr4()
  cr4 = cr4 | CR4_UMIP
  write_cr4(cr4)

  umip_enabled = 1
  foundation.serial_write_string("[CPU Sec] UMIP enabled - user cannot read system registers\n")
  return 1
}

// STAC - Set AC flag to temporarily allow user page access
// Use before legitimate kernel access to user memory
export fn smap_stac() {
  // asm volatile ("stac")
  foundation.serial_write_string("[CPU Sec] STAC - user access allowed\n")
}

// CLAC - Clear AC flag to restore SMAP protection
// Use after kernel access to user memory
export fn smap_clac() {
  // asm volatile ("clac")
  foundation.serial_write_string("[CPU Sec] CLAC - user access blocked\n")
}

// ============================================================================
// ARM64 Security Features (PAN/PXN)
// ============================================================================

// SCTLR_EL1 bits for ARM64
const SCTLR_SPAN: u64 = 1 << 23   // PSTATE.PAN not set on exception entry
const SCTLR_nTWE: u64 = 1 << 18   // WFE not trapped to EL2
const SCTLR_nTWI: u64 = 1 << 16   // WFI not trapped to EL2

// ARM64 security status
var pan_enabled: u32 = 0   // Privileged Access Never
var pxn_enabled: u32 = 0   // Privileged Execute Never

// Check if PAN is supported (ARMv8.1+)
fn arm64_supports_pan(): u32 {
  // Check ID_AA64MMFR1_EL1.PAN field
  return 1
}

// Enable PAN (Privileged Access Never)
// Similar to SMAP - prevents EL1 from accessing user pages
export fn pan_enable(): u32 {
  if pan_enabled == 1 {
    return 1
  }

  if arm64_supports_pan() == 0 {
    foundation.serial_write_string("[CPU Sec] PAN not supported on this ARM64 CPU\n")
    return 0
  }

  // Set PSTATE.PAN = 1
  // msr pan, #1
  pan_enabled = 1
  foundation.serial_write_string("[CPU Sec] PAN enabled (ARM64) - EL1 cannot access user pages\n")
  return 1
}

// Enable PXN via page table attributes
// Set in page table entries, not a global flag
export fn pxn_enable(): u32 {
  if pxn_enabled == 1 {
    return 1
  }

  // PXN is set per-page in the page table attributes
  // This flag just marks that we're using PXN
  pxn_enabled = 1
  foundation.serial_write_string("[CPU Sec] PXN enabled (ARM64) - EL1 cannot execute user pages\n")
  return 1
}

// ============================================================================
// Unified Security Initialization
// ============================================================================

// Initialize all CPU security features
export fn cpu_security_init() {
  if cpu_security_initialized == 1 {
    return
  }

  foundation.serial_write_string("[CPU Sec] Initializing CPU security features...\n")

  // Detect architecture and enable appropriate features
  // For now, assume x86-64 (would detect at runtime)

  // Enable SMEP
  smep_enable()

  // Enable SMAP
  smap_enable()

  // Enable UMIP
  umip_enable()

  cpu_security_initialized = 1

  foundation.serial_write_string("[CPU Sec] CPU security initialization complete\n")
  cpu_security_print_status()
}

// Initialize for ARM64
export fn cpu_security_init_arm64() {
  if cpu_security_initialized == 1 {
    return
  }

  foundation.serial_write_string("[CPU Sec] Initializing ARM64 security features...\n")

  pan_enable()
  pxn_enable()

  cpu_security_initialized = 1
  foundation.serial_write_string("[CPU Sec] ARM64 security initialization complete\n")
}

// Print security status
export fn cpu_security_print_status() {
  foundation.serial_write_string("\n[CPU Sec] Security Status:\n")

  foundation.serial_write_string("  SMEP (x86-64): ")
  if smep_enabled == 1 { foundation.serial_write_string("ENABLED\n") }
  else { foundation.serial_write_string("DISABLED\n") }

  foundation.serial_write_string("  SMAP (x86-64): ")
  if smap_enabled == 1 { foundation.serial_write_string("ENABLED\n") }
  else { foundation.serial_write_string("DISABLED\n") }

  foundation.serial_write_string("  UMIP (x86-64): ")
  if umip_enabled == 1 { foundation.serial_write_string("ENABLED\n") }
  else { foundation.serial_write_string("DISABLED\n") }

  foundation.serial_write_string("  PAN (ARM64):   ")
  if pan_enabled == 1 { foundation.serial_write_string("ENABLED\n") }
  else { foundation.serial_write_string("DISABLED\n") }

  foundation.serial_write_string("  PXN (ARM64):   ")
  if pxn_enabled == 1 { foundation.serial_write_string("ENABLED\n") }
  else { foundation.serial_write_string("DISABLED\n") }

  foundation.serial_write_string("\n")
}

// Check if SMEP is enabled
export fn smep_is_enabled(): u32 {
  return smep_enabled
}

// Check if SMAP is enabled
export fn smap_is_enabled(): u32 {
  return smap_enabled
}

// Check if PAN is enabled
export fn pan_is_enabled(): u32 {
  return pan_enabled
}

// ============================================================================
// User Memory Access Helpers
// ============================================================================

// Safely copy data from user space with SMAP handling
export fn copy_from_user(kernel_dst: u64, user_src: u64, len: u32): u32 {
  if smap_enabled == 1 {
    smap_stac()
  }

  // Perform the copy
  var i: u32 = 0
  while i < len {
    var byte: u8 = @ptrLoad(user_src + i, u8)
    @ptrStore(kernel_dst + i, u8, byte)
    i = i + 1
  }

  if smap_enabled == 1 {
    smap_clac()
  }

  return len
}

// Safely copy data to user space with SMAP handling
export fn copy_to_user(user_dst: u64, kernel_src: u64, len: u32): u32 {
  if smap_enabled == 1 {
    smap_stac()
  }

  // Perform the copy
  var i: u32 = 0
  while i < len {
    var byte: u8 = @ptrLoad(kernel_src + i, u8)
    @ptrStore(user_dst + i, u8, byte)
    i = i + 1
  }

  if smap_enabled == 1 {
    smap_clac()
  }

  return len
}

// ============================================================================
// Security Violation Handling
// ============================================================================

// Handle SMEP violation (kernel tried to execute user page)
export fn smep_violation_handler(fault_addr: u64, error_code: u32) {
  foundation.serial_write_string("\n!!! SMEP VIOLATION !!!\n")
  foundation.serial_write_string("Kernel attempted to execute code at user address: 0x")
  foundation.serial_write_hex(@truncate(fault_addr, u32))
  foundation.serial_write_string("\n")
  foundation.serial_write_string("Error code: 0x")
  foundation.serial_write_hex(error_code)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("This is a critical security violation!\n")

  // In production, would panic or kill the offending process
  // panic("SMEP violation")
}

// Handle SMAP violation (kernel tried to access user page without STAC)
export fn smap_violation_handler(fault_addr: u64, error_code: u32) {
  foundation.serial_write_string("\n!!! SMAP VIOLATION !!!\n")
  foundation.serial_write_string("Kernel attempted to access user memory at: 0x")
  foundation.serial_write_hex(@truncate(fault_addr, u32))
  foundation.serial_write_string("\n")
  foundation.serial_write_string("Error code: 0x")
  foundation.serial_write_hex(error_code)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("Use copy_from_user/copy_to_user for legitimate access!\n")

  // In production, would panic or kill the offending process
}
