// home-os Kernel - Secure Random Number Generator
// Cryptographically secure random numbers for ASLR and other security features

import "../core/foundation.home" as foundation
import "../drivers/timer.home" as timer

// Random state
var random_state: [u64; 4]
var random_initialized: u32 = 0
var random_counter: u64 = 0

// Entropy pool
const ENTROPY_POOL_SIZE: u32 = 256
var entropy_pool: [u8; 256]
var entropy_index: u32 = 0

export fn random_init() {
  if random_initialized == 1 { return }
  
  // Seed with timer and CPU cycles
  random_state[0] = timer.timer_get_ticks()
  random_state[1] = foundation.cpu_read_tsc()
  random_state[2] = timer.timer_get_ticks() ^ 0xDEADBEEFCAFEBABE
  random_state[3] = foundation.cpu_read_tsc() ^ 0x0123456789ABCDEF
  
  // Initialize entropy pool
  var i: u32 = 0
  while i < ENTROPY_POOL_SIZE {
    entropy_pool[i] = @truncate((random_state[0] >> (i % 64)), u8)
    i = i + 1
  }
  
  random_initialized = 1
  foundation.serial_write_string("[Random] Initialized\n")
}

// XorShift256** algorithm for fast, high-quality random numbers
export fn random_get_u64() -> u64 {
  if random_initialized == 0 { random_init() }
  
  var t: u64 = random_state[1]
  var s: u64 = random_state[0]
  
  random_state[0] = t
  t = t ^ (t << 23)
  t = t ^ (t >> 18)
  t = t ^ s
  t = t ^ (s >> 5)
  random_state[1] = t
  
  var result: u64 = t + s
  
  // Mix in entropy
  random_counter = random_counter + 1
  result = result ^ random_counter
  
  return result
}

export fn random_get_u32() -> u32 {
  return @truncate(random_get_u64(), u32)
}

export fn random_get_range(min: u64, max: u64) -> u64 {
  if max <= min { return min }
  
  var range: u64 = max - min
  var random: u64 = random_get_u64()
  
  return min + (random % range)
}

export fn random_get_bytes(buffer: u64, size: u32) {
  var i: u32 = 0
  while i < size {
    if i + 8 <= size {
      // Write 8 bytes at once
      var random: u64 = random_get_u64()
      @intToPtr(buffer + i, u64) = random
      i = i + 8
    } else {
      // Write remaining bytes
      var random: u64 = random_get_u64()
      var j: u32 = 0
      while i < size {
        @intToPtr(buffer + i, u8) = @truncate(random >> (j * 8), u8)
        i = i + 1
        j = j + 1
      }
    }
  }
}

// Add entropy to the pool
export fn random_add_entropy(data: u64, size: u32) {
  var i: u32 = 0
  while i < size {
    var byte: u8 = @intToPtr(data + i, u8)
    entropy_pool[entropy_index] = entropy_pool[entropy_index] ^ byte
    entropy_index = (entropy_index + 1) % ENTROPY_POOL_SIZE
    i = i + 1
  }
  
  // Mix entropy into state
  random_state[0] = random_state[0] ^ @intToPtr(entropy_pool, u64)
  random_state[1] = random_state[1] ^ @intToPtr(entropy_pool + 64, u64)
  random_state[2] = random_state[2] ^ @intToPtr(entropy_pool + 128, u64)
  random_state[3] = random_state[3] ^ @intToPtr(entropy_pool + 192, u64)
}

// Collect entropy from various sources
export fn random_collect_entropy() {
  // Timer entropy
  var timer_val: u64 = timer.timer_get_ticks()
  random_add_entropy(@ptrFromInt(timer_val), 8)
  
  // CPU cycle counter entropy
  var tsc: u64 = foundation.cpu_read_tsc()
  random_add_entropy(@ptrFromInt(tsc), 8)
  
  // Mix counter
  random_counter = random_counter + 1
}

// Get entropy estimate (in bits)
export fn random_get_entropy_bits() -> u32 {
  // Simplified entropy estimate
  return 256  // Full entropy pool
}

export fn random_is_initialized() -> u32 {
  return random_initialized
}
