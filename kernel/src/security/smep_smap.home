// home-os Kernel - SMEP/SMAP Support
// Supervisor Mode Execution Prevention / Supervisor Mode Access Prevention

import "../core/foundation.home" as foundation

// CR4 control register bits
const CR4_SMEP_BIT: u32 = 20  // Bit 20: SMEP enable
const CR4_SMAP_BIT: u32 = 21  // Bit 21: SMAP enable

var smep_enabled: u32 = 0
var smap_enabled: u32 = 0
var smep_violations: u64 = 0
var smap_violations: u64 = 0

export fn smep_smap_init() {
  // Check CPU support
  if smep_check_support() == 1 {
    smep_enable()
  }
  
  if smap_check_support() == 1 {
    smap_enable()
  }
  
  foundation.serial_write_string("[SMEP/SMAP] Initialized - SMEP: ")
  if smep_enabled == 1 {
    foundation.serial_write_string("enabled")
  } else {
    foundation.serial_write_string("disabled")
  }
  foundation.serial_write_string(", SMAP: ")
  if smap_enabled == 1 {
    foundation.serial_write_string("enabled")
  } else {
    foundation.serial_write_string("disabled")
  }
  foundation.serial_write_string("\n")
}

fn smep_check_support() -> u32 {
  // CPUID.07H:EBX[7] = SMEP support
  var eax: u32 = 0x07
  var ecx: u32 = 0
  var ebx: u32 = foundation.cpuid_ebx_ecx(eax, ecx)
  
  if (ebx & (1 << 7)) != 0 {
    return 1
  }
  return 0
}

fn smap_check_support() -> u32 {
  // CPUID.07H:EBX[20] = SMAP support
  var eax: u32 = 0x07
  var ecx: u32 = 0
  var ebx: u32 = foundation.cpuid_ebx_ecx(eax, ecx)
  
  if (ebx & (1 << 20)) != 0 {
    return 1
  }
  return 0
}

fn smep_enable() {
  var cr4: u64 = foundation.read_cr4()
  cr4 = cr4 | (1 << CR4_SMEP_BIT)
  foundation.write_cr4(cr4)
  smep_enabled = 1
  foundation.serial_write_string("[SMEP] Enabled\n")
}

fn smap_enable() {
  var cr4: u64 = foundation.read_cr4()
  cr4 = cr4 | (1 << CR4_SMAP_BIT)
  foundation.write_cr4(cr4)
  smap_enabled = 1
  foundation.serial_write_string("[SMAP] Enabled\n")
}

export fn smep_handle_violation(rip: u64, user_addr: u64) {
  smep_violations = smep_violations + 1
  
  foundation.serial_write_string("[SMEP] VIOLATION DETECTED!\n")
  foundation.serial_write_string("  RIP: 0x")
  foundation.serial_write_hex(@truncate(rip, u32))
  foundation.serial_write_string("\n  User address: 0x")
  foundation.serial_write_hex(@truncate(user_addr, u32))
  foundation.serial_write_string("\n")
  
  foundation.panic("SMEP violation - kernel attempted to execute user code")
}

export fn smap_handle_violation(rip: u64, user_addr: u64) {
  smap_violations = smap_violations + 1
  
  foundation.serial_write_string("[SMAP] VIOLATION DETECTED!\n")
  foundation.serial_write_string("  RIP: 0x")
  foundation.serial_write_hex(@truncate(rip, u32))
  foundation.serial_write_string("\n  User address: 0x")
  foundation.serial_write_hex(@truncate(user_addr, u32))
  foundation.serial_write_string("\n")
  
  foundation.panic("SMAP violation - kernel attempted to access user memory")
}

// Temporarily allow supervisor access to user pages (for copy_to_user, etc.)
export fn smap_stac() {
  if smap_enabled == 0 { return }
  
  // STAC instruction - Set AC flag in RFLAGS
  foundation.asm_stac()
}

export fn smap_clac() {
  if smap_enabled == 0 { return }
  
  // CLAC instruction - Clear AC flag in RFLAGS
  foundation.asm_clac()
}

export fn smep_is_enabled() -> u32 {
  return smep_enabled
}

export fn smap_is_enabled() -> u32 {
  return smap_enabled
}

export fn smep_get_violations() -> u64 {
  return smep_violations
}

export fn smap_get_violations() -> u64 {
  return smap_violations
}
