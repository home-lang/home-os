// home-os Kernel - Integrated Firewall
// Packet filtering, stateful inspection, and application-level filtering

import "../core/foundation.home" as foundation
import "../network/network.home" as network

// Firewall actions
const FW_ACCEPT: u32 = 0
const FW_DROP: u32 = 1
const FW_REJECT: u32 = 2
const FW_LOG: u32 = 3

// Protocol types
const PROTO_TCP: u8 = 6
const PROTO_UDP: u8 = 17
const PROTO_ICMP: u8 = 1

// Rule matching
const MATCH_SRC_IP: u32 = 1 << 0
const MATCH_DST_IP: u32 = 1 << 1
const MATCH_SRC_PORT: u32 = 1 << 2
const MATCH_DST_PORT: u32 = 1 << 3
const MATCH_PROTOCOL: u32 = 1 << 4
const MATCH_STATE: u32 = 1 << 5

// Connection states
const STATE_NEW: u32 = 1
const STATE_ESTABLISHED: u32 = 2
const STATE_RELATED: u32 = 3
const STATE_INVALID: u32 = 4

const MAX_RULES: u32 = 1000
const MAX_CONNECTIONS: u32 = 10000

struct FirewallRule {
  action: u32,
  match_flags: u32,
  src_ip: u32,
  src_mask: u32,
  dst_ip: u32,
  dst_mask: u32,
  src_port: u16,
  dst_port: u16,
  protocol: u8,
  state: u32,
  enabled: u32
}

struct Connection {
  src_ip: u32,
  dst_ip: u32,
  src_port: u16,
  dst_port: u16,
  protocol: u8,
  state: u32,
  packets: u64,
  bytes: u64,
  timestamp: u64
}

var rules: [FirewallRule; 1000]
var rule_count: u32 = 0
var connections: [Connection; 10000]
var connection_count: u32 = 0
var firewall_enabled: u32 = 1
var firewall_initialized: u32 = 0
var packets_accepted: u64 = 0
var packets_dropped: u64 = 0
var packets_rejected: u64 = 0

export fn firewall_init() {
  if firewall_initialized == 1 { return }
  
  rule_count = 0
  connection_count = 0
  firewall_enabled = 1
  
  // Add default rules
  firewall_add_default_rules()
  
  firewall_initialized = 1
  foundation.serial_write_string("[Firewall] Initialized with ")
  foundation.serial_write_hex(rule_count)
  foundation.serial_write_string(" rules\n")
}

fn firewall_add_default_rules() {
  // Allow loopback
  var rule: FirewallRule
  rule.action = FW_ACCEPT
  rule.match_flags = MATCH_SRC_IP
  rule.src_ip = 0x7F000001  // 127.0.0.1
  rule.src_mask = 0xFF000000
  rule.enabled = 1
  firewall_add_rule(rule)
  
  // Allow established connections
  rule.action = FW_ACCEPT
  rule.match_flags = MATCH_STATE
  rule.state = STATE_ESTABLISHED
  rule.enabled = 1
  firewall_add_rule(rule)
  
  // Drop invalid packets
  rule.action = FW_DROP
  rule.match_flags = MATCH_STATE
  rule.state = STATE_INVALID
  rule.enabled = 1
  firewall_add_rule(rule)
}

export fn firewall_add_rule(rule: FirewallRule) -> u32 {
  if rule_count >= MAX_RULES { return 0 }
  
  rules[rule_count] = rule
  rule_count = rule_count + 1
  
  return rule_count - 1
}

export fn firewall_remove_rule(index: u32) -> u32 {
  if index >= rule_count { return 0 }
  
  // Shift rules down
  var i: u32 = index
  while i < rule_count - 1 {
    rules[i] = rules[i + 1]
    i = i + 1
  }
  
  rule_count = rule_count - 1
  return 1
}

export fn firewall_check_packet(src_ip: u32, dst_ip: u32, src_port: u16, dst_port: u16, protocol: u8) -> u32 {
  if firewall_enabled == 0 { return FW_ACCEPT }
  
  // Check connection state
  var state: u32 = firewall_get_connection_state(src_ip, dst_ip, src_port, dst_port, protocol)
  
  // Match against rules
  var i: u32 = 0
  while i < rule_count {
    if rules[i].enabled == 0 {
      i = i + 1
      continue
    }
    
    if firewall_match_rule(rules[i], src_ip, dst_ip, src_port, dst_port, protocol, state) == 1 {
      var action: u32 = rules[i].action
      
      if action == FW_ACCEPT {
        packets_accepted = packets_accepted + 1
        firewall_track_connection(src_ip, dst_ip, src_port, dst_port, protocol, state)
      } else if action == FW_DROP {
        packets_dropped = packets_dropped + 1
      } else if action == FW_REJECT {
        packets_rejected = packets_rejected + 1
      }
      
      return action
    }
    
    i = i + 1
  }
  
  // Default policy: drop
  packets_dropped = packets_dropped + 1
  return FW_DROP
}

fn firewall_match_rule(rule: FirewallRule, src_ip: u32, dst_ip: u32, src_port: u16, dst_port: u16, protocol: u8, state: u32) -> u32 {
  // Check source IP
  if (rule.match_flags & MATCH_SRC_IP) != 0 {
    if (src_ip & rule.src_mask) != (rule.src_ip & rule.src_mask) {
      return 0
    }
  }
  
  // Check destination IP
  if (rule.match_flags & MATCH_DST_IP) != 0 {
    if (dst_ip & rule.dst_mask) != (rule.dst_ip & rule.dst_mask) {
      return 0
    }
  }
  
  // Check source port
  if (rule.match_flags & MATCH_SRC_PORT) != 0 {
    if src_port != rule.src_port {
      return 0
    }
  }
  
  // Check destination port
  if (rule.match_flags & MATCH_DST_PORT) != 0 {
    if dst_port != rule.dst_port {
      return 0
    }
  }
  
  // Check protocol
  if (rule.match_flags & MATCH_PROTOCOL) != 0 {
    if protocol != rule.protocol {
      return 0
    }
  }
  
  // Check state
  if (rule.match_flags & MATCH_STATE) != 0 {
    if state != rule.state {
      return 0
    }
  }
  
  return 1
}

fn firewall_get_connection_state(src_ip: u32, dst_ip: u32, src_port: u16, dst_port: u16, protocol: u8) -> u32 {
  // Look for existing connection
  var i: u32 = 0
  while i < connection_count {
    if connections[i].src_ip == src_ip and
       connections[i].dst_ip == dst_ip and
       connections[i].src_port == src_port and
       connections[i].dst_port == dst_port and
       connections[i].protocol == protocol {
      return connections[i].state
    }
    i = i + 1
  }
  
  // New connection
  return STATE_NEW
}

fn firewall_track_connection(src_ip: u32, dst_ip: u32, src_port: u16, dst_port: u16, protocol: u8, state: u32) {
  // Find existing connection
  var i: u32 = 0
  while i < connection_count {
    if connections[i].src_ip == src_ip and
       connections[i].dst_ip == dst_ip and
       connections[i].src_port == src_port and
       connections[i].dst_port == dst_port and
       connections[i].protocol == protocol {
      connections[i].packets = connections[i].packets + 1
      connections[i].timestamp = foundation.timer_get_ticks()
      
      if state == STATE_NEW {
        connections[i].state = STATE_ESTABLISHED
      }
      
      return
    }
    i = i + 1
  }
  
  // Add new connection
  if connection_count >= MAX_CONNECTIONS {
    firewall_cleanup_connections()
  }
  
  if connection_count < MAX_CONNECTIONS {
    connections[connection_count].src_ip = src_ip
    connections[connection_count].dst_ip = dst_ip
    connections[connection_count].src_port = src_port
    connections[connection_count].dst_port = dst_port
    connections[connection_count].protocol = protocol
    connections[connection_count].state = STATE_ESTABLISHED
    connections[connection_count].packets = 1
    connections[connection_count].bytes = 0
    connections[connection_count].timestamp = foundation.timer_get_ticks()
    connection_count = connection_count + 1
  }
}

fn firewall_cleanup_connections() {
  // Remove old connections
  var now: u64 = foundation.timer_get_ticks()
  var timeout: u64 = 300000  // 5 minutes
  
  var i: u32 = 0
  var j: u32 = 0
  
  while i < connection_count {
    if now - connections[i].timestamp < timeout {
      if i != j {
        connections[j] = connections[i]
      }
      j = j + 1
    }
    i = i + 1
  }
  
  connection_count = j
}

export fn firewall_enable() {
  firewall_enabled = 1
  foundation.serial_write_string("[Firewall] Enabled\n")
}

export fn firewall_disable() {
  firewall_enabled = 0
  foundation.serial_write_string("[Firewall] Disabled\n")
}

export fn firewall_is_enabled() -> u32 {
  return firewall_enabled
}

export fn firewall_get_rule_count() -> u32 {
  return rule_count
}

export fn firewall_get_connection_count() -> u32 {
  return connection_count
}

export fn firewall_get_stats(accepted: u64, dropped: u64, rejected: u64) {
  @intToPtr(accepted, u64) = packets_accepted
  @intToPtr(dropped, u64) = packets_dropped
  @intToPtr(rejected, u64) = packets_rejected
}

export fn firewall_clear_rules() {
  rule_count = 0
  foundation.serial_write_string("[Firewall] Rules cleared\n")
}

export fn firewall_clear_connections() {
  connection_count = 0
  foundation.serial_write_string("[Firewall] Connections cleared\n")
}

// Rate limiting
const MAX_RATE_ENTRIES: u32 = 1000

struct RateLimit {
  ip: u32,
  packets: u32,
  timestamp: u64
}

var rate_limits: [RateLimit; 1000]
var rate_limit_count: u32 = 0

export fn firewall_check_rate_limit(ip: u32, max_packets: u32, window_ms: u64) -> u32 {
  var now: u64 = foundation.timer_get_ticks()
  
  // Find existing entry
  var i: u32 = 0
  while i < rate_limit_count {
    if rate_limits[i].ip == ip {
      if now - rate_limits[i].timestamp < window_ms {
        rate_limits[i].packets = rate_limits[i].packets + 1
        
        if rate_limits[i].packets > max_packets {
          return 0  // Rate limit exceeded
        }
      } else {
        // Reset window
        rate_limits[i].packets = 1
        rate_limits[i].timestamp = now
      }
      
      return 1  // OK
    }
    i = i + 1
  }
  
  // Add new entry
  if rate_limit_count < MAX_RATE_ENTRIES {
    rate_limits[rate_limit_count].ip = ip
    rate_limits[rate_limit_count].packets = 1
    rate_limits[rate_limit_count].timestamp = now
    rate_limit_count = rate_limit_count + 1
  }
  
  return 1  // OK
}
