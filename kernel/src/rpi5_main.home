// HomeOS - Raspberry Pi 5 Kernel Entry Point
// Written in the Home programming language

// Import basics - Home's standard library
import basics/os/serial
import basics/os/dtb
import basics/drivers/bcm_gpio

// Kernel entry point - called by ARM64 bootloader
export fn kernel_main(dtb_addr: u64): never {
  // Initialize serial console for early debugging
  serial.init_uart0()
  serial.write("HomeOS booting on Raspberry Pi 5...\n")

  // Parse device tree to discover hardware
  let device_tree = dtb.parse(dtb_addr)

  // Display boot information
  print_banner()
  print_device_info(device_tree)

  // Initialize GPIO (BCM2712 for Pi 5)
  let gpio = bcm_gpio.init_rpi5()

  // Blink the status LED to show we're alive
  serial.write("Blinking status LED...\n")
  gpio.set_function(42, bcm_gpio.Output)

  let blink_count = 0
  loop {
    gpio.set_pin(42)
    busy_wait(5000000)
    gpio.clear_pin(42)
    busy_wait(5000000)

    blink_count = blink_count + 1
    if blink_count == 5 {
      serial.write("LED blink test complete!\n")
      break
    }
  }

  // Main kernel loop
  serial.write("Entering idle loop...\n")
  loop {
    // Wait for interrupt
    asm("wfe")
  }
}

fn print_banner() {
  serial.write("\n")
  serial.write("╔════════════════════════════════════════╗\n")
  serial.write("║     Home Operating System v0.1.0      ║\n")
  serial.write("║   Built with Home Programming Lang    ║\n")
  serial.write("║      Running on Raspberry Pi 5        ║\n")
  serial.write("╚════════════════════════════════════════╝\n")
  serial.write("\n")
}

fn print_device_info(dt: dtb.DeviceTree) {
  serial.write("=== Device Tree Information ===\n")

  // Get model name
  if dt.root.get_property("model") {
    let model = property.as_string()
    serial.write("Model: ")
    serial.write(model)
    serial.write("\n")
  }

  // Get memory information
  if dt.find_node("/memory") {
    let mem_node = node
    let memory_ranges = dtb.parse_memory(mem_node)

    serial.write("Memory regions:\n")
    for memory_ranges {
      serial.write("  0x")
      serial.write_hex(range.address)
      serial.write(" - 0x")
      serial.write_hex(range.address + range.size)
      serial.write(" (")
      serial.write_dec(range.size / (1024 * 1024))
      serial.write(" MB)\n")
    }
  }

  // Get CPU information
  if dt.find_node("/cpus") {
    let cpus_node = node
    let cpu_count = 0

    for cpus_node.children {
      if child.name.starts_with("cpu") {
        cpu_count = cpu_count + 1
      }
    }

    serial.write("CPUs detected: ")
    serial.write_dec(cpu_count)
    serial.write("\n")
  }

  serial.write("\n")
}

fn busy_wait(cycles: u32) {
  let i = 0
  loop {
    if i >= cycles {
      break
    }
    asm("nop")
    i = i + 1
  }
}
