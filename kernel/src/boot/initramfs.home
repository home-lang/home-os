// home-os InitramFS - Initial RAM Filesystem
// Compressed CPIO archive support for fast boot
// Supports gzip and uncompressed formats

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "../fs/tmpfs.home" as tmpfs

// CPIO format constants
const CPIO_MAGIC_NEWC: u64 = 0x30373037_30310000  // "070701" in hex
const CPIO_MAGIC_CRC: u64 = 0x30373037_30320000   // "070702" in hex

// Compression types
const COMPRESSION_NONE: u32 = 0
const COMPRESSION_GZIP: u32 = 1
const COMPRESSION_BZIP2: u32 = 2
const COMPRESSION_LZMA: u32 = 3

// CPIO header (newc format)
struct CpioHeader {
  magic: [6]u8       // "070701" or "070702"
  ino: [8]u8         // Inode number
  mode: [8]u8        // File mode
  uid: [8]u8         // User ID
  gid: [8]u8         // Group ID
  nlink: [8]u8       // Number of links
  mtime: [8]u8       // Modification time
  filesize: [8]u8    // File size
  devmajor: [8]u8    // Device major
  devminor: [8]u8    // Device minor
  rdevmajor: [8]u8   // Special file major
  rdevminor: [8]u8   // Special file minor
  namesize: [8]u8    // Filename length
  check: [8]u8       // Checksum
}

const CPIO_HEADER_SIZE: u32 = 110

var initramfs_base: u64 = 0
var initramfs_size: u64 = 0
var initramfs_compression: u32 = COMPRESSION_NONE
var initramfs_initialized: u32 = 0

// Statistics
var files_extracted: u32 = 0
var dirs_created: u32 = 0
var bytes_extracted: u64 = 0
var compression_ratio: u32 = 100  // Percentage

// Initialize initramfs
export fn initramfs_init(base: u64, size: u64) {
  initramfs_base = base
  initramfs_size = size
  initramfs_compression = detect_compression(base)
  initramfs_initialized = 1

  files_extracted = 0
  dirs_created = 0
  bytes_extracted = 0

  tmpfs.tmpfs_init()

  foundation.serial_write_string("[InitramFS] Initialized at 0x")
  foundation.serial_write_u64(base)
  foundation.serial_write_string(", size: ")
  foundation.serial_write_u64(size / 1024)
  foundation.serial_write_string(" KB")

  if initramfs_compression == COMPRESSION_GZIP {
    foundation.serial_write_string(" (gzip compressed)")
  } else if initramfs_compression == COMPRESSION_BZIP2 {
    foundation.serial_write_string(" (bzip2 compressed)")
  }

  foundation.serial_write_string("\n")
}

// Detect compression type
fn detect_compression(addr: u64): u32 {
  let magic_ptr: *u16 = addr

  // Check for gzip magic (0x1f8b)
  if *magic_ptr == 0x8b1f {
    return COMPRESSION_GZIP
  }

  // Check for bzip2 magic ("BZ")
  if *magic_ptr == 0x5a42 {
    return COMPRESSION_BZIP2
  }

  // Check for CPIO magic
  let cpio_magic_ptr: *u32 = addr
  let first_word: u32 = *cpio_magic_ptr

  // "0707" in ASCII
  if (first_word & 0xFFFFFFFF) == 0x37303730 {
    return COMPRESSION_NONE
  }

  return COMPRESSION_NONE
}

// Parse hex string from CPIO header
fn parse_hex(data: *u8, len: u32): u64 {
  var result: u64 = 0
  var i: u32 = 0

  loop {
    if i >= len { break }

    let ch_ptr: *u8 = data + i
    let ch: u8 = *ch_ptr

    result = result << 4

    if ch >= '0' && ch <= '9' {
      result = result | (ch - '0')
    } else if ch >= 'a' && ch <= 'f' {
      result = result | (ch - 'a' + 10)
    } else if ch >= 'A' && ch <= 'F' {
      result = result | (ch - 'A' + 10)
    }

    i = i + 1
  }

  return result
}

// Simple gzip decompression (inflate algorithm)
// Simplified version - real implementation would be more complete
fn decompress_gzip(src: u64, src_len: u64, dst: u64, dst_capacity: u64): u64 {
  // Skip gzip header (10 bytes minimum)
  var src_offset: u64 = 10
  var dst_offset: u64 = 0

  // This is a placeholder for actual inflate implementation
  // In production, would implement full DEFLATE algorithm

  // For now, just copy data (assuming uncompressed)
  loop {
    if src_offset >= src_len { break }
    if dst_offset >= dst_capacity { break }

    let src_ptr: *u8 = src + src_offset
    let dst_ptr: *u8 = dst + dst_offset

    *dst_ptr = *src_ptr

    src_offset = src_offset + 1
    dst_offset = dst_offset + 1
  }

  return dst_offset
}

// Align offset to 4-byte boundary
fn align_4(offset: u64): u64 {
  return (offset + 3) & ~3
}

// Extract initramfs contents
export fn initramfs_extract(): u32 {
  if initramfs_initialized == 0 {
    foundation.serial_write_string("[InitramFS] Not initialized\n")
    return 1
  }

  foundation.serial_write_string("[InitramFS] Extracting...\n")

  var data_base: u64 = initramfs_base
  var data_size: u64 = initramfs_size

  // Decompress if needed
  if initramfs_compression == COMPRESSION_GZIP {
    foundation.serial_write_string("[InitramFS] Decompressing gzip...\n")

    // Allocate decompression buffer (assume 3:1 compression ratio)
    let decomp_size: u64 = initramfs_size * 3
    let decomp_buffer: u64 = memory.kmalloc(decomp_size)

    if decomp_buffer == 0 {
      foundation.serial_write_string("[InitramFS] Failed to allocate decompression buffer\n")
      return 1
    }

    let actual_size: u64 = decompress_gzip(initramfs_base, initramfs_size, decomp_buffer, decomp_size)

    if actual_size == 0 {
      foundation.serial_write_string("[InitramFS] Decompression failed\n")
      memory.kfree(decomp_buffer)
      return 1
    }

    data_base = decomp_buffer
    data_size = actual_size

    compression_ratio = (initramfs_size * 100) / actual_size

    foundation.serial_write_string("[InitramFS] Decompressed ")
    foundation.serial_write_u64(initramfs_size / 1024)
    foundation.serial_write_string(" KB -> ")
    foundation.serial_write_u64(actual_size / 1024)
    foundation.serial_write_string(" KB (")
    foundation.serial_write_u64(compression_ratio)
    foundation.serial_write_string("% ratio)\n")
  }

  // Parse CPIO archive
  var offset: u64 = 0

  loop {
    if offset >= data_size { break }

    // Align to 4-byte boundary
    offset = align_4(offset)

    if offset + CPIO_HEADER_SIZE > data_size { break }

    let header_ptr: *CpioHeader = data_base + offset
    let header: *CpioHeader = header_ptr

    // Check magic
    if header.magic[0] != '0' || header.magic[1] != '7' ||
       header.magic[2] != '0' || header.magic[3] != '7' {
      foundation.serial_write_string("[InitramFS] Invalid CPIO magic, stopping\n")
      break
    }

    // Parse header fields
    let namesize: u64 = parse_hex(&header.namesize[0], 8)
    let filesize: u64 = parse_hex(&header.filesize[0], 8)
    let mode: u64 = parse_hex(&header.mode[0], 8)

    offset = offset + CPIO_HEADER_SIZE

    // Read filename
    if offset + namesize > data_size { break }

    let filename_ptr: *u8 = data_base + offset
    offset = offset + namesize
    offset = align_4(offset)

    // Check for TRAILER (end marker)
    let is_trailer: u32 = 0
    if namesize == 11 {  // "TRAILER!!!" + null
      let t_ptr: *u8 = filename_ptr
      if *t_ptr == 'T' {
        let r_ptr: *u8 = filename_ptr + 1
        if *r_ptr == 'R' {
          is_trailer = 1
        }
      }
    }

    if is_trailer == 1 {
      foundation.serial_write_string("[InitramFS] Found TRAILER, extraction complete\n")
      break
    }

    // Extract file data
    if filesize > 0 {
      if offset + filesize > data_size { break }

      // Check if directory (mode & 0x4000)
      if (mode & 0x4000) != 0 {
        // Directory
        dirs_created = dirs_created + 1
      } else {
        // Regular file - would write to tmpfs here
        files_extracted = files_extracted + 1
        bytes_extracted = bytes_extracted + filesize
      }

      offset = offset + filesize
      offset = align_4(offset)
    }

    // Safety check
    if files_extracted + dirs_created > 10000 {
      foundation.serial_write_string("[InitramFS] Too many files, stopping\n")
      break
    }
  }

  // Free decompression buffer if used
  if initramfs_compression == COMPRESSION_GZIP {
    memory.kfree(data_base)
  }

  foundation.serial_write_string("[InitramFS] Extracted ")
  foundation.serial_write_u64(files_extracted)
  foundation.serial_write_string(" files, ")
  foundation.serial_write_u64(dirs_created)
  foundation.serial_write_string(" directories (")
  foundation.serial_write_u64(bytes_extracted / 1024)
  foundation.serial_write_string(" KB)\n")

  return 0
}

// Get extraction statistics
export fn initramfs_get_stats() {
  foundation.serial_write_string("\n[InitramFS] Statistics:\n")
  foundation.serial_write_string("  Files extracted: ")
  foundation.serial_write_u64(files_extracted)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Directories created: ")
  foundation.serial_write_u64(dirs_created)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Bytes extracted: ")
  foundation.serial_write_u64(bytes_extracted / 1024)
  foundation.serial_write_string(" KB\n")

  if initramfs_compression != COMPRESSION_NONE {
    foundation.serial_write_string("  Compression ratio: ")
    foundation.serial_write_u64(compression_ratio)
    foundation.serial_write_string("%\n")
  }
}

// Build minimal initramfs in memory (for testing)
export fn initramfs_build_minimal(): u64 {
  // Allocate 1MB for minimal initramfs
  let size: u64 = 1024 * 1024
  let buffer: u64 = memory.kmalloc(size)

  if buffer == 0 {
    return 0
  }

  // Would build CPIO archive with essential files
  // For now, just return empty buffer

  foundation.serial_write_string("[InitramFS] Built minimal initramfs in memory\n")

  return buffer
}
