// home-os Kernel - System Updates
// Atomic updates with rollback capability

import "../core/foundation.home" as foundation
import "../core/filesystem.home" as filesystem

const MAX_UPDATE_SLOTS: u32 = 2

struct UpdateSlot {
  version: [u8; 32],
  active: u32,
  bootable: u32,
  successful: u32,
  tries_remaining: u32
}

var update_slots: [UpdateSlot; 2]
var current_slot: u32 = 0
var update_initialized: u32 = 0

export fn update_init() {
  if update_initialized == 1 { return }
  
  // Initialize slots
  update_slots[0].active = 1
  update_slots[0].bootable = 1
  update_slots[0].successful = 1
  update_slots[0].tries_remaining = 3
  
  update_slots[1].active = 0
  update_slots[1].bootable = 0
  update_slots[1].successful = 0
  update_slots[1].tries_remaining = 3
  
  current_slot = 0
  
  update_initialized = 1
  foundation.serial_write_string("[Update] System update manager initialized\n")
}

export fn update_check() -> u32 {
  foundation.serial_write_string("[Update] Checking for updates...\n")
  
  // Check update server
  // Compare versions
  
  return 0  // No updates available
}

export fn update_download(version: u64) -> u32 {
  foundation.serial_write_string("[Update] Downloading update: ")
  foundation.serial_write_string(version)
  foundation.serial_write_string("\n")
  
  // Download update package
  // Verify signature
  // Extract to inactive slot
  
  return 1
}

export fn update_apply() -> u32 {
  foundation.serial_write_string("[Update] Applying update...\n")
  
  var inactive_slot: u32 = 1 - current_slot
  
  // Copy new system to inactive slot
  // Update bootloader
  
  update_slots[inactive_slot].bootable = 1
  update_slots[inactive_slot].tries_remaining = 3
  
  foundation.serial_write_string("[Update] Update applied. Reboot to activate.\n")
  
  return 1
}

export fn update_rollback() -> u32 {
  foundation.serial_write_string("[Update] Rolling back to previous version...\n")
  
  var previous_slot: u32 = 1 - current_slot
  
  if update_slots[previous_slot].bootable == 0 {
    foundation.serial_write_string("[Update] No previous version available\n")
    return 0
  }
  
  // Switch to previous slot
  update_slots[previous_slot].active = 1
  update_slots[current_slot].active = 0
  
  foundation.serial_write_string("[Update] Rollback complete. Reboot required.\n")
  
  return 1
}

export fn update_mark_successful() {
  update_slots[current_slot].successful = 1
  update_slots[current_slot].tries_remaining = 3
  
  foundation.serial_write_string("[Update] Current version marked as successful\n")
}

export fn update_get_version(slot: u32, version_out: u64) -> u32 {
  if slot >= MAX_UPDATE_SLOTS { return 0 }
  
  var i: u32 = 0
  while i < 32 {
    @intToPtr(version_out + i, u8) = update_slots[slot].version[i]
    i = i + 1
  }
  
  return 1
}
