// Kernel Heap Allocator for home-os
// Simple bump allocator for now, will be replaced with buddy/slab later
// Based on Home's kernel package: ~/Code/home/packages/kernel/src/kheap.zig

import serial from "./serial.home"

// Heap configuration
let HEAP_START: usize = 0x100000  // Start at 1MB
let HEAP_SIZE: usize = 0x100000   // 1MB heap for now
let HEAP_END: usize = HEAP_START + HEAP_SIZE

// Current heap position (bump allocator)
let heap_current: usize = HEAP_START
let heap_allocated: usize = 0

// Heap block header (for tracking allocations)
struct HeapBlock {
    size: usize,
    used: bool,
    magic: u32,  // Magic number for validation (0xDEADBEEF)
}

let HEAP_MAGIC: u32 = 0xDEADBEEF
let BLOCK_HEADER_SIZE: usize = 16  // sizeof(HeapBlock)

// Initialize heap
export fn init() {
    serial.writeString("Initializing kernel heap...\n")
    serial.writeString("Heap start: ")
    serial.writeHex(HEAP_START)
    serial.writeString("\n")
    serial.writeString("Heap size: ")
    serial.writeHex(HEAP_SIZE)
    serial.writeString("\n")

    heap_current = HEAP_START
    heap_allocated = 0

    serial.writeString("Kernel heap initialized!\n")
}

// Allocate memory from heap
export fn alloc(size: usize): *u8 {
    // Align size to 8 bytes
    let aligned_size = (size + 7) & ~7

    // Check if we have enough space
    let total_size = BLOCK_HEADER_SIZE + aligned_size
    if heap_current + total_size > HEAP_END {
        serial.writeString("ERROR: Heap out of memory!\n")
        serial.writeString("Requested: ")
        serial.writeHex(total_size)
        serial.writeString(" bytes\n")
        serial.writeString("Available: ")
        serial.writeHex(HEAP_END - heap_current)
        serial.writeString(" bytes\n")
        return @ptrFromInt(0)  // Return null
    }

    // Create block header
    let header: *HeapBlock = @ptrFromInt(heap_current)
    header.size = aligned_size
    header.used = true
    header.magic = HEAP_MAGIC

    // Move heap pointer
    let data_ptr = heap_current + BLOCK_HEADER_SIZE
    heap_current = heap_current + total_size
    heap_allocated = heap_allocated + aligned_size

    return @ptrFromInt(data_ptr)
}

// Allocate zeroed memory
export fn calloc(count: usize, size: usize): *u8 {
    let total_size = count * size
    let ptr = alloc(total_size)

    if @intFromPtr(ptr) == 0 {
        return ptr
    }

    // Zero out the memory
    let bytes: [*]u8 = @ptrCast(ptr)
    let i = 0
    loop {
        if i >= total_size {
            break
        }
        bytes[i] = 0
        i = i + 1
    }

    return ptr
}

// Free memory (simplified - just marks as unused for now)
export fn free(ptr: *u8) {
    if @intFromPtr(ptr) == 0 {
        return
    }

    // Get block header
    let header_addr = @intFromPtr(ptr) - BLOCK_HEADER_SIZE
    let header: *HeapBlock = @ptrFromInt(header_addr)

    // Validate magic number
    if header.magic != HEAP_MAGIC {
        serial.writeString("ERROR: Invalid heap block magic!\n")
        return
    }

    // Mark as unused
    header.used = false
    heap_allocated = heap_allocated - header.size
}

// Reallocate memory
export fn realloc(ptr: *u8, new_size: usize): *u8 {
    if @intFromPtr(ptr) == 0 {
        return alloc(new_size)
    }

    // Get old block header
    let header_addr = @intFromPtr(ptr) - BLOCK_HEADER_SIZE
    let header: *HeapBlock = @ptrFromInt(header_addr)

    // Validate magic number
    if header.magic != HEAP_MAGIC {
        serial.writeString("ERROR: Invalid heap block magic in realloc!\n")
        return @ptrFromInt(0)
    }

    let old_size = header.size

    // If new size is smaller or same, just return same pointer
    if new_size <= old_size {
        return ptr
    }

    // Allocate new block
    let new_ptr = alloc(new_size)
    if @intFromPtr(new_ptr) == 0 {
        return new_ptr
    }

    // Copy old data to new block
    let src: [*]u8 = @ptrCast(ptr)
    let dst: [*]u8 = @ptrCast(new_ptr)
    let i = 0
    loop {
        if i >= old_size {
            break
        }
        dst[i] = src[i]
        i = i + 1
    }

    // Free old block
    free(ptr)

    return new_ptr
}

// Get heap statistics
export fn getStats(): struct { allocated: usize, used: usize, free: usize } {
    return .{
        .allocated = heap_current - HEAP_START,
        .used = heap_allocated,
        .free = HEAP_END - heap_current,
    }
}

// Print heap statistics
export fn printStats() {
    let stats = getStats()

    serial.writeString("Heap Statistics:\n")
    serial.writeString("  Total allocated: ")
    serial.writeHex(stats.allocated)
    serial.writeString(" bytes\n")
    serial.writeString("  In use: ")
    serial.writeHex(stats.used)
    serial.writeString(" bytes\n")
    serial.writeString("  Free: ")
    serial.writeHex(stats.free)
    serial.writeString(" bytes\n")
}
