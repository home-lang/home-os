// home-os Memory Audit Tool
// Audits and reports on kernel memory footprint
// Target: <50MB kernel memory usage

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

// Memory region tracking
struct MemoryRegion {
  name: *u8           // Region name
  start_addr: u64     // Start address
  size: u64           // Size in bytes
  usage: u64          // Current usage
  flags: u32          // Region flags
}

// Memory flags
const MEM_KERNEL_CODE: u32 = 1 << 0
const MEM_KERNEL_DATA: u32 = 1 << 1
const MEM_KERNEL_BSS: u32 = 1 << 2
const MEM_KERNEL_HEAP: u32 = 1 << 3
const MEM_KERNEL_STACK: u32 = 1 << 4
const MEM_DRIVER_DATA: u32 = 1 << 5
const MEM_BUFFER_CACHE: u32 = 1 << 6
const MEM_PAGE_TABLES: u32 = 1 << 7

const MAX_REGIONS: u32 = 64

var regions: [MAX_REGIONS]MemoryRegion
var region_count: u32 = 0

// Module memory tracking
struct ModuleMemory {
  module_name: *u8
  static_size: u64
  heap_usage: u64
  should_lazy_load: u32  // Can this be lazy loaded?
  is_essential: u32      // Required for boot?
}

const MAX_MODULES: u32 = 256

var modules: [MAX_MODULES]ModuleMemory
var module_count: u32 = 0

// Initialize memory audit
export fn memory_audit_init() {
  region_count = 0
  module_count = 0

  foundation.serial_write_string("[Memory Audit] Initialized\n")
}

// Register a memory region
export fn memory_audit_register_region(name: *u8, start: u64, size: u64, flags: u32) {
  if region_count >= MAX_REGIONS {
    foundation.serial_write_string("[Memory Audit] Too many regions\n")
    return
  }

  let region: *MemoryRegion = &regions[region_count]
  region.name = name
  region.start_addr = start
  region.size = size
  region.usage = 0
  region.flags = flags

  region_count = region_count + 1
}

// Update region usage
export fn memory_audit_update_usage(region_idx: u32, usage: u64) {
  if region_idx >= region_count { return }

  regions[region_idx].usage = usage
}

// Register a module
export fn memory_audit_register_module(
  name: *u8,
  static_size: u64,
  is_essential: u32,
  should_lazy_load: u32
) {
  if module_count >= MAX_MODULES {
    foundation.serial_write_string("[Memory Audit] Too many modules\n")
    return
  }

  let module: *ModuleMemory = &modules[module_count]
  module.module_name = name
  module.static_size = static_size
  module.heap_usage = 0
  module.should_lazy_load = should_lazy_load
  module.is_essential = is_essential

  module_count = module_count + 1
}

// Update module heap usage
export fn memory_audit_update_module_heap(module_idx: u32, heap_usage: u64) {
  if module_idx >= module_count { return }

  modules[module_idx].heap_usage = heap_usage
}

// Calculate total kernel footprint
fn calculate_total_footprint(): u64 {
  var total: u64 = 0
  var i: u32 = 0

  loop {
    if i >= region_count { break }

    total = total + regions[i].usage
    i = i + 1
  }

  return total
}

// Calculate non-essential memory
fn calculate_non_essential_memory(): u64 {
  var total: u64 = 0
  var i: u32 = 0

  loop {
    if i >= module_count { break }

    if modules[i].is_essential == 0 {
      total = total + modules[i].static_size + modules[i].heap_usage
    }

    i = i + 1
  }

  return total
}

// Calculate lazy-loadable memory
fn calculate_lazy_loadable_memory(): u64 {
  var total: u64 = 0
  var i: u32 = 0

  loop {
    if i >= module_count { break }

    if modules[i].should_lazy_load == 1 {
      total = total + modules[i].static_size + modules[i].heap_usage
    }

    i = i + 1
  }

  return total
}

// Print memory report
export fn memory_audit_print_report() {
  foundation.serial_write_string("\n========== KERNEL MEMORY AUDIT ==========\n\n")

  // Region breakdown
  foundation.serial_write_string("Memory Regions:\n")

  var i: u32 = 0
  loop {
    if i >= region_count { break }

    let region: *MemoryRegion = &regions[i]

    foundation.serial_write_string("  ")
    foundation.serial_write_string(region.name)
    foundation.serial_write_string(": ")
    foundation.serial_write_u64(region.usage / 1024)
    foundation.serial_write_string(" KB / ")
    foundation.serial_write_u64(region.size / 1024)
    foundation.serial_write_string(" KB")

    if region.usage > 0 && region.size > 0 {
      let percent: u64 = (region.usage * 100) / region.size
      foundation.serial_write_string(" (")
      foundation.serial_write_u64(percent)
      foundation.serial_write_string("%)")
    }

    foundation.serial_write_string("\n")

    i = i + 1
  }

  // Total footprint
  let total_kb: u64 = calculate_total_footprint() / 1024
  let total_mb: u64 = total_kb / 1024

  foundation.serial_write_string("\nTotal Kernel Footprint: ")
  foundation.serial_write_u64(total_mb)
  foundation.serial_write_string(" MB (")
  foundation.serial_write_u64(total_kb)
  foundation.serial_write_string(" KB)\n")

  // Target check
  if total_mb < 50 {
    foundation.serial_write_string("Status: UNDER TARGET (<50MB) ✓\n")
  } else {
    foundation.serial_write_string("Status: OVER TARGET (>50MB) ✗\n")
  }

  // Optimization opportunities
  let non_essential_kb: u64 = calculate_non_essential_memory() / 1024
  let lazy_loadable_kb: u64 = calculate_lazy_loadable_memory() / 1024

  foundation.serial_write_string("\nOptimization Opportunities:\n")
  foundation.serial_write_string("  Non-essential modules: ")
  foundation.serial_write_u64(non_essential_kb)
  foundation.serial_write_string(" KB (can be removed for minimal builds)\n")

  foundation.serial_write_string("  Lazy-loadable modules: ")
  foundation.serial_write_u64(lazy_loadable_kb)
  foundation.serial_write_string(" KB (can be deferred)\n")

  // Module breakdown
  foundation.serial_write_string("\nTop Memory Users (Modules):\n")

  // Simple bubble sort to find top users
  var sorted_indices: [MAX_MODULES]u32
  var j: u32 = 0
  loop {
    if j >= module_count { break }
    sorted_indices[j] = j
    j = j + 1
  }

  // Sort by total memory (static + heap)
  var sorted: u32 = 0
  loop {
    if sorted == 1 { break }
    sorted = 1

    j = 0
    loop {
      if j >= module_count - 1 { break }

      let idx_a: u32 = sorted_indices[j]
      let idx_b: u32 = sorted_indices[j + 1]

      let total_a: u64 = modules[idx_a].static_size + modules[idx_a].heap_usage
      let total_b: u64 = modules[idx_b].static_size + modules[idx_b].heap_usage

      if total_a < total_b {
        sorted_indices[j] = idx_b
        sorted_indices[j + 1] = idx_a
        sorted = 0
      }

      j = j + 1
    }
  }

  // Print top 10
  var printed: u32 = 0
  j = 0
  loop {
    if j >= module_count { break }
    if printed >= 10 { break }

    let idx: u32 = sorted_indices[j]
    let module: *ModuleMemory = &modules[idx]
    let total: u64 = module.static_size + module.heap_usage

    if total > 0 {
      foundation.serial_write_string("  ")
      foundation.serial_write_u64(printed + 1)
      foundation.serial_write_string(". ")
      foundation.serial_write_string(module.module_name)
      foundation.serial_write_string(": ")
      foundation.serial_write_u64(total / 1024)
      foundation.serial_write_string(" KB")

      if module.should_lazy_load == 1 {
        foundation.serial_write_string(" [LAZY-LOADABLE]")
      }

      if module.is_essential == 0 {
        foundation.serial_write_string(" [NON-ESSENTIAL]")
      }

      foundation.serial_write_string("\n")

      printed = printed + 1
    }

    j = j + 1
  }

  foundation.serial_write_string("\n=========================================\n\n")
}

// Print compact summary
export fn memory_audit_print_summary() {
  let total_kb: u64 = calculate_total_footprint() / 1024
  let total_mb: u64 = total_kb / 1024

  foundation.serial_write_string("[Memory] Kernel footprint: ")
  foundation.serial_write_u64(total_mb)
  foundation.serial_write_string(" MB")

  if total_mb < 50 {
    foundation.serial_write_string(" ✓\n")
  } else {
    foundation.serial_write_string(" (target: <50MB)\n")
  }
}

// Get list of modules that should be removed for minimal build
export fn memory_audit_get_minimal_build_exclusions() {
  foundation.serial_write_string("\n[Memory Audit] Minimal Build Exclusions:\n")
  foundation.serial_write_string("Remove these modules for headless/minimal builds:\n\n")

  var i: u32 = 0
  var excluded_kb: u64 = 0

  loop {
    if i >= module_count { break }

    let module: *ModuleMemory = &modules[i]

    if module.is_essential == 0 {
      let total: u64 = module.static_size + module.heap_usage

      foundation.serial_write_string("  - ")
      foundation.serial_write_string(module.module_name)
      foundation.serial_write_string(" (")
      foundation.serial_write_u64(total / 1024)
      foundation.serial_write_string(" KB)\n")

      excluded_kb = excluded_kb + (total / 1024)
    }

    i = i + 1
  }

  foundation.serial_write_string("\nTotal savings: ")
  foundation.serial_write_u64(excluded_kb)
  foundation.serial_write_string(" KB (")
  foundation.serial_write_u64(excluded_kb / 1024)
  foundation.serial_write_string(" MB)\n\n")
}

// Get list of modules that can be lazy-loaded
export fn memory_audit_get_lazy_load_candidates() {
  foundation.serial_write_string("\n[Memory Audit] Lazy Load Candidates:\n")
  foundation.serial_write_string("These modules can be loaded on-demand:\n\n")

  var i: u32 = 0
  var deferred_kb: u64 = 0

  loop {
    if i >= module_count { break }

    let module: *ModuleMemory = &modules[i]

    if module.should_lazy_load == 1 {
      let total: u64 = module.static_size + module.heap_usage

      foundation.serial_write_string("  - ")
      foundation.serial_write_string(module.module_name)
      foundation.serial_write_string(" (")
      foundation.serial_write_u64(total / 1024)
      foundation.serial_write_string(" KB)\n")

      deferred_kb = deferred_kb + (total / 1024)
    }

    i = i + 1
  }

  foundation.serial_write_string("\nTotal boot memory savings: ")
  foundation.serial_write_u64(deferred_kb)
  foundation.serial_write_string(" KB (")
  foundation.serial_write_u64(deferred_kb / 1024)
  foundation.serial_write_string(" MB)\n\n")
}
