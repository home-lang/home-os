// home-os Kernel Panic Handler
// Handles unrecoverable errors with detailed diagnostics
// Provides stack traces and system state dumps

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "../arch/arm64/exceptions.home" as exceptions

// Panic reasons
const PANIC_GENERAL: u32 = 0
const PANIC_ASSERTION: u32 = 1
const PANIC_OUT_OF_MEMORY: u32 = 2
const PANIC_STACK_OVERFLOW: u32 = 3
const PANIC_NULL_POINTER: u32 = 4
const PANIC_DIVIDE_BY_ZERO: u32 = 5
const PANIC_INVALID_OPCODE: u32 = 6
const PANIC_PAGE_FAULT: u32 = 7
const PANIC_DOUBLE_FAULT: u32 = 8
const PANIC_HARDWARE_FAULT: u32 = 9

// Maximum stack frames to unwind
const MAX_STACK_FRAMES: u32 = 32

// Panic information
struct PanicInfo {
  reason: u32
  message: *u8
  file: *u8
  line: u32
  function: *u8
  pc: u64           // Program counter
  sp: u64           // Stack pointer
  fp: u64           // Frame pointer
  lr: u64           // Link register
}

var panic_occurred: u32 = 0
var panic_count: u32 = 0
var last_panic: PanicInfo

// Stack frame for unwinding
struct StackFrame {
  fp: u64
  lr: u64
}

// Get reason string
fn get_panic_reason_string(reason: u32): *u8 {
  if reason == PANIC_GENERAL {
    return "General panic"
  } else if reason == PANIC_ASSERTION {
    return "Assertion failed"
  } else if reason == PANIC_OUT_OF_MEMORY {
    return "Out of memory"
  } else if reason == PANIC_STACK_OVERFLOW {
    return "Stack overflow"
  } else if reason == PANIC_NULL_POINTER {
    return "Null pointer dereference"
  } else if reason == PANIC_DIVIDE_BY_ZERO {
    return "Division by zero"
  } else if reason == PANIC_INVALID_OPCODE {
    return "Invalid opcode"
  } else if reason == PANIC_PAGE_FAULT {
    return "Page fault"
  } else if reason == PANIC_DOUBLE_FAULT {
    return "Double fault"
  } else if reason == PANIC_HARDWARE_FAULT {
    return "Hardware fault"
  } else {
    return "Unknown panic"
  }
}

// Print panic header
fn panic_print_header(info: *PanicInfo) {
  foundation.serial_write_string("\n")
  foundation.serial_write_string("================================================================================\n")
  foundation.serial_write_string("                           KERNEL PANIC\n")
  foundation.serial_write_string("================================================================================\n")
  foundation.serial_write_string("\n")

  foundation.serial_write_string("Reason: ")
  foundation.serial_write_string(get_panic_reason_string(info.reason))
  foundation.serial_write_string("\n")

  if info.message != 0 {
    foundation.serial_write_string("Message: ")
    foundation.serial_write_string(info.message)
    foundation.serial_write_string("\n")
  }

  if info.file != 0 {
    foundation.serial_write_string("Location: ")
    foundation.serial_write_string(info.file)
    foundation.serial_write_string(":")
    foundation.serial_write_u64(info.line)
    foundation.serial_write_string("\n")
  }

  if info.function != 0 {
    foundation.serial_write_string("Function: ")
    foundation.serial_write_string(info.function)
    foundation.serial_write_string("\n")
  }

  foundation.serial_write_string("\n")
}

// Print register state
fn panic_print_registers(info: *PanicInfo) {
  foundation.serial_write_string("Register State:\n")

  foundation.serial_write_string("  PC: 0x")
  foundation.serial_write_hex(info.pc)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  SP: 0x")
  foundation.serial_write_hex(info.sp)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  FP: 0x")
  foundation.serial_write_hex(info.fp)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  LR: 0x")
  foundation.serial_write_hex(info.lr)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("\n")
}

// Unwind and print stack trace
fn panic_print_stack_trace(info: *PanicInfo) {
  foundation.serial_write_string("Stack Trace:\n")

  var frame_count: u32 = 0
  var fp: u64 = info.fp
  var lr: u64 = info.lr

  // Print initial frame
  foundation.serial_write_string("  #")
  foundation.serial_write_u64(frame_count)
  foundation.serial_write_string(": 0x")
  foundation.serial_write_hex(info.pc)
  foundation.serial_write_string("\n")

  frame_count = frame_count + 1

  // Unwind stack frames
  loop {
    if frame_count >= MAX_STACK_FRAMES { break }
    if fp == 0 || lr == 0 { break }

    // Validate frame pointer (basic sanity check)
    if fp < 0x1000 || fp > 0xFFFFFFFFFFFF0000 {
      foundation.serial_write_string("  [Invalid frame pointer, stopping]\n")
      break
    }

    foundation.serial_write_string("  #")
    foundation.serial_write_u64(frame_count)
    foundation.serial_write_string(": 0x")
    foundation.serial_write_hex(lr)
    foundation.serial_write_string("\n")

    // Read next frame
    // ARM64 frame layout: [FP, LR] at FP address
    let prev_fp: u64 = memory.read_u64(fp)
    let prev_lr: u64 = memory.read_u64(fp + 8)

    if prev_fp == fp {
      foundation.serial_write_string("  [Stack loop detected, stopping]\n")
      break
    }

    fp = prev_fp
    lr = prev_lr
    frame_count = frame_count + 1
  }

  foundation.serial_write_string("\n")
  foundation.serial_write_string("Total frames: ")
  foundation.serial_write_u64(frame_count)
  foundation.serial_write_string("\n\n")
}

// Print memory around addresses
fn panic_print_memory(addr: u64, label: *u8) {
  foundation.serial_write_string("Memory near ")
  foundation.serial_write_string(label)
  foundation.serial_write_string(" (0x")
  foundation.serial_write_hex(addr)
  foundation.serial_write_string("):\n")

  // Print 8 lines of 16 bytes each
  var line: u32 = 0
  loop {
    if line >= 8 { break }

    let line_addr: u64 = addr + (line * 16) as u64 - 64
    foundation.serial_write_string("  0x")
    foundation.serial_write_hex(line_addr)
    foundation.serial_write_string(": ")

    var col: u32 = 0
    loop {
      if col >= 16 { break }

      let byte_addr: u64 = line_addr + col as u64
      let byte: u8 = memory.read_u8(byte_addr)

      foundation.serial_write_hex_byte(byte)
      foundation.serial_write_string(" ")

      col = col + 1
    }

    foundation.serial_write_string("\n")
    line = line + 1
  }

  foundation.serial_write_string("\n")
}

// Print system information
fn panic_print_system_info() {
  foundation.serial_write_string("System Information:\n")

  foundation.serial_write_string("  Panic count: ")
  foundation.serial_write_u64(panic_count)
  foundation.serial_write_string("\n")

  // Would include: uptime, memory usage, CPU info, etc.
  foundation.serial_write_string("\n")
}

// Main panic handler
export fn panic(reason: u32, message: *u8, file: *u8, line: u32, function: *u8) {
  // Disable interrupts
  exceptions.disable_irq()
  exceptions.disable_fiq()

  panic_count = panic_count + 1

  // Check for double panic
  if panic_occurred == 1 {
    foundation.serial_write_string("\n\n!!! DOUBLE PANIC !!!\n")
    foundation.serial_write_string("System halted.\n")
    loop {
      foundation.nop()
    }
  }

  panic_occurred = 1

  // Gather panic information
  last_panic.reason = reason
  last_panic.message = message
  last_panic.file = file
  last_panic.line = line
  last_panic.function = function

  // Read current registers (would use assembly)
  // For now, use placeholder values
  last_panic.pc = 0  // Would read from exception frame or current PC
  last_panic.sp = 0  // Would read from SP register
  last_panic.fp = 0  // Would read from FP register
  last_panic.lr = 0  // Would read from LR register

  // Print panic information
  panic_print_header(&last_panic)
  panic_print_registers(&last_panic)

  // Print stack trace
  if last_panic.fp != 0 {
    panic_print_stack_trace(&last_panic)
  }

  // Print memory dumps
  if last_panic.pc != 0 {
    panic_print_memory(last_panic.pc, "PC")
  }

  if last_panic.sp != 0 {
    panic_print_memory(last_panic.sp, "SP")
  }

  panic_print_system_info()

  foundation.serial_write_string("================================================================================\n")
  foundation.serial_write_string("System halted. Please reboot.\n")
  foundation.serial_write_string("================================================================================\n")

  // Halt system
  loop {
    exceptions.wait_for_interrupt()
  }
}

// Panic with formatted message
export fn panic_fmt(reason: u32, file: *u8, line: u32, function: *u8) {
  panic(reason, 0, file, line, function)
}

// Assert macro helper
export fn panic_assert(condition: u32, message: *u8, file: *u8, line: u32) {
  if condition == 0 {
    panic(PANIC_ASSERTION, message, file, line, "assert")
  }
}

// Panic on out of memory
export fn panic_oom(file: *u8, line: u32) {
  panic(PANIC_OUT_OF_MEMORY, "Kernel out of memory", file, line, "malloc")
}

// Panic on null pointer
export fn panic_null_ptr(file: *u8, line: u32) {
  panic(PANIC_NULL_POINTER, "Null pointer dereference", file, line, 0)
}

// Panic on page fault
export fn panic_page_fault(addr: u64, file: *u8, line: u32) {
  // Store fault address for diagnostics
  panic(PANIC_PAGE_FAULT, "Page fault", file, line, 0)
}

// Check if panic occurred
export fn panic_has_occurred(): u32 {
  return panic_occurred
}

// Get panic count
export fn panic_get_count(): u32 {
  return panic_count
}

// Get last panic info
export fn panic_get_last_info(): *PanicInfo {
  return &last_panic
}

// Print panic history
export fn panic_print_history() {
  if panic_count == 0 {
    foundation.serial_write_string("[PANIC] No panics recorded\n")
    return
  }

  foundation.serial_write_string("\n[PANIC] Panic History:\n")
  foundation.serial_write_string("  Total panics: ")
  foundation.serial_write_u64(panic_count)
  foundation.serial_write_string("\n")

  if last_panic.message != 0 {
    foundation.serial_write_string("  Last panic: ")
    foundation.serial_write_string(get_panic_reason_string(last_panic.reason))
    foundation.serial_write_string("\n")

    if last_panic.file != 0 {
      foundation.serial_write_string("  Location: ")
      foundation.serial_write_string(last_panic.file)
      foundation.serial_write_string(":")
      foundation.serial_write_u64(last_panic.line)
      foundation.serial_write_string("\n")
    }
  }
}
