// home-os Kernel Panic Handler
// Handles unrecoverable errors with detailed diagnostics
// Provides stack traces and system state dumps

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "../arch/arm64/exceptions.home" as exceptions

// Panic reasons
const PANIC_GENERAL: u32 = 0
const PANIC_ASSERTION: u32 = 1
const PANIC_OUT_OF_MEMORY: u32 = 2
const PANIC_STACK_OVERFLOW: u32 = 3
const PANIC_NULL_POINTER: u32 = 4
const PANIC_DIVIDE_BY_ZERO: u32 = 5
const PANIC_INVALID_OPCODE: u32 = 6
const PANIC_PAGE_FAULT: u32 = 7
const PANIC_DOUBLE_FAULT: u32 = 8
const PANIC_HARDWARE_FAULT: u32 = 9

// Maximum stack frames to unwind
const MAX_STACK_FRAMES: u32 = 32

// Panic information
struct PanicInfo {
  reason: u32
  message: *u8
  file: *u8
  line: u32
  function: *u8
  pc: u64           // Program counter
  sp: u64           // Stack pointer
  fp: u64           // Frame pointer
  lr: u64           // Link register
}

var panic_occurred: u32 = 0
var panic_count: u32 = 0
var last_panic: PanicInfo

// Stack frame for unwinding
struct StackFrame {
  fp: u64
  lr: u64
}

// Get reason string
fn get_panic_reason_string(reason: u32): *u8 {
  if reason == PANIC_GENERAL {
    return "General panic"
  } else if reason == PANIC_ASSERTION {
    return "Assertion failed"
  } else if reason == PANIC_OUT_OF_MEMORY {
    return "Out of memory"
  } else if reason == PANIC_STACK_OVERFLOW {
    return "Stack overflow"
  } else if reason == PANIC_NULL_POINTER {
    return "Null pointer dereference"
  } else if reason == PANIC_DIVIDE_BY_ZERO {
    return "Division by zero"
  } else if reason == PANIC_INVALID_OPCODE {
    return "Invalid opcode"
  } else if reason == PANIC_PAGE_FAULT {
    return "Page fault"
  } else if reason == PANIC_DOUBLE_FAULT {
    return "Double fault"
  } else if reason == PANIC_HARDWARE_FAULT {
    return "Hardware fault"
  } else {
    return "Unknown panic"
  }
}

// Print panic header
fn panic_print_header(info: *PanicInfo) {
  foundation.serial_write_string("\n")
  foundation.serial_write_string("================================================================================\n")
  foundation.serial_write_string("                           KERNEL PANIC\n")
  foundation.serial_write_string("================================================================================\n")
  foundation.serial_write_string("\n")

  foundation.serial_write_string("Reason: ")
  foundation.serial_write_string(get_panic_reason_string(info.reason))
  foundation.serial_write_string("\n")

  if info.message != 0 {
    foundation.serial_write_string("Message: ")
    foundation.serial_write_string(info.message)
    foundation.serial_write_string("\n")
  }

  if info.file != 0 {
    foundation.serial_write_string("Location: ")
    foundation.serial_write_string(info.file)
    foundation.serial_write_string(":")
    foundation.serial_write_u64(info.line)
    foundation.serial_write_string("\n")
  }

  if info.function != 0 {
    foundation.serial_write_string("Function: ")
    foundation.serial_write_string(info.function)
    foundation.serial_write_string("\n")
  }

  foundation.serial_write_string("\n")
}

// Print register state
fn panic_print_registers(info: *PanicInfo) {
  foundation.serial_write_string("Register State:\n")

  foundation.serial_write_string("  PC: 0x")
  foundation.serial_write_hex(info.pc)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  SP: 0x")
  foundation.serial_write_hex(info.sp)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  FP: 0x")
  foundation.serial_write_hex(info.fp)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  LR: 0x")
  foundation.serial_write_hex(info.lr)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("\n")
}

// Unwind and print stack trace
fn panic_print_stack_trace(info: *PanicInfo) {
  foundation.serial_write_string("Stack Trace:\n")

  var frame_count: u32 = 0
  var fp: u64 = info.fp
  var lr: u64 = info.lr

  // Print initial frame
  foundation.serial_write_string("  #")
  foundation.serial_write_u64(frame_count)
  foundation.serial_write_string(": 0x")
  foundation.serial_write_hex(info.pc)
  foundation.serial_write_string("\n")

  frame_count = frame_count + 1

  // Unwind stack frames
  loop {
    if frame_count >= MAX_STACK_FRAMES { break }
    if fp == 0 || lr == 0 { break }

    // Validate frame pointer (basic sanity check)
    if fp < 0x1000 || fp > 0xFFFFFFFFFFFF0000 {
      foundation.serial_write_string("  [Invalid frame pointer, stopping]\n")
      break
    }

    foundation.serial_write_string("  #")
    foundation.serial_write_u64(frame_count)
    foundation.serial_write_string(": 0x")
    foundation.serial_write_hex(lr)
    foundation.serial_write_string("\n")

    // Read next frame
    // ARM64 frame layout: [FP, LR] at FP address
    let prev_fp: u64 = memory.read_u64(fp)
    let prev_lr: u64 = memory.read_u64(fp + 8)

    if prev_fp == fp {
      foundation.serial_write_string("  [Stack loop detected, stopping]\n")
      break
    }

    fp = prev_fp
    lr = prev_lr
    frame_count = frame_count + 1
  }

  foundation.serial_write_string("\n")
  foundation.serial_write_string("Total frames: ")
  foundation.serial_write_u64(frame_count)
  foundation.serial_write_string("\n\n")
}

// Print memory around addresses
fn panic_print_memory(addr: u64, label: *u8) {
  foundation.serial_write_string("Memory near ")
  foundation.serial_write_string(label)
  foundation.serial_write_string(" (0x")
  foundation.serial_write_hex(addr)
  foundation.serial_write_string("):\n")

  // Print 8 lines of 16 bytes each
  var line: u32 = 0
  loop {
    if line >= 8 { break }

    let line_addr: u64 = addr + (line * 16) as u64 - 64
    foundation.serial_write_string("  0x")
    foundation.serial_write_hex(line_addr)
    foundation.serial_write_string(": ")

    var col: u32 = 0
    loop {
      if col >= 16 { break }

      let byte_addr: u64 = line_addr + col as u64
      let byte: u8 = memory.read_u8(byte_addr)

      foundation.serial_write_hex_byte(byte)
      foundation.serial_write_string(" ")

      col = col + 1
    }

    foundation.serial_write_string("\n")
    line = line + 1
  }

  foundation.serial_write_string("\n")
}

// Print system information
fn panic_print_system_info() {
  foundation.serial_write_string("System Information:\n")

  foundation.serial_write_string("  Panic count: ")
  foundation.serial_write_u64(panic_count)
  foundation.serial_write_string("\n")

  // Would include: uptime, memory usage, CPU info, etc.
  foundation.serial_write_string("\n")
}

// Main panic handler
export fn panic(reason: u32, message: *u8, file: *u8, line: u32, function: *u8) {
  // Disable interrupts
  exceptions.disable_irq()
  exceptions.disable_fiq()

  panic_count = panic_count + 1

  // Check for double panic
  if panic_occurred == 1 {
    foundation.serial_write_string("\n\n!!! DOUBLE PANIC !!!\n")
    foundation.serial_write_string("System halted.\n")
    loop {
      foundation.nop()
    }
  }

  panic_occurred = 1

  // Gather panic information
  last_panic.reason = reason
  last_panic.message = message
  last_panic.file = file
  last_panic.line = line
  last_panic.function = function

  // Read current registers (would use assembly)
  // For now, use placeholder values
  last_panic.pc = 0  // Would read from exception frame or current PC
  last_panic.sp = 0  // Would read from SP register
  last_panic.fp = 0  // Would read from FP register
  last_panic.lr = 0  // Would read from LR register

  // Print panic information
  panic_print_header(&last_panic)
  panic_print_registers(&last_panic)

  // Print stack trace
  if last_panic.fp != 0 {
    panic_print_stack_trace(&last_panic)
  }

  // Print memory dumps
  if last_panic.pc != 0 {
    panic_print_memory(last_panic.pc, "PC")
  }

  if last_panic.sp != 0 {
    panic_print_memory(last_panic.sp, "SP")
  }

  panic_print_system_info()

  foundation.serial_write_string("================================================================================\n")
  foundation.serial_write_string("System halted. Please reboot.\n")
  foundation.serial_write_string("================================================================================\n")

  // Halt system
  loop {
    exceptions.wait_for_interrupt()
  }
}

// Panic with formatted message
export fn panic_fmt(reason: u32, file: *u8, line: u32, function: *u8) {
  panic(reason, 0, file, line, function)
}

// Assert macro helper
export fn panic_assert(condition: u32, message: *u8, file: *u8, line: u32) {
  if condition == 0 {
    panic(PANIC_ASSERTION, message, file, line, "assert")
  }
}

// Panic on out of memory
export fn panic_oom(file: *u8, line: u32) {
  panic(PANIC_OUT_OF_MEMORY, "Kernel out of memory", file, line, "malloc")
}

// Panic on null pointer
export fn panic_null_ptr(file: *u8, line: u32) {
  panic(PANIC_NULL_POINTER, "Null pointer dereference", file, line, 0)
}

// Panic on page fault
export fn panic_page_fault(addr: u64, file: *u8, line: u32) {
  // Store fault address for diagnostics
  panic(PANIC_PAGE_FAULT, "Page fault", file, line, 0)
}

// Check if panic occurred
export fn panic_has_occurred(): u32 {
  return panic_occurred
}

// Get panic count
export fn panic_get_count(): u32 {
  return panic_count
}

// Get last panic info
export fn panic_get_last_info(): *PanicInfo {
  return &last_panic
}

// Print panic history
export fn panic_print_history() {
  if panic_count == 0 {
    foundation.serial_write_string("[PANIC] No panics recorded\n")
    return
  }

  foundation.serial_write_string("\n[PANIC] Panic History:\n")
  foundation.serial_write_string("  Total panics: ")
  foundation.serial_write_u64(panic_count)
  foundation.serial_write_string("\n")

  if last_panic.message != 0 {
    foundation.serial_write_string("  Last panic: ")
    foundation.serial_write_string(get_panic_reason_string(last_panic.reason))
    foundation.serial_write_string("\n")

    if last_panic.file != 0 {
      foundation.serial_write_string("  Location: ")
      foundation.serial_write_string(last_panic.file)
      foundation.serial_write_string(":")
      foundation.serial_write_u64(last_panic.line)
      foundation.serial_write_string("\n")
    }
  }
}

// ============================================================================
// Standardized Panic Output Format
// Machine-parseable format for crash analysis tools
// ============================================================================

// Panic output version for tooling compatibility
const PANIC_FORMAT_VERSION: u32 = 1

// Generate standardized crash dump
export fn panic_standardized(reason: u32, message: u64, file: u64, line: u32, function: u64,
                              pc: u64, sp: u64, fp: u64, lr: u64) {
  // Disable interrupts
  exceptions.disable_irq()

  panic_count = panic_count + 1

  if panic_occurred == 1 {
    panic_print_double_fault()
    panic_halt()
    return
  }

  panic_occurred = 1

  // Store panic info
  last_panic.reason = reason
  last_panic.message = message
  last_panic.file = file
  last_panic.line = line
  last_panic.function = function
  last_panic.pc = pc
  last_panic.sp = sp
  last_panic.fp = fp
  last_panic.lr = lr

  // Print standardized output
  panic_print_standard_header()
  panic_print_standard_summary(&last_panic)
  panic_print_standard_registers(&last_panic)
  panic_print_standard_backtrace(&last_panic)
  panic_print_standard_memory(&last_panic)
  panic_print_standard_footer()

  panic_halt()
}

fn panic_print_double_fault() {
  foundation.serial_write_string("\n")
  foundation.serial_write_string("!!! DOUBLE FAULT - RECURSIVE PANIC !!!\n")
  foundation.serial_write_string("PANIC_DOUBLE_FAULT\n")
  foundation.serial_write_string("Original reason: ")
  foundation.serial_write_string(get_panic_reason_string(last_panic.reason))
  foundation.serial_write_string("\n")
}

fn panic_halt() {
  foundation.serial_write_string("SYSTEM_HALTED\n")
  loop {
    foundation.nop()
  }
}

// Standard header format
fn panic_print_standard_header() {
  foundation.serial_write_string("\n")
  foundation.serial_write_string("<<<< HOMEOS KERNEL PANIC >>>>\n")
  foundation.serial_write_string("PANIC_FORMAT_VERSION=")
  foundation.serial_write_u64(PANIC_FORMAT_VERSION)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("TIMESTAMP=")
  // Would use real timestamp - using placeholder
  foundation.serial_write_string("0\n")
  foundation.serial_write_string("\n")
}

// Summary section
fn panic_print_standard_summary(info: *PanicInfo) {
  foundation.serial_write_string("==== SUMMARY ====\n")

  foundation.serial_write_string("REASON=")
  foundation.serial_write_u64(info.reason)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("REASON_STR=")
  foundation.serial_write_string(get_panic_reason_string(info.reason))
  foundation.serial_write_string("\n")

  if info.message != 0 {
    foundation.serial_write_string("MESSAGE=")
    foundation.serial_write_string(info.message)
    foundation.serial_write_string("\n")
  }

  if info.file != 0 {
    foundation.serial_write_string("FILE=")
    foundation.serial_write_string(info.file)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("LINE=")
    foundation.serial_write_u64(info.line)
    foundation.serial_write_string("\n")
  }

  if info.function != 0 {
    foundation.serial_write_string("FUNCTION=")
    foundation.serial_write_string(info.function)
    foundation.serial_write_string("\n")
  }

  foundation.serial_write_string("\n")
}

// Registers section
fn panic_print_standard_registers(info: *PanicInfo) {
  foundation.serial_write_string("==== REGISTERS ====\n")

  foundation.serial_write_string("PC=0x")
  panic_print_hex64(info.pc)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("SP=0x")
  panic_print_hex64(info.sp)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("FP=0x")
  panic_print_hex64(info.fp)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("LR=0x")
  panic_print_hex64(info.lr)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("\n")
}

// Backtrace section
fn panic_print_standard_backtrace(info: *PanicInfo) {
  foundation.serial_write_string("==== BACKTRACE ====\n")

  var frame_count: u32 = 0
  var fp: u64 = info.fp
  var lr: u64 = info.lr

  // Frame 0: current PC
  foundation.serial_write_string("FRAME_")
  foundation.serial_write_u64(frame_count)
  foundation.serial_write_string("=0x")
  panic_print_hex64(info.pc)
  foundation.serial_write_string("\n")
  frame_count = frame_count + 1

  // Unwind frames
  while frame_count < MAX_STACK_FRAMES {
    if fp == 0 or lr == 0 { break }
    if fp < 0x1000 or fp > 0xFFFFFFFFFFFF0000 { break }

    foundation.serial_write_string("FRAME_")
    foundation.serial_write_u64(frame_count)
    foundation.serial_write_string("=0x")
    panic_print_hex64(lr)
    foundation.serial_write_string("\n")

    var prev_fp: u64 = memory.read_u64(fp)
    var prev_lr: u64 = memory.read_u64(fp + 8)

    if prev_fp == fp { break }

    fp = prev_fp
    lr = prev_lr
    frame_count = frame_count + 1
  }

  foundation.serial_write_string("FRAME_COUNT=")
  foundation.serial_write_u64(frame_count)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("\n")
}

// Memory section
fn panic_print_standard_memory(info: *PanicInfo) {
  foundation.serial_write_string("==== MEMORY ====\n")

  // Print memory around PC
  if info.pc != 0 and info.pc > 64 {
    foundation.serial_write_string("MEMORY_PC_START=0x")
    panic_print_hex64(info.pc - 64)
    foundation.serial_write_string("\n")
    foundation.serial_write_string("MEMORY_PC=")
    panic_print_memory_hex(info.pc - 64, 128)
    foundation.serial_write_string("\n")
  }

  // Print memory around SP
  if info.sp != 0 and info.sp > 64 {
    foundation.serial_write_string("MEMORY_SP_START=0x")
    panic_print_hex64(info.sp - 64)
    foundation.serial_write_string("\n")
    foundation.serial_write_string("MEMORY_SP=")
    panic_print_memory_hex(info.sp - 64, 128)
    foundation.serial_write_string("\n")
  }

  foundation.serial_write_string("\n")
}

// Footer section
fn panic_print_standard_footer() {
  foundation.serial_write_string("==== SYSTEM STATE ====\n")

  foundation.serial_write_string("PANIC_COUNT=")
  foundation.serial_write_u64(panic_count)
  foundation.serial_write_string("\n")

  // Add more system state info here
  // Memory usage, CPU state, etc.

  foundation.serial_write_string("\n")
  foundation.serial_write_string("<<<< END PANIC DUMP >>>>\n")
  foundation.serial_write_string("\n")
  foundation.serial_write_string("Please save this output for debugging.\n")
  foundation.serial_write_string("Report issues at: https://github.com/home-os/kernel/issues\n")
  foundation.serial_write_string("\n")
}

// Helper to print 64-bit hex without leading zeros trimmed
fn panic_print_hex64(val: u64) {
  var hex_chars: [16]u8
  hex_chars[0] = '0'
  hex_chars[1] = '1'
  hex_chars[2] = '2'
  hex_chars[3] = '3'
  hex_chars[4] = '4'
  hex_chars[5] = '5'
  hex_chars[6] = '6'
  hex_chars[7] = '7'
  hex_chars[8] = '8'
  hex_chars[9] = '9'
  hex_chars[10] = 'a'
  hex_chars[11] = 'b'
  hex_chars[12] = 'c'
  hex_chars[13] = 'd'
  hex_chars[14] = 'e'
  hex_chars[15] = 'f'

  var i: u32 = 0
  while i < 16 {
    var shift: u32 = (15 - i) * 4
    var nibble: u32 = @truncate((val >> shift) & 0xF, u32)
    foundation.serial_write_char(hex_chars[nibble])
    i = i + 1
  }
}

// Print memory as continuous hex string
fn panic_print_memory_hex(addr: u64, len: u32) {
  var hex_chars: [16]u8
  hex_chars[0] = '0'
  hex_chars[1] = '1'
  hex_chars[2] = '2'
  hex_chars[3] = '3'
  hex_chars[4] = '4'
  hex_chars[5] = '5'
  hex_chars[6] = '6'
  hex_chars[7] = '7'
  hex_chars[8] = '8'
  hex_chars[9] = '9'
  hex_chars[10] = 'a'
  hex_chars[11] = 'b'
  hex_chars[12] = 'c'
  hex_chars[13] = 'd'
  hex_chars[14] = 'e'
  hex_chars[15] = 'f'

  var i: u32 = 0
  while i < len {
    var byte: u8 = memory.read_u8(addr + i)
    foundation.serial_write_char(hex_chars[(byte >> 4) & 0xF])
    foundation.serial_write_char(hex_chars[byte & 0xF])
    i = i + 1
  }
}

// ============================================================================
// Crash Dump to Storage
// ============================================================================

var crash_dump_buffer: [4096]u8
var crash_dump_size: u32 = 0

// Generate crash dump for storage
export fn panic_generate_crash_dump(): u32 {
  crash_dump_size = 0

  // Write header
  crash_dump_size = crash_dump_size + panic_dump_str("HOMEOS_CRASH_DUMP\n")
  crash_dump_size = crash_dump_size + panic_dump_str("VERSION=1\n")

  // Write panic info
  crash_dump_size = crash_dump_size + panic_dump_str("REASON=")
  crash_dump_size = crash_dump_size + panic_dump_u32(last_panic.reason)
  crash_dump_size = crash_dump_size + panic_dump_str("\n")

  if last_panic.message != 0 {
    crash_dump_size = crash_dump_size + panic_dump_str("MESSAGE=")
    crash_dump_size = crash_dump_size + panic_dump_string(last_panic.message)
    crash_dump_size = crash_dump_size + panic_dump_str("\n")
  }

  crash_dump_size = crash_dump_size + panic_dump_str("PC=")
  crash_dump_size = crash_dump_size + panic_dump_hex64(last_panic.pc)
  crash_dump_size = crash_dump_size + panic_dump_str("\n")

  crash_dump_size = crash_dump_size + panic_dump_str("SP=")
  crash_dump_size = crash_dump_size + panic_dump_hex64(last_panic.sp)
  crash_dump_size = crash_dump_size + panic_dump_str("\n")

  return crash_dump_size
}

fn panic_dump_str(str: u64): u32 {
  var len: u32 = 0
  while 1 == 1 {
    var c: u8 = @ptrLoad(str + len, u8)
    if c == 0 { break }
    if crash_dump_size + len < 4096 {
      crash_dump_buffer[crash_dump_size + len] = c
    }
    len = len + 1
  }
  return len
}

fn panic_dump_string(str: u64): u32 {
  return panic_dump_str(str)
}

fn panic_dump_u32(val: u32): u32 {
  var temp: [16]u8
  var i: u32 = 15
  var v: u32 = val
  var len: u32 = 0

  if v == 0 {
    if crash_dump_size < 4096 {
      crash_dump_buffer[crash_dump_size] = '0'
    }
    return 1
  }

  while v > 0 and i > 0 {
    temp[i] = '0' + @truncate(v % 10, u8)
    v = v / 10
    i = i - 1
    len = len + 1
  }

  var j: u32 = 0
  while j < len {
    if crash_dump_size + j < 4096 {
      crash_dump_buffer[crash_dump_size + j] = temp[16 - len + j]
    }
    j = j + 1
  }

  return len
}

fn panic_dump_hex64(val: u64): u32 {
  var hex: [16]u8
  hex[0] = '0'
  hex[1] = '1'
  hex[2] = '2'
  hex[3] = '3'
  hex[4] = '4'
  hex[5] = '5'
  hex[6] = '6'
  hex[7] = '7'
  hex[8] = '8'
  hex[9] = '9'
  hex[10] = 'a'
  hex[11] = 'b'
  hex[12] = 'c'
  hex[13] = 'd'
  hex[14] = 'e'
  hex[15] = 'f'

  // Write "0x"
  if crash_dump_size < 4096 {
    crash_dump_buffer[crash_dump_size] = '0'
  }
  if crash_dump_size + 1 < 4096 {
    crash_dump_buffer[crash_dump_size + 1] = 'x'
  }

  var i: u32 = 0
  while i < 16 {
    var shift: u32 = (15 - i) * 4
    var nibble: u32 = @truncate((val >> shift) & 0xF, u32)
    if crash_dump_size + 2 + i < 4096 {
      crash_dump_buffer[crash_dump_size + 2 + i] = hex[nibble]
    }
    i = i + 1
  }

  return 18
}

// Get crash dump buffer for writing to storage
export fn panic_get_crash_dump(): u64 {
  return &crash_dump_buffer[0]
}

export fn panic_get_crash_dump_size(): u32 {
  return crash_dump_size
}
