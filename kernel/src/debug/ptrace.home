// home-os Kernel - Ptrace (Process Tracing)
// User-space debugging interface

import "../core/foundation.home" as foundation
import "../core/process.home" as process

// Ptrace requests
const PTRACE_TRACEME: u32 = 0
const PTRACE_PEEKTEXT: u32 = 1
const PTRACE_PEEKDATA: u32 = 2
const PTRACE_PEEKUSER: u32 = 3
const PTRACE_POKETEXT: u32 = 4
const PTRACE_POKEDATA: u32 = 5
const PTRACE_POKEUSER: u32 = 6
const PTRACE_CONT: u32 = 7
const PTRACE_KILL: u32 = 8
const PTRACE_SINGLESTEP: u32 = 9
const PTRACE_GETREGS: u32 = 12
const PTRACE_SETREGS: u32 = 13
const PTRACE_ATTACH: u32 = 16
const PTRACE_DETACH: u32 = 17
const PTRACE_SYSCALL: u32 = 24
const PTRACE_SETOPTIONS: u32 = 0x4200
const PTRACE_GETEVENTMSG: u32 = 0x4201
const PTRACE_GETSIGINFO: u32 = 0x4202

// Ptrace options
const PTRACE_O_TRACESYSGOOD: u32 = 1
const PTRACE_O_TRACEFORK: u32 = 2
const PTRACE_O_TRACEVFORK: u32 = 4
const PTRACE_O_TRACECLONE: u32 = 8
const PTRACE_O_TRACEEXEC: u32 = 16
const PTRACE_O_TRACEEXIT: u32 = 64

const MAX_TRACED_PROCESSES: u32 = 64

struct TracedProcess {
  pid: u32,
  tracer_pid: u32,
  options: u32,
  stopped: u32,
  signal: u32
}

var traced_processes: [TracedProcess; 64]
var traced_count: u32 = 0

export fn ptrace_init() {
  traced_count = 0
  foundation.serial_write_string("[Ptrace] Process tracing initialized\n")
}

export fn ptrace(request: u32, pid: u32, addr: u64, data: u64): i64 {
  if request == PTRACE_TRACEME {
    return ptrace_traceme()
  } else if request == PTRACE_ATTACH {
    return ptrace_attach(pid)
  } else if request == PTRACE_DETACH {
    return ptrace_detach(pid)
  } else if request == PTRACE_CONT {
    return ptrace_cont(pid, @truncate(data, u32))
  } else if request == PTRACE_SINGLESTEP {
    return ptrace_singlestep(pid)
  } else if request == PTRACE_GETREGS {
    return ptrace_getregs(pid, data)
  } else if request == PTRACE_SETREGS {
    return ptrace_setregs(pid, data)
  } else if request == PTRACE_PEEKDATA {
    return ptrace_peekdata(pid, addr)
  } else if request == PTRACE_POKEDATA {
    return ptrace_pokedata(pid, addr, data)
  } else if request == PTRACE_SETOPTIONS {
    return ptrace_setoptions(pid, @truncate(data, u32))
  }
  
  return -1  // EINVAL
}

fn ptrace_traceme(): i64 {
  var current_pid: u32 = process.process_get_current()
  var parent_pid: u32 = process.process_get_parent(current_pid)
  
  if traced_count >= MAX_TRACED_PROCESSES { return -1 }
  
  traced_processes[traced_count].pid = current_pid
  traced_processes[traced_count].tracer_pid = parent_pid
  traced_processes[traced_count].options = 0
  traced_processes[traced_count].stopped = 0
  traced_processes[traced_count].signal = 0
  
  traced_count = traced_count + 1
  
  foundation.serial_write_string("[Ptrace] Process ")
  foundation.serial_write_hex(current_pid)
  foundation.serial_write_string(" is now traced by ")
  foundation.serial_write_hex(parent_pid)
  foundation.serial_write_string("\n")
  
  return 0
}

fn ptrace_attach(pid: u32): i64 {
  if traced_count >= MAX_TRACED_PROCESSES { return -1 }
  
  var current_pid: u32 = process.process_get_current()
  
  traced_processes[traced_count].pid = pid
  traced_processes[traced_count].tracer_pid = current_pid
  traced_processes[traced_count].options = 0
  traced_processes[traced_count].stopped = 1
  traced_processes[traced_count].signal = 19  // SIGSTOP
  
  traced_count = traced_count + 1
  
  // Stop the target process
  process.process_stop(pid)
  
  foundation.serial_write_string("[Ptrace] Attached to process ")
  foundation.serial_write_hex(pid)
  foundation.serial_write_string("\n")
  
  return 0
}

fn ptrace_detach(pid: u32): i64 {
  var i: u32 = 0
  while i < traced_count {
    if traced_processes[i].pid == pid {
      // Resume process
      process.process_resume(pid)
      
      // Remove from traced list
      traced_processes[i] = traced_processes[traced_count - 1]
      traced_count = traced_count - 1
      
      return 0
    }
    i = i + 1
  }
  
  return -1
}

fn ptrace_cont(pid: u32, signal: u32): i64 {
  var i: u32 = 0
  while i < traced_count {
    if traced_processes[i].pid == pid {
      traced_processes[i].stopped = 0
      
      // Resume process
      process.process_resume(pid)
      
      // Deliver signal if specified
      if signal != 0 {
        process.process_signal(pid, signal)
      }
      
      return 0
    }
    i = i + 1
  }
  
  return -1
}

fn ptrace_singlestep(pid: u32): i64 {
  var i: u32 = 0
  while i < traced_count {
    if traced_processes[i].pid == pid {
      // Enable single-step mode
      process.process_set_single_step(pid, 1)
      
      // Resume for one instruction
      process.process_resume(pid)
      
      return 0
    }
    i = i + 1
  }
  
  return -1
}

fn ptrace_getregs(pid: u32, regs_out: u64): i64 {
  // Get process registers
  var regs: u64 = process.process_get_registers(pid)
  
  if regs == 0 { return -1 }
  
  // Copy registers to user space
  var i: u32 = 0
  while i < 128 {  // sizeof(user_regs_struct)
    @intToPtr(regs_out + i, u8) = @intToPtr(regs + i, u8)
    i = i + 1
  }
  
  return 0
}

fn ptrace_setregs(pid: u32, regs: u64): i64 {
  // Set process registers
  return @bitCast(process.process_set_registers(pid, regs), i64)
}

fn ptrace_peekdata(pid: u32, addr: u64): i64 {
  // Read word from process memory
  var value: u64 = process.process_read_memory(pid, addr, 8)
  return @bitCast(value, i64)
}

fn ptrace_pokedata(pid: u32, addr: u64, data: u64): i64 {
  // Write word to process memory
  return @bitCast(process.process_write_memory(pid, addr, data, 8), i64)
}

fn ptrace_setoptions(pid: u32, options: u32): i64 {
  var i: u32 = 0
  while i < traced_count {
    if traced_processes[i].pid == pid {
      traced_processes[i].options = options
      return 0
    }
    i = i + 1
  }
  
  return -1
}

export fn ptrace_notify_syscall(pid: u32, syscall_nr: u32, entering: u32) {
  var i: u32 = 0
  while i < traced_count {
    if traced_processes[i].pid == pid {
      if (traced_processes[i].options & PTRACE_O_TRACESYSGOOD) != 0 {
        // Stop process and notify tracer
        traced_processes[i].stopped = 1
        traced_processes[i].signal = 0x80 | 5  // SIGTRAP with syscall bit
        
        process.process_stop(pid)
        process.process_signal(traced_processes[i].tracer_pid, 17)  // SIGCHLD
      }
      break
    }
    i = i + 1
  }
}

export fn ptrace_is_traced(pid: u32): u32 {
  var i: u32 = 0
  while i < traced_count {
    if traced_processes[i].pid == pid {
      return 1
    }
    i = i + 1
  }
  return 0
}
