// home-os Kernel - Enhanced Kernel Debugger (KDB)
// Advanced debugging with breakpoints, watchpoints, and tracing

import "../core/foundation.home" as foundation

const MAX_BREAKPOINTS: u32 = 32
const MAX_WATCHPOINTS: u32 = 8
const MAX_STACK_FRAMES: u32 = 64

struct Breakpoint {
  addr: u64,
  enabled: u32,
  hit_count: u64,
  condition: u64  // Optional condition function
}

struct Watchpoint {
  addr: u64,
  size: u32,
  type: u32,  // 0=read, 1=write, 2=both
  enabled: u32,
  hit_count: u64
}

struct StackFrame {
  rip: u64,
  rbp: u64,
  rsp: u64,
  function_name: [u8; 64]
}

var breakpoints: [Breakpoint; 32]
var breakpoint_count: u32 = 0
var watchpoints: [Watchpoint; 8]
var watchpoint_count: u32 = 0
var kdb_enabled: u32 = 0
var single_step_mode: u32 = 0

export fn kdb_init() {
  if kdb_enabled == 1 { return }
  
  breakpoint_count = 0
  watchpoint_count = 0
  single_step_mode = 0
  
  kdb_enabled = 1
  foundation.serial_write_string("[KDB] Enhanced kernel debugger initialized\n")
}

export fn kdb_add_breakpoint(addr: u64) -> u32 {
  if breakpoint_count >= MAX_BREAKPOINTS { return 0xFFFFFFFF }
  
  breakpoints[breakpoint_count].addr = addr
  breakpoints[breakpoint_count].enabled = 1
  breakpoints[breakpoint_count].hit_count = 0
  breakpoints[breakpoint_count].condition = 0
  
  // Set INT3 instruction at address
  kdb_set_int3(addr)
  
  var bp_id: u32 = breakpoint_count
  breakpoint_count = breakpoint_count + 1
  
  foundation.serial_write_string("[KDB] Breakpoint ")
  foundation.serial_write_hex(bp_id)
  foundation.serial_write_string(" set at 0x")
  foundation.serial_write_hex(@truncate(addr, u32))
  foundation.serial_write_string("\n")
  
  return bp_id
}

export fn kdb_remove_breakpoint(bp_id: u32) -> u32 {
  if bp_id >= breakpoint_count { return 0 }
  
  // Remove INT3 instruction
  kdb_clear_int3(breakpoints[bp_id].addr)
  
  breakpoints[bp_id].enabled = 0
  
  return 1
}

export fn kdb_add_watchpoint(addr: u64, size: u32, type: u32) -> u32 {
  if watchpoint_count >= MAX_WATCHPOINTS { return 0xFFFFFFFF }
  
  watchpoints[watchpoint_count].addr = addr
  watchpoints[watchpoint_count].size = size
  watchpoints[watchpoint_count].type = type
  watchpoints[watchpoint_count].enabled = 1
  watchpoints[watchpoint_count].hit_count = 0
  
  // Set hardware watchpoint (DR0-DR3)
  kdb_set_hw_watchpoint(watchpoint_count, addr, size, type)
  
  var wp_id: u32 = watchpoint_count
  watchpoint_count = watchpoint_count + 1
  
  foundation.serial_write_string("[KDB] Watchpoint ")
  foundation.serial_write_hex(wp_id)
  foundation.serial_write_string(" set at 0x")
  foundation.serial_write_hex(@truncate(addr, u32))
  foundation.serial_write_string("\n")
  
  return wp_id
}

fn kdb_set_int3(addr: u64) {
  // Save original byte
  var original: u8 = @intToPtr(addr, u8)
  
  // Write INT3 (0xCC)
  @intToPtr(addr, u8) = 0xCC
}

fn kdb_clear_int3(addr: u64) {
  // Restore original byte (would need to save it first)
  @intToPtr(addr, u8) = 0x90  // NOP for now
}

fn kdb_set_hw_watchpoint(index: u32, addr: u64, size: u32, type: u32) {
  // Set debug register DR0-DR3
  if index == 0 {
    foundation.write_dr0(addr)
  } else if index == 1 {
    foundation.write_dr1(addr)
  } else if index == 2 {
    foundation.write_dr2(addr)
  } else if index == 3 {
    foundation.write_dr3(addr)
  }
  
  // Configure DR7
  var dr7: u64 = foundation.read_dr7()
  
  // Enable watchpoint
  dr7 = dr7 | (1 << (index * 2))
  
  // Set type and size
  var shift: u32 = 16 + (index * 4)
  dr7 = dr7 | (@intToPtr(type, u64) << shift)
  dr7 = dr7 | (@intToPtr(size, u64) << (shift + 2))
  
  foundation.write_dr7(dr7)
}

export fn kdb_handle_breakpoint(rip: u64) {
  foundation.serial_write_string("[KDB] Breakpoint hit at 0x")
  foundation.serial_write_hex(@truncate(rip, u32))
  foundation.serial_write_string("\n")
  
  // Find breakpoint
  var i: u32 = 0
  while i < breakpoint_count {
    if breakpoints[i].addr == rip and breakpoints[i].enabled == 1 {
      breakpoints[i].hit_count = breakpoints[i].hit_count + 1
      
      // Enter debugger prompt
      kdb_prompt(rip)
      break
    }
    i = i + 1
  }
}

fn kdb_prompt(rip: u64) {
  foundation.serial_write_string("\n[KDB] Debugger prompt (? for help)\n")
  
  while 1 == 1 {
    foundation.serial_write_string("kdb> ")
    
    var cmd: [u8; 256]
    foundation.serial_read_line(@ptrFromInt(cmd), 256)
    
    if cmd[0] == 'c' {  // continue
      break
    } else if cmd[0] == 's' {  // step
      single_step_mode = 1
      break
    } else if cmd[0] == 'b' {  // backtrace
      kdb_print_backtrace(rip)
    } else if cmd[0] == 'r' {  // registers
      kdb_print_registers()
    } else if cmd[0] == 'm' {  // memory
      kdb_dump_memory(rip, 64)
    } else if cmd[0] == 'q' {  // quit
      foundation.panic("KDB: User requested quit")
    } else if cmd[0] == '?' {  // help
      kdb_print_help()
    }
  }
}

fn kdb_print_backtrace(rip: u64) {
  foundation.serial_write_string("\n[KDB] Stack trace:\n")
  
  var rbp: u64 = foundation.read_rbp()
  var frame: u32 = 0
  
  foundation.serial_write_string("  #0  0x")
  foundation.serial_write_hex(@truncate(rip, u32))
  foundation.serial_write_string("\n")
  
  while frame < MAX_STACK_FRAMES and rbp != 0 {
    var ret_addr: u64 = @intToPtr(rbp + 8, u64)
    var prev_rbp: u64 = @intToPtr(rbp, u64)
    
    foundation.serial_write_string("  #")
    foundation.serial_write_hex(frame + 1)
    foundation.serial_write_string("  0x")
    foundation.serial_write_hex(@truncate(ret_addr, u32))
    foundation.serial_write_string("\n")
    
    rbp = prev_rbp
    frame = frame + 1
  }
}

fn kdb_print_registers() {
  foundation.serial_write_string("\n[KDB] Registers:\n")
  foundation.serial_write_string("  RAX: 0x")
  foundation.serial_write_hex(@truncate(foundation.read_rax(), u32))
  foundation.serial_write_string("\n  RBX: 0x")
  foundation.serial_write_hex(@truncate(foundation.read_rbx(), u32))
  foundation.serial_write_string("\n  RCX: 0x")
  foundation.serial_write_hex(@truncate(foundation.read_rcx(), u32))
  foundation.serial_write_string("\n  RDX: 0x")
  foundation.serial_write_hex(@truncate(foundation.read_rdx(), u32))
  foundation.serial_write_string("\n  RSI: 0x")
  foundation.serial_write_hex(@truncate(foundation.read_rsi(), u32))
  foundation.serial_write_string("\n  RDI: 0x")
  foundation.serial_write_hex(@truncate(foundation.read_rdi(), u32))
  foundation.serial_write_string("\n  RBP: 0x")
  foundation.serial_write_hex(@truncate(foundation.read_rbp(), u32))
  foundation.serial_write_string("\n  RSP: 0x")
  foundation.serial_write_hex(@truncate(foundation.read_rsp(), u32))
  foundation.serial_write_string("\n")
}

fn kdb_dump_memory(addr: u64, len: u32) {
  foundation.serial_write_string("\n[KDB] Memory at 0x")
  foundation.serial_write_hex(@truncate(addr, u32))
  foundation.serial_write_string(":\n")
  
  var i: u32 = 0
  while i < len {
    if (i % 16) == 0 {
      foundation.serial_write_string("  0x")
      foundation.serial_write_hex(@truncate(addr + i, u32))
      foundation.serial_write_string(": ")
    }
    
    foundation.serial_write_hex(@intToPtr(addr + i, u8))
    foundation.serial_write_string(" ")
    
    if (i % 16) == 15 {
      foundation.serial_write_string("\n")
    }
    
    i = i + 1
  }
  
  foundation.serial_write_string("\n")
}

fn kdb_print_help() {
  foundation.serial_write_string("\n[KDB] Commands:\n")
  foundation.serial_write_string("  c - continue execution\n")
  foundation.serial_write_string("  s - single step\n")
  foundation.serial_write_string("  b - print backtrace\n")
  foundation.serial_write_string("  r - print registers\n")
  foundation.serial_write_string("  m - dump memory\n")
  foundation.serial_write_string("  q - quit (panic)\n")
  foundation.serial_write_string("  ? - this help\n\n")
}

export fn kdb_enable_single_step() {
  single_step_mode = 1
  
  // Set TF (Trap Flag) in RFLAGS
  var rflags: u64 = foundation.read_rflags()
  rflags = rflags | 0x100
  foundation.write_rflags(rflags)
}

export fn kdb_disable_single_step() {
  single_step_mode = 0
  
  // Clear TF
  var rflags: u64 = foundation.read_rflags()
  rflags = rflags & ~0x100
  foundation.write_rflags(rflags)
}

export fn kdb_list_breakpoints() {
  foundation.serial_write_string("\n[KDB] Breakpoints:\n")
  
  var i: u32 = 0
  while i < breakpoint_count {
    if breakpoints[i].enabled == 1 {
      foundation.serial_write_string("  ")
      foundation.serial_write_hex(i)
      foundation.serial_write_string(": 0x")
      foundation.serial_write_hex(@truncate(breakpoints[i].addr, u32))
      foundation.serial_write_string(" (hits: ")
      foundation.serial_write_hex(@truncate(breakpoints[i].hit_count, u32))
      foundation.serial_write_string(")\n")
    }
    i = i + 1
  }
}

export fn kdb_is_enabled() -> u32 {
  return kdb_enabled
}
