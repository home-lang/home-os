// home-os Memory Leak Detector
// Tracks allocations and deallocations to detect memory leaks
// Provides stack traces for leaked allocations

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "../arch/arm64/timer.home" as timer

// Configuration
const MAX_TRACKED_ALLOCATIONS: u32 = 10000
const MAX_STACK_DEPTH: u32 = 16
const LEAK_REPORT_THRESHOLD: u64 = 1024 * 1024  // 1MB

// Allocation tracking
struct Allocation {
  active: u32
  addr: u64
  size: u64
  timestamp: u64
  file: *u8
  line: u32
  function: *u8
  stack: [MAX_STACK_DEPTH]u64
  stack_depth: u32
}

// Leak summary
struct LeakSummary {
  location: *u8
  total_size: u64
  count: u32
}

var allocations: [MAX_TRACKED_ALLOCATIONS]Allocation
var num_allocations: u32 = 0
var leak_detector_enabled: u32 = 0
var initialized: u32 = 0

// Statistics
var total_allocations: u64 = 0
var total_deallocations: u64 = 0
var total_bytes_allocated: u64 = 0
var total_bytes_freed: u64 = 0
var peak_memory_usage: u64 = 0
var current_memory_usage: u64 = 0
var allocation_failures: u64 = 0

// Initialize memory leak detector
export fn memleak_init() {
  if initialized == 1 {
    foundation.serial_write_string("[MEMLEAK] Already initialized\n")
    return
  }

  foundation.serial_write_string("[MEMLEAK] Initializing memory leak detector...\n")

  num_allocations = 0
  leak_detector_enabled = 0

  total_allocations = 0
  total_deallocations = 0
  total_bytes_allocated = 0
  total_bytes_freed = 0
  peak_memory_usage = 0
  current_memory_usage = 0
  allocation_failures = 0

  // Initialize allocation table
  var i: u32 = 0
  loop {
    if i >= MAX_TRACKED_ALLOCATIONS { break }

    allocations[i].active = 0
    allocations[i].addr = 0
    allocations[i].size = 0
    allocations[i].timestamp = 0
    allocations[i].file = 0
    allocations[i].line = 0
    allocations[i].function = 0
    allocations[i].stack_depth = 0

    i = i + 1
  }

  initialized = 1

  foundation.serial_write_string("[MEMLEAK] Memory leak detector initialized\n")
  foundation.serial_write_string("[MEMLEAK] Tracking up to ")
  foundation.serial_write_u64(MAX_TRACKED_ALLOCATIONS)
  foundation.serial_write_string(" allocations\n")
}

// Enable leak detection
export fn memleak_enable() {
  if initialized == 0 { return }

  leak_detector_enabled = 1

  foundation.serial_write_string("[MEMLEAK] Leak detection enabled\n")
}

// Disable leak detection
export fn memleak_disable() {
  leak_detector_enabled = 0

  foundation.serial_write_string("[MEMLEAK] Leak detection disabled\n")
}

// Track an allocation
export fn memleak_track_alloc(addr: u64, size: u64, file: *u8, line: u32, function: *u8) {
  if leak_detector_enabled == 0 { return }
  if addr == 0 { return }

  // Find free slot
  var slot: u32 = 0xFFFFFFFF
  var i: u32 = 0

  loop {
    if i >= MAX_TRACKED_ALLOCATIONS { break }

    if allocations[i].active == 0 {
      slot = i
      break
    }

    i = i + 1
  }

  if slot == 0xFFFFFFFF {
    allocation_failures = allocation_failures + 1
    return
  }

  // Record allocation
  allocations[slot].active = 1
  allocations[slot].addr = addr
  allocations[slot].size = size
  allocations[slot].timestamp = timer.timer_get_us()
  allocations[slot].file = file
  allocations[slot].line = line
  allocations[slot].function = function
  allocations[slot].stack_depth = 0  // Would capture actual stack

  num_allocations = num_allocations + 1
  total_allocations = total_allocations + 1
  total_bytes_allocated = total_bytes_allocated + size
  current_memory_usage = current_memory_usage + size

  if current_memory_usage > peak_memory_usage {
    peak_memory_usage = current_memory_usage
  }
}

// Track a deallocation
export fn memleak_track_free(addr: u64) {
  if leak_detector_enabled == 0 { return }
  if addr == 0 { return }

  // Find allocation
  var i: u32 = 0
  loop {
    if i >= MAX_TRACKED_ALLOCATIONS { break }

    if allocations[i].active == 1 && allocations[i].addr == addr {
      // Mark as freed
      allocations[i].active = 0

      num_allocations = num_allocations - 1
      total_deallocations = total_deallocations + 1
      total_bytes_freed = total_bytes_freed + allocations[i].size
      current_memory_usage = current_memory_usage - allocations[i].size

      return
    }

    i = i + 1
  }

  // Address not found - potential double free or free of untracked memory
}

// Check for memory leaks
export fn memleak_check(): u32 {
  if leak_detector_enabled == 0 { return 0 }

  let leaked_count: u32 = 0
  let leaked_bytes: u64 = 0

  var i: u32 = 0
  loop {
    if i >= MAX_TRACKED_ALLOCATIONS { break }

    if allocations[i].active == 1 {
      leaked_count = leaked_count + 1
      leaked_bytes = leaked_bytes + allocations[i].size
    }

    i = i + 1
  }

  if leaked_bytes >= LEAK_REPORT_THRESHOLD {
    foundation.serial_write_string("[MEMLEAK] WARNING: ")
    foundation.serial_write_u64(leaked_bytes)
    foundation.serial_write_string(" bytes leaked in ")
    foundation.serial_write_u64(leaked_count)
    foundation.serial_write_string(" allocations\n")
  }

  return leaked_count
}

// Generate leak report
export fn memleak_report() {
  foundation.serial_write_string("\n")
  foundation.serial_write_string("================================================================================\n")
  foundation.serial_write_string("                        MEMORY LEAK DETECTOR REPORT\n")
  foundation.serial_write_string("================================================================================\n")
  foundation.serial_write_string("\n")

  // Summary statistics
  foundation.serial_write_string("Summary:\n")
  foundation.serial_write_string("--------------------------------------------------------------------------------\n")
  foundation.serial_write_string("  Total allocations: ")
  foundation.serial_write_u64(total_allocations)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Total deallocations: ")
  foundation.serial_write_u64(total_deallocations)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Total bytes allocated: ")
  foundation.serial_write_u64(total_bytes_allocated)
  foundation.serial_write_string(" bytes (")
  foundation.serial_write_u64(total_bytes_allocated / 1024)
  foundation.serial_write_string(" KB)\n")

  foundation.serial_write_string("  Total bytes freed: ")
  foundation.serial_write_u64(total_bytes_freed)
  foundation.serial_write_string(" bytes (")
  foundation.serial_write_u64(total_bytes_freed / 1024)
  foundation.serial_write_string(" KB)\n")

  foundation.serial_write_string("  Peak memory usage: ")
  foundation.serial_write_u64(peak_memory_usage)
  foundation.serial_write_string(" bytes (")
  foundation.serial_write_u64(peak_memory_usage / 1024)
  foundation.serial_write_string(" KB)\n")

  foundation.serial_write_string("  Current memory usage: ")
  foundation.serial_write_u64(current_memory_usage)
  foundation.serial_write_string(" bytes (")
  foundation.serial_write_u64(current_memory_usage / 1024)
  foundation.serial_write_string(" KB)\n")

  foundation.serial_write_string("\n")

  // Check for leaks
  let leaked_count: u32 = 0
  let leaked_bytes: u64 = 0

  var i: u32 = 0
  loop {
    if i >= MAX_TRACKED_ALLOCATIONS { break }

    if allocations[i].active == 1 {
      leaked_count = leaked_count + 1
      leaked_bytes = leaked_bytes + allocations[i].size
    }

    i = i + 1
  }

  if leaked_count == 0 {
    foundation.serial_write_string("No memory leaks detected!\n")
  } else {
    foundation.serial_write_string("MEMORY LEAKS DETECTED:\n")
    foundation.serial_write_string("--------------------------------------------------------------------------------\n")
    foundation.serial_write_string("  Leaked allocations: ")
    foundation.serial_write_u64(leaked_count)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  Leaked bytes: ")
    foundation.serial_write_u64(leaked_bytes)
    foundation.serial_write_string(" bytes (")
    foundation.serial_write_u64(leaked_bytes / 1024)
    foundation.serial_write_string(" KB)\n")

    foundation.serial_write_string("\n")

    // Print detailed leak information
    foundation.serial_write_string("Leaked Allocations:\n")
    foundation.serial_write_string("--------------------------------------------------------------------------------\n")
    foundation.serial_write_string("Address           Size        Age(ms)     Location\n")
    foundation.serial_write_string("--------------------------------------------------------------------------------\n")

    let now: u64 = timer.timer_get_us()

    i = 0
    var printed: u32 = 0
    loop {
      if i >= MAX_TRACKED_ALLOCATIONS || printed >= 50 { break }

      if allocations[i].active == 1 {
        // Address
        foundation.serial_write_string("0x")
        foundation.serial_write_hex(allocations[i].addr)
        foundation.serial_write_string("  ")

        // Size
        foundation.serial_write_u64(allocations[i].size)
        foundation.serial_write_string(" bytes  ")

        // Age
        let age_us: u64 = now - allocations[i].timestamp
        let age_ms: u64 = age_us / 1000
        foundation.serial_write_u64(age_ms)
        foundation.serial_write_string("ms  ")

        // Location
        if allocations[i].file != 0 {
          foundation.serial_write_string(allocations[i].file)
          foundation.serial_write_string(":")
          foundation.serial_write_u64(allocations[i].line)
        }

        if allocations[i].function != 0 {
          foundation.serial_write_string(" (")
          foundation.serial_write_string(allocations[i].function)
          foundation.serial_write_string(")")
        }

        foundation.serial_write_string("\n")

        printed = printed + 1
      }

      i = i + 1
    }

    if leaked_count > 50 {
      foundation.serial_write_string("... ")
      foundation.serial_write_u64(leaked_count - 50)
      foundation.serial_write_string(" more leaks not shown\n")
    }

    foundation.serial_write_string("\n")

    // Group leaks by location
    memleak_leak_summary()
  }

  // Print statistics
  if allocation_failures > 0 {
    foundation.serial_write_string("Tracking Failures:\n")
    foundation.serial_write_string("--------------------------------------------------------------------------------\n")
    foundation.serial_write_string("  Allocation tracking failures: ")
    foundation.serial_write_u64(allocation_failures)
    foundation.serial_write_string("\n")
    foundation.serial_write_string("  (Increase MAX_TRACKED_ALLOCATIONS to track more)\n")
    foundation.serial_write_string("\n")
  }

  foundation.serial_write_string("================================================================================\n")
  foundation.serial_write_string("\n")
}

// Leak summary by location
fn memleak_leak_summary() {
  foundation.serial_write_string("Leak Summary by Location:\n")
  foundation.serial_write_string("--------------------------------------------------------------------------------\n")
  foundation.serial_write_string("Count       Total Size      Location\n")
  foundation.serial_write_string("--------------------------------------------------------------------------------\n")

  // This is simplified - would need proper grouping
  var shown: u32 = 0
  var i: u32 = 0

  loop {
    if i >= MAX_TRACKED_ALLOCATIONS || shown >= 20 { break }

    if allocations[i].active == 1 {
      // Count allocations from same location
      let location: *u8 = allocations[i].file
      let line: u32 = allocations[i].line

      var count: u32 = 0
      var total_size: u64 = 0
      var j: u32 = 0

      loop {
        if j >= MAX_TRACKED_ALLOCATIONS { break }

        if allocations[j].active == 1 &&
           allocations[j].file == location &&
           allocations[j].line == line {
          count = count + 1
          total_size = total_size + allocations[j].size
        }

        j = j + 1
      }

      // Print summary
      foundation.serial_write_u64(count)
      foundation.serial_write_string("       ")

      foundation.serial_write_u64(total_size)
      foundation.serial_write_string(" bytes  ")

      if location != 0 {
        foundation.serial_write_string(location)
        foundation.serial_write_string(":")
        foundation.serial_write_u64(line)
      }

      foundation.serial_write_string("\n")

      // Mark as shown
      j = 0
      loop {
        if j >= MAX_TRACKED_ALLOCATIONS { break }

        if allocations[j].active == 1 &&
           allocations[j].file == location &&
           allocations[j].line == line {
          allocations[j].active = 0  // Temporarily mark inactive to skip
        }

        j = j + 1
      }

      shown = shown + 1
    }

    i = i + 1
  }

  // Restore active flags
  i = 0
  loop {
    if i >= MAX_TRACKED_ALLOCATIONS { break }

    if allocations[i].addr != 0 && allocations[i].active == 0 {
      allocations[i].active = 1  // Restore
    }

    i = i + 1
  }

  foundation.serial_write_string("\n")
}

// Clear all tracked allocations
export fn memleak_clear() {
  var i: u32 = 0
  loop {
    if i >= MAX_TRACKED_ALLOCATIONS { break }

    allocations[i].active = 0
    allocations[i].addr = 0
    allocations[i].size = 0

    i = i + 1
  }

  num_allocations = 0
  total_allocations = 0
  total_deallocations = 0
  total_bytes_allocated = 0
  total_bytes_freed = 0
  current_memory_usage = 0
  allocation_failures = 0

  foundation.serial_write_string("[MEMLEAK] Tracking data cleared\n")
}

// Get current statistics
export fn memleak_get_stats(stats: *MemLeakStats) {
  memory.write_u64(stats as u64, total_allocations)
  memory.write_u64(stats as u64 + 8, total_deallocations)
  memory.write_u64(stats as u64 + 16, total_bytes_allocated)
  memory.write_u64(stats as u64 + 24, total_bytes_freed)
  memory.write_u64(stats as u64 + 32, peak_memory_usage)
  memory.write_u64(stats as u64 + 40, current_memory_usage)
  memory.write_u32(stats as u64 + 48, num_allocations)
}

// Statistics structure
struct MemLeakStats {
  total_allocations: u64
  total_deallocations: u64
  total_bytes_allocated: u64
  total_bytes_freed: u64
  peak_memory_usage: u64
  current_memory_usage: u64
  active_allocations: u32
}

// Check if leak detection is enabled
export fn memleak_is_enabled(): u32 {
  return leak_detector_enabled
}

// Get current memory usage
export fn memleak_current_usage(): u64 {
  return current_memory_usage
}

// Get peak memory usage
export fn memleak_peak_usage(): u64 {
  return peak_memory_usage
}

// Periodic leak check (call from scheduler)
export fn memleak_periodic_check() {
  if leak_detector_enabled == 0 { return }

  // Check if we've exceeded threshold
  if current_memory_usage >= LEAK_REPORT_THRESHOLD {
    foundation.serial_write_string("[MEMLEAK] WARNING: Current usage ")
    foundation.serial_write_u64(current_memory_usage / 1024)
    foundation.serial_write_string(" KB exceeds threshold\n")
  }

  // Check for old allocations (potential leaks)
  let now: u64 = timer.timer_get_us()
  let old_threshold: u64 = 60000000  // 60 seconds

  var old_count: u32 = 0
  var old_bytes: u64 = 0

  var i: u32 = 0
  loop {
    if i >= MAX_TRACKED_ALLOCATIONS { break }

    if allocations[i].active == 1 {
      let age: u64 = now - allocations[i].timestamp
      if age > old_threshold {
        old_count = old_count + 1
        old_bytes = old_bytes + allocations[i].size
      }
    }

    i = i + 1
  }

  if old_count > 100 {
    foundation.serial_write_string("[MEMLEAK] WARNING: ")
    foundation.serial_write_u64(old_count)
    foundation.serial_write_string(" allocations older than 60s (")
    foundation.serial_write_u64(old_bytes / 1024)
    foundation.serial_write_string(" KB)\n")
  }
}
