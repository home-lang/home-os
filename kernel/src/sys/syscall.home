// home-os Kernel - System Call Interface
// Real implementation with capability enforcement
// Security: All user-space pointer accesses use safety wrappers

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "../core/process.home" as process
import "../core/filesystem.home" as filesystem
import "../security/capabilities.home" as capabilities
import "../security/seccomp.home" as seccomp
import "../security/audit.home" as audit
import "../security/ptr_safety.home" as ptr_safety
import "../perf/async_io.home" as async_io

// Seccomp return values for reference
const SECCOMP_RET_ALLOW: u32 = 0x7FFF0000
const SECCOMP_RET_ERRNO: u32 = 0x00050000
const SECCOMP_RET_KILL_PROCESS: u32 = 0x80000000

// Capability bits (match capabilities.home)
const CAP_KILL: u64 = 1 << 5
const CAP_SETGID: u64 = 1 << 6
const CAP_SETUID: u64 = 1 << 7
const CAP_NET_BIND_SERVICE: u64 = 1 << 10
const CAP_NET_ADMIN: u64 = 1 << 12
const CAP_NET_RAW: u64 = 1 << 13
const CAP_SYS_MODULE: u64 = 1 << 16
const CAP_SYS_RAWIO: u64 = 1 << 17
const CAP_SYS_CHROOT: u64 = 1 << 18
const CAP_SYS_PTRACE: u64 = 1 << 19
const CAP_SYS_ADMIN: u64 = 1 << 21
const CAP_SYS_BOOT: u64 = 1 << 22
const CAP_SYS_RESOURCE: u64 = 1 << 24
const CAP_SYS_TIME: u64 = 1 << 25
const CAP_MKNOD: u64 = 1 << 27

// Error codes
const EPERM: u64 = 0xFFFFFFFFFFFFFFFF  // Operation not permitted
const EINVAL: u64 = 0xFFFFFFFFFFFFFFFE // Invalid argument
const ENOSYS: u64 = 0xFFFFFFFFFFFFFFFD // Function not implemented

// System call numbers
const SYS_EXIT: u32 = 0
const SYS_FORK: u32 = 1
const SYS_READ: u32 = 2
const SYS_WRITE: u32 = 3
const SYS_OPEN: u32 = 4
const SYS_CLOSE: u32 = 5
const SYS_WAIT: u32 = 6
const SYS_EXEC: u32 = 7
const SYS_GETPID: u32 = 8
const SYS_KILL: u32 = 9
const SYS_MMAP: u32 = 10
const SYS_MUNMAP: u32 = 11
const SYS_BRK: u32 = 12
const SYS_LSEEK: u32 = 13
const SYS_MKDIR: u32 = 14
const SYS_RMDIR: u32 = 15
const SYS_SETUID: u32 = 16
const SYS_SETGID: u32 = 17
const SYS_CHROOT: u32 = 18
const SYS_PTRACE: u32 = 19
const SYS_REBOOT: u32 = 20
const SYS_MKNOD: u32 = 21
const SYS_SOCKET: u32 = 22
const SYS_BIND: u32 = 23
const SYS_IOCTL: u32 = 24
const SYS_CAPGET: u32 = 25
const SYS_CAPSET: u32 = 26
const SYS_SETTIMEOFDAY: u32 = 27
const SYS_SETRLIMIT: u32 = 28

// POSIX file operations
const SYS_STAT: u32 = 29
const SYS_FSTAT: u32 = 30
const SYS_LSTAT: u32 = 31
const SYS_UNLINK: u32 = 32
const SYS_LINK: u32 = 33
const SYS_SYMLINK: u32 = 34
const SYS_READLINK: u32 = 35
const SYS_RENAME: u32 = 36
const SYS_ACCESS: u32 = 37
const SYS_CHMOD: u32 = 38
const SYS_CHOWN: u32 = 39
const SYS_FCHMOD: u32 = 40
const SYS_FCHOWN: u32 = 41
const SYS_TRUNCATE: u32 = 42
const SYS_FTRUNCATE: u32 = 43

// Directory operations
const SYS_CHDIR: u32 = 44
const SYS_FCHDIR: u32 = 45
const SYS_GETCWD: u32 = 46
const SYS_GETDENTS: u32 = 47

// Process operations
const SYS_GETPPID: u32 = 48
const SYS_GETUID: u32 = 49
const SYS_GETGID: u32 = 50
const SYS_GETEUID: u32 = 51
const SYS_GETEGID: u32 = 52
const SYS_SETPGID: u32 = 53
const SYS_GETPGID: u32 = 54
const SYS_SETSID: u32 = 55
const SYS_GETSID: u32 = 56
const SYS_GETGROUPS: u32 = 57
const SYS_SETGROUPS: u32 = 58

// Time operations
const SYS_GETTIMEOFDAY: u32 = 59
const SYS_CLOCK_GETTIME: u32 = 60
const SYS_CLOCK_GETRES: u32 = 61
const SYS_NANOSLEEP: u32 = 62

// Signal operations
const SYS_SIGACTION: u32 = 63
const SYS_SIGPROCMASK: u32 = 64
const SYS_SIGPENDING: u32 = 65
const SYS_SIGSUSPEND: u32 = 66

// Memory operations
const SYS_MPROTECT: u32 = 67
const SYS_MSYNC: u32 = 68
const SYS_MADVISE: u32 = 69
const SYS_MINCORE: u32 = 70

// Networking operations
const SYS_CONNECT: u32 = 71
const SYS_LISTEN: u32 = 72
const SYS_ACCEPT: u32 = 73
const SYS_SEND: u32 = 74
const SYS_RECV: u32 = 75
const SYS_SENDTO: u32 = 76
const SYS_RECVFROM: u32 = 77
const SYS_SHUTDOWN: u32 = 78
const SYS_GETSOCKOPT: u32 = 79
const SYS_SETSOCKOPT: u32 = 80
const SYS_GETPEERNAME: u32 = 81
const SYS_GETSOCKNAME: u32 = 82

// Polling/event operations
const SYS_POLL: u32 = 83
const SYS_SELECT: u32 = 84
const SYS_EPOLL_CREATE: u32 = 85
const SYS_EPOLL_CTL: u32 = 86
const SYS_EPOLL_WAIT: u32 = 87
const SYS_EVENTFD: u32 = 88
const SYS_TIMERFD_CREATE: u32 = 89
const SYS_TIMERFD_SETTIME: u32 = 90
const SYS_TIMERFD_GETTIME: u32 = 91

// File descriptor operations
const SYS_DUP: u32 = 92
const SYS_DUP2: u32 = 93
const SYS_DUP3: u32 = 94
const SYS_PIPE: u32 = 95
const SYS_PIPE2: u32 = 96
const SYS_FCNTL: u32 = 97
const SYS_FLOCK: u32 = 98
const SYS_FSYNC: u32 = 99
const SYS_FDATASYNC: u32 = 100

// System information
const SYS_UNAME: u32 = 101
const SYS_GETRLIMIT: u32 = 102
const SYS_GETRUSAGE: u32 = 103
const SYS_SYSINFO: u32 = 104

// Misc
const SYS_UMASK: u32 = 105
const SYS_MOUNT: u32 = 106
const SYS_UMOUNT: u32 = 107

// Async I/O syscalls (io_uring-like interface)
const SYS_IO_URING_SETUP: u32 = 425
const SYS_IO_URING_ENTER: u32 = 426
const SYS_IO_URING_REGISTER: u32 = 427

// Get current process ID for capability checking
var current_pid: u32 = 0

export fn syscall_set_current_pid(pid: u32) {
  current_pid = pid
}

// Check if current process has required capability
fn require_capability(cap: u64): u32 {
  if capabilities.cap_has_capability(current_pid, cap) == 0 {
    foundation.serial_write_string("[Syscall] Permission denied: missing capability 0x")
    foundation.serial_write_hex(@truncate(cap, u32))
    foundation.serial_write_string(" for PID ")
    foundation.serial_write_hex(current_pid)
    foundation.serial_write_string("\n")

    // Log capability denial to audit system
    audit.audit_log_capability(current_pid, 0, cap, -1)

    return 0
  }
  return 1
}

// Log syscall execution to audit (for sensitive syscalls)
fn audit_syscall(syscall_num: u32, result: i32) {
  audit.audit_log_syscall(current_pid, 0, syscall_num, result)
}

export fn syscall_handler(syscall_num: u32, arg1: u64, arg2: u64, arg3: u64, arg4: u64): u64 {
  // ========================================================================
  // Step 1: Seccomp filtering (before any syscall processing)
  // ========================================================================
  var seccomp_result: u32 = seccomp.seccomp_filter_syscall(current_pid, syscall_num)

  if seccomp_result == SECCOMP_RET_KILL_PROCESS {
    foundation.serial_write_string("[Syscall] Seccomp killed process ")
    foundation.serial_write_hex(current_pid)
    foundation.serial_write_string(" for syscall ")
    foundation.serial_write_hex(syscall_num)
    foundation.serial_write_string("\n")
    process.sys_exit(139)  // SIGSEGV
    return EPERM
  }

  if seccomp_result != SECCOMP_RET_ALLOW {
    // Syscall blocked by seccomp filter
    return EPERM
  }

  // ========================================================================
  // Step 2: Syscall dispatch with capability enforcement
  // ========================================================================

  // Unprivileged syscalls - no capability check needed
  if syscall_num == SYS_EXIT {
    process.sys_exit(arg1)
    return 0
  } else if syscall_num == SYS_FORK {
    // Fork inherits capabilities and seccomp settings
    var result: u64 = process.sys_fork()
    if result > 0 {
      // Parent: set up child capabilities and seccomp
      var child_pid: u32 = @truncate(result, u32)
      capabilities.cap_fork(current_pid, child_pid)
      seccomp.seccomp_inherit(current_pid, child_pid)
    }
    return result
  } else if syscall_num == SYS_READ {
    return filesystem.vfs_read(arg1, arg2, arg3)
  } else if syscall_num == SYS_WRITE {
    return filesystem.vfs_write(arg1, arg2, arg3)
  } else if syscall_num == SYS_OPEN {
    return filesystem.vfs_open(arg1, arg2)
  } else if syscall_num == SYS_CLOSE {
    return filesystem.vfs_close(arg1)
  } else if syscall_num == SYS_WAIT {
    return process.sys_wait(arg1)
  } else if syscall_num == SYS_EXEC {
    // Exec recalculates capabilities
    capabilities.cap_exec(current_pid)
    return process.sys_exec(arg1)
  } else if syscall_num == SYS_GETPID {
    return process.sys_getpid()
  } else if syscall_num == SYS_LSEEK {
    return filesystem.vfs_lseek(arg1, arg2, arg3)
  } else if syscall_num == SYS_MKDIR {
    return filesystem.vfs_mkdir(arg1, arg2)
  } else if syscall_num == SYS_RMDIR {
    return filesystem.vfs_rmdir(arg1)
  } else if syscall_num == SYS_MMAP {
    return memory.kmalloc(arg1)
  } else if syscall_num == SYS_MUNMAP {
    memory.kfree(arg1)
    return 0
  } else if syscall_num == SYS_BRK {
    return memory.kmalloc(arg1)
  }

  // Privileged syscalls - require specific capabilities

  // SYS_KILL requires CAP_KILL to signal other processes
  if syscall_num == SYS_KILL {
    var target_pid: u32 = @truncate(arg1, u32)
    // Can always signal own process
    if target_pid != current_pid {
      if require_capability(CAP_KILL) == 0 {
        return EPERM
      }
    }
    return process.sys_kill(target_pid, arg2)
  }

  // SYS_SETUID requires CAP_SETUID
  if syscall_num == SYS_SETUID {
    if require_capability(CAP_SETUID) == 0 {
      return EPERM
    }
    return process.sys_setuid(@truncate(arg1, u32))
  }

  // SYS_SETGID requires CAP_SETGID
  if syscall_num == SYS_SETGID {
    if require_capability(CAP_SETGID) == 0 {
      return EPERM
    }
    return process.sys_setgid(@truncate(arg1, u32))
  }

  // SYS_CHROOT requires CAP_SYS_CHROOT
  if syscall_num == SYS_CHROOT {
    if require_capability(CAP_SYS_CHROOT) == 0 {
      return EPERM
    }
    return filesystem.vfs_chroot(arg1)
  }

  // SYS_PTRACE requires CAP_SYS_PTRACE
  if syscall_num == SYS_PTRACE {
    if require_capability(CAP_SYS_PTRACE) == 0 {
      return EPERM
    }
    return process.sys_ptrace(arg1, arg2, arg3)
  }

  // SYS_REBOOT requires CAP_SYS_BOOT
  if syscall_num == SYS_REBOOT {
    if require_capability(CAP_SYS_BOOT) == 0 {
      return EPERM
    }
    return sys_reboot(@truncate(arg1, u32))
  }

  // SYS_MKNOD requires CAP_MKNOD for device nodes
  if syscall_num == SYS_MKNOD {
    if require_capability(CAP_MKNOD) == 0 {
      return EPERM
    }
    return filesystem.vfs_mknod(arg1, arg2, arg3)
  }

  // SYS_BIND with port < 1024 requires CAP_NET_BIND_SERVICE
  if syscall_num == SYS_BIND {
    var port: u32 = @truncate(arg2, u32)
    if port < 1024 {
      if require_capability(CAP_NET_BIND_SERVICE) == 0 {
        return EPERM
      }
    }
    return sys_bind(arg1, arg2, arg3)
  }

  // SYS_SOCKET with raw type requires CAP_NET_RAW
  if syscall_num == SYS_SOCKET {
    var sock_type: u32 = @truncate(arg2, u32)
    if sock_type == 3 {  // SOCK_RAW
      if require_capability(CAP_NET_RAW) == 0 {
        return EPERM
      }
    }
    return sys_socket(@truncate(arg1, u32), sock_type, @truncate(arg3, u32))
  }

  // SYS_IOCTL on certain devices requires CAP_SYS_RAWIO
  if syscall_num == SYS_IOCTL {
    // For now, just check if it's a privileged ioctl
    var cmd: u32 = @truncate(arg2, u32)
    if (cmd & 0x80000000) != 0 {  // Privileged ioctl bit
      if require_capability(CAP_SYS_RAWIO) == 0 {
        return EPERM
      }
    }
    return sys_ioctl(arg1, cmd, arg3)
  }

  // SYS_CAPGET - get capabilities (unprivileged for own process)
  if syscall_num == SYS_CAPGET {
    var target_pid: u32 = @truncate(arg1, u32)
    if target_pid == 0 {
      target_pid = current_pid
    }
    return capabilities.cap_get_effective(target_pid)
  }

  // SYS_CAPSET - set capabilities requires CAP_SETPCAP
  if syscall_num == SYS_CAPSET {
    // Can only modify own capabilities, and can only drop them
    var target_pid: u32 = @truncate(arg1, u32)
    if target_pid != current_pid {
      return EPERM
    }
    // Can only drop capabilities, not add new ones
    var current_caps: u64 = capabilities.cap_get_effective(current_pid)
    var new_caps: u64 = arg2
    if (new_caps & ~current_caps) != 0 {
      return EPERM  // Trying to add capabilities we don't have
    }
    capabilities.cap_remove_capability(current_pid, current_caps & ~new_caps)
    return 0
  }

  // SYS_SETTIMEOFDAY requires CAP_SYS_TIME
  if syscall_num == SYS_SETTIMEOFDAY {
    if require_capability(CAP_SYS_TIME) == 0 {
      return EPERM
    }
    return sys_settimeofday(arg1, arg2)
  }

  // SYS_SETRLIMIT requires CAP_SYS_RESOURCE
  if syscall_num == SYS_SETRLIMIT {
    if require_capability(CAP_SYS_RESOURCE) == 0 {
      return EPERM
    }
    return sys_setrlimit(@truncate(arg1, u32), arg2)
  }

  // ========================================================================
  // POSIX File Operations
  // ========================================================================

  if syscall_num == SYS_STAT {
    return sys_stat(arg1, arg2)
  } else if syscall_num == SYS_FSTAT {
    return sys_fstat(@truncate(arg1, u32), arg2)
  } else if syscall_num == SYS_LSTAT {
    return sys_lstat(arg1, arg2)
  } else if syscall_num == SYS_UNLINK {
    return sys_unlink(arg1)
  } else if syscall_num == SYS_LINK {
    return sys_link(arg1, arg2)
  } else if syscall_num == SYS_SYMLINK {
    return sys_symlink(arg1, arg2)
  } else if syscall_num == SYS_READLINK {
    return sys_readlink(arg1, arg2, arg3)
  } else if syscall_num == SYS_RENAME {
    return sys_rename(arg1, arg2)
  } else if syscall_num == SYS_ACCESS {
    return sys_access(arg1, @truncate(arg2, u32))
  } else if syscall_num == SYS_CHMOD {
    return filesystem.vfs_chmod(arg1, @truncate(arg2, u32))
  } else if syscall_num == SYS_CHOWN {
    return filesystem.vfs_chown(arg1, @truncate(arg2, u32), @truncate(arg3, u32))
  } else if syscall_num == SYS_FCHMOD {
    return sys_fchmod(@truncate(arg1, u32), @truncate(arg2, u32))
  } else if syscall_num == SYS_FCHOWN {
    return sys_fchown(@truncate(arg1, u32), @truncate(arg2, u32), @truncate(arg3, u32))
  } else if syscall_num == SYS_TRUNCATE {
    return sys_truncate(arg1, arg2)
  } else if syscall_num == SYS_FTRUNCATE {
    return sys_ftruncate(@truncate(arg1, u32), arg2)
  }

  // ========================================================================
  // Directory Operations
  // ========================================================================

  if syscall_num == SYS_CHDIR {
    return sys_chdir(arg1)
  } else if syscall_num == SYS_FCHDIR {
    return sys_fchdir(@truncate(arg1, u32))
  } else if syscall_num == SYS_GETCWD {
    return sys_getcwd(arg1, arg2)
  } else if syscall_num == SYS_GETDENTS {
    return sys_getdents(@truncate(arg1, u32), arg2, @truncate(arg3, u32))
  }

  // ========================================================================
  // Process Information (unprivileged)
  // ========================================================================

  if syscall_num == SYS_GETPPID {
    return sys_getppid()
  } else if syscall_num == SYS_GETUID {
    return sys_getuid()
  } else if syscall_num == SYS_GETGID {
    return sys_getgid()
  } else if syscall_num == SYS_GETEUID {
    return sys_geteuid()
  } else if syscall_num == SYS_GETEGID {
    return sys_getegid()
  } else if syscall_num == SYS_SETPGID {
    return sys_setpgid(@truncate(arg1, u32), @truncate(arg2, u32))
  } else if syscall_num == SYS_GETPGID {
    return sys_getpgid(@truncate(arg1, u32))
  } else if syscall_num == SYS_SETSID {
    return sys_setsid()
  } else if syscall_num == SYS_GETSID {
    return sys_getsid(@truncate(arg1, u32))
  } else if syscall_num == SYS_GETGROUPS {
    return sys_getgroups(@truncate(arg1, u32), arg2)
  } else if syscall_num == SYS_SETGROUPS {
    if require_capability(CAP_SETGID) == 0 {
      return EPERM
    }
    return sys_setgroups(@truncate(arg1, u32), arg2)
  }

  // ========================================================================
  // Time Operations
  // ========================================================================

  if syscall_num == SYS_GETTIMEOFDAY {
    return sys_gettimeofday(arg1, arg2)
  } else if syscall_num == SYS_CLOCK_GETTIME {
    return sys_clock_gettime(@truncate(arg1, u32), arg2)
  } else if syscall_num == SYS_CLOCK_GETRES {
    return sys_clock_getres(@truncate(arg1, u32), arg2)
  } else if syscall_num == SYS_NANOSLEEP {
    return sys_nanosleep(arg1, arg2)
  }

  // ========================================================================
  // Signal Operations
  // ========================================================================

  if syscall_num == SYS_SIGACTION {
    return sys_sigaction(@truncate(arg1, u32), arg2, arg3)
  } else if syscall_num == SYS_SIGPROCMASK {
    return sys_sigprocmask(@truncate(arg1, u32), arg2, arg3)
  } else if syscall_num == SYS_SIGPENDING {
    return sys_sigpending(arg1)
  } else if syscall_num == SYS_SIGSUSPEND {
    return sys_sigsuspend(arg1)
  }

  // ========================================================================
  // Memory Operations
  // ========================================================================

  if syscall_num == SYS_MPROTECT {
    return sys_mprotect(arg1, arg2, @truncate(arg3, u32))
  } else if syscall_num == SYS_MSYNC {
    return sys_msync(arg1, arg2, @truncate(arg3, u32))
  } else if syscall_num == SYS_MADVISE {
    return sys_madvise(arg1, arg2, @truncate(arg3, u32))
  } else if syscall_num == SYS_MINCORE {
    return sys_mincore(arg1, arg2, arg3)
  }

  // ========================================================================
  // Networking Operations
  // ========================================================================

  if syscall_num == SYS_CONNECT {
    return sys_connect(@truncate(arg1, u32), arg2, @truncate(arg3, u32))
  } else if syscall_num == SYS_LISTEN {
    return sys_listen(@truncate(arg1, u32), @truncate(arg2, u32))
  } else if syscall_num == SYS_ACCEPT {
    return sys_accept(@truncate(arg1, u32), arg2, arg3)
  } else if syscall_num == SYS_SEND {
    return sys_send(@truncate(arg1, u32), arg2, arg3, @truncate(arg4, u32))
  } else if syscall_num == SYS_RECV {
    return sys_recv(@truncate(arg1, u32), arg2, arg3, @truncate(arg4, u32))
  } else if syscall_num == SYS_SENDTO {
    return sys_sendto(@truncate(arg1, u32), arg2, arg3, @truncate(arg4, u32))
  } else if syscall_num == SYS_RECVFROM {
    return sys_recvfrom(@truncate(arg1, u32), arg2, arg3, @truncate(arg4, u32))
  } else if syscall_num == SYS_SHUTDOWN {
    return sys_shutdown(@truncate(arg1, u32), @truncate(arg2, u32))
  } else if syscall_num == SYS_GETSOCKOPT {
    return sys_getsockopt(@truncate(arg1, u32), @truncate(arg2, u32), @truncate(arg3, u32), arg4)
  } else if syscall_num == SYS_SETSOCKOPT {
    return sys_setsockopt(@truncate(arg1, u32), @truncate(arg2, u32), @truncate(arg3, u32), arg4)
  } else if syscall_num == SYS_GETPEERNAME {
    return sys_getpeername(@truncate(arg1, u32), arg2, arg3)
  } else if syscall_num == SYS_GETSOCKNAME {
    return sys_getsockname(@truncate(arg1, u32), arg2, arg3)
  }

  // ========================================================================
  // Polling/Event Operations
  // ========================================================================

  if syscall_num == SYS_POLL {
    return sys_poll(arg1, @truncate(arg2, u32), @truncate(arg3, i32))
  } else if syscall_num == SYS_SELECT {
    return sys_select(@truncate(arg1, u32), arg2, arg3, arg4)
  } else if syscall_num == SYS_EPOLL_CREATE {
    return sys_epoll_create(@truncate(arg1, u32))
  } else if syscall_num == SYS_EPOLL_CTL {
    return sys_epoll_ctl(@truncate(arg1, u32), @truncate(arg2, u32), @truncate(arg3, u32), arg4)
  } else if syscall_num == SYS_EPOLL_WAIT {
    return sys_epoll_wait(@truncate(arg1, u32), arg2, @truncate(arg3, u32), @truncate(arg4, i32))
  } else if syscall_num == SYS_EVENTFD {
    return sys_eventfd(@truncate(arg1, u32), @truncate(arg2, u32))
  } else if syscall_num == SYS_TIMERFD_CREATE {
    return sys_timerfd_create(@truncate(arg1, u32), @truncate(arg2, u32))
  } else if syscall_num == SYS_TIMERFD_SETTIME {
    return sys_timerfd_settime(@truncate(arg1, u32), @truncate(arg2, u32), arg3, arg4)
  } else if syscall_num == SYS_TIMERFD_GETTIME {
    return sys_timerfd_gettime(@truncate(arg1, u32), arg2)
  }

  // ========================================================================
  // File Descriptor Operations
  // ========================================================================

  if syscall_num == SYS_DUP {
    return sys_dup(@truncate(arg1, u32))
  } else if syscall_num == SYS_DUP2 {
    return sys_dup2(@truncate(arg1, u32), @truncate(arg2, u32))
  } else if syscall_num == SYS_DUP3 {
    return sys_dup3(@truncate(arg1, u32), @truncate(arg2, u32), @truncate(arg3, u32))
  } else if syscall_num == SYS_PIPE {
    return sys_pipe(arg1)
  } else if syscall_num == SYS_PIPE2 {
    return sys_pipe2(arg1, @truncate(arg2, u32))
  } else if syscall_num == SYS_FCNTL {
    return sys_fcntl(@truncate(arg1, u32), @truncate(arg2, u32), arg3)
  } else if syscall_num == SYS_FLOCK {
    return sys_flock(@truncate(arg1, u32), @truncate(arg2, u32))
  } else if syscall_num == SYS_FSYNC {
    return sys_fsync(@truncate(arg1, u32))
  } else if syscall_num == SYS_FDATASYNC {
    return sys_fdatasync(@truncate(arg1, u32))
  }

  // ========================================================================
  // System Information
  // ========================================================================

  if syscall_num == SYS_UNAME {
    return sys_uname(arg1)
  } else if syscall_num == SYS_GETRLIMIT {
    return sys_getrlimit(@truncate(arg1, u32), arg2)
  } else if syscall_num == SYS_GETRUSAGE {
    return sys_getrusage(@truncate(arg1, i32), arg2)
  } else if syscall_num == SYS_SYSINFO {
    return sys_sysinfo(arg1)
  }

  // ========================================================================
  // Miscellaneous
  // ========================================================================

  if syscall_num == SYS_UMASK {
    return sys_umask(@truncate(arg1, u32))
  } else if syscall_num == SYS_MOUNT {
    if require_capability(CAP_SYS_ADMIN) == 0 {
      return EPERM
    }
    return sys_mount(arg1, arg2, arg3, @truncate(arg4, u32))
  } else if syscall_num == SYS_UMOUNT {
    if require_capability(CAP_SYS_ADMIN) == 0 {
      return EPERM
    }
    return sys_umount(arg1, @truncate(arg2, u32))
  }

  // ========================================================================
  // Async I/O syscalls (io_uring-like interface)
  // ========================================================================

  // SYS_IO_URING_SETUP - create a new io_uring instance
  // arg1: entries (queue size)
  // arg2: pointer to io_uring_params struct
  // Returns: ring fd on success, negative errno on failure
  if syscall_num == SYS_IO_URING_SETUP {
    var entries: u32 = @truncate(arg1, u32)
    return sys_io_uring_setup(entries, arg2)
  }

  // SYS_IO_URING_ENTER - submit I/O requests and/or wait for completions
  // arg1: ring fd
  // arg2: to_submit (number of SQEs to submit)
  // arg3: min_complete (wait until this many CQEs)
  // arg4: flags
  // Returns: number of CQEs completed
  if syscall_num == SYS_IO_URING_ENTER {
    var ring_id: u32 = @truncate(arg1, u32)
    var to_submit: u32 = @truncate(arg2, u32)
    var min_complete: u32 = @truncate(arg3, u32)
    var flags: u32 = @truncate(arg4, u32)
    return sys_io_uring_enter(ring_id, to_submit, min_complete, flags)
  }

  // SYS_IO_URING_REGISTER - register resources for async I/O
  // arg1: ring fd
  // arg2: opcode (what to register)
  // arg3: arg (pointer to data)
  // arg4: nr_args (number of items)
  // Returns: 0 on success, negative errno on failure
  if syscall_num == SYS_IO_URING_REGISTER {
    var ring_id: u32 = @truncate(arg1, u32)
    var opcode: u32 = @truncate(arg2, u32)
    return sys_io_uring_register(ring_id, opcode, arg3, @truncate(arg4, u32))
  }

  return ENOSYS  // Function not implemented
}

// Stub syscall implementations for new syscalls
fn sys_reboot(cmd: u32): u64 {
  foundation.serial_write_string("[Syscall] Reboot requested with cmd: ")
  foundation.serial_write_hex(cmd)
  foundation.serial_write_string("\n")
  // In real implementation, would trigger system reboot
  return 0
}

fn sys_bind(sockfd: u64, port: u64, addr: u64): u64 {
  // Placeholder for socket bind
  return 0
}

fn sys_socket(domain: u32, sock_type: u32, protocol: u32): u64 {
  // Placeholder for socket creation
  return 0
}

fn sys_ioctl(fd: u64, cmd: u32, arg: u64): u64 {
  // Placeholder for ioctl
  return 0
}

fn sys_settimeofday(tv: u64, tz: u64): u64 {
  // Placeholder for setting time
  return 0
}

fn sys_setrlimit(resource: u32, rlim: u64): u64 {
  // Placeholder for setting resource limits
  return 0
}

// ============================================================================
// POSIX File Operations
// ============================================================================

// Stat structure layout (matches POSIX struct stat)
const STAT_SIZE: u32 = 144  // Size of stat structure

fn sys_stat(path: u64, statbuf: u64): u64 {
  // Get file metadata by path
  if path == 0 or statbuf == 0 { return EINVAL }
  // Would query VFS for inode info and populate statbuf
  return 0
}

fn sys_fstat(fd: u32, statbuf: u64): u64 {
  // Get file metadata by file descriptor
  if statbuf == 0 { return EINVAL }
  // Would query VFS for inode info from fd table
  return 0
}

fn sys_lstat(path: u64, statbuf: u64): u64 {
  // Like stat but doesn't follow symlinks
  if path == 0 or statbuf == 0 { return EINVAL }
  return 0
}

fn sys_unlink(path: u64): u64 {
  // Delete a file
  if path == 0 { return EINVAL }
  // Would call VFS to remove file entry
  return 0
}

fn sys_link(oldpath: u64, newpath: u64): u64 {
  // Create a hard link
  if oldpath == 0 or newpath == 0 { return EINVAL }
  return 0
}

fn sys_symlink(target: u64, linkpath: u64): u64 {
  // Create a symbolic link
  if target == 0 or linkpath == 0 { return EINVAL }
  return 0
}

fn sys_readlink(path: u64, buf: u64, bufsiz: u64): u64 {
  // Read value of a symbolic link
  if path == 0 or buf == 0 { return EINVAL }
  return 0
}

fn sys_rename(oldpath: u64, newpath: u64): u64 {
  // Rename a file
  if oldpath == 0 or newpath == 0 { return EINVAL }
  return 0
}

fn sys_access(path: u64, mode: u32): u64 {
  // Check file accessibility
  if path == 0 { return EINVAL }
  // Would check permissions against current uid/gid
  return 0
}

fn sys_fchmod(fd: u32, mode: u32): u64 {
  // Change mode of file by fd
  return 0
}

fn sys_fchown(fd: u32, owner: u32, group: u32): u64 {
  // Change owner of file by fd
  return 0
}

fn sys_truncate(path: u64, length: u64): u64 {
  // Truncate file to length by path
  if path == 0 { return EINVAL }
  return 0
}

fn sys_ftruncate(fd: u32, length: u64): u64 {
  // Truncate file to length by fd
  return 0
}

// ============================================================================
// Directory Operations
// ============================================================================

// Per-process current working directory
var process_cwd: [256][256]u8  // CWD for each process
var process_cwd_len: [256]u32  // Length of CWD

fn sys_chdir(path: u64): u64 {
  // Change current directory
  if path == 0 { return EINVAL }
  // Would verify path exists and is directory, then update process CWD
  return 0
}

fn sys_fchdir(fd: u32): u64 {
  // Change directory by file descriptor
  return 0
}

fn sys_getcwd(buf: u64, size: u64): u64 {
  // Get current working directory
  if buf == 0 { return EINVAL }

  // Validate user-space buffer before writing
  if ptr_safety.ptr_is_user(buf) == 0 {
    foundation.serial_write_string("[Syscall] getcwd: invalid user buffer\n")
    return EINVAL
  }

  if ptr_safety.ptr_check_range(buf, size) == 0 {
    foundation.serial_write_string("[Syscall] getcwd: buffer range invalid\n")
    return EINVAL
  }

  // Safe write to user buffer
  if ptr_safety.ptr_safe_write_u8(buf, '/') != 0 {
    return EINVAL
  }
  if ptr_safety.ptr_safe_write_u8(buf + 1, 0) != 0 {
    return EINVAL
  }

  return buf  // Return buf on success
}

fn sys_getdents(fd: u32, dirp: u64, count: u32): u64 {
  // Read directory entries
  if dirp == 0 { return EINVAL }
  // Would read directory entries from VFS
  return 0
}

// ============================================================================
// Process Information
// ============================================================================

// Per-process credential information
var process_uid: [256]u32
var process_gid: [256]u32
var process_euid: [256]u32
var process_egid: [256]u32
var process_pgid: [256]u32
var process_sid: [256]u32

fn sys_getppid(): u64 {
  // Get parent process ID
  // Would look up parent_pid from process table
  return 1  // Return init as default parent
}

fn sys_getuid(): u64 {
  if current_pid < 256 {
    return @as(u64, process_uid[current_pid])
  }
  return 0
}

fn sys_getgid(): u64 {
  if current_pid < 256 {
    return @as(u64, process_gid[current_pid])
  }
  return 0
}

fn sys_geteuid(): u64 {
  if current_pid < 256 {
    return @as(u64, process_euid[current_pid])
  }
  return 0
}

fn sys_getegid(): u64 {
  if current_pid < 256 {
    return @as(u64, process_egid[current_pid])
  }
  return 0
}

fn sys_setpgid(pid: u32, pgid: u32): u64 {
  var target_pid: u32 = pid
  if target_pid == 0 { target_pid = current_pid }
  if target_pid >= 256 { return EINVAL }

  var new_pgid: u32 = pgid
  if new_pgid == 0 { new_pgid = target_pid }

  process_pgid[target_pid] = new_pgid
  return 0
}

fn sys_getpgid(pid: u32): u64 {
  var target_pid: u32 = pid
  if target_pid == 0 { target_pid = current_pid }
  if target_pid >= 256 { return EINVAL }
  return @as(u64, process_pgid[target_pid])
}

fn sys_setsid(): u64 {
  // Create new session
  if current_pid >= 256 { return EINVAL }
  process_sid[current_pid] = current_pid
  process_pgid[current_pid] = current_pid
  return @as(u64, current_pid)
}

fn sys_getsid(pid: u32): u64 {
  var target_pid: u32 = pid
  if target_pid == 0 { target_pid = current_pid }
  if target_pid >= 256 { return EINVAL }
  return @as(u64, process_sid[target_pid])
}

fn sys_getgroups(size: u32, list: u64): u64 {
  // Get supplementary group IDs
  if size == 0 {
    return 0  // Return count of groups
  }
  return 0
}

fn sys_setgroups(size: u32, list: u64): u64 {
  // Set supplementary group IDs (requires CAP_SETGID)
  return 0
}

// ============================================================================
// Time Operations
// ============================================================================

// Timeval structure
struct Timeval {
  tv_sec: u64,
  tv_usec: u64
}

// Timespec structure
struct Timespec {
  tv_sec: u64,
  tv_nsec: u64
}

// Clock IDs
const CLOCK_REALTIME: u32 = 0
const CLOCK_MONOTONIC: u32 = 1
const CLOCK_PROCESS_CPUTIME_ID: u32 = 2
const CLOCK_THREAD_CPUTIME_ID: u32 = 3
const CLOCK_MONOTONIC_RAW: u32 = 4
const CLOCK_REALTIME_COARSE: u32 = 5
const CLOCK_MONOTONIC_COARSE: u32 = 6

// System time (would be set from RTC)
var system_time_sec: u64 = 0
var system_time_usec: u64 = 0
var monotonic_time_ns: u64 = 0

fn sys_gettimeofday(tv: u64, tz: u64): u64 {
  if tv != 0 {
    // Validate user-space pointer
    if ptr_safety.ptr_is_user(tv) == 0 {
      foundation.serial_write_string("[Syscall] gettimeofday: invalid user buffer\n")
      return EINVAL
    }

    // Validate range for Timeval structure (16 bytes)
    if ptr_safety.ptr_check_range(tv, 16) == 0 {
      return EINVAL
    }

    // Safe write to user buffer
    if ptr_safety.ptr_safe_write_u64(tv, system_time_sec) != 0 {
      return EINVAL
    }
    if ptr_safety.ptr_safe_write_u64(tv + 8, system_time_usec) != 0 {
      return EINVAL
    }
  }
  return 0
}

fn sys_clock_gettime(clk_id: u32, tp: u64): u64 {
  if tp == 0 { return EINVAL }

  // Validate user-space pointer
  if ptr_safety.ptr_is_user(tp) == 0 {
    foundation.serial_write_string("[Syscall] clock_gettime: invalid user buffer\n")
    return EINVAL
  }

  // Validate range for Timespec structure (16 bytes)
  if ptr_safety.ptr_check_range(tp, 16) == 0 {
    return EINVAL
  }

  if clk_id == CLOCK_REALTIME or clk_id == CLOCK_REALTIME_COARSE {
    // Safe write to user buffer
    if ptr_safety.ptr_safe_write_u64(tp, system_time_sec) != 0 { return EINVAL }
    if ptr_safety.ptr_safe_write_u64(tp + 8, system_time_usec * 1000) != 0 { return EINVAL }
  } else if clk_id == CLOCK_MONOTONIC or clk_id == CLOCK_MONOTONIC_RAW or clk_id == CLOCK_MONOTONIC_COARSE {
    if ptr_safety.ptr_safe_write_u64(tp, monotonic_time_ns / 1_000_000_000) != 0 { return EINVAL }
    if ptr_safety.ptr_safe_write_u64(tp + 8, monotonic_time_ns % 1_000_000_000) != 0 { return EINVAL }
  } else {
    return EINVAL
  }

  return 0
}

fn sys_clock_getres(clk_id: u32, res: u64): u64 {
  if res == 0 { return 0 }  // Just check validity

  // Validate user-space pointer
  if ptr_safety.ptr_is_user(res) == 0 {
    return EINVAL
  }

  // Validate range for Timespec structure (16 bytes)
  if ptr_safety.ptr_check_range(res, 16) == 0 {
    return EINVAL
  }

  // Safe write to user buffer
  if ptr_safety.ptr_safe_write_u64(res, 0) != 0 { return EINVAL }
  if ptr_safety.ptr_safe_write_u64(res + 8, 1) != 0 { return EINVAL }  // 1ns resolution
  return 0
}

fn sys_nanosleep(req: u64, rem: u64): u64 {
  if req == 0 { return EINVAL }
  // Would sleep for specified duration using timer
  return 0
}

// ============================================================================
// Signal Operations
// ============================================================================

// Signal numbers
const SIGHUP: u32 = 1
const SIGINT: u32 = 2
const SIGQUIT: u32 = 3
const SIGKILL: u32 = 9
const SIGTERM: u32 = 15
const SIGCHLD: u32 = 17
const SIGCONT: u32 = 18
const SIGSTOP: u32 = 19

// Signal action flags
const SA_NOCLDSTOP: u32 = 1
const SA_NOCLDWAIT: u32 = 2
const SA_SIGINFO: u32 = 4
const SA_RESTART: u32 = 0x10000000
const SA_RESETHAND: u32 = 0x80000000

fn sys_sigaction(signum: u32, act: u64, oldact: u64): u64 {
  if signum == SIGKILL or signum == SIGSTOP {
    return EINVAL  // Cannot change SIGKILL or SIGSTOP
  }
  // Would install signal handler
  return 0
}

fn sys_sigprocmask(how: u32, set: u64, oldset: u64): u64 {
  // Change blocked signals
  return 0
}

fn sys_sigpending(set: u64): u64 {
  // Get pending signals
  if set == 0 { return EINVAL }
  return 0
}

fn sys_sigsuspend(mask: u64): u64 {
  // Wait for signal with mask
  return EINVAL  // Always returns error when signal arrives
}

// ============================================================================
// Memory Operations
// ============================================================================

// Protection flags
const PROT_NONE: u32 = 0
const PROT_READ: u32 = 1
const PROT_WRITE: u32 = 2
const PROT_EXEC: u32 = 4

// Sync flags
const MS_ASYNC: u32 = 1
const MS_SYNC: u32 = 4
const MS_INVALIDATE: u32 = 2

// Madvise flags
const MADV_NORMAL: u32 = 0
const MADV_RANDOM: u32 = 1
const MADV_SEQUENTIAL: u32 = 2
const MADV_WILLNEED: u32 = 3
const MADV_DONTNEED: u32 = 4

fn sys_mprotect(addr: u64, len: u64, prot: u32): u64 {
  // Change memory protection
  if (addr & 0xFFF) != 0 { return EINVAL }  // Must be page-aligned
  // Would update page table entries
  return 0
}

fn sys_msync(addr: u64, length: u64, flags: u32): u64 {
  // Synchronize memory with backing store
  if (addr & 0xFFF) != 0 { return EINVAL }
  return 0
}

fn sys_madvise(addr: u64, length: u64, advice: u32): u64 {
  // Give memory advice to kernel
  if (addr & 0xFFF) != 0 { return EINVAL }
  return 0
}

fn sys_mincore(addr: u64, length: u64, vec: u64): u64 {
  // Check if pages are in memory
  if (addr & 0xFFF) != 0 or vec == 0 { return EINVAL }
  return 0
}

// ============================================================================
// Networking Operations
// ============================================================================

// Socket domains
const AF_UNIX: u32 = 1
const AF_INET: u32 = 2
const AF_INET6: u32 = 10

// Socket types
const SOCK_STREAM: u32 = 1
const SOCK_DGRAM: u32 = 2
const SOCK_RAW: u32 = 3

// Shutdown modes
const SHUT_RD: u32 = 0
const SHUT_WR: u32 = 1
const SHUT_RDWR: u32 = 2

fn sys_connect(sockfd: u32, addr: u64, addrlen: u32): u64 {
  // Connect socket to address
  if addr == 0 { return EINVAL }
  return 0
}

fn sys_listen(sockfd: u32, backlog: u32): u64 {
  // Mark socket as listening
  return 0
}

fn sys_accept(sockfd: u32, addr: u64, addrlen: u64): u64 {
  // Accept connection on socket
  return 0
}

fn sys_send(sockfd: u32, buf: u64, len: u64, flags: u32): u64 {
  if buf == 0 { return EINVAL }
  return len  // Would send data
}

fn sys_recv(sockfd: u32, buf: u64, len: u64, flags: u32): u64 {
  if buf == 0 { return EINVAL }
  return 0  // Would receive data
}

fn sys_sendto(sockfd: u32, buf: u64, len: u64, flags: u32): u64 {
  // Send to specific address (UDP)
  return len
}

fn sys_recvfrom(sockfd: u32, buf: u64, len: u64, flags: u32): u64 {
  // Receive with sender address (UDP)
  return 0
}

fn sys_shutdown(sockfd: u32, how: u32): u64 {
  if how > SHUT_RDWR { return EINVAL }
  return 0
}

fn sys_getsockopt(sockfd: u32, level: u32, optname: u32, optval: u64): u64 {
  // Get socket option
  return 0
}

fn sys_setsockopt(sockfd: u32, level: u32, optname: u32, optval: u64): u64 {
  // Set socket option
  return 0
}

fn sys_getpeername(sockfd: u32, addr: u64, addrlen: u64): u64 {
  // Get peer address
  if addr == 0 { return EINVAL }
  return 0
}

fn sys_getsockname(sockfd: u32, addr: u64, addrlen: u64): u64 {
  // Get local address
  if addr == 0 { return EINVAL }
  return 0
}

// ============================================================================
// Polling/Event Operations
// ============================================================================

// Poll events
const POLLIN: u16 = 0x0001
const POLLPRI: u16 = 0x0002
const POLLOUT: u16 = 0x0004
const POLLERR: u16 = 0x0008
const POLLHUP: u16 = 0x0010
const POLLNVAL: u16 = 0x0020

// Epoll operations
const EPOLL_CTL_ADD: u32 = 1
const EPOLL_CTL_DEL: u32 = 2
const EPOLL_CTL_MOD: u32 = 3

// Epoll events
const EPOLLIN: u32 = 0x001
const EPOLLOUT: u32 = 0x004
const EPOLLERR: u32 = 0x008
const EPOLLHUP: u32 = 0x010
const EPOLLET: u32 = 0x80000000

// Epoll instance tracking
var epoll_instances: [64]u32
var epoll_count: u32 = 0

fn sys_poll(fds: u64, nfds: u32, timeout: i32): u64 {
  if fds == 0 and nfds > 0 { return EINVAL }
  // Would poll file descriptors for events
  return 0
}

fn sys_select(nfds: u32, readfds: u64, writefds: u64, exceptfds: u64): u64 {
  // Select on file descriptors
  return 0
}

fn sys_epoll_create(size: u32): u64 {
  // Create epoll instance
  if epoll_count >= 64 { return EINVAL }
  var fd: u32 = epoll_count + 100  // Offset to avoid fd conflicts
  epoll_instances[epoll_count] = fd
  epoll_count = epoll_count + 1
  return @as(u64, fd)
}

fn sys_epoll_ctl(epfd: u32, op: u32, fd: u32, event: u64): u64 {
  // Control epoll
  if op > EPOLL_CTL_MOD { return EINVAL }
  return 0
}

fn sys_epoll_wait(epfd: u32, events: u64, maxevents: u32, timeout: i32): u64 {
  if events == 0 or maxevents == 0 { return EINVAL }
  // Would wait for events
  return 0
}

fn sys_eventfd(initval: u32, flags: u32): u64 {
  // Create eventfd
  return 0  // Would return fd
}

fn sys_timerfd_create(clockid: u32, flags: u32): u64 {
  // Create timer fd
  return 0
}

fn sys_timerfd_settime(fd: u32, flags: u32, new_value: u64, old_value: u64): u64 {
  // Set timer
  return 0
}

fn sys_timerfd_gettime(fd: u32, curr_value: u64): u64 {
  // Get current timer value
  return 0
}

// ============================================================================
// File Descriptor Operations
// ============================================================================

fn sys_dup(oldfd: u32): u64 {
  // Duplicate file descriptor
  return 0  // Would return new fd
}

fn sys_dup2(oldfd: u32, newfd: u32): u64 {
  // Duplicate to specific fd
  return @as(u64, newfd)
}

fn sys_dup3(oldfd: u32, newfd: u32, flags: u32): u64 {
  // Duplicate with flags
  if oldfd == newfd { return EINVAL }
  return @as(u64, newfd)
}

// Pipe tracking
var pipe_count: u32 = 0

fn sys_pipe(pipefd: u64): u64 {
  if pipefd == 0 { return EINVAL }

  // Validate user-space pointer
  if ptr_safety.ptr_is_user(pipefd) == 0 {
    foundation.serial_write_string("[Syscall] pipe: invalid user buffer\n")
    return EINVAL
  }

  // Validate range for two u32 values (8 bytes)
  if ptr_safety.ptr_check_range(pipefd, 8) == 0 {
    return EINVAL
  }

  // Validate alignment for u32 access
  if ptr_safety.ptr_is_aligned_u32(pipefd) == 0 {
    foundation.serial_write_string("[Syscall] pipe: unaligned buffer\n")
    return EINVAL
  }

  // Safe write to user buffer
  var read_fd: u32 = 200 + pipe_count * 2      // Read end
  var write_fd: u32 = 200 + pipe_count * 2 + 1 // Write end

  if ptr_safety.ptr_safe_write_u32(pipefd, read_fd) != 0 {
    return EINVAL
  }
  if ptr_safety.ptr_safe_write_u32(pipefd + 4, write_fd) != 0 {
    return EINVAL
  }

  pipe_count = pipe_count + 1
  return 0
}

fn sys_pipe2(pipefd: u64, flags: u32): u64 {
  return sys_pipe(pipefd)  // Would handle flags
}

// Fcntl commands
const F_DUPFD: u32 = 0
const F_GETFD: u32 = 1
const F_SETFD: u32 = 2
const F_GETFL: u32 = 3
const F_SETFL: u32 = 4
const F_GETLK: u32 = 5
const F_SETLK: u32 = 6
const F_SETLKW: u32 = 7

fn sys_fcntl(fd: u32, cmd: u32, arg: u64): u64 {
  // File control operations
  if cmd == F_GETFD or cmd == F_GETFL {
    return 0
  }
  return 0
}

// Flock operations
const LOCK_SH: u32 = 1
const LOCK_EX: u32 = 2
const LOCK_UN: u32 = 8
const LOCK_NB: u32 = 4

fn sys_flock(fd: u32, operation: u32): u64 {
  // File locking
  return 0
}

fn sys_fsync(fd: u32): u64 {
  // Sync file to disk
  return 0
}

fn sys_fdatasync(fd: u32): u64 {
  // Sync file data (not metadata)
  return 0
}

// ============================================================================
// System Information
// ============================================================================

// Utsname structure
struct Utsname {
  sysname: [65]u8,
  nodename: [65]u8,
  release: [65]u8,
  version: [65]u8,
  machine: [65]u8,
  domainname: [65]u8
}

fn sys_uname(buf: u64): u64 {
  if buf == 0 { return EINVAL }

  // Validate user-space pointer
  if ptr_safety.ptr_is_user(buf) == 0 {
    foundation.serial_write_string("[Syscall] uname: invalid user buffer\n")
    return EINVAL
  }

  // Validate range for Utsname structure (390 bytes = 6 * 65)
  if ptr_safety.ptr_check_range(buf, 390) == 0 {
    return EINVAL
  }

  // Safe copy strings using ptr_safety wrappers
  safe_copy_string_to_user(buf, "HomeOS", 65)           // sysname
  safe_copy_string_to_user(buf + 65, "home", 65)        // nodename
  safe_copy_string_to_user(buf + 130, "0.1.0", 65)      // release
  safe_copy_string_to_user(buf + 195, "#1 SMP", 65)     // version
  safe_copy_string_to_user(buf + 260, "x86_64", 65)     // machine
  safe_copy_string_to_user(buf + 325, "(none)", 65)     // domainname

  return 0
}

fn safe_copy_string_to_user(dest: u64, src: []const u8, max_len: u64) void {
  var i: u64 = 0
  while i < src.len and i < max_len - 1 {
    ptr_safety.ptr_safe_write_u8(dest + i, src[i])
    i = i + 1
  }
  ptr_safety.ptr_safe_write_u8(dest + i, 0)  // Null terminate
}

fn copy_string(dest: *[65]u8, src: []const u8) {
  var i: u32 = 0
  while i < src.len and i < 64 {
    dest[i] = src[i]
    i = i + 1
  }
  dest[i] = 0
}

// Resource limit structure
struct Rlimit {
  rlim_cur: u64,  // Soft limit
  rlim_max: u64   // Hard limit
}

// Resource types
const RLIMIT_CPU: u32 = 0
const RLIMIT_FSIZE: u32 = 1
const RLIMIT_DATA: u32 = 2
const RLIMIT_STACK: u32 = 3
const RLIMIT_CORE: u32 = 4
const RLIMIT_RSS: u32 = 5
const RLIMIT_NPROC: u32 = 6
const RLIMIT_NOFILE: u32 = 7
const RLIMIT_MEMLOCK: u32 = 8
const RLIMIT_AS: u32 = 9

const RLIM_INFINITY: u64 = 0xFFFFFFFFFFFFFFFF

fn sys_getrlimit(resource: u32, rlim: u64): u64 {
  if rlim == 0 { return EINVAL }

  // Validate user-space pointer
  if ptr_safety.ptr_is_user(rlim) == 0 {
    foundation.serial_write_string("[Syscall] getrlimit: invalid user buffer\n")
    return EINVAL
  }

  // Validate range for Rlimit structure (16 bytes)
  if ptr_safety.ptr_check_range(rlim, 16) == 0 {
    return EINVAL
  }

  // Return sensible defaults using safe writes
  if resource == RLIMIT_NOFILE {
    if ptr_safety.ptr_safe_write_u64(rlim, 1024) != 0 { return EINVAL }
    if ptr_safety.ptr_safe_write_u64(rlim + 8, 4096) != 0 { return EINVAL }
  } else if resource == RLIMIT_STACK {
    if ptr_safety.ptr_safe_write_u64(rlim, 8 * 1024 * 1024) != 0 { return EINVAL }  // 8MB
    if ptr_safety.ptr_safe_write_u64(rlim + 8, RLIM_INFINITY) != 0 { return EINVAL }
  } else {
    if ptr_safety.ptr_safe_write_u64(rlim, RLIM_INFINITY) != 0 { return EINVAL }
    if ptr_safety.ptr_safe_write_u64(rlim + 8, RLIM_INFINITY) != 0 { return EINVAL }
  }

  return 0
}

// Resource usage structure
struct Rusage {
  ru_utime: Timeval,   // User time
  ru_stime: Timeval,   // System time
  ru_maxrss: u64,      // Max resident set size
  ru_ixrss: u64,       // Shared memory size
  ru_idrss: u64,       // Unshared data size
  ru_isrss: u64,       // Unshared stack size
  ru_minflt: u64,      // Minor page faults
  ru_majflt: u64,      // Major page faults
  ru_nswap: u64,       // Swaps
  ru_inblock: u64,     // Block input operations
  ru_oublock: u64,     // Block output operations
  ru_msgsnd: u64,      // Messages sent
  ru_msgrcv: u64,      // Messages received
  ru_nsignals: u64,    // Signals received
  ru_nvcsw: u64,       // Voluntary context switches
  ru_nivcsw: u64       // Involuntary context switches
}

const RUSAGE_SELF: i32 = 0
const RUSAGE_CHILDREN: i32 = -1
const RUSAGE_THREAD: i32 = 1

fn sys_getrusage(who: i32, usage: u64): u64 {
  if usage == 0 { return EINVAL }
  // Would fill in resource usage from process accounting
  return 0
}

// Sysinfo structure
struct Sysinfo {
  uptime: u64,        // Seconds since boot
  loads: [3]u64,      // 1, 5, 15 minute load averages
  totalram: u64,      // Total usable main memory
  freeram: u64,       // Available memory
  sharedram: u64,     // Amount of shared memory
  bufferram: u64,     // Memory used by buffers
  totalswap: u64,     // Total swap space
  freeswap: u64,      // Swap space available
  procs: u16,         // Number of processes
  pad: u16,
  totalhigh: u64,     // Total high memory
  freehigh: u64,      // Available high memory
  mem_unit: u32       // Memory unit size (bytes)
}

fn sys_sysinfo(info: u64): u64 {
  if info == 0 { return EINVAL }

  // Validate user-space pointer
  if ptr_safety.ptr_is_user(info) == 0 {
    foundation.serial_write_string("[Syscall] sysinfo: invalid user buffer\n")
    return EINVAL
  }

  // Validate range for Sysinfo structure (112 bytes)
  if ptr_safety.ptr_check_range(info, 112) == 0 {
    return EINVAL
  }

  // Safe writes to user buffer
  // uptime (offset 0)
  if ptr_safety.ptr_safe_write_u64(info, monotonic_time_ns / 1_000_000_000) != 0 { return EINVAL }

  // loads[3] (offset 8, 16, 24)
  if ptr_safety.ptr_safe_write_u64(info + 8, 0) != 0 { return EINVAL }
  if ptr_safety.ptr_safe_write_u64(info + 16, 0) != 0 { return EINVAL }
  if ptr_safety.ptr_safe_write_u64(info + 24, 0) != 0 { return EINVAL }

  // totalram, freeram, sharedram, bufferram (offsets 32, 40, 48, 56)
  if ptr_safety.ptr_safe_write_u64(info + 32, 256 * 1024 * 1024) != 0 { return EINVAL }  // 256MB
  if ptr_safety.ptr_safe_write_u64(info + 40, 128 * 1024 * 1024) != 0 { return EINVAL }  // 128MB
  if ptr_safety.ptr_safe_write_u64(info + 48, 0) != 0 { return EINVAL }
  if ptr_safety.ptr_safe_write_u64(info + 56, 0) != 0 { return EINVAL }

  // totalswap, freeswap (offsets 64, 72)
  if ptr_safety.ptr_safe_write_u64(info + 64, 0) != 0 { return EINVAL }
  if ptr_safety.ptr_safe_write_u64(info + 72, 0) != 0 { return EINVAL }

  // procs (u16), pad (u16) at offset 80
  if ptr_safety.ptr_safe_write_u32(info + 80, 1) != 0 { return EINVAL }  // procs=1, pad=0

  // totalhigh, freehigh (offsets 84, 92)
  if ptr_safety.ptr_safe_write_u64(info + 84, 0) != 0 { return EINVAL }
  if ptr_safety.ptr_safe_write_u64(info + 92, 0) != 0 { return EINVAL }

  // mem_unit (offset 100)
  if ptr_safety.ptr_safe_write_u32(info + 100, 1) != 0 { return EINVAL }

  return 0
}

// ============================================================================
// Miscellaneous
// ============================================================================

var current_umask: u32 = 0o022

fn sys_umask(mask: u32): u64 {
  var old_mask: u32 = current_umask
  current_umask = mask & 0o777
  return @as(u64, old_mask)
}

fn sys_mount(source: u64, target: u64, filesystemtype: u64, mountflags: u32): u64 {
  // Mount filesystem (requires CAP_SYS_ADMIN - checked in handler)
  if target == 0 { return EINVAL }
  foundation.serial_write_string("[Syscall] mount requested\n")
  return 0
}

fn sys_umount(target: u64, flags: u32): u64 {
  // Unmount filesystem (requires CAP_SYS_ADMIN - checked in handler)
  if target == 0 { return EINVAL }
  foundation.serial_write_string("[Syscall] umount requested\n")
  return 0
}

// ============================================================================
// Time Update (called by timer interrupt)
// ============================================================================

export fn syscall_tick_time(ns_elapsed: u64) {
  monotonic_time_ns = monotonic_time_ns + ns_elapsed

  // Update system time (simple increment, real implementation would use RTC)
  system_time_usec = system_time_usec + (ns_elapsed / 1000)
  while system_time_usec >= 1_000_000 {
    system_time_sec = system_time_sec + 1
    system_time_usec = system_time_usec - 1_000_000
  }
}

export fn syscall_set_time(sec: u64, usec: u64) {
  system_time_sec = sec
  system_time_usec = usec
}

export fn syscall_init() {
  foundation.serial_write_string("[Syscall] Initialized\n")

  // Initialize async I/O subsystem
  async_io.async_io_init()
}

// ============================================================================
// Async I/O (io_uring-like) syscall implementations
// ============================================================================

// io_uring_params flags
const IORING_SETUP_SQPOLL: u32 = 1 << 1       // Use polling thread
const IORING_SETUP_SQ_AFF: u32 = 1 << 2       // SQ poll thread affinity
const IORING_SETUP_CQSIZE: u32 = 1 << 3       // Custom CQ size
const IORING_SETUP_CLAMP: u32 = 1 << 4        // Clamp queue sizes

// io_uring_enter flags
const IORING_ENTER_GETEVENTS: u32 = 1 << 0    // Wait for events
const IORING_ENTER_SQ_WAKEUP: u32 = 1 << 1    // Wake SQ poll thread
const IORING_ENTER_SQ_WAIT: u32 = 1 << 2      // Wait for SQ space

// io_uring_register opcodes
const IORING_REGISTER_BUFFERS: u32 = 0
const IORING_REGISTER_FILES: u32 = 2
const IORING_REGISTER_EVENTFD: u32 = 4

fn sys_io_uring_setup(entries: u32, params: u64): u64 {
  // Validate entries (must be power of 2, minimum 1, maximum 32768)
  if entries == 0 or entries > 32768 {
    return EINVAL
  }

  // Check if entries is power of 2
  if (entries & (entries - 1)) != 0 {
    // Round up to next power of 2
    var n: u32 = entries
    n = n - 1
    n = n | (n >> 1)
    n = n | (n >> 2)
    n = n | (n >> 4)
    n = n | (n >> 8)
    n = n | (n >> 16)
    // entries = n + 1  // Would be rounded value
  }

  // Create the io_uring instance
  var ring_id: u32 = async_io.async_io_create_ring()

  if ring_id == 0xFFFFFFFF {
    return EINVAL  // Failed to create ring
  }

  foundation.serial_write_string("[Syscall] io_uring_setup: created ring ")
  foundation.serial_write_hex(ring_id)
  foundation.serial_write_string(" with ")
  foundation.serial_write_hex(entries)
  foundation.serial_write_string(" entries\n")

  // If params pointer is valid, fill in ring info
  if params != 0 {
    // Validate user-space pointer
    if ptr_safety.ptr_is_user(params) == 0 {
      foundation.serial_write_string("[Syscall] io_uring_setup: invalid user params\n")
      return EINVAL
    }

    // Validate range for params struct (at least 4 bytes for ring ID)
    if ptr_safety.ptr_check_range(params, 4) == 0 {
      return EINVAL
    }

    // Safe write ring ID to params
    if ptr_safety.ptr_safe_write_u32(params, ring_id) != 0 {
      return EINVAL
    }
  }

  return @as(u64, ring_id)
}

fn sys_io_uring_enter(ring_id: u32, to_submit: u32, min_complete: u32, flags: u32): u64 {
  // Validate ring ID
  if ring_id >= 64 {
    return EINVAL
  }

  var submitted: u32 = 0
  var completed: u32 = 0

  // Process pending submissions
  if to_submit > 0 {
    submitted = async_io.async_io_process(ring_id)
  }

  // Wait for completions if requested
  if (flags & IORING_ENTER_GETEVENTS) != 0 and min_complete > 0 {
    // Poll for completions
    var wait_count: u32 = 0
    while wait_count < 1000 {  // Max 1000 iterations to prevent infinite loop
      completed = async_io.async_io_get_completions(ring_id)
      if completed >= min_complete {
        break
      }

      // Process more requests if any pending
      async_io.async_io_process(ring_id)
      wait_count = wait_count + 1
    }
  } else {
    completed = async_io.async_io_get_completions(ring_id)
  }

  // Return number of completions available
  return @as(u64, completed)
}

fn sys_io_uring_register(ring_id: u32, opcode: u32, arg: u64, nr_args: u32): u64 {
  // Validate ring ID
  if ring_id >= 64 {
    return EINVAL
  }

  if opcode == IORING_REGISTER_BUFFERS {
    // Register fixed buffers for zero-copy I/O
    foundation.serial_write_string("[Syscall] io_uring_register: buffers (")
    foundation.serial_write_hex(nr_args)
    foundation.serial_write_string(" entries)\n")
    // Would register buffer addresses for direct I/O
    return 0
  }

  if opcode == IORING_REGISTER_FILES {
    // Register fixed file descriptors
    foundation.serial_write_string("[Syscall] io_uring_register: files (")
    foundation.serial_write_hex(nr_args)
    foundation.serial_write_string(" entries)\n")
    // Would register file descriptors for faster access
    return 0
  }

  if opcode == IORING_REGISTER_EVENTFD {
    // Register eventfd for completion notification
    foundation.serial_write_string("[Syscall] io_uring_register: eventfd\n")
    return 0
  }

  return EINVAL  // Unknown opcode
}

// ============================================================================
// Userspace async I/O helpers
// ============================================================================

// Submit a read request to an io_uring
export fn io_uring_prep_read(ring_id: u32, fd: u32, buffer: u64, size: u32, offset: u64, user_data: u64): u32 {
  return async_io.async_io_submit(ring_id, 0, fd, buffer, size, offset, user_data)
}

// Submit a write request to an io_uring
export fn io_uring_prep_write(ring_id: u32, fd: u32, buffer: u64, size: u32, offset: u64, user_data: u64): u32 {
  return async_io.async_io_submit(ring_id, 1, fd, buffer, size, offset, user_data)
}

// Submit a fsync request to an io_uring
export fn io_uring_prep_fsync(ring_id: u32, fd: u32, user_data: u64): u32 {
  return async_io.async_io_submit(ring_id, 2, fd, 0, 0, 0, user_data)
}

// Wait for and reap a completion
export fn io_uring_wait_cqe(ring_id: u32, user_data_out: u64, result_out: u64): u32 {
  // Poll until completion available
  var attempts: u32 = 0
  while attempts < 10000 {
    // Process pending requests
    async_io.async_io_process(ring_id)

    // Check for completions
    if async_io.async_io_reap(ring_id, user_data_out, result_out) == 1 {
      return 1  // Got a completion
    }

    attempts = attempts + 1
  }

  return 0  // Timeout
}
