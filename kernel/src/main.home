// home-os Kernel - Unified Main Entry Point
// Consolidates all architecture-specific entry points and interrupt handlers

// Import the kernel initialization orchestrator
import "core/kernel_init.home" as kernel_init
import "core/foundation.home" as foundation
import "core/memory.home" as memory
import "core/process.home" as process
import "core/filesystem.home" as filesystem
import "core/vfs_block_io.home" as block_io
import "core/vfs_mmap_integration.home" as vfs_mmap

// Import scheduler
import "sched/scheduler.home" as scheduler

// Import system
import "sys/syscall.home" as syscall
import "sys/signal.home" as signal

// Import memory management
import "mm/mm_integration.home" as mm

// Import drivers
import "drivers/keyboard.home" as keyboard
import "drivers/timer.home" as timer
import "drivers/framebuffer.home" as framebuffer

// Import network
import "net/socket.home" as socket
import "net/tcp.home" as tcp
import "net/udp.home" as udp

// Import security
import "security/caps.home" as caps
import "security/seccomp.home" as seccomp

// Import integration libraries
import "lib/shell_syscall.home" as shell_syscall
import "integration.home" as integration

// ============================================================================
// CONSTANTS
// ============================================================================

// Exception vectors (x86_64)
const EXCEPTION_DIVIDE_ERROR: u32 = 0
const EXCEPTION_DEBUG: u32 = 1
const EXCEPTION_NMI: u32 = 2
const EXCEPTION_BREAKPOINT: u32 = 3
const EXCEPTION_OVERFLOW: u32 = 4
const EXCEPTION_BOUND_RANGE: u32 = 5
const EXCEPTION_INVALID_OPCODE: u32 = 6
const EXCEPTION_DEVICE_NOT_AVAILABLE: u32 = 7
const EXCEPTION_DOUBLE_FAULT: u32 = 8
const EXCEPTION_INVALID_TSS: u32 = 10
const EXCEPTION_SEGMENT_NOT_PRESENT: u32 = 11
const EXCEPTION_STACK_SEGMENT_FAULT: u32 = 12
const EXCEPTION_GENERAL_PROTECTION: u32 = 13
const EXCEPTION_PAGE_FAULT: u32 = 14
const EXCEPTION_X87_FP: u32 = 16
const EXCEPTION_ALIGNMENT_CHECK: u32 = 17
const EXCEPTION_MACHINE_CHECK: u32 = 18
const EXCEPTION_SIMD_FP: u32 = 19

// IRQ vectors
const IRQ_TIMER: u32 = 32
const IRQ_KEYBOARD: u32 = 33
const IRQ_CASCADE: u32 = 34
const IRQ_COM2: u32 = 35
const IRQ_COM1: u32 = 36
const IRQ_LPT2: u32 = 37
const IRQ_FLOPPY: u32 = 38
const IRQ_LPT1: u32 = 39
const IRQ_RTC: u32 = 40
const IRQ_FREE1: u32 = 41
const IRQ_FREE2: u32 = 42
const IRQ_FREE3: u32 = 43
const IRQ_MOUSE: u32 = 44
const IRQ_FPU: u32 = 45
const IRQ_PRIMARY_ATA: u32 = 46
const IRQ_SECONDARY_ATA: u32 = 47

// Syscall vector
const SYSCALL_VECTOR: u32 = 0x80

// ============================================================================
// GLOBAL STATE
// ============================================================================

var kernel_running: u32 = 0
var in_interrupt: u32 = 0
var interrupt_nesting: u32 = 0

// ============================================================================
// UNIFIED KERNEL ENTRY POINT
// ============================================================================

export fn kernel_main(magic: u32, boot_info: u32): never {
  // Disable interrupts during initialization
  foundation.cli()

  // Validate multiboot magic (for x86)
  if magic != 0x36D76289 {
    foundation.serial_write_string("[Boot] Warning: Invalid multiboot2 magic\n")
  }

  // Store boot info for later parsing
  if boot_info != 0 {
    parse_boot_info(boot_info)
  }

  // Run the comprehensive kernel initialization
  kernel_init.kernel_init()

  // Initialize additional integration layers
  post_init_integrations()

  // Enable interrupts
  foundation.sti()

  // Mark kernel as running
  kernel_running = 1

  // Kernel is now running
  foundation.serial_write_string("\n[Kernel] Entering main loop\n")

  // Main kernel loop - scheduler runs from timer interrupt
  while true {
    // Check for pending signals on current process
    var current_pid: u32 = scheduler.get_current_pid()
    if current_pid != 0 {
      signal.signal_deliver_pending(current_pid)
    }

    // Check memory pressure
    var pressure: u32 = mm.check_memory_pressure()
    if pressure == 3 {  // PRESSURE_CRITICAL
      foundation.serial_write_string("[Kernel] Critical memory pressure detected\n")
      mm.oom_kill()
    }

    // Halt until next interrupt
    foundation.hlt()
  }
}

// ============================================================================
// ARCHITECTURE-SPECIFIC ENTRY POINTS
// ============================================================================

// x86_64 entry point (from boot.s)
export fn _start_x86_64(magic: u32, boot_info: u32): never {
  kernel_main(magic, boot_info)
}

// ARM64/AArch64 entry point
export fn _start_aarch64(dtb_ptr: u64): never {
  // ARM64 doesn't use multiboot
  // DTB (Device Tree Blob) pointer is passed instead
  kernel_main(0, @intCast(dtb_ptr))
}

// Raspberry Pi entry point
export fn _start_rpi(dtb_ptr: u64): never {
  // Raspberry Pi uses DTB
  kernel_main(0, @intCast(dtb_ptr))
}

// RISC-V entry point
export fn _start_riscv(hart_id: u64, dtb_ptr: u64): never {
  // RISC-V passes hart (hardware thread) ID and DTB
  kernel_main(0, @intCast(dtb_ptr))
}

// ============================================================================
// BOOT INFO PARSING
// ============================================================================

fn parse_boot_info(info_addr: u32) {
  // Parse multiboot2 info structure
  var ptr: *u32 = @ptrFromInt(@as(u64, info_addr))
  var total_size: u32 = ptr.*

  foundation.serial_write_string("[Boot] Boot info at ")
  foundation.serial_write_hex(info_addr)
  foundation.serial_write_string(", size=")
  foundation.serial_write_hex(total_size)
  foundation.serial_write_string("\n")

  // Parse tags
  var offset: u32 = 8  // Skip size and reserved
  while offset < total_size {
    var tag_ptr: *u32 = @ptrFromInt(@as(u64, info_addr + offset))
    var tag_type: u32 = tag_ptr.*
    var tag_size: u32 = @ptrFromInt(@as(u64, info_addr + offset + 4)).*

    if tag_type == 0 { break }  // End tag

    // Handle specific tags
    if tag_type == 6 {
      // Memory map tag
      foundation.serial_write_string("[Boot] Found memory map\n")
    } else if tag_type == 8 {
      // Framebuffer tag
      foundation.serial_write_string("[Boot] Found framebuffer info\n")
    }

    // Align to 8 bytes
    offset = offset + ((tag_size + 7) & 0xFFFFFFF8)
  }
}

fn post_init_integrations() {
  foundation.serial_write_string("[Kernel] Post-init integrations\n")

  // Initialize shell syscall layer
  shell_syscall.shell_syscall_init()
  foundation.serial_write_string("  - Shell syscall layer... OK\n")

  // Initialize VFS mmap
  vfs_mmap.vfs_mmap_init()
  foundation.serial_write_string("  - VFS mmap... OK\n")

  // Initialize block I/O layer
  block_io.block_io_init()
  foundation.serial_write_string("  - Block I/O layer... OK\n")

  // Initialize memory integration
  mm.mm_integration_init()
  foundation.serial_write_string("  - Memory integration... OK\n")

  // Initialize legacy integration if needed
  integration.init_all_integrations()
  foundation.serial_write_string("  - Legacy integrations... OK\n")
}

// ============================================================================
// EXCEPTION HANDLERS
// ============================================================================

export fn exception_handler(vector: u32, error_code: u64, rip: u64, rsp: u64) {
  in_interrupt = 1

  if vector == EXCEPTION_PAGE_FAULT {
    // Page fault - get CR2 (faulting address)
    var fault_addr: u64 = foundation.read_cr2()

    // Try to handle via VFS mmap
    var current_pid: u32 = scheduler.get_current_pid()
    var result: u32 = vfs_mmap.handle_page_fault(current_pid, fault_addr, @intCast(error_code))

    if result == 0 {
      // Handled successfully
      in_interrupt = 0
      return
    }

    // Unhandled page fault - send SIGSEGV
    foundation.serial_write_string("[Exception] Page fault at ")
    foundation.serial_write_hex64(fault_addr)
    foundation.serial_write_string(", error=")
    foundation.serial_write_hex64(error_code)
    foundation.serial_write_string(", PID=")
    foundation.serial_write_hex(current_pid)
    foundation.serial_write_string("\n")

    if current_pid != 0 {
      signal.signal_send(current_pid, 11, 0)  // SIGSEGV
    } else {
      kernel_panic("Page fault in kernel mode", rip, rsp)
    }
  } else if vector == EXCEPTION_GENERAL_PROTECTION {
    foundation.serial_write_string("[Exception] General protection fault\n")
    foundation.serial_write_string("  Error code: ")
    foundation.serial_write_hex64(error_code)
    foundation.serial_write_string("\n  RIP: ")
    foundation.serial_write_hex64(rip)
    foundation.serial_write_string("\n")

    var current_pid: u32 = scheduler.get_current_pid()
    if current_pid != 0 {
      signal.signal_send(current_pid, 11, 0)  // SIGSEGV
    } else {
      kernel_panic("GPF in kernel mode", rip, rsp)
    }
  } else if vector == EXCEPTION_DOUBLE_FAULT {
    kernel_panic("Double fault", rip, rsp)
  } else if vector == EXCEPTION_DIVIDE_ERROR {
    var current_pid: u32 = scheduler.get_current_pid()
    if current_pid != 0 {
      signal.signal_send(current_pid, 8, 0)  // SIGFPE
    } else {
      kernel_panic("Divide error in kernel", rip, rsp)
    }
  } else if vector == EXCEPTION_INVALID_OPCODE {
    var current_pid: u32 = scheduler.get_current_pid()
    if current_pid != 0 {
      signal.signal_send(current_pid, 4, 0)  // SIGILL
    } else {
      kernel_panic("Invalid opcode in kernel", rip, rsp)
    }
  } else if vector == EXCEPTION_BREAKPOINT {
    foundation.serial_write_string("[Debug] Breakpoint at ")
    foundation.serial_write_hex64(rip)
    foundation.serial_write_string("\n")
    var current_pid: u32 = scheduler.get_current_pid()
    if current_pid != 0 {
      signal.signal_send(current_pid, 5, 0)  // SIGTRAP
    }
  } else {
    foundation.serial_write_string("[Exception] Unhandled exception ")
    foundation.serial_write_hex(vector)
    foundation.serial_write_string(" at ")
    foundation.serial_write_hex64(rip)
    foundation.serial_write_string("\n")
    kernel_panic("Unhandled exception", rip, rsp)
  }

  in_interrupt = 0
}

// ============================================================================
// INTERRUPT HANDLERS
// ============================================================================

export fn irq_handler(irq: u32) {
  in_interrupt = 1
  interrupt_nesting = interrupt_nesting + 1

  if irq == IRQ_TIMER {
    // Timer interrupt - scheduler tick
    timer.timer_tick()
    scheduler.scheduler_tick()

    // Check for pending signals
    var current_pid: u32 = scheduler.get_current_pid()
    if current_pid != 0 {
      signal.signal_deliver_pending(current_pid)
    }
  } else if irq == IRQ_KEYBOARD {
    // Keyboard interrupt
    keyboard.keyboard_interrupt()
  } else if irq == IRQ_PRIMARY_ATA or irq == IRQ_SECONDARY_ATA {
    // ATA disk interrupt
    block_io.block_io_interrupt(irq)
  } else if irq >= 48 and irq <= 55 {
    // Network interrupt (assume IRQ 48-55 for network)
    socket.socket_rx_interrupt()
  }

  // Send EOI to PIC
  foundation.pic_eoi(irq)

  interrupt_nesting = interrupt_nesting - 1
  in_interrupt = 0
}

// ============================================================================
// SYSCALL ENTRY POINT
// ============================================================================

export fn syscall_entry(syscall_num: u32, arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64, arg6: u64): i64 {
  // Get current process
  var pid: u32 = scheduler.get_current_pid()

  // Check seccomp filter
  if seccomp.seccomp_check(pid, syscall_num) != 0 {
    return -1  // EPERM
  }

  // Dispatch syscall
  return syscall.syscall_dispatch(syscall_num, arg1, arg2, arg3, arg4, arg5, arg6)
}

// ============================================================================
// KERNEL PANIC
// ============================================================================

fn kernel_panic(msg: *u8, rip: u64, rsp: u64) {
  foundation.cli()  // Disable interrupts

  foundation.serial_write_string("\n")
  foundation.serial_write_string("===============================================\n")
  foundation.serial_write_string("!!! KERNEL PANIC !!!\n")
  foundation.serial_write_string("===============================================\n")
  foundation.serial_write_string("Message: ")
  foundation.serial_write_string(msg)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("RIP: ")
  foundation.serial_write_hex64(rip)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("RSP: ")
  foundation.serial_write_hex64(rsp)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("Current PID: ")
  foundation.serial_write_hex(scheduler.get_current_pid())
  foundation.serial_write_string("\n")
  foundation.serial_write_string("Kernel phase: ")
  foundation.serial_write_hex(kernel_init.kernel_get_phase())
  foundation.serial_write_string("\n")

  // Print stack trace
  print_stack_trace(rsp)

  foundation.serial_write_string("\nSystem halted.\n")

  // Halt forever
  while true {
    foundation.hlt()
  }
}

fn print_stack_trace(rsp: u64) {
  foundation.serial_write_string("\nStack trace:\n")

  var frame: u64 = rsp
  var i: u32 = 0

  while i < 16 and frame != 0 and frame < 0xFFFFFFFF80000000 {
    var addr: *u64 = @ptrFromInt(frame)
    if addr.* != 0 {
      foundation.serial_write_string("  [")
      foundation.serial_write_hex(i)
      foundation.serial_write_string("] ")
      foundation.serial_write_hex64(addr.*)
      foundation.serial_write_string("\n")
    }
    frame = frame + 8
    i = i + 1
  }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

export fn kernel_is_running(): u32 {
  return kernel_running
}

export fn in_interrupt_context(): u32 {
  return in_interrupt
}

export fn get_interrupt_nesting(): u32 {
  return interrupt_nesting
}

// ============================================================================
// SHUTDOWN / REBOOT
// ============================================================================

export fn kernel_shutdown() {
  foundation.serial_write_string("\n[Kernel] Initiating shutdown...\n")

  kernel_running = 0

  // Use kernel_init's shutdown
  kernel_init.kernel_shutdown()
}

export fn kernel_reboot() {
  foundation.serial_write_string("\n[Kernel] Initiating reboot...\n")

  kernel_running = 0

  // Use kernel_init's reboot
  kernel_init.kernel_reboot()
}
