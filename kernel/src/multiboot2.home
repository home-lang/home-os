// Multiboot2 bootloader information parser
// Parses Multiboot2 tags to extract memory map and boot information

// Multiboot2 constants
const MULTIBOOT2_MAGIC: u32 = 0x36d76289

// Tag types
const TAG_TYPE_END: u32 = 0
const TAG_TYPE_CMDLINE: u32 = 1
const TAG_TYPE_BOOT_LOADER_NAME: u32 = 2
const TAG_TYPE_MODULE: u32 = 3
const TAG_TYPE_BASIC_MEMINFO: u32 = 4
const TAG_TYPE_BOOTDEV: u32 = 5
const TAG_TYPE_MMAP: u32 = 6
const TAG_TYPE_VBE: u32 = 7
const TAG_TYPE_FRAMEBUFFER: u32 = 8
const TAG_TYPE_ELF_SECTIONS: u32 = 9
const TAG_TYPE_APM: u32 = 10
const TAG_TYPE_EFI32: u32 = 11
const TAG_TYPE_EFI64: u32 = 12
const TAG_TYPE_SMBIOS: u32 = 13
const TAG_TYPE_ACPI_OLD: u32 = 14
const TAG_TYPE_ACPI_NEW: u32 = 15
const TAG_TYPE_NETWORK: u32 = 16
const TAG_TYPE_EFI_MMAP: u32 = 17
const TAG_TYPE_EFI_BS: u32 = 18
const TAG_TYPE_EFI32_IH: u32 = 19
const TAG_TYPE_EFI64_IH: u32 = 20
const TAG_TYPE_LOAD_BASE_ADDR: u32 = 21

// Memory map entry types
const MMAP_TYPE_AVAILABLE: u32 = 1
const MMAP_TYPE_RESERVED: u32 = 2
const MMAP_TYPE_ACPI_RECLAIMABLE: u32 = 3
const MMAP_TYPE_NVS: u32 = 4
const MMAP_TYPE_BADRAM: u32 = 5

// Multiboot2 info structure (header)
type Multiboot2Info = struct {
  total_size: u32
  reserved: u32
}

// Generic tag header
type TagHeader = struct {
  type: u32
  size: u32
}

// Basic memory info tag
type TagBasicMeminfo = struct {
  type: u32
  size: u32
  mem_lower: u32  // KB of lower memory
  mem_upper: u32  // KB of upper memory
}

// Memory map tag
type TagMmap = struct {
  type: u32
  size: u32
  entry_size: u32
  entry_version: u32
  // followed by entries
}

// Memory map entry
type MmapEntry = struct {
  base_addr: u64
  length: u64
  type: u32
  reserved: u32
}

// Boot information structure
export type BootInfo = struct {
  mem_lower: u32
  mem_upper: u32
  total_memory: u64
  mmap_count: u32
  mmap_entries: [32]MemoryRegion
}

// Memory region structure
export type MemoryRegion = struct {
  base: u64
  length: u64
  type: u32
  available: bool
}

// Parse Multiboot2 information
export fn parseMultiboot2(info_addr: u32) -> BootInfo {
  let boot_info: BootInfo = BootInfo{
    mem_lower: 0,
    mem_upper: 0,
    total_memory: 0,
    mmap_count: 0,
    mmap_entries: [MemoryRegion{
      base: 0,
      length: 0,
      type: 0,
      available: false,
    }; 32],
  }

  // Read Multiboot2 info header
  let info_ptr: u64 = info_addr as u64
  let total_size: u32 = readU32(info_ptr)

  // Start at first tag (after header = 8 bytes)
  let tag_addr: u64 = info_ptr + 8
  let end_addr: u64 = info_ptr + (total_size as u64)

  loop {
    if tag_addr >= end_addr {
      break
    }

    // Read tag header
    let tag_type: u32 = readU32(tag_addr)
    let tag_size: u32 = readU32(tag_addr + 4)

    // End tag
    if tag_type == TAG_TYPE_END {
      break
    }

    // Parse basic memory info
    if tag_type == TAG_TYPE_BASIC_MEMINFO {
      boot_info.mem_lower = readU32(tag_addr + 8)
      boot_info.mem_upper = readU32(tag_addr + 12)
      boot_info.total_memory = ((boot_info.mem_upper as u64) + 1024) * 1024
    }

    // Parse memory map
    if tag_type == TAG_TYPE_MMAP {
      let entry_size: u32 = readU32(tag_addr + 8)
      let entry_version: u32 = readU32(tag_addr + 12)

      // Start of entries (after tag header + entry_size + entry_version)
      let entry_addr: u64 = tag_addr + 16
      let mmap_end: u64 = tag_addr + (tag_size as u64)

      let entry_count: u32 = 0
      loop {
        if entry_addr >= mmap_end {
          break
        }
        if entry_count >= 32 {
          break
        }

        // Read memory map entry
        let base_addr: u64 = readU64(entry_addr)
        let length: u64 = readU64(entry_addr + 8)
        let mem_type: u32 = readU32(entry_addr + 16)

        // Store in boot info
        boot_info.mmap_entries[entry_count] = MemoryRegion{
          base: base_addr,
          length: length,
          type: mem_type,
          available: mem_type == MMAP_TYPE_AVAILABLE,
        }

        entry_count = entry_count + 1
        entry_addr = entry_addr + (entry_size as u64)
      }

      boot_info.mmap_count = entry_count
    }

    // Move to next tag (align to 8 bytes)
    let aligned_size: u32 = (tag_size + 7) & ~7
    tag_addr = tag_addr + (aligned_size as u64)
  }

  return boot_info
}

// Helper: Read u32 from physical address
fn readU32(addr: u64) -> u32 {
  let ptr: *u32 = addr as *u32
  return *ptr
}

// Helper: Read u64 from physical address
fn readU64(addr: u64) -> u64 {
  let ptr: *u64 = addr as *u64
  return *ptr
}

// Print memory map information
export fn printMemoryMap(boot_info: BootInfo, write_fn: fn(str) -> void) {
  write_fn("\n=== Memory Map ===\n")
  write_fn("Lower memory: ")
  writeU32(boot_info.mem_lower, write_fn)
  write_fn(" KB\n")

  write_fn("Upper memory: ")
  writeU32(boot_info.mem_upper, write_fn)
  write_fn(" KB\n")

  write_fn("Total memory: ")
  writeU64(boot_info.total_memory, write_fn)
  write_fn(" bytes\n\n")

  write_fn("Memory regions: ")
  writeU32(boot_info.mmap_count, write_fn)
  write_fn("\n")

  let i: u32 = 0
  loop {
    if i >= boot_info.mmap_count {
      break
    }

    let region: MemoryRegion = boot_info.mmap_entries[i]

    write_fn("  Region ")
    writeU32(i, write_fn)
    write_fn(": base=0x")
    writeU64Hex(region.base, write_fn)
    write_fn(" length=0x")
    writeU64Hex(region.length, write_fn)
    write_fn(" type=")
    writeU32(region.type, write_fn)

    if region.available {
      write_fn(" [AVAILABLE]\n")
    } else {
      write_fn(" [RESERVED]\n")
    }

    i = i + 1
  }

  write_fn("\n")
}

// Helper: Write u32 as decimal
fn writeU32(value: u32, write_fn: fn(str) -> void) {
  if value == 0 {
    write_fn("0")
    return
  }

  let digits: [10]u8 = [0; 10]
  let count: u32 = 0
  let temp: u32 = value

  loop {
    if temp == 0 {
      break
    }
    digits[count] = (temp % 10) as u8
    temp = temp / 10
    count = count + 1
  }

  loop {
    if count == 0 {
      break
    }
    count = count - 1
    let digit_char: u8 = ('0' as u8) + digits[count]
    let digit_str: str = [digit_char] as str
    write_fn(digit_str)
  }
}

// Helper: Write u64 as decimal
fn writeU64(value: u64, write_fn: fn(str) -> void) {
  if value == 0 {
    write_fn("0")
    return
  }

  let digits: [20]u8 = [0; 20]
  let count: u32 = 0
  let temp: u64 = value

  loop {
    if temp == 0 {
      break
    }
    digits[count] = (temp % 10) as u8
    temp = temp / 10
    count = count + 1
  }

  loop {
    if count == 0 {
      break
    }
    count = count - 1
    let digit_char: u8 = ('0' as u8) + digits[count]
    let digit_str: str = [digit_char] as str
    write_fn(digit_str)
  }
}

// Helper: Write u64 as hexadecimal
fn writeU64Hex(value: u64, write_fn: fn(str) -> void) {
  const HEX_CHARS: str = "0123456789ABCDEF"

  let digits: [16]u8 = [0; 16]
  let count: u32 = 0
  let temp: u64 = value

  if value == 0 {
    write_fn("0")
    return
  }

  loop {
    if temp == 0 {
      break
    }
    digits[count] = (temp & 0xF) as u8
    temp = temp >> 4
    count = count + 1
  }

  loop {
    if count == 0 {
      break
    }
    count = count - 1
    let hex_char: u8 = HEX_CHARS[digits[count]] as u8
    let hex_str: str = [hex_char] as str
    write_fn(hex_str)
  }
}
