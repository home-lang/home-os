// home-os Kernel - Z-Wave Protocol Stack
// Sub-GHz wireless mesh networking for home automation

import "../core/foundation.home" as foundation

// ============================================================================
// Z-WAVE CONSTANTS
// ============================================================================

const ZWAVE_FREQ_US: u32 = 908420    // 908.42 MHz (US)
const ZWAVE_FREQ_EU: u32 = 868420    // 868.42 MHz (EU)
const ZWAVE_FREQ_ANZ: u32 = 921420   // 921.42 MHz (AU/NZ)

const MAX_ZWAVE_NODES: u32 = 232     // Z-Wave limit
const MAX_ASSOCIATIONS: u32 = 64

// Node types
const ZWAVE_NODE_CONTROLLER: u8 = 0x01
const ZWAVE_NODE_STATIC: u8 = 0x02
const ZWAVE_NODE_SLAVE: u8 = 0x03
const ZWAVE_NODE_ROUTING_SLAVE: u8 = 0x04

// Generic device classes
const ZWAVE_GENERIC_CONTROLLER: u8 = 0x01
const ZWAVE_GENERIC_SWITCH_BINARY: u8 = 0x10
const ZWAVE_GENERIC_SWITCH_MULTILEVEL: u8 = 0x11
const ZWAVE_GENERIC_SENSOR_BINARY: u8 = 0x20
const ZWAVE_GENERIC_SENSOR_MULTILEVEL: u8 = 0x21
const ZWAVE_GENERIC_THERMOSTAT: u8 = 0x08
const ZWAVE_GENERIC_ENTRY_CONTROL: u8 = 0x40
const ZWAVE_GENERIC_METER: u8 = 0x31

// Command classes
const ZWAVE_CC_BASIC: u8 = 0x20
const ZWAVE_CC_SWITCH_BINARY: u8 = 0x25
const ZWAVE_CC_SWITCH_MULTILEVEL: u8 = 0x26
const ZWAVE_CC_SENSOR_BINARY: u8 = 0x30
const ZWAVE_CC_SENSOR_MULTILEVEL: u8 = 0x31
const ZWAVE_CC_METER: u8 = 0x32
const ZWAVE_CC_THERMOSTAT_MODE: u8 = 0x40
const ZWAVE_CC_THERMOSTAT_SETPOINT: u8 = 0x43
const ZWAVE_CC_DOOR_LOCK: u8 = 0x62
const ZWAVE_CC_BATTERY: u8 = 0x80
const ZWAVE_CC_WAKEUP: u8 = 0x84
const ZWAVE_CC_ASSOCIATION: u8 = 0x85
const ZWAVE_CC_VERSION: u8 = 0x86
const ZWAVE_CC_MANUFACTURER: u8 = 0x72
const ZWAVE_CC_NOTIFICATION: u8 = 0x71
const ZWAVE_CC_SECURITY: u8 = 0x98
const ZWAVE_CC_SECURITY_2: u8 = 0x9F

// Frame types
const ZWAVE_FRAME_SINGLECAST: u8 = 0x01
const ZWAVE_FRAME_MULTICAST: u8 = 0x02
const ZWAVE_FRAME_BROADCAST: u8 = 0x04
const ZWAVE_FRAME_ACK_REQ: u8 = 0x40

// ============================================================================
// Z-WAVE DATA STRUCTURES
// ============================================================================

struct ZWaveNode {
  node_id: u8,
  home_id: u32,
  generic_class: u8,
  specific_class: u8,
  manufacturer_id: u16,
  product_type: u16,
  product_id: u16,
  command_classes: [u8; 32],
  cc_count: u8,
  name: [u8; 32],
  location: [u8; 32],
  is_listening: u32,
  is_routing: u32,
  is_beaming: u32,
  is_security: u32,
  is_failed: u32,
  battery_level: u8,
  last_seen: u64
}

struct ZWaveAssociation {
  source_node: u8,
  group_id: u8,
  target_nodes: [u8; 8],
  target_count: u8
}

struct ZWaveNetwork {
  home_id: u32,
  controller_node_id: u8,
  suc_node_id: u8,
  frequency: u32,
  network_key: [u8; 16],
  inclusion_mode: u32,
  exclusion_mode: u32
}

struct ZWaveFrame {
  home_id: u32,
  source_id: u8,
  frame_control: u8,
  length: u8,
  dest_id: u8,
  command_class: u8,
  command: u8,
  payload: [u8; 64],
  payload_len: u8
}

// ============================================================================
// Z-WAVE STATE
// ============================================================================

var zw_network: ZWaveNetwork
var zw_nodes: [ZWaveNode; 232]
var zw_node_count: u32 = 0
var zw_associations: [ZWaveAssociation; 64]
var zw_assoc_count: u32 = 0
var zw_callback_id: u8 = 1
var zw_initialized: u32 = 0
var zw_dongle_handle: u32 = 0

// ============================================================================
// INITIALIZATION
// ============================================================================

export fn zwave_init(frequency: u32): u32 {
  foundation.serial_write_string("[Z-Wave] Initializing stack...\n")

  // Find USB Z-Wave dongle (Z-Stick, Aeotec, etc.)
  zw_dongle_handle = find_zwave_dongle()
  if zw_dongle_handle == 0 {
    foundation.serial_write_string("[Z-Wave] No dongle found\n")
    return 0
  }

  zw_network.frequency = frequency
  zw_network.inclusion_mode = 0
  zw_network.exclusion_mode = 0

  // Get home ID from controller
  zwave_get_home_id()

  // Get initial node list
  zwave_get_node_list()

  zw_initialized = 1

  foundation.serial_write_string("[Z-Wave] Stack initialized, Home ID: 0x")
  foundation.serial_write_hex(zw_network.home_id)
  foundation.serial_write_string("\n")

  return 1
}

fn find_zwave_dongle(): u32 {
  // Look for common Z-Wave USB dongles
  // Aeotec Z-Stick: VID=0x0658, PID=0x0200
  // Zooz: VID=0x0658, PID=0x0200
  // Sigma Designs: VID=0x0658

  // Stub: Would enumerate USB devices
  return 1
}

fn zwave_get_home_id() {
  var cmd: [u8; 4]
  cmd[0] = 0x01  // SOF
  cmd[1] = 0x03  // Length
  cmd[2] = 0x00  // Request
  cmd[3] = 0x20  // FUNC_ID_MEMORY_GET_ID

  send_to_serial(&cmd, 4)

  // Response would contain home_id and node_id
  zw_network.home_id = 0x12345678  // Placeholder
  zw_network.controller_node_id = 1
}

fn zwave_get_node_list() {
  var cmd: [u8; 4]
  cmd[0] = 0x01
  cmd[1] = 0x03
  cmd[2] = 0x00
  cmd[3] = 0x02  // FUNC_ID_SERIAL_API_GET_INIT_DATA

  send_to_serial(&cmd, 4)

  // Response would contain node bitmask
}

// ============================================================================
// INCLUSION / EXCLUSION
// ============================================================================

export fn zwave_start_inclusion(): u32 {
  if zw_initialized == 0 { return 0 }

  zw_network.inclusion_mode = 1

  var cmd: [u8; 5]
  cmd[0] = 0x01
  cmd[1] = 0x04
  cmd[2] = 0x00
  cmd[3] = 0x4A  // FUNC_ID_ZW_ADD_NODE_TO_NETWORK
  cmd[4] = 0xC1  // ADD_NODE_ANY | ADD_NODE_OPTION_NETWORK_WIDE

  send_to_serial(&cmd, 5)

  foundation.serial_write_string("[Z-Wave] Inclusion mode started\n")
  return 1
}

export fn zwave_stop_inclusion(): u32 {
  zw_network.inclusion_mode = 0

  var cmd: [u8; 5]
  cmd[0] = 0x01
  cmd[1] = 0x04
  cmd[2] = 0x00
  cmd[3] = 0x4A
  cmd[4] = 0x05  // ADD_NODE_STOP

  send_to_serial(&cmd, 5)

  foundation.serial_write_string("[Z-Wave] Inclusion mode stopped\n")
  return 1
}

export fn zwave_start_exclusion(): u32 {
  if zw_initialized == 0 { return 0 }

  zw_network.exclusion_mode = 1

  var cmd: [u8; 5]
  cmd[0] = 0x01
  cmd[1] = 0x04
  cmd[2] = 0x00
  cmd[3] = 0x4B  // FUNC_ID_ZW_REMOVE_NODE_FROM_NETWORK
  cmd[4] = 0x01  // REMOVE_NODE_ANY

  send_to_serial(&cmd, 5)

  foundation.serial_write_string("[Z-Wave] Exclusion mode started\n")
  return 1
}

export fn zwave_stop_exclusion(): u32 {
  zw_network.exclusion_mode = 0

  var cmd: [u8; 5]
  cmd[0] = 0x01
  cmd[1] = 0x04
  cmd[2] = 0x00
  cmd[3] = 0x4B
  cmd[4] = 0x05  // REMOVE_NODE_STOP

  send_to_serial(&cmd, 5)

  foundation.serial_write_string("[Z-Wave] Exclusion mode stopped\n")
  return 1
}

// ============================================================================
// NODE MANAGEMENT
// ============================================================================

export fn zwave_node_added(node_id: u8, info: *[u8; 32]): u32 {
  if zw_node_count >= MAX_ZWAVE_NODES { return 0 }

  var idx: u32 = zw_node_count

  zw_nodes[idx].node_id = node_id
  zw_nodes[idx].home_id = zw_network.home_id
  zw_nodes[idx].generic_class = (*info)[0]
  zw_nodes[idx].specific_class = (*info)[1]
  zw_nodes[idx].is_failed = 0
  zw_nodes[idx].last_seen = foundation.get_tick_count()

  // Copy command classes
  var i: u32 = 0
  while i < 30 && (*info)[i + 2] != 0 {
    zw_nodes[idx].command_classes[i] = (*info)[i + 2]
    i = i + 1
  }
  zw_nodes[idx].cc_count = i as u8

  zw_node_count = zw_node_count + 1

  foundation.serial_write_string("[Z-Wave] Node added: ")
  foundation.serial_write_hex(node_id as u32)
  foundation.serial_write_string("\n")

  // Request additional info
  zwave_request_manufacturer_info(node_id)

  return idx
}

export fn zwave_node_removed(node_id: u8): u32 {
  var i: u32 = 0
  while i < zw_node_count {
    if zw_nodes[i].node_id == node_id {
      // Mark as removed (don't actually remove, just mark failed)
      zw_nodes[i].is_failed = 1
      foundation.serial_write_string("[Z-Wave] Node removed: ")
      foundation.serial_write_hex(node_id as u32)
      foundation.serial_write_string("\n")
      return 1
    }
    i = i + 1
  }
  return 0
}

fn zwave_request_manufacturer_info(node_id: u8) {
  var frame: ZWaveFrame
  frame.dest_id = node_id
  frame.command_class = ZWAVE_CC_MANUFACTURER
  frame.command = 0x04  // Get
  frame.payload_len = 0

  zwave_send_frame(&frame)
}

export fn zwave_get_node_count(): u32 {
  return zw_node_count
}

export fn zwave_get_node(index: u32, node: *ZWaveNode): u32 {
  if index >= zw_node_count { return 0 }
  *node = zw_nodes[index]
  return 1
}

// ============================================================================
// COMMAND CLASSES
// ============================================================================

export fn zwave_basic_set(node_id: u8, value: u8): u32 {
  var frame: ZWaveFrame
  frame.dest_id = node_id
  frame.command_class = ZWAVE_CC_BASIC
  frame.command = 0x01  // Set
  frame.payload[0] = value
  frame.payload_len = 1

  return zwave_send_frame(&frame)
}

export fn zwave_basic_get(node_id: u8): u32 {
  var frame: ZWaveFrame
  frame.dest_id = node_id
  frame.command_class = ZWAVE_CC_BASIC
  frame.command = 0x02  // Get
  frame.payload_len = 0

  return zwave_send_frame(&frame)
}

export fn zwave_switch_binary_set(node_id: u8, on: u32): u32 {
  var frame: ZWaveFrame
  frame.dest_id = node_id
  frame.command_class = ZWAVE_CC_SWITCH_BINARY
  frame.command = 0x01  // Set

  if on == 1 {
    frame.payload[0] = 0xFF
  } else {
    frame.payload[0] = 0x00
  }
  frame.payload_len = 1

  return zwave_send_frame(&frame)
}

export fn zwave_switch_multilevel_set(node_id: u8, level: u8, duration: u8): u32 {
  var frame: ZWaveFrame
  frame.dest_id = node_id
  frame.command_class = ZWAVE_CC_SWITCH_MULTILEVEL
  frame.command = 0x01  // Set

  frame.payload[0] = level
  frame.payload[1] = duration
  frame.payload_len = 2

  return zwave_send_frame(&frame)
}

export fn zwave_thermostat_setpoint_set(node_id: u8, setpoint_type: u8, value: i16): u32 {
  var frame: ZWaveFrame
  frame.dest_id = node_id
  frame.command_class = ZWAVE_CC_THERMOSTAT_SETPOINT
  frame.command = 0x01  // Set

  frame.payload[0] = setpoint_type
  frame.payload[1] = 0x22  // Size=2, Scale=Celsius, Precision=1
  frame.payload[2] = (value >> 8) as u8
  frame.payload[3] = (value & 0xFF) as u8
  frame.payload_len = 4

  return zwave_send_frame(&frame)
}

export fn zwave_door_lock_set(node_id: u8, locked: u32): u32 {
  var frame: ZWaveFrame
  frame.dest_id = node_id
  frame.command_class = ZWAVE_CC_DOOR_LOCK
  frame.command = 0x01  // Set

  if locked == 1 {
    frame.payload[0] = 0xFF  // Secured
  } else {
    frame.payload[0] = 0x00  // Unsecured
  }
  frame.payload_len = 1

  return zwave_send_frame(&frame)
}

export fn zwave_sensor_multilevel_get(node_id: u8, sensor_type: u8): u32 {
  var frame: ZWaveFrame
  frame.dest_id = node_id
  frame.command_class = ZWAVE_CC_SENSOR_MULTILEVEL
  frame.command = 0x04  // Get

  frame.payload[0] = sensor_type
  frame.payload_len = 1

  return zwave_send_frame(&frame)
}

// ============================================================================
// ASSOCIATIONS
// ============================================================================

export fn zwave_association_set(source_node: u8, group_id: u8, target_node: u8): u32 {
  var frame: ZWaveFrame
  frame.dest_id = source_node
  frame.command_class = ZWAVE_CC_ASSOCIATION
  frame.command = 0x01  // Set

  frame.payload[0] = group_id
  frame.payload[1] = target_node
  frame.payload_len = 2

  // Also store locally
  if zw_assoc_count < MAX_ASSOCIATIONS {
    zw_associations[zw_assoc_count].source_node = source_node
    zw_associations[zw_assoc_count].group_id = group_id
    zw_associations[zw_assoc_count].target_nodes[0] = target_node
    zw_associations[zw_assoc_count].target_count = 1
    zw_assoc_count = zw_assoc_count + 1
  }

  return zwave_send_frame(&frame)
}

export fn zwave_association_remove(source_node: u8, group_id: u8, target_node: u8): u32 {
  var frame: ZWaveFrame
  frame.dest_id = source_node
  frame.command_class = ZWAVE_CC_ASSOCIATION
  frame.command = 0x04  // Remove

  frame.payload[0] = group_id
  frame.payload[1] = target_node
  frame.payload_len = 2

  return zwave_send_frame(&frame)
}

// ============================================================================
// FRAME HANDLING
// ============================================================================

fn zwave_send_frame(frame: *ZWaveFrame): u32 {
  var buf: [u8; 64]
  var len: u32 = 0

  buf[len] = 0x01  // SOF
  len = len + 1

  // Length placeholder
  var len_pos: u32 = len
  len = len + 1

  buf[len] = 0x00  // Request
  len = len + 1

  buf[len] = 0x13  // FUNC_ID_ZW_SEND_DATA
  len = len + 1

  buf[len] = frame.dest_id
  len = len + 1

  // Command length
  var cmd_len: u8 = 2 + frame.payload_len
  buf[len] = cmd_len
  len = len + 1

  buf[len] = frame.command_class
  len = len + 1

  buf[len] = frame.command
  len = len + 1

  // Payload
  var i: u32 = 0
  while i < frame.payload_len {
    buf[len] = frame.payload[i]
    len = len + 1
    i = i + 1
  }

  buf[len] = 0x25  // Transmit options
  len = len + 1

  buf[len] = zw_callback_id
  zw_callback_id = zw_callback_id + 1
  len = len + 1

  // Update length
  buf[len_pos] = (len - 2) as u8

  // Calculate checksum
  var checksum: u8 = 0xFF
  i = 1
  while i < len {
    checksum = checksum ^ buf[i]
    i = i + 1
  }
  buf[len] = checksum
  len = len + 1

  return send_to_serial(&buf, len)
}

// ============================================================================
// SERIAL COMMUNICATION
// ============================================================================

fn send_to_serial(data: *[u8], len: u32): u32 {
  // Stub: Would send to serial port
  return 1
}

fn receive_from_serial(data: *[u8; 256]): u32 {
  // Stub: Would receive from serial port
  return 0
}

export fn zwave_process_messages() {
  var buf: [u8; 256]
  var len: u32 = receive_from_serial(&buf)

  while len > 0 {
    process_zwave_message(&buf, len)
    len = receive_from_serial(&buf)
  }
}

fn process_zwave_message(data: *[u8; 256], len: u32) {
  if len < 4 { return }
  if (*data)[0] != 0x01 { return }  // Not SOF

  var func_id: u8 = (*data)[3]

  if func_id == 0x04 {
    // Application command handler
    var src_node: u8 = (*data)[5]
    var cmd_class: u8 = (*data)[7]
    var cmd: u8 = (*data)[8]

    handle_command(src_node, cmd_class, cmd, &(*data)[9], len - 9)
  } else if func_id == 0x4A {
    // Add node status
    var status: u8 = (*data)[5]
    if status == 0x03 {
      // Node found, get info
    } else if status == 0x05 {
      // Protocol done
    } else if status == 0x06 {
      // Done
      zwave_stop_inclusion()
    }
  }
}

fn handle_command(node_id: u8, cmd_class: u8, cmd: u8, payload: *[u8], len: u32) {
  // Update last seen
  var i: u32 = 0
  while i < zw_node_count {
    if zw_nodes[i].node_id == node_id {
      zw_nodes[i].last_seen = foundation.get_tick_count()
      break
    }
    i = i + 1
  }

  // Handle specific command classes
  if cmd_class == ZWAVE_CC_BATTERY && cmd == 0x03 {
    // Battery report
    var level: u8 = (*payload)[0]
    update_battery_level(node_id, level)
  } else if cmd_class == ZWAVE_CC_SENSOR_MULTILEVEL && cmd == 0x05 {
    // Sensor report
    handle_sensor_report(node_id, payload)
  } else if cmd_class == ZWAVE_CC_NOTIFICATION && cmd == 0x05 {
    // Notification report
    handle_notification(node_id, payload)
  }
}

fn update_battery_level(node_id: u8, level: u8) {
  var i: u32 = 0
  while i < zw_node_count {
    if zw_nodes[i].node_id == node_id {
      zw_nodes[i].battery_level = level
      break
    }
    i = i + 1
  }
}

fn handle_sensor_report(node_id: u8, payload: *[u8]) {
  var sensor_type: u8 = (*payload)[0]
  // Parse value based on precision/scale/size...
  foundation.serial_write_string("[Z-Wave] Sensor report from node ")
  foundation.serial_write_hex(node_id as u32)
  foundation.serial_write_string("\n")
}

fn handle_notification(node_id: u8, payload: *[u8]) {
  var notification_type: u8 = (*payload)[1]
  var event: u8 = (*payload)[2]
  foundation.serial_write_string("[Z-Wave] Notification from node ")
  foundation.serial_write_hex(node_id as u32)
  foundation.serial_write_string(" type=")
  foundation.serial_write_hex(notification_type as u32)
  foundation.serial_write_string("\n")
}
