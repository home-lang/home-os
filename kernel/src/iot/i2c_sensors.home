// home-os I2C Sensor Drivers
// Support for BME280, BMP280, MPU6050, BH1750, ADS1115, SHT31, VL53L0X, and more

import "../core/foundation.home" as foundation
import "../drivers/i2c.home" as i2c

// ============================================================================
// I2C Sensor Types
// ============================================================================

const I2C_SENSOR_BME280: u8 = 0        // Temperature, Humidity, Pressure
const I2C_SENSOR_BMP280: u8 = 1        // Temperature, Pressure
const I2C_SENSOR_MPU6050: u8 = 2       // 6-axis IMU (Accel + Gyro)
const I2C_SENSOR_MPU9250: u8 = 3       // 9-axis IMU (Accel + Gyro + Mag)
const I2C_SENSOR_BH1750: u8 = 4        // Ambient light sensor
const I2C_SENSOR_ADS1115: u8 = 5       // 16-bit ADC
const I2C_SENSOR_SHT31: u8 = 6         // Temperature + Humidity
const I2C_SENSOR_VL53L0X: u8 = 7       // Time-of-flight distance sensor
const I2C_SENSOR_INA219: u8 = 8        // Current/Power sensor
const I2C_SENSOR_MCP9808: u8 = 9       // High-accuracy temperature
const I2C_SENSOR_TSL2561: u8 = 10      // Light sensor (lux)
const I2C_SENSOR_HMC5883L: u8 = 11     // 3-axis magnetometer
const I2C_SENSOR_APDS9960: u8 = 12     // Gesture/Color/Proximity
const I2C_SENSOR_MAX30102: u8 = 13     // Pulse oximeter

// Common I2C addresses
const BME280_ADDR_PRIMARY: u8 = 0x76
const BME280_ADDR_SECONDARY: u8 = 0x77
const BMP280_ADDR_PRIMARY: u8 = 0x76
const BMP280_ADDR_SECONDARY: u8 = 0x77
const MPU6050_ADDR_PRIMARY: u8 = 0x68
const MPU6050_ADDR_SECONDARY: u8 = 0x69
const BH1750_ADDR_PRIMARY: u8 = 0x23
const BH1750_ADDR_SECONDARY: u8 = 0x5C
const ADS1115_ADDR_GND: u8 = 0x48
const ADS1115_ADDR_VDD: u8 = 0x49
const SHT31_ADDR_PRIMARY: u8 = 0x44
const VL53L0X_ADDR: u8 = 0x29
const INA219_ADDR: u8 = 0x40
const MCP9808_ADDR: u8 = 0x18

const MAX_I2C_SENSORS: u32 = 32

// ============================================================================
// BME280 Registers
// ============================================================================

const BME280_REG_CHIP_ID: u8 = 0xD0
const BME280_REG_RESET: u8 = 0xE0
const BME280_REG_CTRL_HUM: u8 = 0xF2
const BME280_REG_STATUS: u8 = 0xF3
const BME280_REG_CTRL_MEAS: u8 = 0xF4
const BME280_REG_CONFIG: u8 = 0xF5
const BME280_REG_PRESS_MSB: u8 = 0xF7
const BME280_REG_TEMP_MSB: u8 = 0xFA
const BME280_REG_HUM_MSB: u8 = 0xFD
const BME280_REG_CALIB00: u8 = 0x88
const BME280_REG_CALIB26: u8 = 0xE1

const BME280_CHIP_ID: u8 = 0x60
const BMP280_CHIP_ID: u8 = 0x58

// ============================================================================
// MPU6050 Registers
// ============================================================================

const MPU6050_REG_SMPLRT_DIV: u8 = 0x19
const MPU6050_REG_CONFIG: u8 = 0x1A
const MPU6050_REG_GYRO_CONFIG: u8 = 0x1B
const MPU6050_REG_ACCEL_CONFIG: u8 = 0x1C
const MPU6050_REG_ACCEL_XOUT_H: u8 = 0x3B
const MPU6050_REG_TEMP_OUT_H: u8 = 0x41
const MPU6050_REG_GYRO_XOUT_H: u8 = 0x43
const MPU6050_REG_PWR_MGMT_1: u8 = 0x6B
const MPU6050_REG_PWR_MGMT_2: u8 = 0x6C
const MPU6050_REG_WHO_AM_I: u8 = 0x75

const MPU6050_WHO_AM_I_VALUE: u8 = 0x68

// ============================================================================
// BH1750 Commands
// ============================================================================

const BH1750_POWER_DOWN: u8 = 0x00
const BH1750_POWER_ON: u8 = 0x01
const BH1750_RESET: u8 = 0x07
const BH1750_CONT_H_RES: u8 = 0x10     // Continuous high resolution (1 lux)
const BH1750_CONT_H_RES2: u8 = 0x11    // Continuous high resolution (0.5 lux)
const BH1750_CONT_L_RES: u8 = 0x13     // Continuous low resolution (4 lux)
const BH1750_ONE_H_RES: u8 = 0x20      // One-time high resolution
const BH1750_ONE_H_RES2: u8 = 0x21     // One-time high resolution 2
const BH1750_ONE_L_RES: u8 = 0x23      // One-time low resolution

// ============================================================================
// ADS1115 Registers
// ============================================================================

const ADS1115_REG_CONVERSION: u8 = 0x00
const ADS1115_REG_CONFIG: u8 = 0x01
const ADS1115_REG_LO_THRESH: u8 = 0x02
const ADS1115_REG_HI_THRESH: u8 = 0x03

// ADS1115 config bits
const ADS1115_OS_SINGLE: u16 = 0x8000
const ADS1115_MUX_AIN0: u16 = 0x4000
const ADS1115_MUX_AIN1: u16 = 0x5000
const ADS1115_MUX_AIN2: u16 = 0x6000
const ADS1115_MUX_AIN3: u16 = 0x7000
const ADS1115_PGA_6144: u16 = 0x0000   // ±6.144V
const ADS1115_PGA_4096: u16 = 0x0200   // ±4.096V
const ADS1115_PGA_2048: u16 = 0x0400   // ±2.048V
const ADS1115_PGA_1024: u16 = 0x0600   // ±1.024V
const ADS1115_MODE_SINGLE: u16 = 0x0100
const ADS1115_DR_128: u16 = 0x0080     // 128 SPS

// ============================================================================
// Data Structures
// ============================================================================

// BME280 calibration data
struct Bme280Calibration {
    dig_T1: u16,
    dig_T2: i16,
    dig_T3: i16,
    dig_P1: u16,
    dig_P2: i16,
    dig_P3: i16,
    dig_P4: i16,
    dig_P5: i16,
    dig_P6: i16,
    dig_P7: i16,
    dig_P8: i16,
    dig_P9: i16,
    dig_H1: u8,
    dig_H2: i16,
    dig_H3: u8,
    dig_H4: i16,
    dig_H5: i16,
    dig_H6: i8,
    t_fine: i32
}

// Environmental reading (BME280, BMP280, SHT31)
struct EnvironmentalReading {
    temperature_c: i32,      // Temperature in 0.01°C
    humidity_percent: u32,   // Humidity in 0.01%
    pressure_pa: u32,        // Pressure in Pa
    valid: u8,
    timestamp: u64
}

// IMU reading (MPU6050, MPU9250)
struct ImuReading {
    accel_x: i16,            // Acceleration in raw units
    accel_y: i16,
    accel_z: i16,
    gyro_x: i16,             // Gyroscope in raw units
    gyro_y: i16,
    gyro_z: i16,
    mag_x: i16,              // Magnetometer (if available)
    mag_y: i16,
    mag_z: i16,
    temperature: i16,        // Die temperature
    valid: u8,
    timestamp: u64
}

// Light reading (BH1750, TSL2561)
struct LightReading {
    lux: u32,                // Light level in lux
    raw_value: u16,
    valid: u8,
    timestamp: u64
}

// ADC reading (ADS1115)
struct AdcReading {
    channel: u8,
    raw_value: i16,
    voltage_mv: i32,         // Voltage in millivolts
    valid: u8,
    timestamp: u64
}

// Distance reading (VL53L0X)
struct DistanceReading {
    distance_mm: u16,
    signal_rate: u16,
    ambient_rate: u16,
    valid: u8,
    timestamp: u64
}

// Power reading (INA219)
struct PowerReading {
    voltage_mv: i32,
    current_ma: i32,
    power_mw: i32,
    valid: u8,
    timestamp: u64
}

// I2C sensor configuration
struct I2cSensor {
    sensor_type: u8,
    i2c_controller: u32,
    i2c_device: u32,         // Device handle from i2c driver
    i2c_address: u8,
    poll_interval_ms: u32,
    last_poll: u64,

    // Calibration data
    bme280_calib: Bme280Calibration,

    // Reading data
    env_reading: EnvironmentalReading,
    imu_reading: ImuReading,
    light_reading: LightReading,
    adc_reading: AdcReading,
    distance_reading: DistanceReading,
    power_reading: PowerReading,

    active: u8
}

// Statistics
struct I2cSensorStats {
    total_reads: u64,
    successful_reads: u64,
    failed_reads: u64,
    init_failures: u64
}

// ============================================================================
// Global State
// ============================================================================

var i2c_sensors: [I2cSensor; 32]
var i2c_sensor_count: u32 = 0
var i2c_sensor_stats: I2cSensorStats
var i2c_sensors_initialized: u32 = 0

// ============================================================================
// Initialization
// ============================================================================

export fn i2c_sensors_init(): u32 {
    if i2c_sensors_initialized == 1 {
        return 1
    }

    var i: u32 = 0
    while i < MAX_I2C_SENSORS {
        i2c_sensors[i].active = 0
        i = i + 1
    }

    i2c_sensor_stats.total_reads = 0
    i2c_sensor_stats.successful_reads = 0
    i2c_sensor_stats.failed_reads = 0
    i2c_sensor_stats.init_failures = 0

    i2c_sensor_count = 0
    i2c_sensors_initialized = 1

    foundation.serial_write_string("[I2C-Sensors] Initialized\n")
    return 1
}

// ============================================================================
// BME280/BMP280 Sensor
// ============================================================================

// Register BME280 sensor
export fn i2c_sensor_register_bme280(controller: u32, address: u8): u32 {
    if i2c_sensor_count >= MAX_I2C_SENSORS {
        return 0xFFFFFFFF
    }

    var idx: u32 = i2c_sensor_count

    // Register I2C device
    var dev_handle: u32 = i2c.i2c_register_device(controller, address, i2c.I2C_ADDR_7BIT)
    if dev_handle == 0xFFFFFFFF {
        i2c_sensor_stats.init_failures = i2c_sensor_stats.init_failures + 1
        return 0xFFFFFFFF
    }

    // Check chip ID
    var chip_id: u8 = i2c.i2c_read_byte(dev_handle, BME280_REG_CHIP_ID)
    if chip_id != BME280_CHIP_ID && chip_id != BMP280_CHIP_ID {
        i2c.i2c_unregister_device(dev_handle)
        i2c_sensor_stats.init_failures = i2c_sensor_stats.init_failures + 1
        return 0xFFFFFFFF
    }

    i2c_sensors[idx].sensor_type = if chip_id == BME280_CHIP_ID { I2C_SENSOR_BME280 } else { I2C_SENSOR_BMP280 }
    i2c_sensors[idx].i2c_controller = controller
    i2c_sensors[idx].i2c_device = dev_handle
    i2c_sensors[idx].i2c_address = address
    i2c_sensors[idx].poll_interval_ms = 1000
    i2c_sensors[idx].last_poll = 0
    i2c_sensors[idx].active = 1

    // Read calibration data
    bme280_read_calibration(idx)

    // Configure sensor
    // Humidity oversampling x1
    i2c.i2c_write_byte(dev_handle, BME280_REG_CTRL_HUM, 0x01)
    // Temperature x2, Pressure x16, Normal mode
    i2c.i2c_write_byte(dev_handle, BME280_REG_CTRL_MEAS, 0x57)
    // Standby 62.5ms, filter x4
    i2c.i2c_write_byte(dev_handle, BME280_REG_CONFIG, 0x28)

    i2c_sensor_count = i2c_sensor_count + 1

    foundation.serial_write_string("[I2C-Sensors] BME280 registered at 0x")
    foundation.serial_write_hex(address)
    foundation.serial_write_string("\n")

    return idx
}

// Read BME280 calibration data
fn bme280_read_calibration(idx: u32) {
    var dev: u32 = i2c_sensors[idx].i2c_device

    var calib_data: [u8; 26]
    i2c.i2c_read(dev, BME280_REG_CALIB00, @ptrFromInt(calib_data), 26)

    i2c_sensors[idx].bme280_calib.dig_T1 = (calib_data[1] << 8) | calib_data[0]
    i2c_sensors[idx].bme280_calib.dig_T2 = (calib_data[3] << 8) | calib_data[2]
    i2c_sensors[idx].bme280_calib.dig_T3 = (calib_data[5] << 8) | calib_data[4]
    i2c_sensors[idx].bme280_calib.dig_P1 = (calib_data[7] << 8) | calib_data[6]
    i2c_sensors[idx].bme280_calib.dig_P2 = (calib_data[9] << 8) | calib_data[8]
    i2c_sensors[idx].bme280_calib.dig_P3 = (calib_data[11] << 8) | calib_data[10]
    i2c_sensors[idx].bme280_calib.dig_P4 = (calib_data[13] << 8) | calib_data[12]
    i2c_sensors[idx].bme280_calib.dig_P5 = (calib_data[15] << 8) | calib_data[14]
    i2c_sensors[idx].bme280_calib.dig_P6 = (calib_data[17] << 8) | calib_data[16]
    i2c_sensors[idx].bme280_calib.dig_P7 = (calib_data[19] << 8) | calib_data[18]
    i2c_sensors[idx].bme280_calib.dig_P8 = (calib_data[21] << 8) | calib_data[20]
    i2c_sensors[idx].bme280_calib.dig_P9 = (calib_data[23] << 8) | calib_data[22]
    i2c_sensors[idx].bme280_calib.dig_H1 = calib_data[25]

    // Read humidity calibration from 0xE1-0xE7
    var hum_calib: [u8; 7]
    i2c.i2c_read(dev, BME280_REG_CALIB26, @ptrFromInt(hum_calib), 7)

    i2c_sensors[idx].bme280_calib.dig_H2 = (hum_calib[1] << 8) | hum_calib[0]
    i2c_sensors[idx].bme280_calib.dig_H3 = hum_calib[2]
    i2c_sensors[idx].bme280_calib.dig_H4 = (hum_calib[3] << 4) | (hum_calib[4] & 0x0F)
    i2c_sensors[idx].bme280_calib.dig_H5 = (hum_calib[5] << 4) | (hum_calib[4] >> 4)
    i2c_sensors[idx].bme280_calib.dig_H6 = hum_calib[6]
}

// Read BME280 sensor
export fn i2c_sensor_read_bme280(handle: u32): u32 {
    if handle >= i2c_sensor_count { return 0 }
    if i2c_sensors[handle].active == 0 { return 0 }

    i2c_sensor_stats.total_reads = i2c_sensor_stats.total_reads + 1

    var dev: u32 = i2c_sensors[handle].i2c_device

    // Read raw data (8 bytes: pressure[3], temp[3], humidity[2])
    var raw_data: [u8; 8]
    var bytes_read: u32 = i2c.i2c_read(dev, BME280_REG_PRESS_MSB, @ptrFromInt(raw_data), 8)
    if bytes_read != 8 {
        i2c_sensor_stats.failed_reads = i2c_sensor_stats.failed_reads + 1
        i2c_sensors[handle].env_reading.valid = 0
        return 0
    }

    // Parse raw values
    var adc_P: i32 = ((raw_data[0] << 16) | (raw_data[1] << 8) | raw_data[2]) >> 4
    var adc_T: i32 = ((raw_data[3] << 16) | (raw_data[4] << 8) | raw_data[5]) >> 4
    var adc_H: i32 = (raw_data[6] << 8) | raw_data[7]

    // Compensate temperature
    var temp: i32 = bme280_compensate_temp(handle, adc_T)
    var press: u32 = bme280_compensate_pressure(handle, adc_P)
    var hum: u32 = bme280_compensate_humidity(handle, adc_H)

    i2c_sensors[handle].env_reading.temperature_c = temp
    i2c_sensors[handle].env_reading.pressure_pa = press
    i2c_sensors[handle].env_reading.humidity_percent = hum
    i2c_sensors[handle].env_reading.valid = 1
    i2c_sensors[handle].env_reading.timestamp = foundation.timer_get_ticks()
    i2c_sensors[handle].last_poll = foundation.timer_get_ticks()

    i2c_sensor_stats.successful_reads = i2c_sensor_stats.successful_reads + 1
    return 1
}

// BME280 temperature compensation (returns 0.01°C)
fn bme280_compensate_temp(handle: u32, adc_T: i32): i32 {
    var dig_T1: i32 = i2c_sensors[handle].bme280_calib.dig_T1
    var dig_T2: i32 = i2c_sensors[handle].bme280_calib.dig_T2
    var dig_T3: i32 = i2c_sensors[handle].bme280_calib.dig_T3

    var var1: i32 = ((((adc_T >> 3) - (dig_T1 << 1))) * dig_T2) >> 11
    var var2: i32 = (((((adc_T >> 4) - dig_T1) * ((adc_T >> 4) - dig_T1)) >> 12) * dig_T3) >> 14

    i2c_sensors[handle].bme280_calib.t_fine = var1 + var2
    var T: i32 = (i2c_sensors[handle].bme280_calib.t_fine * 5 + 128) >> 8

    return T
}

// BME280 pressure compensation (returns Pa)
fn bme280_compensate_pressure(handle: u32, adc_P: i32): u32 {
    var t_fine: i64 = i2c_sensors[handle].bme280_calib.t_fine

    var var1: i64 = t_fine - 128000
    var var2: i64 = var1 * var1 * i2c_sensors[handle].bme280_calib.dig_P6
    var2 = var2 + ((var1 * i2c_sensors[handle].bme280_calib.dig_P5) << 17)
    var2 = var2 + (i2c_sensors[handle].bme280_calib.dig_P4 << 35)
    var1 = ((var1 * var1 * i2c_sensors[handle].bme280_calib.dig_P3) >> 8) +
           ((var1 * i2c_sensors[handle].bme280_calib.dig_P2) << 12)
    var1 = ((1 << 47) + var1) * i2c_sensors[handle].bme280_calib.dig_P1 >> 33

    if var1 == 0 { return 0 }

    var p: i64 = 1048576 - adc_P
    p = (((p << 31) - var2) * 3125) / var1
    var1 = (i2c_sensors[handle].bme280_calib.dig_P9 * (p >> 13) * (p >> 13)) >> 25
    var2 = (i2c_sensors[handle].bme280_calib.dig_P8 * p) >> 19

    p = ((p + var1 + var2) >> 8) + (i2c_sensors[handle].bme280_calib.dig_P7 << 4)

    return @truncate(p >> 8, u32)
}

// BME280 humidity compensation (returns 0.01%)
fn bme280_compensate_humidity(handle: u32, adc_H: i32): u32 {
    var t_fine: i32 = i2c_sensors[handle].bme280_calib.t_fine

    var v_x1: i32 = t_fine - 76800
    var dig_H2: i32 = i2c_sensors[handle].bme280_calib.dig_H2
    var dig_H4: i32 = i2c_sensors[handle].bme280_calib.dig_H4
    var dig_H5: i32 = i2c_sensors[handle].bme280_calib.dig_H5

    v_x1 = (((adc_H << 14) - (dig_H4 << 20) - (dig_H5 * v_x1)) + 16384) >> 15
    v_x1 = v_x1 * (((((((v_x1 * i2c_sensors[handle].bme280_calib.dig_H6) >> 10) *
           (((v_x1 * i2c_sensors[handle].bme280_calib.dig_H3) >> 11) + 32768)) >> 10) + 2097152) *
           dig_H2 + 8192) >> 14)
    v_x1 = v_x1 - (((((v_x1 >> 15) * (v_x1 >> 15)) >> 7) * i2c_sensors[handle].bme280_calib.dig_H1) >> 4)

    if v_x1 < 0 { v_x1 = 0 }
    if v_x1 > 419430400 { v_x1 = 419430400 }

    var humidity: u32 = v_x1 >> 12
    return (humidity * 100) >> 10  // Convert to 0.01%
}

// ============================================================================
// MPU6050 6-Axis IMU
// ============================================================================

// Register MPU6050 sensor
export fn i2c_sensor_register_mpu6050(controller: u32, address: u8): u32 {
    if i2c_sensor_count >= MAX_I2C_SENSORS {
        return 0xFFFFFFFF
    }

    var idx: u32 = i2c_sensor_count

    // Register I2C device
    var dev_handle: u32 = i2c.i2c_register_device(controller, address, i2c.I2C_ADDR_7BIT)
    if dev_handle == 0xFFFFFFFF {
        i2c_sensor_stats.init_failures = i2c_sensor_stats.init_failures + 1
        return 0xFFFFFFFF
    }

    // Check WHO_AM_I
    var who_am_i: u8 = i2c.i2c_read_byte(dev_handle, MPU6050_REG_WHO_AM_I)
    if who_am_i != MPU6050_WHO_AM_I_VALUE {
        i2c.i2c_unregister_device(dev_handle)
        i2c_sensor_stats.init_failures = i2c_sensor_stats.init_failures + 1
        return 0xFFFFFFFF
    }

    i2c_sensors[idx].sensor_type = I2C_SENSOR_MPU6050
    i2c_sensors[idx].i2c_controller = controller
    i2c_sensors[idx].i2c_device = dev_handle
    i2c_sensors[idx].i2c_address = address
    i2c_sensors[idx].poll_interval_ms = 10   // 100 Hz
    i2c_sensors[idx].last_poll = 0
    i2c_sensors[idx].active = 1

    // Wake up (exit sleep mode)
    i2c.i2c_write_byte(dev_handle, MPU6050_REG_PWR_MGMT_1, 0x00)

    // Configure: ±2g accelerometer, ±250°/s gyroscope
    i2c.i2c_write_byte(dev_handle, MPU6050_REG_ACCEL_CONFIG, 0x00)
    i2c.i2c_write_byte(dev_handle, MPU6050_REG_GYRO_CONFIG, 0x00)

    // Set sample rate divider (8kHz / (1 + 7) = 1kHz)
    i2c.i2c_write_byte(dev_handle, MPU6050_REG_SMPLRT_DIV, 0x07)

    // Configure DLPF (digital low-pass filter)
    i2c.i2c_write_byte(dev_handle, MPU6050_REG_CONFIG, 0x06)

    i2c_sensor_count = i2c_sensor_count + 1

    foundation.serial_write_string("[I2C-Sensors] MPU6050 registered at 0x")
    foundation.serial_write_hex(address)
    foundation.serial_write_string("\n")

    return idx
}

// Read MPU6050 sensor
export fn i2c_sensor_read_mpu6050(handle: u32): u32 {
    if handle >= i2c_sensor_count { return 0 }
    if i2c_sensors[handle].active == 0 { return 0 }

    i2c_sensor_stats.total_reads = i2c_sensor_stats.total_reads + 1

    var dev: u32 = i2c_sensors[handle].i2c_device

    // Read 14 bytes: accel[6], temp[2], gyro[6]
    var raw_data: [u8; 14]
    var bytes_read: u32 = i2c.i2c_read(dev, MPU6050_REG_ACCEL_XOUT_H, @ptrFromInt(raw_data), 14)
    if bytes_read != 14 {
        i2c_sensor_stats.failed_reads = i2c_sensor_stats.failed_reads + 1
        i2c_sensors[handle].imu_reading.valid = 0
        return 0
    }

    // Parse accelerometer
    i2c_sensors[handle].imu_reading.accel_x = (raw_data[0] << 8) | raw_data[1]
    i2c_sensors[handle].imu_reading.accel_y = (raw_data[2] << 8) | raw_data[3]
    i2c_sensors[handle].imu_reading.accel_z = (raw_data[4] << 8) | raw_data[5]

    // Parse temperature
    i2c_sensors[handle].imu_reading.temperature = (raw_data[6] << 8) | raw_data[7]

    // Parse gyroscope
    i2c_sensors[handle].imu_reading.gyro_x = (raw_data[8] << 8) | raw_data[9]
    i2c_sensors[handle].imu_reading.gyro_y = (raw_data[10] << 8) | raw_data[11]
    i2c_sensors[handle].imu_reading.gyro_z = (raw_data[12] << 8) | raw_data[13]

    i2c_sensors[handle].imu_reading.valid = 1
    i2c_sensors[handle].imu_reading.timestamp = foundation.timer_get_ticks()
    i2c_sensors[handle].last_poll = foundation.timer_get_ticks()

    i2c_sensor_stats.successful_reads = i2c_sensor_stats.successful_reads + 1
    return 1
}

// ============================================================================
// BH1750 Ambient Light Sensor
// ============================================================================

// Register BH1750 sensor
export fn i2c_sensor_register_bh1750(controller: u32, address: u8): u32 {
    if i2c_sensor_count >= MAX_I2C_SENSORS {
        return 0xFFFFFFFF
    }

    var idx: u32 = i2c_sensor_count

    // Register I2C device
    var dev_handle: u32 = i2c.i2c_register_device(controller, address, i2c.I2C_ADDR_7BIT)
    if dev_handle == 0xFFFFFFFF {
        i2c_sensor_stats.init_failures = i2c_sensor_stats.init_failures + 1
        return 0xFFFFFFFF
    }

    i2c_sensors[idx].sensor_type = I2C_SENSOR_BH1750
    i2c_sensors[idx].i2c_controller = controller
    i2c_sensors[idx].i2c_device = dev_handle
    i2c_sensors[idx].i2c_address = address
    i2c_sensors[idx].poll_interval_ms = 200
    i2c_sensors[idx].last_poll = 0
    i2c_sensors[idx].active = 1

    // Power on and set continuous high resolution mode
    i2c.i2c_write_byte(dev_handle, BH1750_POWER_ON, 0)
    i2c.i2c_write_byte(dev_handle, BH1750_CONT_H_RES, 0)

    i2c_sensor_count = i2c_sensor_count + 1

    foundation.serial_write_string("[I2C-Sensors] BH1750 registered at 0x")
    foundation.serial_write_hex(address)
    foundation.serial_write_string("\n")

    return idx
}

// Read BH1750 sensor
export fn i2c_sensor_read_bh1750(handle: u32): u32 {
    if handle >= i2c_sensor_count { return 0 }
    if i2c_sensors[handle].active == 0 { return 0 }

    i2c_sensor_stats.total_reads = i2c_sensor_stats.total_reads + 1

    var dev: u32 = i2c_sensors[handle].i2c_device

    // Read 2 bytes
    var raw_data: [u8; 2]
    var bytes_read: u32 = i2c.i2c_read(dev, 0, @ptrFromInt(raw_data), 2)
    if bytes_read != 2 {
        i2c_sensor_stats.failed_reads = i2c_sensor_stats.failed_reads + 1
        i2c_sensors[handle].light_reading.valid = 0
        return 0
    }

    var raw_value: u16 = (raw_data[0] << 8) | raw_data[1]

    // Convert to lux (divide by 1.2)
    i2c_sensors[handle].light_reading.raw_value = raw_value
    i2c_sensors[handle].light_reading.lux = (raw_value * 10) / 12
    i2c_sensors[handle].light_reading.valid = 1
    i2c_sensors[handle].light_reading.timestamp = foundation.timer_get_ticks()
    i2c_sensors[handle].last_poll = foundation.timer_get_ticks()

    i2c_sensor_stats.successful_reads = i2c_sensor_stats.successful_reads + 1
    return 1
}

// ============================================================================
// ADS1115 16-bit ADC
// ============================================================================

// Register ADS1115 sensor
export fn i2c_sensor_register_ads1115(controller: u32, address: u8): u32 {
    if i2c_sensor_count >= MAX_I2C_SENSORS {
        return 0xFFFFFFFF
    }

    var idx: u32 = i2c_sensor_count

    // Register I2C device
    var dev_handle: u32 = i2c.i2c_register_device(controller, address, i2c.I2C_ADDR_7BIT)
    if dev_handle == 0xFFFFFFFF {
        i2c_sensor_stats.init_failures = i2c_sensor_stats.init_failures + 1
        return 0xFFFFFFFF
    }

    i2c_sensors[idx].sensor_type = I2C_SENSOR_ADS1115
    i2c_sensors[idx].i2c_controller = controller
    i2c_sensors[idx].i2c_device = dev_handle
    i2c_sensors[idx].i2c_address = address
    i2c_sensors[idx].poll_interval_ms = 100
    i2c_sensors[idx].last_poll = 0
    i2c_sensors[idx].active = 1

    i2c_sensor_count = i2c_sensor_count + 1

    foundation.serial_write_string("[I2C-Sensors] ADS1115 registered at 0x")
    foundation.serial_write_hex(address)
    foundation.serial_write_string("\n")

    return idx
}

// Read ADS1115 single channel
export fn i2c_sensor_read_ads1115(handle: u32, channel: u8): i16 {
    if handle >= i2c_sensor_count { return 0 }
    if i2c_sensors[handle].active == 0 { return 0 }

    i2c_sensor_stats.total_reads = i2c_sensor_stats.total_reads + 1

    var dev: u32 = i2c_sensors[handle].i2c_device

    // Build config: single-shot, channel, ±4.096V, 128 SPS
    var config: u16 = ADS1115_OS_SINGLE | ADS1115_PGA_4096 | ADS1115_MODE_SINGLE | ADS1115_DR_128

    // Set channel
    if channel == 0 { config = config | ADS1115_MUX_AIN0 }
    else if channel == 1 { config = config | ADS1115_MUX_AIN1 }
    else if channel == 2 { config = config | ADS1115_MUX_AIN2 }
    else if channel == 3 { config = config | ADS1115_MUX_AIN3 }

    // Write config
    i2c.i2c_write_word(dev, ADS1115_REG_CONFIG, config)

    // Wait for conversion (minimum 8ms at 128 SPS)
    delay_ms(10)

    // Read result
    var result: u16 = i2c.i2c_read_word(dev, ADS1115_REG_CONVERSION)
    var signed_result: i16 = @bitCast(result, i16)

    i2c_sensors[handle].adc_reading.channel = channel
    i2c_sensors[handle].adc_reading.raw_value = signed_result
    // ±4.096V range, 16-bit = 0.125mV per bit
    i2c_sensors[handle].adc_reading.voltage_mv = (signed_result * 125) / 1000
    i2c_sensors[handle].adc_reading.valid = 1
    i2c_sensors[handle].adc_reading.timestamp = foundation.timer_get_ticks()
    i2c_sensors[handle].last_poll = foundation.timer_get_ticks()

    i2c_sensor_stats.successful_reads = i2c_sensor_stats.successful_reads + 1
    return signed_result
}

// ============================================================================
// SHT31 Temperature + Humidity
// ============================================================================

// Register SHT31 sensor
export fn i2c_sensor_register_sht31(controller: u32, address: u8): u32 {
    if i2c_sensor_count >= MAX_I2C_SENSORS {
        return 0xFFFFFFFF
    }

    var idx: u32 = i2c_sensor_count

    // Register I2C device
    var dev_handle: u32 = i2c.i2c_register_device(controller, address, i2c.I2C_ADDR_7BIT)
    if dev_handle == 0xFFFFFFFF {
        i2c_sensor_stats.init_failures = i2c_sensor_stats.init_failures + 1
        return 0xFFFFFFFF
    }

    i2c_sensors[idx].sensor_type = I2C_SENSOR_SHT31
    i2c_sensors[idx].i2c_controller = controller
    i2c_sensors[idx].i2c_device = dev_handle
    i2c_sensors[idx].i2c_address = address
    i2c_sensors[idx].poll_interval_ms = 500
    i2c_sensors[idx].last_poll = 0
    i2c_sensors[idx].active = 1

    // Soft reset
    i2c.i2c_write_word(dev_handle, 0x30, 0xA2)
    delay_ms(10)

    i2c_sensor_count = i2c_sensor_count + 1

    foundation.serial_write_string("[I2C-Sensors] SHT31 registered at 0x")
    foundation.serial_write_hex(address)
    foundation.serial_write_string("\n")

    return idx
}

// Read SHT31 sensor
export fn i2c_sensor_read_sht31(handle: u32): u32 {
    if handle >= i2c_sensor_count { return 0 }
    if i2c_sensors[handle].active == 0 { return 0 }

    i2c_sensor_stats.total_reads = i2c_sensor_stats.total_reads + 1

    var dev: u32 = i2c_sensors[handle].i2c_device

    // Send measurement command (high repeatability, clock stretching disabled)
    i2c.i2c_write_word(dev, 0x24, 0x00)

    // Wait for measurement (15ms for high repeatability)
    delay_ms(20)

    // Read 6 bytes: temp[2], crc, humidity[2], crc
    var raw_data: [u8; 6]
    var bytes_read: u32 = i2c.i2c_read(dev, 0, @ptrFromInt(raw_data), 6)
    if bytes_read != 6 {
        i2c_sensor_stats.failed_reads = i2c_sensor_stats.failed_reads + 1
        i2c_sensors[handle].env_reading.valid = 0
        return 0
    }

    // Parse temperature (ignore CRC for simplicity)
    var temp_raw: u16 = (raw_data[0] << 8) | raw_data[1]
    // Temperature = -45 + 175 * (raw / 65535)
    var temp_c: i32 = -4500 + ((17500 * temp_raw) / 65535)

    // Parse humidity
    var hum_raw: u16 = (raw_data[3] << 8) | raw_data[4]
    // Humidity = 100 * (raw / 65535)
    var humidity: u32 = (10000 * hum_raw) / 65535

    i2c_sensors[handle].env_reading.temperature_c = temp_c
    i2c_sensors[handle].env_reading.humidity_percent = humidity
    i2c_sensors[handle].env_reading.valid = 1
    i2c_sensors[handle].env_reading.timestamp = foundation.timer_get_ticks()
    i2c_sensors[handle].last_poll = foundation.timer_get_ticks()

    i2c_sensor_stats.successful_reads = i2c_sensor_stats.successful_reads + 1
    return 1
}

// ============================================================================
// VL53L0X Time-of-Flight Distance Sensor
// ============================================================================

// Register VL53L0X sensor
export fn i2c_sensor_register_vl53l0x(controller: u32, address: u8): u32 {
    if i2c_sensor_count >= MAX_I2C_SENSORS {
        return 0xFFFFFFFF
    }

    var idx: u32 = i2c_sensor_count

    // Register I2C device
    var dev_handle: u32 = i2c.i2c_register_device(controller, address, i2c.I2C_ADDR_7BIT)
    if dev_handle == 0xFFFFFFFF {
        i2c_sensor_stats.init_failures = i2c_sensor_stats.init_failures + 1
        return 0xFFFFFFFF
    }

    i2c_sensors[idx].sensor_type = I2C_SENSOR_VL53L0X
    i2c_sensors[idx].i2c_controller = controller
    i2c_sensors[idx].i2c_device = dev_handle
    i2c_sensors[idx].i2c_address = address
    i2c_sensors[idx].poll_interval_ms = 50
    i2c_sensors[idx].last_poll = 0
    i2c_sensors[idx].active = 1

    // Basic initialization (simplified - full init is complex)
    // Set I2C standard mode
    i2c.i2c_write_byte(dev_handle, 0x88, 0x00)
    // Start ranging
    i2c.i2c_write_byte(dev_handle, 0x00, 0x01)

    i2c_sensor_count = i2c_sensor_count + 1

    foundation.serial_write_string("[I2C-Sensors] VL53L0X registered at 0x")
    foundation.serial_write_hex(address)
    foundation.serial_write_string("\n")

    return idx
}

// Read VL53L0X sensor
export fn i2c_sensor_read_vl53l0x(handle: u32): u32 {
    if handle >= i2c_sensor_count { return 0 }
    if i2c_sensors[handle].active == 0 { return 0 }

    i2c_sensor_stats.total_reads = i2c_sensor_stats.total_reads + 1

    var dev: u32 = i2c_sensors[handle].i2c_device

    // Start single measurement
    i2c.i2c_write_byte(dev, 0x00, 0x01)

    // Wait for measurement complete
    var timeout: u32 = 100
    while timeout > 0 {
        var status: u8 = i2c.i2c_read_byte(dev, 0x13)
        if (status & 0x07) != 0 {
            break
        }
        delay_ms(1)
        timeout = timeout - 1
    }

    if timeout == 0 {
        i2c_sensor_stats.failed_reads = i2c_sensor_stats.failed_reads + 1
        i2c_sensors[handle].distance_reading.valid = 0
        return 0
    }

    // Read distance (register 0x14-0x15)
    var distance: u16 = i2c.i2c_read_word(dev, 0x14)

    // Clear interrupt
    i2c.i2c_write_byte(dev, 0x0B, 0x01)

    i2c_sensors[handle].distance_reading.distance_mm = distance
    i2c_sensors[handle].distance_reading.valid = 1
    i2c_sensors[handle].distance_reading.timestamp = foundation.timer_get_ticks()
    i2c_sensors[handle].last_poll = foundation.timer_get_ticks()

    i2c_sensor_stats.successful_reads = i2c_sensor_stats.successful_reads + 1
    return 1
}

// ============================================================================
// Generic Reading Functions
// ============================================================================

// Get temperature in 0.01°C
export fn i2c_sensor_get_temperature(handle: u32): i32 {
    if handle >= i2c_sensor_count { return -27300 }  // Absolute zero
    return i2c_sensors[handle].env_reading.temperature_c
}

// Get humidity in 0.01%
export fn i2c_sensor_get_humidity(handle: u32): u32 {
    if handle >= i2c_sensor_count { return 0 }
    return i2c_sensors[handle].env_reading.humidity_percent
}

// Get pressure in Pa
export fn i2c_sensor_get_pressure(handle: u32): u32 {
    if handle >= i2c_sensor_count { return 0 }
    return i2c_sensors[handle].env_reading.pressure_pa
}

// Get light level in lux
export fn i2c_sensor_get_lux(handle: u32): u32 {
    if handle >= i2c_sensor_count { return 0 }
    return i2c_sensors[handle].light_reading.lux
}

// Get distance in mm (VL53L0X)
export fn i2c_sensor_get_distance(handle: u32): u16 {
    if handle >= i2c_sensor_count { return 0 }
    return i2c_sensors[handle].distance_reading.distance_mm
}

// Get IMU reading pointer
export fn i2c_sensor_get_imu_reading(handle: u32): u64 {
    if handle >= i2c_sensor_count { return 0 }
    return @ptrFromInt(i2c_sensors[handle].imu_reading)
}

// ============================================================================
// Polling
// ============================================================================

// Poll all sensors
export fn i2c_sensors_poll_all() {
    var now: u64 = foundation.timer_get_ticks()

    var i: u32 = 0
    while i < i2c_sensor_count {
        if i2c_sensors[i].active == 1 {
            if i2c_sensors[i].poll_interval_ms > 0 {
                if now - i2c_sensors[i].last_poll >= i2c_sensors[i].poll_interval_ms {
                    i2c_sensor_read(i)
                }
            }
        }
        i = i + 1
    }
}

// Generic read based on sensor type
export fn i2c_sensor_read(handle: u32): u32 {
    if handle >= i2c_sensor_count { return 0 }

    var sensor_type: u8 = i2c_sensors[handle].sensor_type

    if sensor_type == I2C_SENSOR_BME280 || sensor_type == I2C_SENSOR_BMP280 {
        return i2c_sensor_read_bme280(handle)
    } else if sensor_type == I2C_SENSOR_MPU6050 {
        return i2c_sensor_read_mpu6050(handle)
    } else if sensor_type == I2C_SENSOR_BH1750 {
        return i2c_sensor_read_bh1750(handle)
    } else if sensor_type == I2C_SENSOR_SHT31 {
        return i2c_sensor_read_sht31(handle)
    } else if sensor_type == I2C_SENSOR_VL53L0X {
        return i2c_sensor_read_vl53l0x(handle)
    }

    return 0
}

// ============================================================================
// Utility Functions
// ============================================================================

fn delay_ms(ms: u32) {
    var start: u64 = foundation.timer_get_ticks()
    var target: u64 = start + (ms * 1000)
    while foundation.timer_get_ticks() < target {
        // Busy wait
    }
}

// Get sensor count
export fn i2c_sensors_get_count(): u32 {
    return i2c_sensor_count
}

// Get sensor type
export fn i2c_sensor_get_type(handle: u32): u8 {
    if handle >= i2c_sensor_count { return 0xFF }
    return i2c_sensors[handle].sensor_type
}

// Unregister sensor
export fn i2c_sensor_unregister(handle: u32) {
    if handle >= i2c_sensor_count { return }
    if i2c_sensors[handle].active == 0 { return }

    i2c.i2c_unregister_device(i2c_sensors[handle].i2c_device)
    i2c_sensors[handle].active = 0
}

// Get statistics
export fn i2c_sensors_get_stats(): u64 {
    return @ptrFromInt(i2c_sensor_stats)
}

// ============================================================================
// Shutdown
// ============================================================================

export fn i2c_sensors_shutdown() {
    if i2c_sensors_initialized == 0 { return }

    var i: u32 = 0
    while i < i2c_sensor_count {
        if i2c_sensors[i].active == 1 {
            i2c_sensor_unregister(i)
        }
        i = i + 1
    }

    i2c_sensors_initialized = 0
    foundation.serial_write_string("[I2C-Sensors] Shutdown complete\n")
}
