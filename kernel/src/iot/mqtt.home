// home-os Kernel - MQTT Broker
// Lightweight message broker for IoT

import "../core/foundation.home" as foundation
import "../network/network.home" as network

const MQTT_PORT: u16 = 1883
const MAX_MQTT_CLIENTS: u32 = 100
const MAX_MQTT_TOPICS: u32 = 256

struct MQTTClient {
  socket: u32,
  client_id: [u8; 64],
  connected: u32,
  keepalive: u32,
  last_ping: u64
}

struct MQTTTopic {
  name: [u8; 128],
  subscribers: [u32; 32],
  subscriber_count: u32,
  qos: u8
}

var mqtt_clients: [MQTTClient; 100]
var mqtt_client_count: u32 = 0
var mqtt_topics: [MQTTTopic; 256]
var mqtt_topic_count: u32 = 0
var mqtt_server_socket: u32 = 0
var mqtt_running: u32 = 0

export fn mqtt_broker_init() {
  mqtt_client_count = 0
  mqtt_topic_count = 0
  mqtt_running = 0
  
  foundation.serial_write_string("[MQTT] Broker initialized\n")
}

export fn mqtt_broker_start() -> u32 {
  foundation.serial_write_string("[MQTT] Starting broker on port ")
  foundation.serial_write_hex(MQTT_PORT)
  foundation.serial_write_string("\n")
  
  mqtt_server_socket = network.socket_create(2, 1, 0)
  if mqtt_server_socket == 0xFFFFFFFF { return 0 }
  
  network.socket_bind(mqtt_server_socket, 0, MQTT_PORT)
  network.socket_listen(mqtt_server_socket, 100)
  
  mqtt_running = 1
  
  foundation.serial_write_string("[MQTT] Broker started\n")
  
  return 1
}

export fn mqtt_broker_accept() -> u32 {
  if mqtt_running == 0 { return 0xFFFFFFFF }
  if mqtt_client_count >= MAX_MQTT_CLIENTS { return 0xFFFFFFFF }
  
  var client_socket: u32 = network.socket_accept(mqtt_server_socket)
  if client_socket == 0xFFFFFFFF { return 0xFFFFFFFF }
  
  var client_id: u32 = mqtt_client_count
  
  mqtt_clients[client_id].socket = client_socket
  mqtt_clients[client_id].connected = 0
  mqtt_clients[client_id].keepalive = 60
  mqtt_clients[client_id].last_ping = foundation.timer_get_ticks()
  
  mqtt_client_count = mqtt_client_count + 1
  
  foundation.serial_write_string("[MQTT] Client connected\n")
  
  return client_id
}

export fn mqtt_handle_connect(client_id: u32, client_name: u64, keepalive: u32) -> u32 {
  if client_id >= mqtt_client_count { return 0 }
  
  // Copy client ID
  var i: u32 = 0
  while i < 63 {
    var ch: u8 = @intToPtr(client_name + i, u8)
    mqtt_clients[client_id].client_id[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  
  mqtt_clients[client_id].connected = 1
  mqtt_clients[client_id].keepalive = keepalive
  
  foundation.serial_write_string("[MQTT] Client ")
  foundation.serial_write_string(client_name)
  foundation.serial_write_string(" connected\n")
  
  // Send CONNACK
  mqtt_send_connack(client_id)
  
  return 1
}

fn mqtt_send_connack(client_id: u32) {
  var packet: [u8; 4]
  packet[0] = 0x20  // CONNACK
  packet[1] = 2     // Remaining length
  packet[2] = 0     // Session present
  packet[3] = 0     // Return code (success)
  
  network.socket_send(mqtt_clients[client_id].socket, @ptrFromInt(packet), 4)
}

export fn mqtt_subscribe(client_id: u32, topic: u64, qos: u8) -> u32 {
  if client_id >= mqtt_client_count { return 0 }
  
  // Find or create topic
  var topic_id: u32 = mqtt_find_topic(topic)
  
  if topic_id == 0xFFFFFFFF {
    topic_id = mqtt_create_topic(topic, qos)
  }
  
  if topic_id == 0xFFFFFFFF { return 0 }
  
  // Add subscriber
  if mqtt_topics[topic_id].subscriber_count < 32 {
    mqtt_topics[topic_id].subscribers[mqtt_topics[topic_id].subscriber_count] = client_id
    mqtt_topics[topic_id].subscriber_count = mqtt_topics[topic_id].subscriber_count + 1
  }
  
  foundation.serial_write_string("[MQTT] Client subscribed to ")
  foundation.serial_write_string(topic)
  foundation.serial_write_string("\n")
  
  return 1
}

fn mqtt_find_topic(topic: u64) -> u32 {
  var i: u32 = 0
  while i < mqtt_topic_count {
    if mqtt_strcmp(@ptrFromInt(mqtt_topics[i].name), topic) == 1 {
      return i
    }
    i = i + 1
  }
  return 0xFFFFFFFF
}

fn mqtt_create_topic(topic: u64, qos: u8) -> u32 {
  if mqtt_topic_count >= MAX_MQTT_TOPICS { return 0xFFFFFFFF }
  
  var topic_id: u32 = mqtt_topic_count
  
  // Copy topic name
  var i: u32 = 0
  while i < 127 {
    var ch: u8 = @intToPtr(topic + i, u8)
    mqtt_topics[topic_id].name[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  
  mqtt_topics[topic_id].subscriber_count = 0
  mqtt_topics[topic_id].qos = qos
  
  mqtt_topic_count = mqtt_topic_count + 1
  
  return topic_id
}

export fn mqtt_publish(client_id: u32, topic: u64, message: u64, message_len: u32) -> u32 {
  if client_id >= mqtt_client_count { return 0 }
  
  var topic_id: u32 = mqtt_find_topic(topic)
  if topic_id == 0xFFFFFFFF { return 0 }
  
  foundation.serial_write_string("[MQTT] Publishing to ")
  foundation.serial_write_string(topic)
  foundation.serial_write_string("\n")
  
  // Send to all subscribers
  var i: u32 = 0
  while i < mqtt_topics[topic_id].subscriber_count {
    var subscriber_id: u32 = mqtt_topics[topic_id].subscribers[i]
    mqtt_send_publish(subscriber_id, topic, message, message_len)
    i = i + 1
  }
  
  return 1
}

fn mqtt_send_publish(client_id: u32, topic: u64, message: u64, message_len: u32) {
  // Build PUBLISH packet
  var packet: [u8; 1024]
  packet[0] = 0x30  // PUBLISH
  
  // Send packet
  network.socket_send(mqtt_clients[client_id].socket, @ptrFromInt(packet), message_len + 10)
}

fn mqtt_strcmp(s1: u64, s2: u64) -> u32 {
  var i: u32 = 0
  while 1 == 1 {
    var c1: u8 = @intToPtr(s1 + i, u8)
    var c2: u8 = @intToPtr(s2 + i, u8)
    
    if c1 != c2 { return 0 }
    if c1 == 0 { return 1 }
    
    i = i + 1
  }
  return 0
}

export fn mqtt_broker_stop() {
  mqtt_running = 0
  network.socket_close(mqtt_server_socket)
  
  foundation.serial_write_string("[MQTT] Broker stopped\n")
}
