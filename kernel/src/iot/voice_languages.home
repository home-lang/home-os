// Multi-Language Support for Voice Assistant
// Localized voice commands and responses
// Part of HomeOS Voice Assistant subsystem

const basics = @import("basics");
const memory = @import("memory");

// ============================================================================
// Language Constants
// ============================================================================

const MAX_LANGUAGES: u32 = 20;
const MAX_PHRASES_PER_INTENT: u32 = 10;
const MAX_PHRASE_LEN: u32 = 256;
const MAX_ENTITY_SYNONYMS: u32 = 20;

// ============================================================================
// Language Types
// ============================================================================

pub const Language = enum {
    English,
    Spanish,
    French,
    German,
    Italian,
    Portuguese,
    Dutch,
    Polish,
    Russian,
    Chinese,
    Japanese,
    Korean,
    Arabic,
    Hindi,
    Vietnamese,
    Thai,
    Indonesian,
    Turkish,
    Swedish,
    Norwegian,

    pub fn get_code(self: Language) []const u8 {
        return switch (self) {
            .English => "en",
            .Spanish => "es",
            .French => "fr",
            .German => "de",
            .Italian => "it",
            .Portuguese => "pt",
            .Dutch => "nl",
            .Polish => "pl",
            .Russian => "ru",
            .Chinese => "zh",
            .Japanese => "ja",
            .Korean => "ko",
            .Arabic => "ar",
            .Hindi => "hi",
            .Vietnamese => "vi",
            .Thai => "th",
            .Indonesian => "id",
            .Turkish => "tr",
            .Swedish => "sv",
            .Norwegian => "no",
        };
    }

    pub fn get_name(self: Language) []const u8 {
        return switch (self) {
            .English => "English",
            .Spanish => "Español",
            .French => "Français",
            .German => "Deutsch",
            .Italian => "Italiano",
            .Portuguese => "Português",
            .Dutch => "Nederlands",
            .Polish => "Polski",
            .Russian => "Русский",
            .Chinese => "中文",
            .Japanese => "日本語",
            .Korean => "한국어",
            .Arabic => "العربية",
            .Hindi => "हिन्दी",
            .Vietnamese => "Tiếng Việt",
            .Thai => "ไทย",
            .Indonesian => "Bahasa Indonesia",
            .Turkish => "Türkçe",
            .Swedish => "Svenska",
            .Norwegian => "Norsk",
        };
    }

    pub fn is_rtl(self: Language) bool {
        return switch (self) {
            .Arabic => true,
            else => false,
        };
    }
};

// ============================================================================
// Localized Phrase
// ============================================================================

pub const LocalizedPhrase = struct {
    text: [MAX_PHRASE_LEN]u8,
    text_len: u32,

    pub fn get(self: *const LocalizedPhrase) []const u8 {
        return self.text[0..self.text_len];
    }

    pub fn set(self: *LocalizedPhrase, txt: []const u8) void {
        const len = if (txt.len > MAX_PHRASE_LEN) MAX_PHRASE_LEN else txt.len;
        for (i in 0..len) {
            self.text[i] = txt[i];
        }
        self.text_len = @intCast(u32, len);
    }
};

// ============================================================================
// Intent Phrases (patterns for recognition)
// ============================================================================

pub const IntentPhrases = struct {
    intent_name: [64]u8,
    intent_name_len: u32,

    phrases: [MAX_PHRASES_PER_INTENT]LocalizedPhrase,
    num_phrases: u32,

    pub fn get_intent_name(self: *const IntentPhrases) []const u8 {
        return self.intent_name[0..self.intent_name_len];
    }
};

// ============================================================================
// Entity Synonyms (device names, room names in different languages)
// ============================================================================

pub const EntitySynonym = struct {
    canonical: [64]u8,        // Standard English name
    canonical_len: u32,
    localized: [64]u8,        // Localized name
    localized_len: u32,

    pub fn get_canonical(self: *const EntitySynonym) []const u8 {
        return self.canonical[0..self.canonical_len];
    }

    pub fn get_localized(self: *const EntitySynonym) []const u8 {
        return self.localized[0..self.localized_len];
    }
};

pub const EntitySynonyms = struct {
    entity_type: [32]u8,
    entity_type_len: u32,

    synonyms: [MAX_ENTITY_SYNONYMS]EntitySynonym,
    num_synonyms: u32,
};

// ============================================================================
// Response Templates
// ============================================================================

pub const ResponseKey = enum {
    // Confirmations
    Ok,
    Done,
    Confirmed,
    Cancelled,

    // Device responses
    LightTurnedOn,
    LightTurnedOff,
    LightDimmed,
    LightColorSet,
    ThermostatSet,
    LockLocked,
    LockUnlocked,
    DoorOpened,
    DoorClosed,

    // Queries
    CurrentTemperature,
    CurrentHumidity,
    DeviceStatus,
    SecurityStatus,

    // Errors
    DeviceNotFound,
    RoomNotFound,
    CommandNotUnderstood,
    ActionFailed,
    NotAuthorized,

    // Prompts
    WhichRoom,
    WhichDevice,
    WhatTemperature,
    WhatBrightness,
    Confirm,

    // Greetings
    Hello,
    Goodbye,
    HowCanIHelp,
    YoureWelcome,

    // Time
    CurrentTime,
    CurrentDate,

    // Weather
    CurrentWeather,
    ForecastToday,
};

pub const ResponseTemplate = struct {
    key: ResponseKey,
    template: [MAX_PHRASE_LEN]u8,
    template_len: u32,

    // Template may contain placeholders: {device}, {room}, {value}, {time}, etc.
    pub fn get_template(self: *const ResponseTemplate) []const u8 {
        return self.template[0..self.template_len];
    }
};

// ============================================================================
// Language Pack
// ============================================================================

pub const LanguagePack = struct {
    language: Language,

    // Intent recognition phrases
    intent_phrases: [32]IntentPhrases,
    num_intents: u32,

    // Entity synonyms
    room_synonyms: EntitySynonyms,
    device_synonyms: EntitySynonyms,
    state_synonyms: EntitySynonyms,

    // Response templates
    responses: [64]ResponseTemplate,
    num_responses: u32,

    // Wake words
    wake_words: [5]LocalizedPhrase,
    num_wake_words: u32,

    // Number words (for parsing "twenty-one", "vingt-et-un", etc.)
    number_words: [100]LocalizedPhrase,

    // Common filler words to ignore
    filler_words: [20]LocalizedPhrase,
    num_fillers: u32,
};

// ============================================================================
// Language Manager
// ============================================================================

pub const LanguageManager = struct {
    languages: [MAX_LANGUAGES]*LanguagePack,
    num_languages: u32,

    current_language: Language,
    fallback_language: Language,

    // Phrase cache for fast lookup
    phrase_hash_table: [1024]?*const LocalizedPhrase,
};

pub fn language_manager_init() *LanguageManager {
    const manager = memory.allocate(LanguageManager) orelse return null;

    manager.num_languages = 0;
    manager.current_language = .English;
    manager.fallback_language = .English;

    // Clear hash table
    for (i in 0..1024) {
        manager.phrase_hash_table[i] = null;
    }

    // Load built-in English
    const english = create_english_pack();
    if (english) |en| {
        manager.languages[0] = en;
        manager.num_languages = 1;
    }

    return manager;
}

pub fn set_language(manager: *LanguageManager, lang: Language) bool {
    // Check if language is available
    for (i in 0..manager.num_languages) {
        if (manager.languages[i].language == lang) {
            manager.current_language = lang;
            return true;
        }
    }
    return false;
}

pub fn add_language_pack(manager: *LanguageManager, pack: *LanguagePack) bool {
    if (manager.num_languages >= MAX_LANGUAGES) return false;

    // Check if already exists
    for (i in 0..manager.num_languages) {
        if (manager.languages[i].language == pack.language) {
            // Replace existing
            manager.languages[i] = pack;
            return true;
        }
    }

    manager.languages[manager.num_languages] = pack;
    manager.num_languages += 1;
    return true;
}

pub fn get_current_pack(manager: *const LanguageManager) ?*const LanguagePack {
    for (i in 0..manager.num_languages) {
        if (manager.languages[i].language == manager.current_language) {
            return manager.languages[i];
        }
    }

    // Fall back
    for (i in 0..manager.num_languages) {
        if (manager.languages[i].language == manager.fallback_language) {
            return manager.languages[i];
        }
    }

    return null;
}

// ============================================================================
// Response Generation
// ============================================================================

pub fn get_response(manager: *const LanguageManager, key: ResponseKey) []const u8 {
    const pack = get_current_pack(manager) orelse return "Error";

    for (i in 0..pack.num_responses) {
        if (pack.responses[i].key == key) {
            return pack.responses[i].get_template();
        }
    }

    // Try fallback language
    if (manager.current_language != manager.fallback_language) {
        for (i in 0..manager.num_languages) {
            if (manager.languages[i].language == manager.fallback_language) {
                for (j in 0..manager.languages[i].num_responses) {
                    if (manager.languages[i].responses[j].key == key) {
                        return manager.languages[i].responses[j].get_template();
                    }
                }
            }
        }
    }

    return "Error";
}

pub fn format_response(
    manager: *const LanguageManager,
    key: ResponseKey,
    params: *const ResponseParams,
    output: *[512]u8
) u32 {
    const template = get_response(manager, key);
    return format_template(template, params, output);
}

pub const ResponseParams = struct {
    device: ?[]const u8,
    room: ?[]const u8,
    value: ?[]const u8,
    time: ?[]const u8,
    temperature: ?i32,
    humidity: ?u32,
    brightness: ?u32,
    person: ?[]const u8,
};

fn format_template(template: []const u8, params: *const ResponseParams, output: *[512]u8) u32 {
    var out_idx: u32 = 0;
    var i: u32 = 0;

    while (i < template.len and out_idx < 511) {
        if (template[i] == '{') {
            // Find closing brace
            var end = i + 1;
            while (end < template.len and template[end] != '}') {
                end += 1;
            }

            if (end < template.len) {
                const placeholder = template[i + 1 .. end];

                // Substitute placeholder
                const value = get_param_value(params, placeholder);
                if (value) |v| {
                    for (c in v) {
                        if (out_idx < 511) {
                            output[out_idx] = c;
                            out_idx += 1;
                        }
                    }
                }

                i = end + 1;
                continue;
            }
        }

        output[out_idx] = template[i];
        out_idx += 1;
        i += 1;
    }

    return out_idx;
}

fn get_param_value(params: *const ResponseParams, placeholder: []const u8) ?[]const u8 {
    if (strings_equal(placeholder, "device")) return params.device;
    if (strings_equal(placeholder, "room")) return params.room;
    if (strings_equal(placeholder, "value")) return params.value;
    if (strings_equal(placeholder, "time")) return params.time;
    if (strings_equal(placeholder, "person")) return params.person;

    // Numeric values need formatting
    // In a full implementation, we'd format numbers here

    return null;
}

// ============================================================================
// Entity Normalization
// ============================================================================

pub fn normalize_entity(manager: *const LanguageManager, entity_type: []const u8, localized_value: []const u8) ?[]const u8 {
    const pack = get_current_pack(manager) orelse return null;

    // Select the right synonym list
    var synonyms: ?*const EntitySynonyms = null;
    if (strings_equal(entity_type, "room")) {
        synonyms = &pack.room_synonyms;
    } else if (strings_equal(entity_type, "device")) {
        synonyms = &pack.device_synonyms;
    } else if (strings_equal(entity_type, "state")) {
        synonyms = &pack.state_synonyms;
    }

    if (synonyms) |syns| {
        const lower = to_lowercase_temp(localized_value);

        for (i in 0..syns.num_synonyms) {
            const syn_lower = to_lowercase_temp(syns.synonyms[i].get_localized());
            if (strings_equal(lower, syn_lower)) {
                return syns.synonyms[i].get_canonical();
            }
        }
    }

    // No match, return original
    return localized_value;
}

pub fn localize_entity(manager: *const LanguageManager, entity_type: []const u8, canonical_value: []const u8) ?[]const u8 {
    const pack = get_current_pack(manager) orelse return canonical_value;

    var synonyms: ?*const EntitySynonyms = null;
    if (strings_equal(entity_type, "room")) {
        synonyms = &pack.room_synonyms;
    } else if (strings_equal(entity_type, "device")) {
        synonyms = &pack.device_synonyms;
    } else if (strings_equal(entity_type, "state")) {
        synonyms = &pack.state_synonyms;
    }

    if (synonyms) |syns| {
        for (i in 0..syns.num_synonyms) {
            if (strings_equal(syns.synonyms[i].get_canonical(), canonical_value)) {
                return syns.synonyms[i].get_localized();
            }
        }
    }

    return canonical_value;
}

// ============================================================================
// Wake Word Detection (Localized)
// ============================================================================

pub fn get_wake_words(manager: *const LanguageManager) []const LocalizedPhrase {
    const pack = get_current_pack(manager) orelse return &[_]LocalizedPhrase{};
    return pack.wake_words[0..pack.num_wake_words];
}

pub fn is_wake_word(manager: *const LanguageManager, text: []const u8) bool {
    const pack = get_current_pack(manager) orelse return false;

    const lower = to_lowercase_temp(text);

    for (i in 0..pack.num_wake_words) {
        const wake_lower = to_lowercase_temp(pack.wake_words[i].get());
        if (strings_equal(lower, wake_lower)) {
            return true;
        }
    }

    return false;
}

// ============================================================================
// Number Parsing (Localized)
// ============================================================================

pub fn parse_number_word(manager: *const LanguageManager, text: []const u8) ?i32 {
    const pack = get_current_pack(manager) orelse return null;

    const lower = to_lowercase_temp(text);

    // Check number words
    for (i in 0..100) {
        if (pack.number_words[i].text_len > 0) {
            const num_lower = to_lowercase_temp(pack.number_words[i].get());
            if (strings_equal(lower, num_lower)) {
                return @intCast(i32, i);
            }
        }
    }

    // Try parsing as digit string
    return parse_number_string(text);
}

fn parse_number_string(text: []const u8) ?i32 {
    var result: i32 = 0;
    var negative = false;
    var i: u32 = 0;

    if (text.len == 0) return null;

    if (text[0] == '-') {
        negative = true;
        i = 1;
    }

    while (i < text.len) {
        const c = text[i];
        if (c >= '0' and c <= '9') {
            result = result * 10 + @intCast(i32, c - '0');
        } else {
            return null; // Invalid character
        }
        i += 1;
    }

    return if (negative) -result else result;
}

// ============================================================================
// Filler Word Removal
// ============================================================================

pub fn remove_filler_words(manager: *const LanguageManager, text: []const u8, output: *[512]u8) u32 {
    const pack = get_current_pack(manager) orelse {
        // No pack, copy as-is
        for (i in 0..text.len) {
            output[i] = text[i];
        }
        return @intCast(u32, text.len);
    };

    var out_idx: u32 = 0;
    var word_start: u32 = 0;
    var i: u32 = 0;

    while (i <= text.len) {
        const is_end = i == text.len;
        const is_space = !is_end and text[i] == ' ';

        if (is_end or is_space) {
            if (i > word_start) {
                const word = text[word_start..i];

                // Check if it's a filler word
                var is_filler = false;
                const word_lower = to_lowercase_temp(word);

                for (f in 0..pack.num_fillers) {
                    const filler_lower = to_lowercase_temp(pack.filler_words[f].get());
                    if (strings_equal(word_lower, filler_lower)) {
                        is_filler = true;
                        break;
                    }
                }

                // Copy non-filler words
                if (!is_filler) {
                    if (out_idx > 0) {
                        output[out_idx] = ' ';
                        out_idx += 1;
                    }
                    for (c in word) {
                        output[out_idx] = c;
                        out_idx += 1;
                    }
                }
            }
            word_start = i + 1;
        }
        i += 1;
    }

    return out_idx;
}

// ============================================================================
// Built-in English Language Pack
// ============================================================================

fn create_english_pack() ?*LanguagePack {
    const pack = memory.allocate(LanguagePack) orelse return null;

    pack.language = .English;

    // Wake words
    pack.wake_words[0].set("hey home");
    pack.wake_words[1].set("ok home");
    pack.wake_words[2].set("home");
    pack.num_wake_words = 3;

    // Filler words
    pack.filler_words[0].set("please");
    pack.filler_words[1].set("the");
    pack.filler_words[2].set("a");
    pack.filler_words[3].set("an");
    pack.filler_words[4].set("can");
    pack.filler_words[5].set("you");
    pack.filler_words[6].set("would");
    pack.filler_words[7].set("could");
    pack.filler_words[8].set("just");
    pack.num_fillers = 9;

    // Number words
    const number_names = [_][]const u8{
        "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine",
        "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen",
        "twenty", "twenty-one", "twenty-two", "twenty-three", "twenty-four", "twenty-five",
    };
    for (i in 0..number_names.len) {
        pack.number_words[i].set(number_names[i]);
    }

    // Room synonyms
    pack.room_synonyms.entity_type_len = 4;
    pack.room_synonyms.entity_type[0..4] = "room".*;

    add_synonym(&pack.room_synonyms, "living_room", "living room");
    add_synonym(&pack.room_synonyms, "living_room", "lounge");
    add_synonym(&pack.room_synonyms, "bedroom", "bedroom");
    add_synonym(&pack.room_synonyms, "bedroom", "master bedroom");
    add_synonym(&pack.room_synonyms, "kitchen", "kitchen");
    add_synonym(&pack.room_synonyms, "bathroom", "bathroom");
    add_synonym(&pack.room_synonyms, "bathroom", "washroom");
    add_synonym(&pack.room_synonyms, "office", "office");
    add_synonym(&pack.room_synonyms, "office", "study");
    add_synonym(&pack.room_synonyms, "garage", "garage");
    add_synonym(&pack.room_synonyms, "basement", "basement");
    add_synonym(&pack.room_synonyms, "attic", "attic");

    // Device synonyms
    pack.device_synonyms.entity_type_len = 6;
    pack.device_synonyms.entity_type[0..6] = "device".*;

    add_synonym(&pack.device_synonyms, "light", "light");
    add_synonym(&pack.device_synonyms, "light", "lights");
    add_synonym(&pack.device_synonyms, "light", "lamp");
    add_synonym(&pack.device_synonyms, "thermostat", "thermostat");
    add_synonym(&pack.device_synonyms, "thermostat", "temperature");
    add_synonym(&pack.device_synonyms, "thermostat", "heating");
    add_synonym(&pack.device_synonyms, "thermostat", "cooling");
    add_synonym(&pack.device_synonyms, "thermostat", "AC");
    add_synonym(&pack.device_synonyms, "lock", "lock");
    add_synonym(&pack.device_synonyms, "lock", "door lock");
    add_synonym(&pack.device_synonyms, "fan", "fan");
    add_synonym(&pack.device_synonyms, "tv", "TV");
    add_synonym(&pack.device_synonyms, "tv", "television");

    // State synonyms
    pack.state_synonyms.entity_type_len = 5;
    pack.state_synonyms.entity_type[0..5] = "state".*;

    add_synonym(&pack.state_synonyms, "on", "on");
    add_synonym(&pack.state_synonyms, "off", "off");
    add_synonym(&pack.state_synonyms, "dim", "dim");
    add_synonym(&pack.state_synonyms, "dim", "dimmed");
    add_synonym(&pack.state_synonyms, "bright", "bright");
    add_synonym(&pack.state_synonyms, "bright", "full");
    add_synonym(&pack.state_synonyms, "locked", "locked");
    add_synonym(&pack.state_synonyms, "unlocked", "unlocked");
    add_synonym(&pack.state_synonyms, "open", "open");
    add_synonym(&pack.state_synonyms, "closed", "closed");

    // Response templates
    var r: u32 = 0;

    pack.responses[r].key = .Ok;
    pack.responses[r].template[0..2] = "OK".*;
    pack.responses[r].template_len = 2;
    r += 1;

    pack.responses[r].key = .Done;
    pack.responses[r].template[0..4] = "Done".*;
    pack.responses[r].template_len = 4;
    r += 1;

    pack.responses[r].key = .LightTurnedOn;
    set_template(&pack.responses[r], "Turned on the {device} in the {room}");
    r += 1;

    pack.responses[r].key = .LightTurnedOff;
    set_template(&pack.responses[r], "Turned off the {device} in the {room}");
    r += 1;

    pack.responses[r].key = .LightDimmed;
    set_template(&pack.responses[r], "Set the {device} to {value} percent");
    r += 1;

    pack.responses[r].key = .ThermostatSet;
    set_template(&pack.responses[r], "Set temperature to {value} degrees");
    r += 1;

    pack.responses[r].key = .LockLocked;
    set_template(&pack.responses[r], "The {device} is now locked");
    r += 1;

    pack.responses[r].key = .LockUnlocked;
    set_template(&pack.responses[r], "The {device} is now unlocked");
    r += 1;

    pack.responses[r].key = .DeviceNotFound;
    set_template(&pack.responses[r], "I couldn't find that device");
    r += 1;

    pack.responses[r].key = .RoomNotFound;
    set_template(&pack.responses[r], "I don't know that room");
    r += 1;

    pack.responses[r].key = .CommandNotUnderstood;
    set_template(&pack.responses[r], "Sorry, I didn't understand that");
    r += 1;

    pack.responses[r].key = .WhichRoom;
    set_template(&pack.responses[r], "Which room?");
    r += 1;

    pack.responses[r].key = .WhichDevice;
    set_template(&pack.responses[r], "Which device?");
    r += 1;

    pack.responses[r].key = .Hello;
    set_template(&pack.responses[r], "Hello! How can I help?");
    r += 1;

    pack.responses[r].key = .Goodbye;
    set_template(&pack.responses[r], "Goodbye!");
    r += 1;

    pack.responses[r].key = .HowCanIHelp;
    set_template(&pack.responses[r], "How can I help you?");
    r += 1;

    pack.responses[r].key = .CurrentTime;
    set_template(&pack.responses[r], "The time is {time}");
    r += 1;

    pack.responses[r].key = .CurrentTemperature;
    set_template(&pack.responses[r], "The temperature in the {room} is {value} degrees");
    r += 1;

    pack.num_responses = r;

    // Intent phrases
    pack.num_intents = 0;
    add_intent_phrases(pack, "turn_on", &[_][]const u8{
        "turn on", "switch on", "enable", "activate", "start",
    });
    add_intent_phrases(pack, "turn_off", &[_][]const u8{
        "turn off", "switch off", "disable", "deactivate", "stop",
    });
    add_intent_phrases(pack, "dim", &[_][]const u8{
        "dim", "set brightness", "make darker", "lower",
    });
    add_intent_phrases(pack, "set_temperature", &[_][]const u8{
        "set temperature", "set thermostat", "make it", "set to",
    });
    add_intent_phrases(pack, "lock", &[_][]const u8{
        "lock", "secure",
    });
    add_intent_phrases(pack, "unlock", &[_][]const u8{
        "unlock", "open",
    });
    add_intent_phrases(pack, "query_temperature", &[_][]const u8{
        "what's the temperature", "how warm", "how cold", "what temperature",
    });
    add_intent_phrases(pack, "query_time", &[_][]const u8{
        "what time", "what's the time", "tell me the time",
    });

    return pack;
}

fn add_synonym(synonyms: *EntitySynonyms, canonical: []const u8, localized: []const u8) void {
    if (synonyms.num_synonyms >= MAX_ENTITY_SYNONYMS) return;

    const idx = synonyms.num_synonyms;

    const can_len = if (canonical.len > 64) 64 else canonical.len;
    for (i in 0..can_len) {
        synonyms.synonyms[idx].canonical[i] = canonical[i];
    }
    synonyms.synonyms[idx].canonical_len = @intCast(u32, can_len);

    const loc_len = if (localized.len > 64) 64 else localized.len;
    for (i in 0..loc_len) {
        synonyms.synonyms[idx].localized[i] = localized[i];
    }
    synonyms.synonyms[idx].localized_len = @intCast(u32, loc_len);

    synonyms.num_synonyms += 1;
}

fn set_template(response: *ResponseTemplate, text: []const u8) void {
    const len = if (text.len > MAX_PHRASE_LEN) MAX_PHRASE_LEN else text.len;
    for (i in 0..len) {
        response.template[i] = text[i];
    }
    response.template_len = @intCast(u32, len);
}

fn add_intent_phrases(pack: *LanguagePack, intent_name: []const u8, phrases: []const []const u8) void {
    if (pack.num_intents >= 32) return;

    const idx = pack.num_intents;

    const name_len = if (intent_name.len > 64) 64 else intent_name.len;
    for (i in 0..name_len) {
        pack.intent_phrases[idx].intent_name[i] = intent_name[i];
    }
    pack.intent_phrases[idx].intent_name_len = @intCast(u32, name_len);

    pack.intent_phrases[idx].num_phrases = 0;
    for (phrase in phrases) {
        if (pack.intent_phrases[idx].num_phrases >= MAX_PHRASES_PER_INTENT) break;

        const pidx = pack.intent_phrases[idx].num_phrases;
        pack.intent_phrases[idx].phrases[pidx].set(phrase);
        pack.intent_phrases[idx].num_phrases += 1;
    }

    pack.num_intents += 1;
}

// ============================================================================
// Spanish Language Pack (Example additional language)
// ============================================================================

pub fn create_spanish_pack() ?*LanguagePack {
    const pack = memory.allocate(LanguagePack) orelse return null;

    pack.language = .Spanish;

    // Wake words
    pack.wake_words[0].set("oye casa");
    pack.wake_words[1].set("hola casa");
    pack.wake_words[2].set("casa");
    pack.num_wake_words = 3;

    // Filler words
    pack.filler_words[0].set("por favor");
    pack.filler_words[1].set("el");
    pack.filler_words[2].set("la");
    pack.filler_words[3].set("los");
    pack.filler_words[4].set("las");
    pack.filler_words[5].set("un");
    pack.filler_words[6].set("una");
    pack.filler_words[7].set("puedes");
    pack.filler_words[8].set("podrías");
    pack.num_fillers = 9;

    // Number words (Spanish)
    const spanish_numbers = [_][]const u8{
        "cero", "uno", "dos", "tres", "cuatro", "cinco", "seis", "siete", "ocho", "nueve",
        "diez", "once", "doce", "trece", "catorce", "quince", "dieciséis", "diecisiete", "dieciocho", "diecinueve",
        "veinte", "veintiuno", "veintidós", "veintitrés", "veinticuatro", "veinticinco",
    };
    for (i in 0..spanish_numbers.len) {
        pack.number_words[i].set(spanish_numbers[i]);
    }

    // Room synonyms (Spanish)
    pack.room_synonyms.entity_type_len = 4;
    pack.room_synonyms.entity_type[0..4] = "room".*;

    add_synonym(&pack.room_synonyms, "living_room", "sala");
    add_synonym(&pack.room_synonyms, "living_room", "salón");
    add_synonym(&pack.room_synonyms, "bedroom", "dormitorio");
    add_synonym(&pack.room_synonyms, "bedroom", "habitación");
    add_synonym(&pack.room_synonyms, "bedroom", "cuarto");
    add_synonym(&pack.room_synonyms, "kitchen", "cocina");
    add_synonym(&pack.room_synonyms, "bathroom", "baño");
    add_synonym(&pack.room_synonyms, "office", "oficina");
    add_synonym(&pack.room_synonyms, "office", "estudio");
    add_synonym(&pack.room_synonyms, "garage", "garaje");

    // Device synonyms (Spanish)
    pack.device_synonyms.entity_type_len = 6;
    pack.device_synonyms.entity_type[0..6] = "device".*;

    add_synonym(&pack.device_synonyms, "light", "luz");
    add_synonym(&pack.device_synonyms, "light", "luces");
    add_synonym(&pack.device_synonyms, "light", "lámpara");
    add_synonym(&pack.device_synonyms, "thermostat", "termostato");
    add_synonym(&pack.device_synonyms, "thermostat", "temperatura");
    add_synonym(&pack.device_synonyms, "thermostat", "calefacción");
    add_synonym(&pack.device_synonyms, "thermostat", "aire acondicionado");
    add_synonym(&pack.device_synonyms, "lock", "cerradura");
    add_synonym(&pack.device_synonyms, "fan", "ventilador");
    add_synonym(&pack.device_synonyms, "tv", "televisor");
    add_synonym(&pack.device_synonyms, "tv", "televisión");
    add_synonym(&pack.device_synonyms, "tv", "tele");

    // State synonyms (Spanish)
    pack.state_synonyms.entity_type_len = 5;
    pack.state_synonyms.entity_type[0..5] = "state".*;

    add_synonym(&pack.state_synonyms, "on", "encendido");
    add_synonym(&pack.state_synonyms, "on", "prendido");
    add_synonym(&pack.state_synonyms, "off", "apagado");
    add_synonym(&pack.state_synonyms, "dim", "atenuado");
    add_synonym(&pack.state_synonyms, "bright", "brillante");
    add_synonym(&pack.state_synonyms, "locked", "cerrado");
    add_synonym(&pack.state_synonyms, "unlocked", "abierto");

    // Response templates (Spanish)
    var r: u32 = 0;

    pack.responses[r].key = .Ok;
    set_template(&pack.responses[r], "De acuerdo");
    r += 1;

    pack.responses[r].key = .Done;
    set_template(&pack.responses[r], "Listo");
    r += 1;

    pack.responses[r].key = .LightTurnedOn;
    set_template(&pack.responses[r], "Encendí la {device} en {room}");
    r += 1;

    pack.responses[r].key = .LightTurnedOff;
    set_template(&pack.responses[r], "Apagué la {device} en {room}");
    r += 1;

    pack.responses[r].key = .ThermostatSet;
    set_template(&pack.responses[r], "Temperatura ajustada a {value} grados");
    r += 1;

    pack.responses[r].key = .DeviceNotFound;
    set_template(&pack.responses[r], "No encontré ese dispositivo");
    r += 1;

    pack.responses[r].key = .CommandNotUnderstood;
    set_template(&pack.responses[r], "Lo siento, no entendí");
    r += 1;

    pack.responses[r].key = .WhichRoom;
    set_template(&pack.responses[r], "¿En qué habitación?");
    r += 1;

    pack.responses[r].key = .Hello;
    set_template(&pack.responses[r], "¡Hola! ¿En qué puedo ayudarte?");
    r += 1;

    pack.responses[r].key = .Goodbye;
    set_template(&pack.responses[r], "¡Adiós!");
    r += 1;

    pack.responses[r].key = .CurrentTime;
    set_template(&pack.responses[r], "Son las {time}");
    r += 1;

    pack.responses[r].key = .CurrentTemperature;
    set_template(&pack.responses[r], "La temperatura en {room} es {value} grados");
    r += 1;

    pack.num_responses = r;

    // Intent phrases (Spanish)
    pack.num_intents = 0;
    add_intent_phrases(pack, "turn_on", &[_][]const u8{
        "enciende", "prende", "activa", "encender",
    });
    add_intent_phrases(pack, "turn_off", &[_][]const u8{
        "apaga", "desactiva", "apagar",
    });
    add_intent_phrases(pack, "dim", &[_][]const u8{
        "atenúa", "baja", "oscurece",
    });
    add_intent_phrases(pack, "set_temperature", &[_][]const u8{
        "pon la temperatura", "ajusta", "configura",
    });
    add_intent_phrases(pack, "lock", &[_][]const u8{
        "cierra", "bloquea",
    });
    add_intent_phrases(pack, "unlock", &[_][]const u8{
        "abre", "desbloquea",
    });
    add_intent_phrases(pack, "query_temperature", &[_][]const u8{
        "qué temperatura", "cuántos grados", "hace frío", "hace calor",
    });
    add_intent_phrases(pack, "query_time", &[_][]const u8{
        "qué hora es", "dime la hora",
    });

    return pack;
}

// ============================================================================
// Utility Functions
// ============================================================================

fn strings_equal(a: []const u8, b: []const u8) bool {
    if (a.len != b.len) return false;
    for (i in 0..a.len) {
        if (a[i] != b[i]) return false;
    }
    return true;
}

var temp_lower_buf: [512]u8 = undefined;

fn to_lowercase_temp(text: []const u8) []const u8 {
    const len = if (text.len > 512) 512 else text.len;

    for (i in 0..len) {
        const c = text[i];
        if (c >= 'A' and c <= 'Z') {
            temp_lower_buf[i] = c + 32;
        } else {
            temp_lower_buf[i] = c;
        }
    }

    return temp_lower_buf[0..len];
}

// ============================================================================
// Module Initialization
// ============================================================================

pub fn init() bool {
    return true;
}
