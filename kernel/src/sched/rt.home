// home-os Real-Time Scheduler
// RT scheduling class

import "../core/foundation.home" as foundation

const RT_PRIO_MAX: u32 = 100

struct RtRunQueue {
  active: [u32; 100],
  nr_running: u32,
  highest_prio: u32
}

var rt_rq: RtRunQueue
var rt_initialized: u32 = 0

export fn rt_init() {
  rt_rq.nr_running = 0
  rt_rq.highest_prio = RT_PRIO_MAX
  rt_initialized = 1
  foundation.serial_write_string("[RT] Real-time scheduler initialized\n")
}

export fn rt_enqueue(task_id: u32, priority: u32) {
  if priority >= RT_PRIO_MAX { return }
  
  rt_rq.active[priority] = task_id
  rt_rq.nr_running = rt_rq.nr_running + 1
  
  if priority < rt_rq.highest_prio {
    rt_rq.highest_prio = priority
  }
}

export fn rt_dequeue(task_id: u32, priority: u32) {
  if priority >= RT_PRIO_MAX { return }
  
  rt_rq.active[priority] = 0
  if rt_rq.nr_running > 0 {
    rt_rq.nr_running = rt_rq.nr_running - 1
  }
  
  // Find new highest priority
  if priority == rt_rq.highest_prio {
    var i: u32 = 0
    while i < RT_PRIO_MAX {
      if rt_rq.active[i] != 0 {
        rt_rq.highest_prio = i
        break
      }
      i = i + 1
    }
  }
}

export fn rt_pick_next() -> u32 {
  if rt_rq.nr_running == 0 { return 0xFFFFFFFF }
  return rt_rq.active[rt_rq.highest_prio]
}

export fn rt_get_load() -> u32 {
  return rt_rq.nr_running
}
