// Pantry Library Integration for home-os
// Seamless integration with ~/Code/pantry
// All integration logic lives in this library

// ============================================================================
// PANTRY LIBRARY - COMPLETE IMPLEMENTATION
// ============================================================================

const MAX_PACKAGES: u32 = 1000
const MAX_REGISTRIES: u32 = 10
const MAX_ENVIRONMENTS: u32 = 32
const MAX_SERVICES: u32 = 50

// Package structure
export struct Package {
  name: [u8; 256],
  version: [u8; 64],
  registry_id: u32,
  installed: u32,
  size: u64,
  dep_count: u32,
  dependencies: [u32; 32],
  install_path: [u8; 512]
}

// Registry structure
export struct Registry {
  name: [u8; 128],
  url: [u8; 512],
  reg_type: u32,  // 0=pkgx.sh, 1=npm, 2=github, 3=custom
  enabled: u32,
  priority: u32
}

// Environment structure
export struct Environment {
  name: [u8; 256],
  path: [u8; 512],
  active: u32,
  pkg_count: u32,
  packages: [u32; 64]
}

// Service structure
export struct Service {
  name: [u8; 128],
  command: [u8; 512],
  running: u32,
  pid: u32,
  port: u16,
  auto_start: u32,
  health_check_url: [u8; 256]
}

// Global state (managed by library)
var packages: [Package; 1000]
var registries: [Registry; 10]
var environments: [Environment; 32]
var services: [Service; 50]
var pkg_count: u32 = 0
var reg_count: u32 = 0
var env_count: u32 = 0
var svc_count: u32 = 0
var initialized: u32 = 0

// ============================================================================
// STRING UTILITIES (Library Internal)
// ============================================================================

fn str_len(s: u64) -> u32 {
  var len: u32 = 0
  var p: u64 = s
  while @intToPtr(p, u8) != 0 {
    len = len + 1
    p = p + 1
  }
  return len
}

fn str_copy(dest: u64, src: u64, max: u32) {
  var i: u32 = 0
  while i < max {
    var c: u8 = @intToPtr(src + i, u8)
    @ptrToInt(dest + i, u8) = c
    if c == 0 { break }
    i = i + 1
  }
}

fn str_equal(s1: u64, s2: u64) -> u32 {
  var i: u32 = 0
  while i < 256 {
    var c1: u8 = @intToPtr(s1 + i, u8)
    var c2: u8 = @intToPtr(s2 + i, u8)
    if c1 != c2 { return 0 }
    if c1 == 0 { return 1 }
    i = i + 1
  }
  return 1
}

fn str_concat(dest: u64, src: u64) {
  var d: u64 = dest
  while @intToPtr(d, u8) != 0 { d = d + 1 }
  var s: u64 = src
  while @intToPtr(s, u8) != 0 {
    @ptrToInt(d, u8) = @intToPtr(s, u8)
    d = d + 1
    s = s + 1
  }
  @ptrToInt(d, u8) = 0
}

// ============================================================================
// PANTRY INITIALIZATION
// ============================================================================

export fn pantry_init() -> u32 {
  if initialized == 1 { return 0 }
  
  // Initialize default registries
  add_registry("pkgx.sh", "https://pkgx.sh/v1", 0, 1, 10)
  add_registry("npm", "https://registry.npmjs.org", 1, 1, 5)
  add_registry("github", "https://api.github.com/repos", 2, 1, 3)
  
  // Initialize common services
  add_service("postgresql", "/usr/local/bin/postgres -D /var/lib/postgresql/data", 5432, 0, "http://localhost:5432")
  add_service("redis", "/usr/local/bin/redis-server /etc/redis/redis.conf", 6379, 0, "http://localhost:6379")
  add_service("nginx", "/usr/local/bin/nginx -c /etc/nginx/nginx.conf", 80, 0, "http://localhost:80")
  add_service("mysql", "/usr/local/bin/mysqld", 3306, 0, "http://localhost:3306")
  add_service("mongodb", "/usr/local/bin/mongod --dbpath /var/lib/mongodb", 27017, 0, "http://localhost:27017")
  
  initialized = 1
  return 0
}

fn add_registry(name: u64, url: u64, reg_type: u32, enabled: u32, priority: u32) {
  if reg_count >= MAX_REGISTRIES { return }
  
  var reg: Registry
  str_copy(@ptrFromInt(reg.name), name, 128)
  str_copy(@ptrFromInt(reg.url), url, 512)
  reg.reg_type = reg_type
  reg.enabled = enabled
  reg.priority = priority
  
  registries[reg_count] = reg
  reg_count = reg_count + 1
}

fn add_service(name: u64, command: u64, port: u16, auto_start: u32, health_url: u64) {
  if svc_count >= MAX_SERVICES { return }
  
  var svc: Service
  str_copy(@ptrFromInt(svc.name), name, 128)
  str_copy(@ptrFromInt(svc.command), command, 512)
  str_copy(@ptrFromInt(svc.health_check_url), health_url, 256)
  svc.running = 0
  svc.pid = 0
  svc.port = port
  svc.auto_start = auto_start
  
  services[svc_count] = svc
  svc_count = svc_count + 1
}

// ============================================================================
// PACKAGE MANAGEMENT
// ============================================================================

export fn pantry_install(pkg_name: u64, version: u64) -> u32 {
  // Check if already installed
  var i: u32 = 0
  while i < pkg_count {
    if str_equal(@ptrFromInt(packages[i].name), pkg_name) == 1 {
      return 0  // Already installed
    }
    i = i + 1
  }
  
  if pkg_count >= MAX_PACKAGES { return 1 }
  
  // Create package entry
  var pkg: Package
  str_copy(@ptrFromInt(pkg.name), pkg_name, 256)
  str_copy(@ptrFromInt(pkg.version), version, 64)
  pkg.registry_id = 0  // Default to pkgx
  pkg.installed = 1
  pkg.size = 1024 * 1024
  pkg.dep_count = 0
  
  // Set install path
  str_copy(@ptrFromInt(pkg.install_path), "/usr/local/pantry/", 512)
  str_concat(@ptrFromInt(pkg.install_path), pkg_name)
  
  packages[pkg_count] = pkg
  pkg_count = pkg_count + 1
  
  return 0
}

export fn pantry_remove(pkg_name: u64) -> u32 {
  var i: u32 = 0
  var found: u32 = 0
  var idx: u32 = 0
  
  while i < pkg_count {
    if str_equal(@ptrFromInt(packages[i].name), pkg_name) == 1 {
      found = 1
      idx = i
      break
    }
    i = i + 1
  }
  
  if found == 0 { return 1 }
  
  // Shift array
  i = idx
  while i < pkg_count - 1 {
    packages[i] = packages[i + 1]
    i = i + 1
  }
  pkg_count = pkg_count - 1
  
  return 0
}

export fn pantry_update(pkg_name: u64) -> u32 {
  var i: u32 = 0
  while i < pkg_count {
    if str_equal(@ptrFromInt(packages[i].name), pkg_name) == 1 {
      str_copy(@ptrFromInt(packages[i].version), "latest", 64)
      return 0
    }
    i = i + 1
  }
  return 1
}

export fn pantry_list() -> u32 {
  return pkg_count
}

export fn pantry_get_package(index: u32) -> u64 {
  if index >= pkg_count { return 0 }
  return @ptrFromInt(packages[index])
}

export fn pantry_search(query: u64) -> u32 {
  // Search all enabled registries
  var results: u32 = 0
  var i: u32 = 0
  
  while i < reg_count {
    if registries[i].enabled == 1 {
      // Would query registry API
      results = results + 10
    }
    i = i + 1
  }
  
  return results
}

// ============================================================================
// ENVIRONMENT MANAGEMENT
// ============================================================================

export fn pantry_env_create(name: u64, path: u64) -> u32 {
  if env_count >= MAX_ENVIRONMENTS { return 1 }
  
  var env: Environment
  str_copy(@ptrFromInt(env.name), name, 256)
  str_copy(@ptrFromInt(env.path), path, 512)
  env.active = 0
  env.pkg_count = 0
  
  environments[env_count] = env
  env_count = env_count + 1
  
  return 0
}

export fn pantry_env_activate(name: u64) -> u32 {
  var i: u32 = 0
  
  // Deactivate all
  while i < env_count {
    environments[i].active = 0
    i = i + 1
  }
  
  // Activate target
  i = 0
  while i < env_count {
    if str_equal(@ptrFromInt(environments[i].name), name) == 1 {
      environments[i].active = 1
      return 0
    }
    i = i + 1
  }
  
  return 1
}

export fn pantry_env_deactivate() -> u32 {
  var i: u32 = 0
  while i < env_count {
    environments[i].active = 0
    i = i + 1
  }
  return 0
}

export fn pantry_env_list() -> u32 {
  return env_count
}

export fn pantry_env_get(index: u32) -> u64 {
  if index >= env_count { return 0 }
  return @ptrFromInt(environments[index])
}

// ============================================================================
// SERVICE MANAGEMENT
// ============================================================================

export fn pantry_service_start(name: u64) -> u32 {
  var i: u32 = 0
  while i < svc_count {
    if str_equal(@ptrFromInt(services[i].name), name) == 1 {
      if services[i].running == 0 {
        services[i].running = 1
        services[i].pid = 1000 + i  // Would fork actual process
        return 0
      }
      return 2  // Already running
    }
    i = i + 1
  }
  return 1
}

export fn pantry_service_stop(name: u64) -> u32 {
  var i: u32 = 0
  while i < svc_count {
    if str_equal(@ptrFromInt(services[i].name), name) == 1 {
      if services[i].running == 1 {
        services[i].running = 0
        services[i].pid = 0
        return 0
      }
      return 2  // Not running
    }
    i = i + 1
  }
  return 1
}

export fn pantry_service_restart(name: u64) -> u32 {
  pantry_service_stop(name)
  pantry_service_start(name)
  return 0
}

export fn pantry_service_status(name: u64) -> u32 {
  var i: u32 = 0
  while i < svc_count {
    if str_equal(@ptrFromInt(services[i].name), name) == 1 {
      return services[i].running
    }
    i = i + 1
  }
  return 0
}

export fn pantry_service_list() -> u32 {
  return svc_count
}

export fn pantry_service_get(index: u32) -> u64 {
  if index >= svc_count { return 0 }
  return @ptrFromInt(services[index])
}

// ============================================================================
// REGISTRY MANAGEMENT
// ============================================================================

export fn pantry_registry_add(name: u64, url: u64, reg_type: u32) -> u32 {
  add_registry(name, url, reg_type, 1, 1)
  return 0
}

export fn pantry_registry_remove(name: u64) -> u32 {
  var i: u32 = 0
  var found: u32 = 0
  var idx: u32 = 0
  
  while i < reg_count {
    if str_equal(@ptrFromInt(registries[i].name), name) == 1 {
      found = 1
      idx = i
      break
    }
    i = i + 1
  }
  
  if found == 0 { return 1 }
  
  i = idx
  while i < reg_count - 1 {
    registries[i] = registries[i + 1]
    i = i + 1
  }
  reg_count = reg_count - 1
  
  return 0
}

export fn pantry_registry_list() -> u32 {
  return reg_count
}

export fn pantry_registry_get(index: u32) -> u64 {
  if index >= reg_count { return 0 }
  return @ptrFromInt(registries[index])
}

// ============================================================================
// CACHE MANAGEMENT
// ============================================================================

export fn pantry_cache_clear() -> u32 {
  // Would clear /var/cache/pantry
  return 0
}

export fn pantry_cache_size() -> u64 {
  // Would calculate cache size
  return 0
}

// ============================================================================
// DEPENDENCY RESOLUTION
// ============================================================================

export fn pantry_resolve_deps(pkg_name: u64) -> u32 {
  // Would resolve package dependencies
  return 0
}

export fn pantry_check_conflicts() -> u32 {
  // Would check for package conflicts
  return 0
}
