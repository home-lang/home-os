// home-os kernel - Main entry point
// Built with Home Programming Language using Home's kernel package

const Kernel = @import("~/Code/home/packages/kernel/src/kernel.zig");
const Basics = @import("basics");

// Use Home's kernel modules
const serial = Kernel.serial;
const interrupts = Kernel.interrupts;
const asm_ops = Kernel.asm;

// Multiboot2 magic constant
const MULTIBOOT2_MAGIC: u32 = 0x36d76289;

// Kernel panic handler
pub fn panic(msg: []const u8, error_return_trace: ?*Basics.StackTrace, ret_addr: ?usize) noreturn {
    _ = error_return_trace;
    _ = ret_addr;

    serial.write(serial.COM1, "\n[PANIC] ");
    serial.write(serial.COM1, msg);
    serial.write(serial.COM1, "\n");

    // Halt the CPU
    while (true) {
        asm_ops.hlt();
    }
}

// Kernel main entry point (called from boot.s)
export fn kernel_main(magic: u32, info_addr: u32) callconv(.c) noreturn {
    // Initialize serial console at COM1, 115200 baud
    serial.initPort(serial.COM1, 115200, .None, .One, .Eight);

    serial.write(serial.COM1, "home-os kernel starting...\n");
    serial.write(serial.COM1, "Serial initialized OK\n");

    // Print banner
    serial.write(serial.COM1, "=== home-os ===\n");
    serial.write(serial.COM1, "A modern, minimal operating system\n");
    serial.write(serial.COM1, "Built with Home, Craft, and Pantry\n\n");

    // Verify Multiboot2 magic number
    if (magic != MULTIBOOT2_MAGIC) {
        @panic("Invalid Multiboot2 magic number!");
    }

    serial.write(serial.COM1, "Multiboot2 magic verified: 0x");
    serial.writeHex(serial.COM1, magic);
    serial.write(serial.COM1, "\n");
    serial.write(serial.COM1, "Multiboot2: OK\n");

    // Display boot info
    serial.write(serial.COM1, "Boot info address: 0x");
    serial.writeHex(serial.COM1, info_addr);
    serial.write(serial.COM1, "\n");
    serial.write(serial.COM1, "Boot info: OK\n");
    serial.write(serial.COM1, "Bootloader: GRUB\n\n");

    // Initialize IDT (Interrupt Descriptor Table)
    serial.write(serial.COM1, "Initializing IDT...\n");

    // Create IDT with 256 entries
    var idt: [256]interrupts.IdtEntry align(16) = [_]interrupts.IdtEntry{
        interrupts.IdtEntry{
            .offset_low = 0,
            .selector = 0,
            .ist = 0,
            .reserved1 = 0,
            .gate_type = 0,
            .zero = 0,
            .dpl = 0,
            .present = 0,
            .offset_middle = 0,
            .offset_high = 0,
            .reserved2 = 0,
        },
    } ** 256;

    // Set up exception handlers (vectors 0-31)
    const default_handler_addr = @intFromPtr(&defaultExceptionHandler);

    // Create interrupt gates for CPU exceptions
    // Selector 0x08 = kernel code segment, DPL=0 (ring 0), IST=0
    var i: u8 = 0;
    while (i < 32) : (i += 1) {
        idt[i] = interrupts.IdtEntry.interrupt(default_handler_addr, 0x08, 0, 0);
    }

    // Load IDT using Home's interrupt module
    const idt_ptr = interrupts.IdtPointer.init(idt[0..]);
    interrupts.loadIdt(&idt_ptr);

    serial.write(serial.COM1, "IDT loaded successfully!\n\n");

    // Kernel initialized successfully
    serial.write(serial.COM1, "Kernel initialized successfully!\n");
    serial.write(serial.COM1, "Entering idle loop...\n\n");
    serial.write(serial.COM1, "System ready. Press Ctrl+Alt+Del to reboot.\n");

    // Idle loop - halt until next interrupt
    while (true) {
        asm_ops.hlt();
    }
}

// Default exception handler
fn defaultExceptionHandler() callconv(.Naked) noreturn {
    // Save all registers
    asm volatile (
        \\push %%rax
        \\push %%rbx
        \\push %%rcx
        \\push %%rdx
        \\push %%rsi
        \\push %%rdi
        \\push %%rbp
        \\push %%r8
        \\push %%r9
        \\push %%r10
        \\push %%r11
        \\push %%r12
        \\push %%r13
        \\push %%r14
        \\push %%r15
    );

    // Print exception message to COM1
    const com1: u16 = 0x3F8;
    const msg = "\n\n*** EXCEPTION OCCURRED ***\nDefault handler invoked\nSystem halted\n";

    // Simple direct serial output
    var idx: usize = 0;
    while (idx < msg.len) : (idx += 1) {
        // Wait for transmit empty
        while ((asm_ops.inb(com1 + 5) & 0x20) == 0) {}
        // Send character
        asm_ops.outb(com1, msg[idx]);
    }

    // Halt forever
    while (true) {
        asm volatile ("cli; hlt");
    }
}
