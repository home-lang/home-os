// home-os Kernel - ARM64 SMP (Symmetric Multi-Processing)
// Multi-core support for ARM64

import "../../core/foundation.home" as foundation

const MAX_CPUS: u32 = 4

var cpu_online: [u32; 4]
var cpu_count: u32 = 1
var smp_initialized: u32 = 0

export fn arm64_smp_init() {
  if smp_initialized == 1 { return }
  
  foundation.serial_write_string("[ARM64-SMP] Initializing multi-core support...\n")
  
  // CPU 0 is already running
  cpu_online[0] = 1
  
  // Detect number of CPUs
  cpu_count = arm64_detect_cpu_count()
  
  foundation.serial_write_string("[ARM64-SMP] Detected ")
  foundation.serial_write_hex(cpu_count)
  foundation.serial_write_string(" CPUs\n")
  
  // Start secondary CPUs
  var cpu: u32 = 1
  while cpu < cpu_count {
    arm64_start_cpu(cpu)
    cpu = cpu + 1
  }
  
  smp_initialized = 1
  foundation.serial_write_string("[ARM64-SMP] All CPUs online\n")
}

fn arm64_detect_cpu_count() -> u32 {
  // Read from device tree or return hardcoded value
  return 4  // Raspberry Pi 4 has 4 cores
}

fn arm64_start_cpu(cpu_id: u32) {
  foundation.serial_write_string("[ARM64-SMP] Starting CPU ")
  foundation.serial_write_hex(cpu_id)
  foundation.serial_write_string("\n")
  
  // Setup secondary CPU entry point
  var entry_point: u64 = @ptrFromInt(arm64_secondary_entry)
  
  // Write entry point to mailbox for secondary CPU
  arm64_write_cpu_mailbox(cpu_id, entry_point)
  
  // Send event to wake up CPU
  foundation.arm64_sev()
  
  // Wait for CPU to come online
  var timeout: u32 = 1000000
  while cpu_online[cpu_id] == 0 and timeout > 0 {
    foundation.cpu_relax()
    timeout = timeout - 1
  }
  
  if cpu_online[cpu_id] == 1 {
    foundation.serial_write_string("[ARM64-SMP] CPU ")
    foundation.serial_write_hex(cpu_id)
    foundation.serial_write_string(" online\n")
  } else {
    foundation.serial_write_string("[ARM64-SMP] CPU ")
    foundation.serial_write_hex(cpu_id)
    foundation.serial_write_string(" failed to start\n")
  }
}

fn arm64_write_cpu_mailbox(cpu_id: u32, value: u64) {
  // CPU mailbox addresses (Raspberry Pi specific)
  var mailbox_base: u64 = 0x400000E0
  var mailbox: u64 = mailbox_base + (cpu_id * 16)
  
  @intToPtr(mailbox, u64) = value
  
  // Data synchronization barrier
  foundation.arm64_dsb()
}

export fn arm64_secondary_entry() {
  // Get CPU ID
  var cpu_id: u32 = arm64_get_cpu_id()
  
  // Setup per-CPU data
  arm64_setup_cpu(cpu_id)
  
  // Mark CPU as online
  cpu_online[cpu_id] = 1
  
  // Enter idle loop
  arm64_cpu_idle()
}

fn arm64_setup_cpu(cpu_id: u32) {
  // Setup exception vectors
  var vector_table: u64 = foundation.get_vector_table()
  foundation.arm64_write_vbar_el1(vector_table)
  
  // Enable caches
  var sctlr: u64 = foundation.arm64_read_sctlr_el1()
  sctlr = sctlr | (1 << 2) | (1 << 12)  // Enable D-cache and I-cache
  foundation.arm64_write_sctlr_el1(sctlr)
  
  // Setup page tables
  var ttbr0: u64 = foundation.get_kernel_pgd()
  foundation.arm64_write_ttbr0_el1(ttbr0)
  foundation.arm64_write_ttbr1_el1(ttbr0)
  
  // Invalidate TLB
  foundation.arm64_tlbi_vmalle1()
  foundation.arm64_dsb()
  foundation.arm64_isb()
}

fn arm64_cpu_idle() {
  while 1 == 1 {
    foundation.arm64_wfi()  // Wait for interrupt
  }
}

fn arm64_get_cpu_id() -> u32 {
  var mpidr: u64 = foundation.arm64_read_mpidr_el1()
  return @truncate(mpidr & 0xFF, u32)
}

export fn arm64_smp_get_cpu_count() -> u32 {
  return cpu_count
}

export fn arm64_smp_is_online(cpu_id: u32) -> u32 {
  if cpu_id >= MAX_CPUS { return 0 }
  return cpu_online[cpu_id]
}

export fn arm64_smp_send_ipi(cpu_id: u32, vector: u32) {
  // Send inter-processor interrupt
  foundation.arm64_send_sgi(cpu_id, vector)
}

export fn arm64_smp_broadcast_ipi(vector: u32) {
  var cpu: u32 = 0
  while cpu < cpu_count {
    if cpu != arm64_get_cpu_id() {
      arm64_smp_send_ipi(cpu, vector)
    }
    cpu = cpu + 1
  }
}
