// home-os Kernel - ARM64 Boot
// ARM64 kernel entry and initialization

import "../../core/foundation.home" as foundation

// Exception levels
const EL0: u32 = 0  // User mode
const EL1: u32 = 1  // Kernel mode
const EL2: u32 = 2  // Hypervisor
const EL3: u32 = 3  // Secure monitor

// System registers
const SCTLR_EL1_MMU_ENABLE: u64 = 1 << 0
const SCTLR_EL1_CACHE_ENABLE: u64 = 1 << 2
const SCTLR_EL1_ICACHE_ENABLE: u64 = 1 << 12

var boot_initialized: u32 = 0

export fn arm64_boot_init() {
  if boot_initialized == 1 { return }
  
  // Check current exception level
  var current_el: u32 = arm64_get_current_el()
  
  foundation.serial_write_string("[ARM64] Boot from EL")
  foundation.serial_write_hex(current_el)
  foundation.serial_write_string("\n")
  
  // Drop to EL1 if needed
  if current_el == EL2 {
    arm64_drop_to_el1()
  } else if current_el == EL3 {
    arm64_drop_to_el2()
    arm64_drop_to_el1()
  }
  
  // Setup system registers
  arm64_setup_system_registers()
  
  // Setup exception vector table
  arm64_setup_vectors()
  
  boot_initialized = 1
  foundation.serial_write_string("[ARM64] Boot initialization complete\n")
}

fn arm64_get_current_el() -> u32 {
  var el: u64 = foundation.arm64_read_currentel()
  return @truncate((el >> 2) & 0x3, u32)
}

fn arm64_drop_to_el1() {
  foundation.serial_write_string("[ARM64] Dropping to EL1\n")
  
  // Configure HCR_EL2 (Hypervisor Configuration Register)
  var hcr: u64 = 1 << 31  // RW bit: EL1 is AArch64
  foundation.arm64_write_hcr_el2(hcr)
  
  // Configure SPSR_EL2 (Saved Program Status Register)
  var spsr: u64 = 0x3C5  // EL1h with interrupts masked
  foundation.arm64_write_spsr_el2(spsr)
  
  // Set ELR_EL2 to return address
  var return_addr: u64 = foundation.get_pc()
  foundation.arm64_write_elr_el2(return_addr)
  
  // Execute ERET to drop to EL1
  foundation.arm64_eret()
}

fn arm64_drop_to_el2() {
  foundation.serial_write_string("[ARM64] Dropping to EL2\n")
  
  // Configure SCR_EL3 (Secure Configuration Register)
  var scr: u64 = (1 << 10) | (1 << 0)  // RW + NS bits
  foundation.arm64_write_scr_el3(scr)
  
  // Configure SPSR_EL3
  var spsr: u64 = 0x3C9  // EL2h with interrupts masked
  foundation.arm64_write_spsr_el3(spsr)
  
  // Set ELR_EL3
  var return_addr: u64 = foundation.get_pc()
  foundation.arm64_write_elr_el3(return_addr)
  
  // Execute ERET
  foundation.arm64_eret()
}

fn arm64_setup_system_registers() {
  // Setup SCTLR_EL1 (System Control Register)
  var sctlr: u64 = foundation.arm64_read_sctlr_el1()
  
  // Enable MMU, caches, and instruction cache
  sctlr = sctlr | SCTLR_EL1_MMU_ENABLE
  sctlr = sctlr | SCTLR_EL1_CACHE_ENABLE
  sctlr = sctlr | SCTLR_EL1_ICACHE_ENABLE
  
  foundation.arm64_write_sctlr_el1(sctlr)
  
  // Setup TCR_EL1 (Translation Control Register)
  var tcr: u64 = 0
  tcr = tcr | (16 << 0)   // T0SZ: 48-bit VA
  tcr = tcr | (16 << 16)  // T1SZ: 48-bit VA
  tcr = tcr | (0 << 14)   // TG0: 4KB granule
  tcr = tcr | (2 << 30)   // TG1: 4KB granule
  tcr = tcr | (1 << 8)    // IRGN0: Normal, Inner Write-Back
  tcr = tcr | (1 << 10)   // ORGN0: Normal, Outer Write-Back
  tcr = tcr | (3 << 12)   // SH0: Inner Shareable
  
  foundation.arm64_write_tcr_el1(tcr)
  
  // Setup MAIR_EL1 (Memory Attribute Indirection Register)
  var mair: u64 = 0
  mair = mair | (0x00 << 0)   // Device-nGnRnE
  mair = mair | (0x04 << 8)   // Device-nGnRE
  mair = mair | (0xFF << 16)  // Normal, Write-Back
  
  foundation.arm64_write_mair_el1(mair)
  
  foundation.serial_write_string("[ARM64] System registers configured\n")
}

fn arm64_setup_vectors() {
  // Setup exception vector table
  var vector_table: u64 = @ptrFromInt(arm64_vector_table)
  foundation.arm64_write_vbar_el1(vector_table)
  
  foundation.serial_write_string("[ARM64] Exception vectors at 0x")
  foundation.serial_write_hex(@truncate(vector_table, u32))
  foundation.serial_write_string("\n")
}

// Exception vector table (simplified)
export fn arm64_vector_table() {
  // This would be implemented in assembly
  // Each entry is 128 bytes aligned
}

export fn arm64_enable_mmu(ttbr0: u64, ttbr1: u64) {
  // Set translation table base registers
  foundation.arm64_write_ttbr0_el1(ttbr0)
  foundation.arm64_write_ttbr1_el1(ttbr1)
  
  // Invalidate TLB
  foundation.arm64_tlbi_vmalle1()
  
  // Data synchronization barrier
  foundation.arm64_dsb()
  
  // Instruction synchronization barrier
  foundation.arm64_isb()
  
  foundation.serial_write_string("[ARM64] MMU enabled\n")
}

export fn arm64_enable_caches() {
  // Enable instruction and data caches
  var sctlr: u64 = foundation.arm64_read_sctlr_el1()
  sctlr = sctlr | SCTLR_EL1_CACHE_ENABLE | SCTLR_EL1_ICACHE_ENABLE
  foundation.arm64_write_sctlr_el1(sctlr)
  
  foundation.serial_write_string("[ARM64] Caches enabled\n")
}

export fn arm64_get_cpu_id() -> u32 {
  var mpidr: u64 = foundation.arm64_read_mpidr_el1()
  return @truncate(mpidr & 0xFF, u32)
}

export fn arm64_get_cpu_count() -> u32 {
  // Read from device tree or hardcode for now
  return 4  // Raspberry Pi 4 has 4 cores
}
