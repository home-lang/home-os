// home-os ARM Generic Timer Driver
// ARM architecture timer with EL1 physical and virtual timers
// Provides high-resolution timing, interrupts, and scheduler ticks

import "../../core/foundation.home" as foundation
import "../../core/memory.home" as memory

// Timer control register bits
const TIMER_ENABLE: u32 = 1 << 0
const TIMER_IMASK: u32 = 1 << 1     // Interrupt mask
const TIMER_ISTATUS: u32 = 1 << 2   // Interrupt status

// Timer interrupt IRQ numbers (platform-specific)
const TIMER_IRQ_PHYS_NONSECURE: u32 = 30  // PPI 14
const TIMER_IRQ_VIRT: u32 = 27            // PPI 11
const TIMER_IRQ_PHYS_SECURE: u32 = 29     // PPI 13
const TIMER_IRQ_HYPERVISOR: u32 = 26      // PPI 10

// Timer types
const TIMER_TYPE_PHYSICAL: u32 = 0
const TIMER_TYPE_VIRTUAL: u32 = 1

// Typical timer frequency (platform-dependent)
// Raspberry Pi 4/5 use 54MHz (0x03375E90)
const DEFAULT_TIMER_FREQ: u64 = 54000000

// Timer callback type
type TimerCallback = fn(elapsed_us: u64)

// Timer state
struct TimerState {
  frequency: u64        // Timer frequency in Hz
  initialized: u32      // Initialization flag
  callback: TimerCallback  // Timer interrupt callback
  last_count: u64       // Last counter value
  total_ticks: u64      // Total timer ticks
  timer_interrupts: u64 // Number of timer interrupts
}

var timer_state: TimerState

// Statistics
var timer_overruns: u64 = 0
var missed_deadlines: u64 = 0

// Read system counter frequency (CNTFRQ_EL0)
fn read_timer_frequency(): u64 {
  // In real implementation: asm("mrs %0, cntfrq_el0" : "=r"(freq))
  return DEFAULT_TIMER_FREQ
}

// Read physical counter (CNTPCT_EL0)
fn read_physical_counter(): u64 {
  // In real implementation: asm("mrs %0, cntpct_el0" : "=r"(count))
  // For now, return incrementing value
  return timer_state.total_ticks
}

// Read virtual counter (CNTVCT_EL0)
fn read_virtual_counter(): u64 {
  // In real implementation: asm("mrs %0, cntvct_el0" : "=r"(count))
  return timer_state.total_ticks
}

// Write physical timer compare value (CNTP_CVAL_EL0)
fn write_physical_compare(value: u64) {
  // In real implementation: asm("msr cntp_cval_el0, %0" :: "r"(value))
}

// Write physical timer control (CNTP_CTL_EL0)
fn write_physical_control(value: u32) {
  // In real implementation: asm("msr cntp_ctl_el0, %0" :: "r"(value))
}

// Read physical timer control (CNTP_CTL_EL0)
fn read_physical_control(): u32 {
  // In real implementation: asm("mrs %0, cntp_ctl_el0" : "=r"(ctl))
  return 0
}

// Write virtual timer compare value (CNTV_CVAL_EL0)
fn write_virtual_compare(value: u64) {
  // In real implementation: asm("msr cntv_cval_el0, %0" :: "r"(value))
}

// Write virtual timer control (CNTV_CTL_EL0)
fn write_virtual_control(value: u32) {
  // In real implementation: asm("msr cntv_ctl_el0, %0" :: "r"(value))
}

// Read virtual timer control (CNTV_CTL_EL0)
fn read_virtual_control(): u32 {
  // In real implementation: asm("mrs %0, cntv_ctl_el0" : "=r"(ctl))
  return 0
}

// Initialize ARM Generic Timer
export fn timer_init(): u32 {
  if timer_state.initialized == 1 {
    foundation.serial_write_string("[ARM Timer] Already initialized\n")
    return 0
  }

  foundation.serial_write_string("[ARM Timer] Initializing ARM Generic Timer...\n")

  // Read timer frequency
  timer_state.frequency = read_timer_frequency()

  foundation.serial_write_string("[ARM Timer] Timer frequency: ")
  foundation.serial_write_u64(timer_state.frequency)
  foundation.serial_write_string(" Hz\n")

  // Initialize state
  timer_state.callback = 0
  timer_state.last_count = read_physical_counter()
  timer_state.total_ticks = 0
  timer_state.timer_interrupts = 0

  // Disable timers initially
  write_physical_control(TIMER_IMASK)  // Masked, disabled
  write_virtual_control(TIMER_IMASK)   // Masked, disabled

  timer_state.initialized = 1

  foundation.serial_write_string("[ARM Timer] Initialization complete\n")
  return 0
}

// Get current timestamp in microseconds
export fn timer_get_us(): u64 {
  if timer_state.initialized == 0 { return 0 }

  let count: u64 = read_physical_counter()
  return (count * 1000000) / timer_state.frequency
}

// Get current timestamp in milliseconds
export fn timer_get_ms(): u64 {
  if timer_state.initialized == 0 { return 0 }

  let count: u64 = read_physical_counter()
  return (count * 1000) / timer_state.frequency
}

// Get current timestamp in seconds
export fn timer_get_seconds(): u64 {
  if timer_state.initialized == 0 { return 0 }

  let count: u64 = read_physical_counter()
  return count / timer_state.frequency
}

// Get raw counter value
export fn timer_get_counter(): u64 {
  return read_physical_counter()
}

// Get timer frequency
export fn timer_get_frequency(): u64 {
  return timer_state.frequency
}

// Delay for microseconds
export fn timer_delay_us(us: u64) {
  if timer_state.initialized == 0 { return }

  let start: u64 = timer_get_us()
  let target: u64 = start + us

  loop {
    let now: u64 = timer_get_us()
    if now >= target { break }
  }
}

// Delay for milliseconds
export fn timer_delay_ms(ms: u64) {
  timer_delay_us(ms * 1000)
}

// Delay for seconds
export fn timer_delay_seconds(seconds: u64) {
  timer_delay_us(seconds * 1000000)
}

// Register timer callback
export fn timer_register_callback(callback: TimerCallback) {
  timer_state.callback = callback
}

// Set timer to fire after microseconds
export fn timer_set_timeout_us(us: u64, timer_type: u32): u32 {
  if timer_state.initialized == 0 { return 1 }

  // Calculate compare value
  let current: u64 = if timer_type == TIMER_TYPE_PHYSICAL {
    read_physical_counter()
  } else {
    read_virtual_counter()
  }

  let ticks: u64 = (us * timer_state.frequency) / 1000000
  let compare: u64 = current + ticks

  if timer_type == TIMER_TYPE_PHYSICAL {
    // Set physical timer
    write_physical_compare(compare)
    write_physical_control(TIMER_ENABLE)  // Enable, unmasked
  } else {
    // Set virtual timer
    write_virtual_compare(compare)
    write_virtual_control(TIMER_ENABLE)  // Enable, unmasked
  }

  return 0
}

// Set timer to fire after milliseconds
export fn timer_set_timeout_ms(ms: u64, timer_type: u32): u32 {
  return timer_set_timeout_us(ms * 1000, timer_type)
}

// Set periodic timer (for scheduler ticks)
export fn timer_set_periodic_us(period_us: u64, timer_type: u32): u32 {
  return timer_set_timeout_us(period_us, timer_type)
}

// Set periodic timer in Hz
export fn timer_set_periodic_hz(hz: u64, timer_type: u32): u32 {
  if hz == 0 { return 1 }

  let period_us: u64 = 1000000 / hz
  return timer_set_periodic_us(period_us, timer_type)
}

// Cancel timer
export fn timer_cancel(timer_type: u32) {
  if timer_state.initialized == 0 { return }

  if timer_type == TIMER_TYPE_PHYSICAL {
    write_physical_control(TIMER_IMASK)  // Mask and disable
  } else {
    write_virtual_control(TIMER_IMASK)   // Mask and disable
  }
}

// Handle timer interrupt
export fn timer_handle_interrupt(timer_type: u32) {
  if timer_state.initialized == 0 { return }

  timer_state.timer_interrupts = timer_state.timer_interrupts + 1

  // Read current counter
  let current: u64 = if timer_type == TIMER_TYPE_PHYSICAL {
    read_physical_counter()
  } else {
    read_virtual_counter()
  }

  // Calculate elapsed time
  let elapsed_ticks: u64 = current - timer_state.last_count
  let elapsed_us: u64 = (elapsed_ticks * 1000000) / timer_state.frequency

  timer_state.last_count = current
  timer_state.total_ticks = timer_state.total_ticks + elapsed_ticks

  // Call registered callback
  if timer_state.callback != 0 {
    timer_state.callback(elapsed_us)
  }

  // Clear interrupt by writing to control register
  if timer_type == TIMER_TYPE_PHYSICAL {
    let ctl: u32 = read_physical_control()
    write_physical_control(ctl | TIMER_IMASK)  // Mask interrupt
  } else {
    let ctl: u32 = read_virtual_control()
    write_virtual_control(ctl | TIMER_IMASK)  // Mask interrupt
  }
}

// Get uptime in microseconds
export fn timer_get_uptime_us(): u64 {
  return timer_get_us()
}

// Get uptime in milliseconds
export fn timer_get_uptime_ms(): u64 {
  return timer_get_ms()
}

// Get uptime in seconds
export fn timer_get_uptime_seconds(): u64 {
  return timer_get_seconds()
}

// Benchmark helper - start timing
export fn timer_benchmark_start(): u64 {
  return timer_get_us()
}

// Benchmark helper - end timing and return duration
export fn timer_benchmark_end(start: u64): u64 {
  let end: u64 = timer_get_us()
  return end - start
}

// Convert ticks to microseconds
export fn timer_ticks_to_us(ticks: u64): u64 {
  if timer_state.frequency == 0 { return 0 }
  return (ticks * 1000000) / timer_state.frequency
}

// Convert microseconds to ticks
export fn timer_us_to_ticks(us: u64): u64 {
  return (us * timer_state.frequency) / 1000000
}

// Check if timer is running
export fn timer_is_running(timer_type: u32): u32 {
  let ctl: u32 = if timer_type == TIMER_TYPE_PHYSICAL {
    read_physical_control()
  } else {
    read_virtual_control()
  }

  return if (ctl & TIMER_ENABLE) != 0 { 1 } else { 0 }
}

// Check if timer interrupt is pending
export fn timer_is_pending(timer_type: u32): u32 {
  let ctl: u32 = if timer_type == TIMER_TYPE_PHYSICAL {
    read_physical_control()
  } else {
    read_virtual_control()
  }

  return if (ctl & TIMER_ISTATUS) != 0 { 1 } else { 0 }
}

// Print timer statistics
export fn timer_print_stats() {
  foundation.serial_write_string("\n[ARM Timer] Statistics:\n")

  foundation.serial_write_string("  Frequency: ")
  foundation.serial_write_u64(timer_state.frequency)
  foundation.serial_write_string(" Hz\n")

  foundation.serial_write_string("  Uptime: ")
  foundation.serial_write_u64(timer_get_uptime_seconds())
  foundation.serial_write_string(" seconds\n")

  foundation.serial_write_string("  Total ticks: ")
  foundation.serial_write_u64(timer_state.total_ticks)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Timer interrupts: ")
  foundation.serial_write_u64(timer_state.timer_interrupts)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Timer overruns: ")
  foundation.serial_write_u64(timer_overruns)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Missed deadlines: ")
  foundation.serial_write_u64(missed_deadlines)
  foundation.serial_write_string("\n")
}

// Print current time
export fn timer_print_time() {
  let seconds: u64 = timer_get_uptime_seconds()
  let minutes: u64 = seconds / 60
  let hours: u64 = minutes / 60

  let s: u64 = seconds % 60
  let m: u64 = minutes % 60
  let h: u64 = hours

  foundation.serial_write_string("[ARM Timer] Uptime: ")
  foundation.serial_write_u64(h)
  foundation.serial_write_string(":")

  if m < 10 {
    foundation.serial_write_string("0")
  }
  foundation.serial_write_u64(m)
  foundation.serial_write_string(":")

  if s < 10 {
    foundation.serial_write_string("0")
  }
  foundation.serial_write_u64(s)
  foundation.serial_write_string("\n")
}

// Calibrate timer (useful for determining actual frequency)
export fn timer_calibrate(): u64 {
  foundation.serial_write_string("[ARM Timer] Calibrating timer...\n")

  let start: u64 = read_physical_counter()

  // Delay using a known reference (e.g., RTC or crystal oscillator)
  // For now, just read counter again
  var i: u32 = 0
  loop {
    if i >= 1000000 { break }
    foundation.nop()
    i = i + 1
  }

  let end: u64 = read_physical_counter()
  let elapsed_ticks: u64 = end - start

  foundation.serial_write_string("[ARM Timer] Calibration: ")
  foundation.serial_write_u64(elapsed_ticks)
  foundation.serial_write_string(" ticks elapsed\n")

  return elapsed_ticks
}
