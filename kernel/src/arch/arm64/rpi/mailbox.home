// home-os Raspberry Pi Mailbox Interface
// VideoCore GPU communication via mailbox property interface

import "../../../core/types"
import "../../../sync/spinlock"

// =============================================================================
// Mailbox Base Addresses
// =============================================================================

const MAILBOX_BASE_PI3: u64 = 0x3F00B880    // BCM2837
const MAILBOX_BASE_PI4: u64 = 0xFE00B880    // BCM2711

// =============================================================================
// Mailbox Register Offsets
// =============================================================================

const MBOX_READ: u64 = 0x00       // Read data from VC to ARM
const MBOX_POLL: u64 = 0x10       // Read without receiving
const MBOX_SENDER: u64 = 0x14     // Sender info
const MBOX_STATUS: u64 = 0x18     // Status
const MBOX_CONFIG: u64 = 0x1C     // Configuration
const MBOX_WRITE: u64 = 0x20      // Write data from ARM to VC

// =============================================================================
// Mailbox Status Bits
// =============================================================================

const MBOX_FULL: u32 = 0x80000000   // Mailbox is full (can't write)
const MBOX_EMPTY: u32 = 0x40000000  // Mailbox is empty (can't read)

// =============================================================================
// Mailbox Channels
// =============================================================================

enum MailboxChannel {
    PowerManagement = 0,
    Framebuffer = 1,
    VirtualUART = 2,
    VCHIQ = 3,
    LEDs = 4,
    Buttons = 5,
    TouchScreen = 6,
    PropertyTagsArmToVc = 8,
    PropertyTagsVcToArm = 9,
}

// =============================================================================
// Property Tags (Request/Response)
// =============================================================================

// VideoCore property tags
const TAG_END: u32 = 0x00000000

// VideoCore info
const TAG_GET_FIRMWARE_REV: u32 = 0x00000001

// Hardware info
const TAG_GET_BOARD_MODEL: u32 = 0x00010001
const TAG_GET_BOARD_REVISION: u32 = 0x00010002
const TAG_GET_BOARD_MAC_ADDRESS: u32 = 0x00010003
const TAG_GET_BOARD_SERIAL: u32 = 0x00010004
const TAG_GET_ARM_MEMORY: u32 = 0x00010005
const TAG_GET_VC_MEMORY: u32 = 0x00010006
const TAG_GET_CLOCKS: u32 = 0x00010007

// Power
const TAG_GET_POWER_STATE: u32 = 0x00020001
const TAG_GET_TIMING: u32 = 0x00020002
const TAG_SET_POWER_STATE: u32 = 0x00028001

// Clocks
const TAG_GET_CLOCK_STATE: u32 = 0x00030001
const TAG_SET_CLOCK_STATE: u32 = 0x00038001
const TAG_GET_CLOCK_RATE: u32 = 0x00030002
const TAG_SET_CLOCK_RATE: u32 = 0x00038002
const TAG_GET_MAX_CLOCK_RATE: u32 = 0x00030004
const TAG_GET_MIN_CLOCK_RATE: u32 = 0x00030007
const TAG_GET_TURBO: u32 = 0x00030009
const TAG_SET_TURBO: u32 = 0x00038009

// Voltage
const TAG_GET_VOLTAGE: u32 = 0x00030003
const TAG_SET_VOLTAGE: u32 = 0x00038003
const TAG_GET_MAX_VOLTAGE: u32 = 0x00030005
const TAG_GET_MIN_VOLTAGE: u32 = 0x00030008
const TAG_GET_TEMPERATURE: u32 = 0x00030006
const TAG_GET_MAX_TEMPERATURE: u32 = 0x0003000A

// Memory
const TAG_ALLOCATE_MEMORY: u32 = 0x0003000C
const TAG_LOCK_MEMORY: u32 = 0x0003000D
const TAG_UNLOCK_MEMORY: u32 = 0x0003000E
const TAG_RELEASE_MEMORY: u32 = 0x0003000F
const TAG_EXECUTE_CODE: u32 = 0x00030010
const TAG_GET_DISPMANX_HANDLE: u32 = 0x00030014
const TAG_GET_EDID_BLOCK: u32 = 0x00030020

// Framebuffer
const TAG_ALLOCATE_BUFFER: u32 = 0x00040001
const TAG_RELEASE_BUFFER: u32 = 0x00048001
const TAG_BLANK_SCREEN: u32 = 0x00040002
const TAG_GET_PHYSICAL_SIZE: u32 = 0x00040003
const TAG_TEST_PHYSICAL_SIZE: u32 = 0x00044003
const TAG_SET_PHYSICAL_SIZE: u32 = 0x00048003
const TAG_GET_VIRTUAL_SIZE: u32 = 0x00040004
const TAG_TEST_VIRTUAL_SIZE: u32 = 0x00044004
const TAG_SET_VIRTUAL_SIZE: u32 = 0x00048004
const TAG_GET_DEPTH: u32 = 0x00040005
const TAG_TEST_DEPTH: u32 = 0x00044005
const TAG_SET_DEPTH: u32 = 0x00048005
const TAG_GET_PIXEL_ORDER: u32 = 0x00040006
const TAG_TEST_PIXEL_ORDER: u32 = 0x00044006
const TAG_SET_PIXEL_ORDER: u32 = 0x00048006
const TAG_GET_ALPHA_MODE: u32 = 0x00040007
const TAG_TEST_ALPHA_MODE: u32 = 0x00044007
const TAG_SET_ALPHA_MODE: u32 = 0x00048007
const TAG_GET_PITCH: u32 = 0x00040008
const TAG_GET_VIRTUAL_OFFSET: u32 = 0x00040009
const TAG_TEST_VIRTUAL_OFFSET: u32 = 0x00044009
const TAG_SET_VIRTUAL_OFFSET: u32 = 0x00048009
const TAG_GET_OVERSCAN: u32 = 0x0004000A
const TAG_TEST_OVERSCAN: u32 = 0x0004400A
const TAG_SET_OVERSCAN: u32 = 0x0004800A
const TAG_GET_PALETTE: u32 = 0x0004000B
const TAG_TEST_PALETTE: u32 = 0x0004400B
const TAG_SET_PALETTE: u32 = 0x0004800B
const TAG_SET_CURSOR_INFO: u32 = 0x00008010
const TAG_SET_CURSOR_STATE: u32 = 0x00008011

// DMA
const TAG_GET_DMA_CHANNELS: u32 = 0x00060001

// Config
const TAG_GET_COMMAND_LINE: u32 = 0x00050001

// =============================================================================
// Clock IDs
// =============================================================================

enum ClockId {
    Reserved = 0,
    EMMC = 1,
    UART = 2,
    ARM = 3,
    Core = 4,
    V3D = 5,
    H264 = 6,
    ISP = 7,
    SDRAM = 8,
    Pixel = 9,
    PWM = 10,
    HEVC = 11,
    EMMC2 = 12,
    M2MC = 13,
    PixelBVB = 14,
}

// =============================================================================
// Power Device IDs
// =============================================================================

enum PowerDeviceId {
    SDCard = 0,
    UART0 = 1,
    UART1 = 2,
    USBHost = 3,
    I2C0 = 4,
    I2C1 = 5,
    I2C2 = 6,
    SPI = 7,
    CCP2TX = 8,
}

// =============================================================================
// Voltage IDs
// =============================================================================

enum VoltageId {
    Reserved = 0,
    Core = 1,
    SDRAMController = 2,
    SDRAMPhy = 3,
    SDRAMIo = 4,
}

// =============================================================================
// Property Tag Request/Response Codes
// =============================================================================

const REQUEST_CODE: u32 = 0x00000000
const RESPONSE_SUCCESS: u32 = 0x80000000
const RESPONSE_ERROR: u32 = 0x80000001

// =============================================================================
// Property Buffer
// =============================================================================

// Property buffer must be 16-byte aligned
#[repr(C, align(16))]
struct PropertyBuffer {
    buffer_size: u32,
    request_response_code: u32,
    tags: [u32; 256],
}

// =============================================================================
// Mailbox State
// =============================================================================

struct MailboxState {
    base: u64,
    lock: Spinlock,
}

static mut MAILBOX: MailboxState = MailboxState {
    base: MAILBOX_BASE_PI4,
    lock: Spinlock::new(),
}

static mut PROP_BUFFER: PropertyBuffer = PropertyBuffer {
    buffer_size: 0,
    request_response_code: 0,
    tags: [0u32; 256],
}

// =============================================================================
// Low-level Register Access
// =============================================================================

fn mbox_read(offset: u64): u32 {
    unsafe {
        let addr = MAILBOX.base + offset
        let value: u32
        asm!("ldr {0:w}, [{1}]", out(reg) value, in(reg) addr)
        return value
    }
}

fn mbox_write(offset: u64, value: u32) {
    unsafe {
        let addr = MAILBOX.base + offset
        asm!("str {0:w}, [{1}]", in(reg) value, in(reg) addr)
    }
}

fn memory_barrier() {
    asm!("dmb sy")
}

// =============================================================================
// Mailbox Initialization
// =============================================================================

export fn mailbox_init(base: u64): i32 {
    unsafe {
        MAILBOX.base = base
        MAILBOX.lock.init()
    }
    return 0
}

// =============================================================================
// Core Mailbox Functions
// =============================================================================

// Send data to mailbox channel (blocking)
export fn mailbox_write(channel: MailboxChannel, data: u32): i32 {
    // Data must be 16-byte aligned and channel is in bottom 4 bits
    let value = (data & !0xF) | ((channel as u32) & 0xF)

    // Wait until mailbox is not full
    while (mbox_read(MBOX_STATUS) & MBOX_FULL) != 0 {}

    memory_barrier()
    mbox_write(MBOX_WRITE, value)

    return 0
}

// Read from mailbox channel (blocking)
export fn mailbox_read(channel: MailboxChannel): u32 {
    loop {
        // Wait until mailbox is not empty
        while (mbox_read(MBOX_STATUS) & MBOX_EMPTY) != 0 {}

        memory_barrier()
        let data = mbox_read(MBOX_READ)

        // Check if this is our channel
        if (data & 0xF) == (channel as u32) {
            return data & !0xF
        }
    }
}

// Call property channel and wait for response
fn property_call(): bool {
    unsafe {
        let buffer_addr = &PROP_BUFFER as *const _ as u32

        // Write buffer address to property channel
        mailbox_write(MailboxChannel::PropertyTagsArmToVc, buffer_addr)

        // Read response
        let response = mailbox_read(MailboxChannel::PropertyTagsArmToVc)

        // Check response
        return PROP_BUFFER.request_response_code == RESPONSE_SUCCESS
    }
}

// =============================================================================
// Property Tag Helpers
// =============================================================================

// Build a single-value property request
fn build_single_request(tag: u32, value_size: u32): usize {
    unsafe {
        PROP_BUFFER.buffer_size = 12 + 12 + value_size + 4  // Header + tag + end
        PROP_BUFFER.request_response_code = REQUEST_CODE
        PROP_BUFFER.tags[0] = tag
        PROP_BUFFER.tags[1] = value_size
        PROP_BUFFER.tags[2] = 0  // Request indicator
        // Response data goes in tags[3..]
        let end_idx = 3 + (value_size / 4) as usize
        PROP_BUFFER.tags[end_idx] = TAG_END
        return 3
    }
}

// Build request with input values
fn build_request_with_values(tag: u32, values: &[u32]): usize {
    unsafe {
        let value_size = (values.len() * 4) as u32
        PROP_BUFFER.buffer_size = 12 + 12 + value_size + 4
        PROP_BUFFER.request_response_code = REQUEST_CODE
        PROP_BUFFER.tags[0] = tag
        PROP_BUFFER.tags[1] = value_size
        PROP_BUFFER.tags[2] = 0
        for i in 0..values.len() {
            PROP_BUFFER.tags[3 + i] = values[i]
        }
        let end_idx = 3 + values.len()
        PROP_BUFFER.tags[end_idx] = TAG_END
        return 3
    }
}

// =============================================================================
// Hardware Information Queries
// =============================================================================

// Get firmware revision
export fn mailbox_get_firmware_revision(): u32 {
    unsafe {
        MAILBOX.lock.lock()
        let idx = build_single_request(TAG_GET_FIRMWARE_REV, 4)
        PROP_BUFFER.tags[idx] = 0
        let success = property_call()
        let result = if success { PROP_BUFFER.tags[idx] } else { 0 }
        MAILBOX.lock.unlock()
        return result
    }
}

// Get board model
export fn mailbox_get_board_model(): u32 {
    unsafe {
        MAILBOX.lock.lock()
        let idx = build_single_request(TAG_GET_BOARD_MODEL, 4)
        PROP_BUFFER.tags[idx] = 0
        let success = property_call()
        let result = if success { PROP_BUFFER.tags[idx] } else { 0 }
        MAILBOX.lock.unlock()
        return result
    }
}

// Get board revision
export fn mailbox_get_board_revision(): u32 {
    unsafe {
        MAILBOX.lock.lock()
        let idx = build_single_request(TAG_GET_BOARD_REVISION, 4)
        PROP_BUFFER.tags[idx] = 0
        let success = property_call()
        let result = if success { PROP_BUFFER.tags[idx] } else { 0 }
        MAILBOX.lock.unlock()
        return result
    }
}

// Get board serial number
export fn mailbox_get_board_serial(): u64 {
    unsafe {
        MAILBOX.lock.lock()
        let idx = build_single_request(TAG_GET_BOARD_SERIAL, 8)
        PROP_BUFFER.tags[idx] = 0
        PROP_BUFFER.tags[idx + 1] = 0
        let success = property_call()
        let result = if success {
            (PROP_BUFFER.tags[idx + 1] as u64) << 32 | PROP_BUFFER.tags[idx] as u64
        } else {
            0
        }
        MAILBOX.lock.unlock()
        return result
    }
}

// Get MAC address
export fn mailbox_get_mac_address(): [u8; 6] {
    unsafe {
        MAILBOX.lock.lock()
        let idx = build_single_request(TAG_GET_BOARD_MAC_ADDRESS, 6)
        PROP_BUFFER.tags[idx] = 0
        PROP_BUFFER.tags[idx + 1] = 0
        let success = property_call()

        let mut mac: [u8; 6] = [0u8; 6]
        if success {
            let word0 = PROP_BUFFER.tags[idx]
            let word1 = PROP_BUFFER.tags[idx + 1]
            mac[0] = (word0 & 0xFF) as u8
            mac[1] = ((word0 >> 8) & 0xFF) as u8
            mac[2] = ((word0 >> 16) & 0xFF) as u8
            mac[3] = ((word0 >> 24) & 0xFF) as u8
            mac[4] = (word1 & 0xFF) as u8
            mac[5] = ((word1 >> 8) & 0xFF) as u8
        }
        MAILBOX.lock.unlock()
        return mac
    }
}

// Get ARM memory (base and size)
export fn mailbox_get_arm_memory(): (u32, u32) {
    unsafe {
        MAILBOX.lock.lock()
        let idx = build_single_request(TAG_GET_ARM_MEMORY, 8)
        PROP_BUFFER.tags[idx] = 0
        PROP_BUFFER.tags[idx + 1] = 0
        let success = property_call()
        let result = if success {
            (PROP_BUFFER.tags[idx], PROP_BUFFER.tags[idx + 1])
        } else {
            (0, 0)
        }
        MAILBOX.lock.unlock()
        return result
    }
}

// Get VideoCore memory (base and size)
export fn mailbox_get_vc_memory(): (u32, u32) {
    unsafe {
        MAILBOX.lock.lock()
        let idx = build_single_request(TAG_GET_VC_MEMORY, 8)
        PROP_BUFFER.tags[idx] = 0
        PROP_BUFFER.tags[idx + 1] = 0
        let success = property_call()
        let result = if success {
            (PROP_BUFFER.tags[idx], PROP_BUFFER.tags[idx + 1])
        } else {
            (0, 0)
        }
        MAILBOX.lock.unlock()
        return result
    }
}

// =============================================================================
// Clock Functions
// =============================================================================

// Get clock rate
export fn mailbox_get_clock_rate(clock_id: ClockId): u32 {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 2] = [clock_id as u32, 0]
        let idx = build_request_with_values(TAG_GET_CLOCK_RATE, &values)
        let success = property_call()
        let result = if success { PROP_BUFFER.tags[idx + 1] } else { 0 }
        MAILBOX.lock.unlock()
        return result
    }
}

// Set clock rate
export fn mailbox_set_clock_rate(clock_id: ClockId, rate: u32, skip_turbo: bool): u32 {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 3] = [clock_id as u32, rate, if skip_turbo { 1 } else { 0 }]
        let idx = build_request_with_values(TAG_SET_CLOCK_RATE, &values)
        let success = property_call()
        let result = if success { PROP_BUFFER.tags[idx + 1] } else { 0 }
        MAILBOX.lock.unlock()
        return result
    }
}

// Get max clock rate
export fn mailbox_get_max_clock_rate(clock_id: ClockId): u32 {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 2] = [clock_id as u32, 0]
        let idx = build_request_with_values(TAG_GET_MAX_CLOCK_RATE, &values)
        let success = property_call()
        let result = if success { PROP_BUFFER.tags[idx + 1] } else { 0 }
        MAILBOX.lock.unlock()
        return result
    }
}

// Get min clock rate
export fn mailbox_get_min_clock_rate(clock_id: ClockId): u32 {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 2] = [clock_id as u32, 0]
        let idx = build_request_with_values(TAG_GET_MIN_CLOCK_RATE, &values)
        let success = property_call()
        let result = if success { PROP_BUFFER.tags[idx + 1] } else { 0 }
        MAILBOX.lock.unlock()
        return result
    }
}

// =============================================================================
// Power Functions
// =============================================================================

// Get power state
export fn mailbox_get_power_state(device_id: PowerDeviceId): (bool, bool) {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 2] = [device_id as u32, 0]
        let idx = build_request_with_values(TAG_GET_POWER_STATE, &values)
        let success = property_call()
        let result = if success {
            let state = PROP_BUFFER.tags[idx + 1]
            ((state & 0x1) != 0, (state & 0x2) != 0)  // (on, exists)
        } else {
            (false, false)
        }
        MAILBOX.lock.unlock()
        return result
    }
}

// Set power state
export fn mailbox_set_power_state(device_id: PowerDeviceId, on: bool, wait: bool): bool {
    unsafe {
        MAILBOX.lock.lock()
        let state = (if on { 1u32 } else { 0u32 }) | (if wait { 2u32 } else { 0u32 })
        let values: [u32; 2] = [device_id as u32, state]
        let idx = build_request_with_values(TAG_SET_POWER_STATE, &values)
        let success = property_call()
        let result = if success {
            (PROP_BUFFER.tags[idx + 1] & 0x1) != 0
        } else {
            false
        }
        MAILBOX.lock.unlock()
        return result
    }
}

// =============================================================================
// Temperature Functions
// =============================================================================

// Get temperature (returns milli-degrees Celsius)
export fn mailbox_get_temperature(): u32 {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 2] = [0, 0]  // Temperature ID = 0
        let idx = build_request_with_values(TAG_GET_TEMPERATURE, &values)
        let success = property_call()
        let result = if success { PROP_BUFFER.tags[idx + 1] } else { 0 }
        MAILBOX.lock.unlock()
        return result
    }
}

// Get max temperature
export fn mailbox_get_max_temperature(): u32 {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 2] = [0, 0]
        let idx = build_request_with_values(TAG_GET_MAX_TEMPERATURE, &values)
        let success = property_call()
        let result = if success { PROP_BUFFER.tags[idx + 1] } else { 0 }
        MAILBOX.lock.unlock()
        return result
    }
}

// =============================================================================
// Voltage Functions
// =============================================================================

// Get voltage (returns micro-volts offset from 1.2V)
export fn mailbox_get_voltage(voltage_id: VoltageId): u32 {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 2] = [voltage_id as u32, 0]
        let idx = build_request_with_values(TAG_GET_VOLTAGE, &values)
        let success = property_call()
        let result = if success { PROP_BUFFER.tags[idx + 1] } else { 0 }
        MAILBOX.lock.unlock()
        return result
    }
}

// Set voltage
export fn mailbox_set_voltage(voltage_id: VoltageId, value: u32): bool {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 2] = [voltage_id as u32, value]
        let idx = build_request_with_values(TAG_SET_VOLTAGE, &values)
        let success = property_call()
        MAILBOX.lock.unlock()
        return success
    }
}

// =============================================================================
// Memory Allocation
// =============================================================================

// Allocate GPU memory
// Returns handle (0 on failure)
export fn mailbox_allocate_memory(size: u32, alignment: u32, flags: u32): u32 {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 3] = [size, alignment, flags]
        let idx = build_request_with_values(TAG_ALLOCATE_MEMORY, &values)
        let success = property_call()
        let result = if success { PROP_BUFFER.tags[idx] } else { 0 }
        MAILBOX.lock.unlock()
        return result
    }
}

// Lock memory (get bus address)
export fn mailbox_lock_memory(handle: u32): u32 {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 1] = [handle]
        let idx = build_request_with_values(TAG_LOCK_MEMORY, &values)
        let success = property_call()
        let result = if success { PROP_BUFFER.tags[idx] } else { 0 }
        MAILBOX.lock.unlock()
        return result
    }
}

// Unlock memory
export fn mailbox_unlock_memory(handle: u32): bool {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 1] = [handle]
        build_request_with_values(TAG_UNLOCK_MEMORY, &values)
        let success = property_call()
        MAILBOX.lock.unlock()
        return success
    }
}

// Release memory
export fn mailbox_release_memory(handle: u32): bool {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 1] = [handle]
        build_request_with_values(TAG_RELEASE_MEMORY, &values)
        let success = property_call()
        MAILBOX.lock.unlock()
        return success
    }
}

// =============================================================================
// Framebuffer Functions
// =============================================================================

struct FramebufferInfo {
    width: u32,
    height: u32,
    virtual_width: u32,
    virtual_height: u32,
    pitch: u32,
    depth: u32,
    x_offset: u32,
    y_offset: u32,
    pointer: u32,
    size: u32,
}

// Allocate framebuffer
export fn mailbox_allocate_framebuffer(
    width: u32,
    height: u32,
    depth: u32
): Option<FramebufferInfo> {
    unsafe {
        MAILBOX.lock.lock()

        // Build multi-tag request
        let mut idx: usize = 0

        // Set physical size
        PROP_BUFFER.tags[idx] = TAG_SET_PHYSICAL_SIZE
        PROP_BUFFER.tags[idx + 1] = 8
        PROP_BUFFER.tags[idx + 2] = 0
        PROP_BUFFER.tags[idx + 3] = width
        PROP_BUFFER.tags[idx + 4] = height
        idx += 5

        // Set virtual size
        PROP_BUFFER.tags[idx] = TAG_SET_VIRTUAL_SIZE
        PROP_BUFFER.tags[idx + 1] = 8
        PROP_BUFFER.tags[idx + 2] = 0
        PROP_BUFFER.tags[idx + 3] = width
        PROP_BUFFER.tags[idx + 4] = height
        idx += 5

        // Set depth
        PROP_BUFFER.tags[idx] = TAG_SET_DEPTH
        PROP_BUFFER.tags[idx + 1] = 4
        PROP_BUFFER.tags[idx + 2] = 0
        PROP_BUFFER.tags[idx + 3] = depth
        idx += 4

        // Allocate buffer
        PROP_BUFFER.tags[idx] = TAG_ALLOCATE_BUFFER
        PROP_BUFFER.tags[idx + 1] = 8
        PROP_BUFFER.tags[idx + 2] = 0
        PROP_BUFFER.tags[idx + 3] = 16  // Alignment
        PROP_BUFFER.tags[idx + 4] = 0   // Size (response)
        idx += 5

        // Get pitch
        PROP_BUFFER.tags[idx] = TAG_GET_PITCH
        PROP_BUFFER.tags[idx + 1] = 4
        PROP_BUFFER.tags[idx + 2] = 0
        PROP_BUFFER.tags[idx + 3] = 0
        idx += 4

        // End tag
        PROP_BUFFER.tags[idx] = TAG_END
        idx += 1

        PROP_BUFFER.buffer_size = (12 + idx * 4) as u32
        PROP_BUFFER.request_response_code = REQUEST_CODE

        if !property_call() {
            MAILBOX.lock.unlock()
            return None
        }

        // Parse response
        let fb_pointer = PROP_BUFFER.tags[18] & 0x3FFFFFFF  // Clear upper bits
        let fb_size = PROP_BUFFER.tags[19]
        let pitch = PROP_BUFFER.tags[23]

        let info = FramebufferInfo {
            width: width,
            height: height,
            virtual_width: width,
            virtual_height: height,
            pitch: pitch,
            depth: depth,
            x_offset: 0,
            y_offset: 0,
            pointer: fb_pointer,
            size: fb_size,
        }

        MAILBOX.lock.unlock()
        return Some(info)
    }
}

// Get physical display size
export fn mailbox_get_physical_size(): (u32, u32) {
    unsafe {
        MAILBOX.lock.lock()
        let idx = build_single_request(TAG_GET_PHYSICAL_SIZE, 8)
        PROP_BUFFER.tags[idx] = 0
        PROP_BUFFER.tags[idx + 1] = 0
        let success = property_call()
        let result = if success {
            (PROP_BUFFER.tags[idx], PROP_BUFFER.tags[idx + 1])
        } else {
            (0, 0)
        }
        MAILBOX.lock.unlock()
        return result
    }
}

// Set virtual offset (for double buffering)
export fn mailbox_set_virtual_offset(x: u32, y: u32): bool {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 2] = [x, y]
        build_request_with_values(TAG_SET_VIRTUAL_OFFSET, &values)
        let success = property_call()
        MAILBOX.lock.unlock()
        return success
    }
}

// Blank screen
export fn mailbox_blank_screen(blank: bool): bool {
    unsafe {
        MAILBOX.lock.lock()
        let values: [u32; 1] = [if blank { 1 } else { 0 }]
        build_request_with_values(TAG_BLANK_SCREEN, &values)
        let success = property_call()
        MAILBOX.lock.unlock()
        return success
    }
}

// =============================================================================
// Command Line
// =============================================================================

export fn mailbox_get_command_line(buffer: &mut [u8]): usize {
    unsafe {
        MAILBOX.lock.lock()

        let max_len = buffer.len().min(256)
        PROP_BUFFER.buffer_size = (12 + 12 + max_len + 4) as u32
        PROP_BUFFER.request_response_code = REQUEST_CODE
        PROP_BUFFER.tags[0] = TAG_GET_COMMAND_LINE
        PROP_BUFFER.tags[1] = max_len as u32
        PROP_BUFFER.tags[2] = 0

        // Clear buffer area
        for i in 0..max_len / 4 {
            PROP_BUFFER.tags[3 + i] = 0
        }

        PROP_BUFFER.tags[3 + max_len / 4] = TAG_END

        if !property_call() {
            MAILBOX.lock.unlock()
            return 0
        }

        // Copy response to buffer
        let response_len = (PROP_BUFFER.tags[2] & 0x7FFFFFFF) as usize
        let copy_len = response_len.min(max_len)

        let src = &PROP_BUFFER.tags[3] as *const u32 as *const u8
        for i in 0..copy_len {
            buffer[i] = *src.add(i)
        }

        MAILBOX.lock.unlock()
        return copy_len
    }
}

// =============================================================================
// DMA Channels
// =============================================================================

export fn mailbox_get_dma_channels(): u32 {
    unsafe {
        MAILBOX.lock.lock()
        let idx = build_single_request(TAG_GET_DMA_CHANNELS, 4)
        PROP_BUFFER.tags[idx] = 0
        let success = property_call()
        let result = if success { PROP_BUFFER.tags[idx] } else { 0 }
        MAILBOX.lock.unlock()
        return result
    }
}

// =============================================================================
// EDID (Display Info)
// =============================================================================

export fn mailbox_get_edid(block: u32, buffer: &mut [u8; 128]): bool {
    unsafe {
        MAILBOX.lock.lock()

        PROP_BUFFER.buffer_size = 12 + 12 + 136 + 4
        PROP_BUFFER.request_response_code = REQUEST_CODE
        PROP_BUFFER.tags[0] = TAG_GET_EDID_BLOCK
        PROP_BUFFER.tags[1] = 136
        PROP_BUFFER.tags[2] = 0
        PROP_BUFFER.tags[3] = block

        for i in 0..32 {
            PROP_BUFFER.tags[4 + i] = 0
        }
        PROP_BUFFER.tags[36] = TAG_END

        if !property_call() {
            MAILBOX.lock.unlock()
            return false
        }

        // Check status
        if PROP_BUFFER.tags[4] != 0 {
            MAILBOX.lock.unlock()
            return false
        }

        // Copy EDID data
        let src = &PROP_BUFFER.tags[5] as *const u32 as *const u8
        for i in 0..128 {
            buffer[i] = *src.add(i)
        }

        MAILBOX.lock.unlock()
        return true
    }
}
