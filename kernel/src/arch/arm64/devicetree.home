// home-os Kernel - Device Tree Parser
// Parse Flattened Device Tree (FDT) for hardware discovery

import "../../core/foundation.home" as foundation

// FDT header magic
const FDT_MAGIC: u32 = 0xD00DFEED

// FDT tokens
const FDT_BEGIN_NODE: u32 = 0x00000001
const FDT_END_NODE: u32 = 0x00000002
const FDT_PROP: u32 = 0x00000003
const FDT_NOP: u32 = 0x00000004
const FDT_END: u32 = 0x00000009

struct FDTHeader {
  magic: u32,
  totalsize: u32,
  off_dt_struct: u32,
  off_dt_strings: u32,
  off_mem_rsvmap: u32,
  version: u32,
  last_comp_version: u32,
  boot_cpuid_phys: u32,
  size_dt_strings: u32,
  size_dt_struct: u32
}

var fdt_base: u64 = 0
var dt_initialized: u32 = 0

export fn devicetree_init(fdt_addr: u64) {
  if dt_initialized == 1 { return }
  
  fdt_base = fdt_addr
  
  // Verify magic
  var magic: u32 = dt_read_be32(fdt_addr)
  if magic != FDT_MAGIC {
    foundation.serial_write_string("[DT] Invalid FDT magic: 0x")
    foundation.serial_write_hex(magic)
    foundation.serial_write_string("\n")
    return
  }
  
  var version: u32 = dt_read_be32(fdt_addr + 20)
  foundation.serial_write_string("[DT] Device Tree version ")
  foundation.serial_write_hex(version)
  foundation.serial_write_string("\n")
  
  dt_initialized = 1
  
  // Parse device tree
  devicetree_parse()
}

fn devicetree_parse() {
  var header: FDTHeader
  header.magic = dt_read_be32(fdt_base)
  header.totalsize = dt_read_be32(fdt_base + 4)
  header.off_dt_struct = dt_read_be32(fdt_base + 8)
  header.off_dt_strings = dt_read_be32(fdt_base + 12)
  
  foundation.serial_write_string("[DT] Parsing device tree...\n")
  
  var struct_ptr: u64 = fdt_base + header.off_dt_struct
  var strings_ptr: u64 = fdt_base + header.off_dt_strings
  
  dt_parse_node(struct_ptr, strings_ptr, 0)
}

fn dt_parse_node(struct_ptr: u64, strings_ptr: u64, depth: u32) -> u64 {
  var ptr: u64 = struct_ptr
  
  while 1 == 1 {
    var token: u32 = dt_read_be32(ptr)
    ptr = ptr + 4
    
    if token == FDT_BEGIN_NODE {
      // Node name
      var name: u64 = ptr
      var name_len: u32 = dt_strlen(name)
      
      // Print node
      var i: u32 = 0
      while i < depth {
        foundation.serial_write_string("  ")
        i = i + 1
      }
      foundation.serial_write_string("[DT] Node: ")
      foundation.serial_write_string(name)
      foundation.serial_write_string("\n")
      
      ptr = ptr + ((name_len + 4) & ~3)
      
      // Parse child nodes and properties
      ptr = dt_parse_node(ptr, strings_ptr, depth + 1)
      
    } else if token == FDT_PROP {
      var len: u32 = dt_read_be32(ptr)
      ptr = ptr + 4
      var nameoff: u32 = dt_read_be32(ptr)
      ptr = ptr + 4
      
      var prop_name: u64 = strings_ptr + nameoff
      var prop_value: u64 = ptr
      
      // Print property
      var i: u32 = 0
      while i < depth {
        foundation.serial_write_string("  ")
        i = i + 1
      }
      foundation.serial_write_string("[DT]   ")
      foundation.serial_write_string(prop_name)
      foundation.serial_write_string(" = ")
      
      if len == 4 {
        foundation.serial_write_hex(dt_read_be32(prop_value))
      }
      foundation.serial_write_string("\n")
      
      ptr = ptr + ((len + 3) & ~3)
      
    } else if token == FDT_END_NODE {
      return ptr
      
    } else if token == FDT_NOP {
      continue
      
    } else if token == FDT_END {
      return ptr
    }
  }
  
  return ptr
}

fn dt_read_be32(addr: u64) -> u32 {
  var b0: u32 = @intToPtr(addr, u8)
  var b1: u32 = @intToPtr(addr + 1, u8)
  var b2: u32 = @intToPtr(addr + 2, u8)
  var b3: u32 = @intToPtr(addr + 3, u8)
  
  return (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
}

fn dt_strlen(str: u64) -> u32 {
  var len: u32 = 0
  while @intToPtr(str + len, u8) != 0 {
    len = len + 1
  }
  return len
}

export fn devicetree_get_property(path: u64, prop_name: u64, value_out: u64, size_out: u64) -> u32 {
  // Find node by path and get property
  // Simplified implementation
  return 0
}

export fn devicetree_get_memory_size() -> u64 {
  // Parse /memory node to get RAM size
  return 4 * 1024 * 1024 * 1024  // Default 4GB
}

export fn devicetree_get_cpu_count() -> u32 {
  // Count /cpus/cpu@* nodes
  return 4  // Default 4 cores
}

export fn devicetree_find_compatible(compatible: u64) -> u64 {
  // Find first node with matching compatible string
  return 0
}
