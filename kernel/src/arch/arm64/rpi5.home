// home-os Kernel - Raspberry Pi 5 Support
// BCM2712 SoC and RP1 I/O controller

import "../../core/foundation.home" as foundation

// BCM2712 peripheral base addresses
const BCM2712_PERIPH_BASE: u64 = 0x1F00000000

// RP1 I/O controller (PCIe-connected southbridge)
const RP1_BASE: u64 = 0x1F000D0000
const RP1_IO_BANK0: u64 = RP1_BASE + 0x00000
const RP1_SYS_RIO0: u64 = RP1_BASE + 0x10000
const RP1_PADS_BANK0: u64 = RP1_BASE + 0x20000
const RP1_UART0: u64 = RP1_BASE + 0x30000
const RP1_SPI0: u64 = RP1_BASE + 0x50000
const RP1_I2C0: u64 = RP1_BASE + 0x70000
const RP1_PWM0: u64 = RP1_BASE + 0x98000
const RP1_ETH: u64 = RP1_BASE + 0x100000

// PCIe configuration
const PCIE_BASE: u64 = BCM2712_PERIPH_BASE + 0x120000
const PCIE_CONFIG_BASE: u64 = 0x1F00100000

// Video Core VII GPU
const VC7_BASE: u64 = BCM2712_PERIPH_BASE + 0x400000

var rpi5_initialized: u32 = 0

export fn rpi5_init() {
  if rpi5_initialized == 1 { return }
  
  foundation.serial_write_string("[RPI5] Initializing Raspberry Pi 5...\n")
  
  // Initialize PCIe for RP1 access
  rpi5_pcie_init()
  
  // Initialize RP1 I/O controller
  rpi5_rp1_init()
  
  // Initialize UART via RP1
  rpi5_uart_init()
  
  // Initialize GPIO via RP1
  rpi5_gpio_init()
  
  // Initialize Ethernet
  rpi5_eth_init()
  
  rpi5_initialized = 1
  foundation.serial_write_string("[RPI5] Initialization complete\n")
}

fn rpi5_pcie_init() {
  foundation.serial_write_string("[RPI5] Initializing PCIe Gen 2.0...\n")
  
  // Enable PCIe controller
  var pcie_ctrl: u64 = PCIE_BASE + 0x00
  @intToPtr(pcie_ctrl, u32) = 1
  
  // Wait for link up
  var timeout: u32 = 1000000
  while timeout > 0 {
    var status: u32 = @intToPtr(PCIE_BASE + 0x04, u32)
    if (status & 0x1) != 0 {
      break
    }
    timeout = timeout - 1
  }
  
  foundation.serial_write_string("[RPI5] PCIe link established\n")
}

fn rpi5_rp1_init() {
  foundation.serial_write_string("[RPI5] Initializing RP1 southbridge...\n")
  
  // Reset RP1
  var reset_reg: u64 = RP1_SYS_RIO0 + 0x00
  @intToPtr(reset_reg, u32) = 0
  rpi5_delay(1000)
  @intToPtr(reset_reg, u32) = 1
  rpi5_delay(1000)
  
  foundation.serial_write_string("[RPI5] RP1 initialized\n")
}

fn rpi5_uart_init() {
  // Configure UART0 via RP1
  var uart_ctrl: u64 = RP1_UART0 + 0x30  // UARTCR
  
  // Disable UART
  @intToPtr(uart_ctrl, u32) = 0
  
  // Set baud rate (115200)
  var ibrd: u64 = RP1_UART0 + 0x24  // UARTIBRD
  var fbrd: u64 = RP1_UART0 + 0x28  // UARTFBRD
  @intToPtr(ibrd, u32) = 26  // Integer part
  @intToPtr(fbrd, u32) = 3   // Fractional part
  
  // Set line control (8N1)
  var lcrh: u64 = RP1_UART0 + 0x2C  // UARTLCR_H
  @intToPtr(lcrh, u32) = 0x70  // 8 bits, FIFO enabled
  
  // Enable UART
  @intToPtr(uart_ctrl, u32) = 0x301  // Enable TX, RX, UART
  
  foundation.serial_write_string("[RPI5] UART initialized\n")
}

fn rpi5_gpio_init() {
  foundation.serial_write_string("[RPI5] GPIO initialized via RP1\n")
}

fn rpi5_eth_init() {
  foundation.serial_write_string("[RPI5] Initializing Gigabit Ethernet (BCM54213S)...\n")
  
  // Initialize Ethernet MAC via RP1
  var eth_ctrl: u64 = RP1_ETH + 0x00
  @intToPtr(eth_ctrl, u32) = 1
  
  foundation.serial_write_string("[RPI5] Ethernet initialized\n")
}

export fn rpi5_uart_putc(c: u8) {
  // Wait for TX FIFO not full
  var fr: u64 = RP1_UART0 + 0x18  // UARTFR
  while (@intToPtr(fr, u32) & 0x20) != 0 {}
  
  var dr: u64 = RP1_UART0 + 0x00  // UARTDR
  @intToPtr(dr, u32) = c
}

export fn rpi5_uart_getc() -> u8 {
  // Wait for RX FIFO not empty
  var fr: u64 = RP1_UART0 + 0x18  // UARTFR
  while (@intToPtr(fr, u32) & 0x10) != 0 {}
  
  var dr: u64 = RP1_UART0 + 0x00  // UARTDR
  return @truncate(@intToPtr(dr, u32), u8)
}

export fn rpi5_gpio_set(pin: u32) {
  if pin >= 28 { return }
  
  var set_reg: u64 = RP1_IO_BANK0 + 0x2000 + (pin * 8)
  @intToPtr(set_reg, u32) = 1 << (pin % 32)
}

export fn rpi5_gpio_clear(pin: u32) {
  if pin >= 28 { return }
  
  var clr_reg: u64 = RP1_IO_BANK0 + 0x3000 + (pin * 8)
  @intToPtr(clr_reg, u32) = 1 << (pin % 32)
}

export fn rpi5_gpio_function(pin: u32, func: u32) {
  if pin >= 28 { return }
  
  var ctrl_reg: u64 = RP1_IO_BANK0 + (pin * 8) + 0x04
  var val: u32 = @intToPtr(ctrl_reg, u32)
  val = val & ~0x1F
  val = val | (func & 0x1F)
  @intToPtr(ctrl_reg, u32) = val
}

export fn rpi5_get_board_revision() -> u32 {
  // Read board revision via firmware mailbox
  return 0xD04170  // Pi 5 revision code
}

export fn rpi5_get_arm_memory() -> u64 {
  // Raspberry Pi 5 has 4GB or 8GB
  return 8 * 1024 * 1024 * 1024  // 8GB
}

export fn rpi5_get_cpu_freq() -> u32 {
  // ARM Cortex-A76 @ 2.4GHz
  return 2400000000
}

fn rpi5_delay(count: u32) {
  var i: u32 = 0
  while i < count {
    foundation.nop()
    i = i + 1
  }
}

// Video Core VII GPU support
export fn rpi5_gpu_init() {
  foundation.serial_write_string("[RPI5] Initializing Video Core VII GPU...\n")
  
  // Initialize Vulkan 1.2 support
  var gpu_ctrl: u64 = VC7_BASE + 0x00
  @intToPtr(gpu_ctrl, u32) = 1
  
  foundation.serial_write_string("[RPI5] GPU initialized (Vulkan 1.2, OpenGL ES 3.1)\n")
}

// PCIe NVMe support
export fn rpi5_nvme_init() {
  foundation.serial_write_string("[RPI5] Scanning for NVMe devices...\n")
  
  // Scan PCIe bus for NVMe controllers
  var bus: u32 = 0
  var dev: u32 = 0
  var func: u32 = 0
  
  while bus < 1 {
    while dev < 32 {
      var config_addr: u64 = PCIE_CONFIG_BASE + (bus << 20) + (dev << 15) + (func << 12)
      var vendor_id: u32 = @intToPtr(config_addr, u32)
      
      if vendor_id != 0xFFFFFFFF and vendor_id != 0 {
        var class_code: u32 = @intToPtr(config_addr + 0x08, u32)
        
        // Check for NVMe controller (class 0x010802)
        if (class_code >> 8) == 0x010802 {
          foundation.serial_write_string("[RPI5] Found NVMe controller at ")
          foundation.serial_write_hex(bus)
          foundation.serial_write_string(":")
          foundation.serial_write_hex(dev)
          foundation.serial_write_string("\n")
        }
      }
      
      dev = dev + 1
    }
    bus = bus + 1
  }
}

// Power management
export fn rpi5_set_cpu_freq(freq_mhz: u32) {
  foundation.serial_write_string("[RPI5] Setting CPU frequency to ")
  foundation.serial_write_hex(freq_mhz)
  foundation.serial_write_string(" MHz\n")
  
  // CPU frequency scaling via firmware
}

export fn rpi5_get_temperature() -> u32 {
  // Read CPU temperature
  return 45  // Placeholder
}
