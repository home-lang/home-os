// home-os Kernel - Raspberry Pi 3 B+ Support
// BCM2837B0 SoC (Cortex-A53 quad-core @ 1.4GHz)
// Minimal boot path optimized for 1GB RAM

import "../../core/foundation.home" as foundation

// ============================================================================
// BCM2837 PERIPHERAL BASE ADDRESSES
// ============================================================================

// Pi 3 uses different peripheral base than Pi 4
const PERIPH_BASE: u64 = 0x3F000000      // BCM2837 peripheral base

// UART (Mini UART via AUX)
const AUX_BASE: u64 = PERIPH_BASE + 0x215000
const AUX_ENABLES: u64 = AUX_BASE + 0x04
const AUX_MU_IO: u64 = AUX_BASE + 0x40
const AUX_MU_IER: u64 = AUX_BASE + 0x44
const AUX_MU_IIR: u64 = AUX_BASE + 0x48
const AUX_MU_LCR: u64 = AUX_BASE + 0x4C
const AUX_MU_MCR: u64 = AUX_BASE + 0x50
const AUX_MU_LSR: u64 = AUX_BASE + 0x54
const AUX_MU_CNTL: u64 = AUX_BASE + 0x60
const AUX_MU_BAUD: u64 = AUX_BASE + 0x68

// PL011 UART (primary UART)
const UART0_BASE: u64 = PERIPH_BASE + 0x201000
const UART0_DR: u64 = UART0_BASE + 0x00
const UART0_FR: u64 = UART0_BASE + 0x18
const UART0_IBRD: u64 = UART0_BASE + 0x24
const UART0_FBRD: u64 = UART0_BASE + 0x28
const UART0_LCRH: u64 = UART0_BASE + 0x2C
const UART0_CR: u64 = UART0_BASE + 0x30
const UART0_IMSC: u64 = UART0_BASE + 0x38
const UART0_ICR: u64 = UART0_BASE + 0x44

// GPIO
const GPIO_BASE: u64 = PERIPH_BASE + 0x200000
const GPFSEL0: u64 = GPIO_BASE + 0x00
const GPFSEL1: u64 = GPIO_BASE + 0x04
const GPFSEL2: u64 = GPIO_BASE + 0x08
const GPFSEL3: u64 = GPIO_BASE + 0x0C
const GPFSEL4: u64 = GPIO_BASE + 0x10
const GPFSEL5: u64 = GPIO_BASE + 0x14
const GPSET0: u64 = GPIO_BASE + 0x1C
const GPSET1: u64 = GPIO_BASE + 0x20
const GPCLR0: u64 = GPIO_BASE + 0x28
const GPCLR1: u64 = GPIO_BASE + 0x2C
const GPLEV0: u64 = GPIO_BASE + 0x34
const GPLEV1: u64 = GPIO_BASE + 0x38
const GPPUD: u64 = GPIO_BASE + 0x94
const GPPUDCLK0: u64 = GPIO_BASE + 0x98
const GPPUDCLK1: u64 = GPIO_BASE + 0x9C

// Mailbox
const MBOX_BASE: u64 = PERIPH_BASE + 0xB880
const MBOX_READ: u64 = MBOX_BASE + 0x00
const MBOX_POLL: u64 = MBOX_BASE + 0x10
const MBOX_SENDER: u64 = MBOX_BASE + 0x14
const MBOX_STATUS: u64 = MBOX_BASE + 0x18
const MBOX_CONFIG: u64 = MBOX_BASE + 0x1C
const MBOX_WRITE: u64 = MBOX_BASE + 0x20

// System Timer
const SYSTIMER_BASE: u64 = PERIPH_BASE + 0x3000
const SYSTIMER_CS: u64 = SYSTIMER_BASE + 0x00
const SYSTIMER_CLO: u64 = SYSTIMER_BASE + 0x04
const SYSTIMER_CHI: u64 = SYSTIMER_BASE + 0x08
const SYSTIMER_C0: u64 = SYSTIMER_BASE + 0x0C
const SYSTIMER_C1: u64 = SYSTIMER_BASE + 0x10
const SYSTIMER_C2: u64 = SYSTIMER_BASE + 0x14
const SYSTIMER_C3: u64 = SYSTIMER_BASE + 0x18

// Interrupt Controller
const IRQ_BASE: u64 = PERIPH_BASE + 0xB200
const IRQ_BASIC_PENDING: u64 = IRQ_BASE + 0x00
const IRQ_PENDING_1: u64 = IRQ_BASE + 0x04
const IRQ_PENDING_2: u64 = IRQ_BASE + 0x08
const IRQ_ENABLE_1: u64 = IRQ_BASE + 0x10
const IRQ_ENABLE_2: u64 = IRQ_BASE + 0x14
const IRQ_ENABLE_BASIC: u64 = IRQ_BASE + 0x18
const IRQ_DISABLE_1: u64 = IRQ_BASE + 0x1C
const IRQ_DISABLE_2: u64 = IRQ_BASE + 0x20
const IRQ_DISABLE_BASIC: u64 = IRQ_BASE + 0x24

// SD/EMMC
const EMMC_BASE: u64 = PERIPH_BASE + 0x300000

// Ethernet (USB via LAN9514)
const USB_BASE: u64 = PERIPH_BASE + 0x980000

// WiFi/Bluetooth (CYW43455)
const WIFI_SDIO_BASE: u64 = PERIPH_BASE + 0x300000  // Shared with EMMC

// ============================================================================
// MAILBOX CHANNELS
// ============================================================================

const MBOX_CH_POWER: u32 = 0
const MBOX_CH_FB: u32 = 1
const MBOX_CH_VUART: u32 = 2
const MBOX_CH_VCHIQ: u32 = 3
const MBOX_CH_LEDS: u32 = 4
const MBOX_CH_BTNS: u32 = 5
const MBOX_CH_TOUCH: u32 = 6
const MBOX_CH_COUNT: u32 = 7
const MBOX_CH_PROP: u32 = 8

// Mailbox status flags
const MBOX_FULL: u32 = 0x80000000
const MBOX_EMPTY: u32 = 0x40000000

// ============================================================================
// CLOCK IDs
// ============================================================================

const CLOCK_RESERVED: u32 = 0
const CLOCK_EMMC: u32 = 1
const CLOCK_UART: u32 = 2
const CLOCK_ARM: u32 = 3
const CLOCK_CORE: u32 = 4
const CLOCK_V3D: u32 = 5
const CLOCK_H264: u32 = 6
const CLOCK_ISP: u32 = 7
const CLOCK_SDRAM: u32 = 8
const CLOCK_PIXEL: u32 = 9
const CLOCK_PWM: u32 = 10
const CLOCK_HEVC: u32 = 11
const CLOCK_EMMC2: u32 = 12
const CLOCK_M2MC: u32 = 13
const CLOCK_PIXEL_BVB: u32 = 14

// ============================================================================
// STATE
// ============================================================================

var rpi3_initialized: u32 = 0
var rpi3_board_revision: u32 = 0
var rpi3_arm_memory_base: u64 = 0
var rpi3_arm_memory_size: u64 = 0

// ============================================================================
// DELAY FUNCTIONS
// ============================================================================

fn rpi3_delay_cycles(count: u32) {
  var i: u32 = 0
  loop {
    if i >= count { break }
    // ARM64 NOP
    asm volatile ("nop")
    i = i + 1
  }
}

fn rpi3_delay_us(us: u32) {
  // System timer runs at 1MHz
  let start: u32 = mmio_read(SYSTIMER_CLO)
  loop {
    let current: u32 = mmio_read(SYSTIMER_CLO)
    if (current - start) >= us { break }
  }
}

// ============================================================================
// MMIO HELPERS
// ============================================================================

fn mmio_write(addr: u64, val: u32) {
  let ptr: *volatile u32 = addr
  *ptr = val
}

fn mmio_read(addr: u64): u32 {
  let ptr: *volatile u32 = addr
  return *ptr
}

// ============================================================================
// UART INITIALIZATION
// ============================================================================

fn rpi3_uart_init() {
  // Disable UART0
  mmio_write(UART0_CR, 0)

  // Setup GPIO pins 14 and 15 for UART
  // GPIO14 = TXD0, GPIO15 = RXD0

  // Disable pull-up/down for all GPIO pins
  mmio_write(GPPUD, 0)
  rpi3_delay_cycles(150)

  // Disable pull-up/down for pins 14, 15
  mmio_write(GPPUDCLK0, (1 << 14) | (1 << 15))
  rpi3_delay_cycles(150)

  // Clear the modification
  mmio_write(GPPUDCLK0, 0)

  // Clear pending interrupts
  mmio_write(UART0_ICR, 0x7FF)

  // Set integer & fractional part of baud rate
  // Divider = UART_CLOCK/(16 * Baud)
  // UART_CLOCK = 48MHz (from GPU)
  // Baud = 115200
  // Divider = 48000000 / (16 * 115200) = 26.0417
  // Integer = 26, Fractional = 0.0417 * 64 = 2.67 â‰ˆ 3
  mmio_write(UART0_IBRD, 26)
  mmio_write(UART0_FBRD, 3)

  // Enable FIFO & 8 bit data transmission (1 stop bit, no parity)
  mmio_write(UART0_LCRH, (1 << 4) | (1 << 5) | (1 << 6))

  // Mask all interrupts
  mmio_write(UART0_IMSC, (1 << 1) | (1 << 4) | (1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9) | (1 << 10))

  // Enable UART0, receive & transmit
  mmio_write(UART0_CR, (1 << 0) | (1 << 8) | (1 << 9))

  foundation.serial_write_string("[RPI3] UART0 initialized at 115200 baud\n")
}

// ============================================================================
// GPIO FUNCTIONS
// ============================================================================

fn rpi3_gpio_init() {
  // GPIO is mostly ready after UART init
  foundation.serial_write_string("[RPI3] GPIO initialized\n")
}

export fn rpi3_gpio_set_function(pin: u32, func: u32) {
  if pin > 53 { return }

  let reg_offset: u32 = (pin / 10) * 4
  let bit_offset: u32 = (pin % 10) * 3
  let reg_addr: u64 = GPFSEL0 + reg_offset

  var val: u32 = mmio_read(reg_addr)
  val = val & ~(7 << bit_offset)
  val = val | ((func & 7) << bit_offset)
  mmio_write(reg_addr, val)
}

export fn rpi3_gpio_set(pin: u32) {
  if pin > 53 { return }

  if pin < 32 {
    mmio_write(GPSET0, 1 << pin)
  } else {
    mmio_write(GPSET1, 1 << (pin - 32))
  }
}

export fn rpi3_gpio_clear(pin: u32) {
  if pin > 53 { return }

  if pin < 32 {
    mmio_write(GPCLR0, 1 << pin)
  } else {
    mmio_write(GPCLR1, 1 << (pin - 32))
  }
}

export fn rpi3_gpio_read(pin: u32): u32 {
  if pin > 53 { return 0 }

  if pin < 32 {
    return (mmio_read(GPLEV0) >> pin) & 1
  } else {
    return (mmio_read(GPLEV1) >> (pin - 32)) & 1
  }
}

// ============================================================================
// MAILBOX FUNCTIONS
// ============================================================================

fn rpi3_mailbox_init() {
  foundation.serial_write_string("[RPI3] Mailbox initialized\n")
}

export fn rpi3_mailbox_call(channel: u32, data: u64): u32 {
  // Combine data address with channel
  let msg: u32 = ((data & 0xFFFFFFF0) | (channel & 0xF))

  // Wait until we can write to the mailbox
  loop {
    if (mmio_read(MBOX_STATUS) & MBOX_FULL) == 0 { break }
  }

  // Write the message
  mmio_write(MBOX_WRITE, msg)

  // Wait for response
  loop {
    loop {
      if (mmio_read(MBOX_STATUS) & MBOX_EMPTY) == 0 { break }
    }

    let response: u32 = mmio_read(MBOX_READ)

    // Is it a response to our message?
    if (response & 0xF) == channel {
      // Return success status
      let status_ptr: *u32 = (data + 4)
      return *status_ptr
    }
  }
}

// ============================================================================
// SYSTEM INFORMATION
// ============================================================================

export fn rpi3_get_board_revision(): u32 {
  // 16-byte aligned buffer
  var __attribute__((aligned(16))) buffer: [8]u32

  buffer[0] = 32           // Buffer size
  buffer[1] = 0            // Request code
  buffer[2] = 0x00010002   // Tag: Get board revision
  buffer[3] = 4            // Value buffer size
  buffer[4] = 0            // Request/response code
  buffer[5] = 0            // Value (will be filled)
  buffer[6] = 0            // End tag
  buffer[7] = 0            // Padding

  rpi3_mailbox_call(MBOX_CH_PROP, &buffer)

  return buffer[5]
}

export fn rpi3_get_arm_memory(): u64 {
  var __attribute__((aligned(16))) buffer: [9]u32

  buffer[0] = 36
  buffer[1] = 0
  buffer[2] = 0x00010005   // Tag: Get ARM memory
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0            // Base
  buffer[6] = 0            // Size
  buffer[7] = 0            // End tag
  buffer[8] = 0

  rpi3_mailbox_call(MBOX_CH_PROP, &buffer)

  rpi3_arm_memory_base = buffer[5]
  rpi3_arm_memory_size = buffer[6]

  return rpi3_arm_memory_size
}

export fn rpi3_get_clock_rate(clock_id: u32): u32 {
  var __attribute__((aligned(16))) buffer: [9]u32

  buffer[0] = 36
  buffer[1] = 0
  buffer[2] = 0x00030002   // Tag: Get clock rate
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = clock_id
  buffer[6] = 0            // Rate (will be filled)
  buffer[7] = 0
  buffer[8] = 0

  rpi3_mailbox_call(MBOX_CH_PROP, &buffer)

  return buffer[6]
}

export fn rpi3_set_clock_rate(clock_id: u32, rate: u32): u32 {
  var __attribute__((aligned(16))) buffer: [10]u32

  buffer[0] = 40
  buffer[1] = 0
  buffer[2] = 0x00038002   // Tag: Set clock rate
  buffer[3] = 12
  buffer[4] = 0
  buffer[5] = clock_id
  buffer[6] = rate
  buffer[7] = 0            // Skip turbo
  buffer[8] = 0
  buffer[9] = 0

  rpi3_mailbox_call(MBOX_CH_PROP, &buffer)

  return buffer[6]
}

// ============================================================================
// SD CARD INITIALIZATION
// ============================================================================

fn rpi3_sd_init() {
  // Set EMMC clock to 400kHz for initialization
  rpi3_set_clock_rate(CLOCK_EMMC, 400000)

  // Configure GPIO for SD card
  // GPIO 48-53 are used for SD card

  // SD_CLK  = GPIO 48 (ALT3)
  // SD_CMD  = GPIO 49 (ALT3)
  // SD_DAT0 = GPIO 50 (ALT3)
  // SD_DAT1 = GPIO 51 (ALT3)
  // SD_DAT2 = GPIO 52 (ALT3)
  // SD_DAT3 = GPIO 53 (ALT3)

  var i: u32 = 48
  loop {
    if i > 53 { break }
    rpi3_gpio_set_function(i, 7)  // ALT3
    i = i + 1
  }

  foundation.serial_write_string("[RPI3] SD card GPIO configured\n")
}

// ============================================================================
// ETHERNET (via USB LAN9514)
// ============================================================================

fn rpi3_ethernet_init() {
  // Ethernet on Pi 3 is via USB hub (LAN9514)
  // This requires USB initialization first
  foundation.serial_write_string("[RPI3] Ethernet requires USB init (LAN9514)\n")
}

// ============================================================================
// WIFI/BLUETOOTH (CYW43455)
// ============================================================================

fn rpi3_wifi_init() {
  // CYW43455 is connected via SDIO
  // GPIO pins for WiFi:
  // WL_ON = GPIO 41 (output, active high)
  // BT_ON = GPIO 42 (output, active high)

  // Enable WiFi module
  rpi3_gpio_set_function(41, 1)  // Output
  rpi3_gpio_set(41)              // Power on

  // Enable Bluetooth module
  rpi3_gpio_set_function(42, 1)  // Output
  rpi3_gpio_set(42)              // Power on

  rpi3_delay_us(50000)  // 50ms delay for power-up

  foundation.serial_write_string("[RPI3] WiFi/BT module powered on\n")
}

// ============================================================================
// UART I/O
// ============================================================================

export fn rpi3_uart_putc(c: u8) {
  // Wait for UART to be ready
  loop {
    if (mmio_read(UART0_FR) & (1 << 5)) == 0 { break }
  }
  mmio_write(UART0_DR, c)
}

export fn rpi3_uart_getc(): u8 {
  // Wait for data
  loop {
    if (mmio_read(UART0_FR) & (1 << 4)) == 0 { break }
  }
  return mmio_read(UART0_DR) & 0xFF
}

export fn rpi3_uart_puts(s: []const u8) {
  var i: u32 = 0
  loop {
    if i >= s.len { break }
    rpi3_uart_putc(s[i])
    i = i + 1
  }
}

// ============================================================================
// MAIN INITIALIZATION
// ============================================================================

export fn rpi3_init() {
  if rpi3_initialized == 1 { return }

  foundation.serial_write_string("\n")
  foundation.serial_write_string("====================================\n")
  foundation.serial_write_string("  home-os - Raspberry Pi 3 B+ Init\n")
  foundation.serial_write_string("====================================\n\n")

  // Initialize UART first for debug output
  rpi3_uart_init()

  // Initialize GPIO
  rpi3_gpio_init()

  // Initialize mailbox
  rpi3_mailbox_init()

  // Get system info
  rpi3_board_revision = rpi3_get_board_revision()
  foundation.serial_write_string("[RPI3] Board revision: 0x")
  foundation.serial_write_hex(rpi3_board_revision)
  foundation.serial_write_string("\n")

  let memory_size: u64 = rpi3_get_arm_memory()
  foundation.serial_write_string("[RPI3] ARM memory: ")
  foundation.serial_write_u64(memory_size / 1024 / 1024)
  foundation.serial_write_string(" MB\n")

  let arm_clock: u32 = rpi3_get_clock_rate(CLOCK_ARM)
  foundation.serial_write_string("[RPI3] ARM clock: ")
  foundation.serial_write_u64(arm_clock / 1000000)
  foundation.serial_write_string(" MHz\n")

  // Initialize SD card
  rpi3_sd_init()

  // Initialize WiFi/Bluetooth
  rpi3_wifi_init()

  // Initialize Ethernet (info only, needs USB)
  rpi3_ethernet_init()

  rpi3_initialized = 1

  foundation.serial_write_string("\n[RPI3] Initialization complete\n")
  foundation.serial_write_string("====================================\n\n")
}

// ============================================================================
// MINIMAL BOOT PATH
// ============================================================================

// Entry point for minimal Pi 3 boot
export fn rpi3_minimal_boot() {
  // 1. Initialize UART for debug output
  rpi3_uart_init()

  rpi3_uart_puts("home-os minimal boot on Pi 3 B+\n")

  // 2. Initialize GPIO
  rpi3_gpio_init()

  // 3. Initialize mailbox
  rpi3_mailbox_init()

  // 4. Get memory size
  let mem: u64 = rpi3_get_arm_memory()
  rpi3_uart_puts("Memory: ")
  // Would print memory size here

  // 5. Initialize SD card
  rpi3_sd_init()

  // 6. Ready for kernel handoff
  rpi3_uart_puts("Ready for kernel\n")
}

// ============================================================================
// POWER MANAGEMENT
// ============================================================================

export fn rpi3_power_off() {
  var __attribute__((aligned(16))) buffer: [8]u32

  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00028001   // Tag: Set power state
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0            // Device ID (0 = SD card)
  buffer[6] = 0            // State: off
  buffer[7] = 0

  rpi3_mailbox_call(MBOX_CH_PROP, &buffer)
}

export fn rpi3_reboot() {
  // Use watchdog to reboot
  const PM_BASE: u64 = PERIPH_BASE + 0x100000
  const PM_RSTC: u64 = PM_BASE + 0x1C
  const PM_WDOG: u64 = PM_BASE + 0x24
  const PM_PASSWORD: u32 = 0x5A000000
  const PM_RSTC_WRCFG_FULL_RESET: u32 = 0x00000020

  // Set watchdog timeout to minimum
  mmio_write(PM_WDOG, PM_PASSWORD | 1)
  mmio_write(PM_RSTC, PM_PASSWORD | PM_RSTC_WRCFG_FULL_RESET)

  // Wait for reboot
  loop {}
}

// ============================================================================
// /proc interface
// ============================================================================

export fn rpi3_proc_read(buffer: *u8, size: u32): u32 {
  var offset: u32 = 0

  let header: []const u8 = "Raspberry Pi 3 B+ (BCM2837B0)\n"
  var i: u32 = 0
  loop {
    if i >= header.len { break }
    if offset >= size - 1 { break }
    buffer[offset] = header[i]
    offset = offset + 1
    i = i + 1
  }

  // Add board revision
  let rev_line: []const u8 = "Board revision: "
  i = 0
  loop {
    if i >= rev_line.len { break }
    if offset >= size - 1 { break }
    buffer[offset] = rev_line[i]
    offset = offset + 1
    i = i + 1
  }

  // Would add hex revision here

  buffer[offset] = 10  // newline
  offset = offset + 1

  buffer[offset] = 0
  return offset
}
