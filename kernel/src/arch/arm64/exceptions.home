// home-os ARM64 Exception Handling
// EL1 (Exception Level 1) exception vector table and handlers
// Handles synchronous exceptions, IRQ, FIQ, and SError

import "../../core/foundation.home" as foundation
import "../../core/memory.home" as memory

// Exception types
const EXC_TYPE_SYNC: u32 = 0
const EXC_TYPE_IRQ: u32 = 1
const EXC_TYPE_FIQ: u32 = 2
const EXC_TYPE_SERROR: u32 = 3

// Exception sources (based on which vector)
const EXC_SRC_CURR_SP0: u32 = 0  // Current EL with SP0
const EXC_SRC_CURR_SPX: u32 = 1  // Current EL with SPx
const EXC_SRC_LOWER_64: u32 = 2  // Lower EL (AArch64)
const EXC_SRC_LOWER_32: u32 = 3  // Lower EL (AArch32)

// Exception Syndrome Register (ESR_EL1) exception classes
const ESR_EC_UNKNOWN: u32 = 0x00
const ESR_EC_WFI_WFE: u32 = 0x01
const ESR_EC_CP15_32: u32 = 0x03
const ESR_EC_CP15_64: u32 = 0x04
const ESR_EC_CP14_MR: u32 = 0x05
const ESR_EC_CP14_LS: u32 = 0x06
const ESR_EC_FP_ASIMD: u32 = 0x07
const ESR_EC_CP10_ID: u32 = 0x08
const ESR_EC_CP14_64: u32 = 0x0C
const ESR_EC_ILL_STATE: u32 = 0x0E
const ESR_EC_SVC_64: u32 = 0x15
const ESR_EC_HVC_64: u32 = 0x16
const ESR_EC_SMC_64: u32 = 0x17
const ESR_EC_SYS_64: u32 = 0x18
const ESR_EC_IABT_LOW: u32 = 0x20
const ESR_EC_IABT_CUR: u32 = 0x21
const ESR_EC_PC_ALIGN: u32 = 0x22
const ESR_EC_DABT_LOW: u32 = 0x24
const ESR_EC_DABT_CUR: u32 = 0x25
const ESR_EC_SP_ALIGN: u32 = 0x26
const ESR_EC_FP_EXC_32: u32 = 0x28
const ESR_EC_FP_EXC_64: u32 = 0x2C
const ESR_EC_SERROR: u32 = 0x2F
const ESR_EC_BREAKPT_LOW: u32 = 0x30
const ESR_EC_BREAKPT_CUR: u32 = 0x31
const ESR_EC_SOFTSTP_LOW: u32 = 0x32
const ESR_EC_SOFTSTP_CUR: u32 = 0x33
const ESR_EC_WATCHPT_LOW: u32 = 0x34
const ESR_EC_WATCHPT_CUR: u32 = 0x35
const ESR_EC_BKPT_32: u32 = 0x38
const ESR_EC_BRK_64: u32 = 0x3C

// Saved register context
struct ExceptionFrame {
  x0: u64
  x1: u64
  x2: u64
  x3: u64
  x4: u64
  x5: u64
  x6: u64
  x7: u64
  x8: u64
  x9: u64
  x10: u64
  x11: u64
  x12: u64
  x13: u64
  x14: u64
  x15: u64
  x16: u64
  x17: u64
  x18: u64
  x19: u64
  x20: u64
  x21: u64
  x22: u64
  x23: u64
  x24: u64
  x25: u64
  x26: u64
  x27: u64
  x28: u64
  x29: u64  // Frame pointer
  x30: u64  // Link register
  sp: u64   // Stack pointer
  pc: u64   // Program counter (ELR_EL1)
  pstate: u64  // Processor state (SPSR_EL1)
  esr: u64  // Exception syndrome
  far: u64  // Fault address
}

// Exception handler type
type ExceptionHandler = fn(frame: *ExceptionFrame)

// Exception handlers
var sync_handler: ExceptionHandler = 0
var irq_handler: ExceptionHandler = 0
var fiq_handler: ExceptionHandler = 0
var serror_handler: ExceptionHandler = 0

// Statistics
var sync_exceptions: u64 = 0
var irq_exceptions: u64 = 0
var fiq_exceptions: u64 = 0
var serror_exceptions: u64 = 0
var unhandled_exceptions: u64 = 0

// Exception class names
const exception_class_names: [64]*u8 = [
  "Unknown",
  "WFI/WFE",
  "Reserved",
  "CP15 32-bit",
  "CP15 64-bit",
  "CP14 MCR/MRC",
  "CP14 LDC/STC",
  "FP/ASIMD",
  "CP10 ID",
  "Reserved",
  "Reserved",
  "Reserved",
  "CP14 64-bit",
  "Reserved",
  "Illegal State",
  "Reserved",
  "Reserved",
  "Reserved",
  "Reserved",
  "Reserved",
  "Reserved",
  "SVC 64-bit",
  "HVC 64-bit",
  "SMC 64-bit",
  "MSR/MRS 64-bit",
  "Reserved",
  "Reserved",
  "Reserved",
  "Reserved",
  "Reserved",
  "Reserved",
  "Reserved",
  "Inst Abort (lower)",
  "Inst Abort (current)",
  "PC Alignment",
  "Reserved",
  "Data Abort (lower)",
  "Data Abort (current)",
  "SP Alignment",
  "Reserved",
  "FP Exception 32",
  "Reserved",
  "Reserved",
  "Reserved",
  "FP Exception 64",
  "Reserved",
  "Reserved",
  "SError",
  "Breakpoint (lower)",
  "Breakpoint (current)",
  "Software Step (lower)",
  "Software Step (current)",
  "Watchpoint (lower)",
  "Watchpoint (current)",
  "Reserved",
  "Reserved",
  "BKPT 32",
  "Reserved",
  "Reserved",
  "Reserved",
  "BRK 64",
  "Reserved",
  "Reserved",
  "Reserved"
]

// Initialize exception handling
export fn exceptions_init() {
  foundation.serial_write_string("[ARM64] Initializing exception handling...\n")

  // Exception vector table would be installed here via VBAR_EL1
  // extern fn exception_vectors()
  // asm("msr vbar_el1, %0" :: "r"(&exception_vectors))

  foundation.serial_write_string("[ARM64] Exception vectors installed\n")
}

// Register exception handlers
export fn register_sync_handler(handler: ExceptionHandler) {
  sync_handler = handler
}

export fn register_irq_handler(handler: ExceptionHandler) {
  irq_handler = handler
}

export fn register_fiq_handler(handler: ExceptionHandler) {
  fiq_handler = handler
}

export fn register_serror_handler(handler: ExceptionHandler) {
  serror_handler = handler
}

// Get exception class from ESR
fn get_exception_class(esr: u64): u32 {
  return ((esr >> 26) & 0x3F) as u32
}

// Get exception class name
fn get_exception_class_name(ec: u32): *u8 {
  if ec < 64 {
    return exception_class_names[ec]
  }
  return "Invalid"
}

// Print exception frame
fn print_exception_frame(frame: *ExceptionFrame) {
  foundation.serial_write_string("\n=== Exception Frame ===\n")

  foundation.serial_write_string("PC:      0x")
  foundation.serial_write_hex(frame.pc)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("SP:      0x")
  foundation.serial_write_hex(frame.sp)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("PSTATE:  0x")
  foundation.serial_write_hex(frame.pstate)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("ESR:     0x")
  foundation.serial_write_hex(frame.esr)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("FAR:     0x")
  foundation.serial_write_hex(frame.far)
  foundation.serial_write_string("\n")

  let ec: u32 = get_exception_class(frame.esr)
  foundation.serial_write_string("EC:      0x")
  foundation.serial_write_hex(ec)
  foundation.serial_write_string(" (")
  foundation.serial_write_string(get_exception_class_name(ec))
  foundation.serial_write_string(")\n")

  foundation.serial_write_string("\nRegisters:\n")
  foundation.serial_write_string("x0:  0x")
  foundation.serial_write_hex(frame.x0)
  foundation.serial_write_string("  x1:  0x")
  foundation.serial_write_hex(frame.x1)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("x2:  0x")
  foundation.serial_write_hex(frame.x2)
  foundation.serial_write_string("  x3:  0x")
  foundation.serial_write_hex(frame.x3)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("x4:  0x")
  foundation.serial_write_hex(frame.x4)
  foundation.serial_write_string("  x5:  0x")
  foundation.serial_write_hex(frame.x5)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("x29: 0x")
  foundation.serial_write_hex(frame.x29)
  foundation.serial_write_string("  x30: 0x")
  foundation.serial_write_hex(frame.x30)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("=====================\n\n")
}

// Handle synchronous exception
export fn handle_sync_exception(frame: *ExceptionFrame) {
  sync_exceptions = sync_exceptions + 1

  let ec: u32 = get_exception_class(frame.esr)

  if sync_handler != 0 {
    sync_handler(frame)
  } else {
    unhandled_exceptions = unhandled_exceptions + 1

    foundation.serial_write_string("\n[ARM64] Unhandled synchronous exception!\n")
    foundation.serial_write_string("Exception Class: ")
    foundation.serial_write_string(get_exception_class_name(ec))
    foundation.serial_write_string("\n")

    print_exception_frame(frame)

    // Handle specific exception types
    if ec == ESR_EC_DABT_CUR || ec == ESR_EC_DABT_LOW {
      foundation.serial_write_string("Data Abort at address: 0x")
      foundation.serial_write_hex(frame.far)
      foundation.serial_write_string("\n")
    } else if ec == ESR_EC_IABT_CUR || ec == ESR_EC_IABT_LOW {
      foundation.serial_write_string("Instruction Abort at address: 0x")
      foundation.serial_write_hex(frame.far)
      foundation.serial_write_string("\n")
    } else if ec == ESR_EC_PC_ALIGN {
      foundation.serial_write_string("PC Alignment fault\n")
    } else if ec == ESR_EC_SP_ALIGN {
      foundation.serial_write_string("SP Alignment fault\n")
    } else if ec == ESR_EC_SVC_64 {
      foundation.serial_write_string("SVC instruction (syscall)\n")
    }

    // Halt system
    foundation.serial_write_string("System halted.\n")
    loop {
      foundation.nop()
    }
  }
}

// Handle IRQ exception
export fn handle_irq_exception(frame: *ExceptionFrame) {
  irq_exceptions = irq_exceptions + 1

  if irq_handler != 0 {
    irq_handler(frame)
  } else {
    unhandled_exceptions = unhandled_exceptions + 1
    foundation.serial_write_string("[ARM64] Unhandled IRQ\n")
  }
}

// Handle FIQ exception
export fn handle_fiq_exception(frame: *ExceptionFrame) {
  fiq_exceptions = fiq_exceptions + 1

  if fiq_handler != 0 {
    fiq_handler(frame)
  } else {
    unhandled_exceptions = unhandled_exceptions + 1
    foundation.serial_write_string("[ARM64] Unhandled FIQ\n")
  }
}

// Handle SError exception
export fn handle_serror_exception(frame: *ExceptionFrame) {
  serror_exceptions = serror_exceptions + 1

  if serror_handler != 0 {
    serror_handler(frame)
  } else {
    unhandled_exceptions = unhandled_exceptions + 1

    foundation.serial_write_string("\n[ARM64] Unhandled SError!\n")
    print_exception_frame(frame)

    foundation.serial_write_string("System halted.\n")
    loop {
      foundation.nop()
    }
  }
}

// Enable interrupts
export fn enable_irq() {
  // In real implementation: asm("msr daifclr, #2")
  foundation.serial_write_string("[ARM64] IRQ enabled\n")
}

// Disable interrupts
export fn disable_irq() {
  // In real implementation: asm("msr daifset, #2")
  foundation.serial_write_string("[ARM64] IRQ disabled\n")
}

// Enable FIQ
export fn enable_fiq() {
  // In real implementation: asm("msr daifclr, #1")
  foundation.serial_write_string("[ARM64] FIQ enabled\n")
}

// Disable FIQ
export fn disable_fiq() {
  // In real implementation: asm("msr daifset, #1")
  foundation.serial_write_string("[ARM64] FIQ disabled\n")
}

// Check if interrupts are enabled
export fn are_interrupts_enabled(): u32 {
  // In real implementation: read DAIF from PSTATE
  // asm("mrs %0, daif" : "=r"(daif))
  // return (daif & (1 << 7)) == 0
  return 1
}

// Wait for interrupt
export fn wait_for_interrupt() {
  // In real implementation: asm("wfi")
  foundation.nop()
}

// Wait for event
export fn wait_for_event() {
  // In real implementation: asm("wfe")
  foundation.nop()
}

// Send event
export fn send_event() {
  // In real implementation: asm("sev")
}

// Data synchronization barrier
export fn dsb() {
  // In real implementation: asm("dsb sy")
}

// Data memory barrier
export fn dmb() {
  // In real implementation: asm("dmb sy")
}

// Instruction synchronization barrier
export fn isb() {
  // In real implementation: asm("isb")
}

// Print exception statistics
export fn exceptions_print_stats() {
  foundation.serial_write_string("\n[ARM64] Exception Statistics:\n")

  foundation.serial_write_string("  Synchronous exceptions: ")
  foundation.serial_write_u64(sync_exceptions)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  IRQ exceptions: ")
  foundation.serial_write_u64(irq_exceptions)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  FIQ exceptions: ")
  foundation.serial_write_u64(fiq_exceptions)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  SError exceptions: ")
  foundation.serial_write_u64(serror_exceptions)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Unhandled exceptions: ")
  foundation.serial_write_u64(unhandled_exceptions)
  foundation.serial_write_string("\n")

  let total: u64 = sync_exceptions + irq_exceptions + fiq_exceptions + serror_exceptions
  foundation.serial_write_string("  Total exceptions: ")
  foundation.serial_write_u64(total)
  foundation.serial_write_string("\n")
}

// Exception vector table (assembly implementation would go in separate .s file)
// This defines the layout but actual implementation needs assembly

/*
.section .text.vectors
.align 11  // Vector table must be 2KB aligned

exception_vectors:
    // Current EL with SP0
    .align 7
    b sync_exc_sp0
    .align 7
    b irq_exc_sp0
    .align 7
    b fiq_exc_sp0
    .align 7
    b serror_exc_sp0

    // Current EL with SPx
    .align 7
    b sync_exc_spx
    .align 7
    b irq_exc_spx
    .align 7
    b fiq_exc_spx
    .align 7
    b serror_exc_spx

    // Lower EL (AArch64)
    .align 7
    b sync_exc_lower_64
    .align 7
    b irq_exc_lower_64
    .align 7
    b fiq_exc_lower_64
    .align 7
    b serror_exc_lower_64

    // Lower EL (AArch32)
    .align 7
    b sync_exc_lower_32
    .align 7
    b irq_exc_lower_32
    .align 7
    b fiq_exc_lower_32
    .align 7
    b serror_exc_lower_32
*/
