// home-os Kernel - Raspberry Pi 4 Support
// BCM2711 SoC and peripheral drivers

import "../../core/foundation.home" as foundation

// BCM2711 peripheral base addresses
const PERIPH_BASE: u64 = 0xFE000000

// UART (Mini UART)
const UART_BASE: u64 = PERIPH_BASE + 0x215000
const AUX_ENABLES: u64 = PERIPH_BASE + 0x215004
const AUX_MU_IO: u64 = UART_BASE + 0x40
const AUX_MU_IER: u64 = UART_BASE + 0x44
const AUX_MU_IIR: u64 = UART_BASE + 0x48
const AUX_MU_LCR: u64 = UART_BASE + 0x4C
const AUX_MU_MCR: u64 = UART_BASE + 0x50
const AUX_MU_LSR: u64 = UART_BASE + 0x54
const AUX_MU_CNTL: u64 = UART_BASE + 0x60
const AUX_MU_BAUD: u64 = UART_BASE + 0x68

// GPIO
const GPIO_BASE: u64 = PERIPH_BASE + 0x200000
const GPFSEL0: u64 = GPIO_BASE + 0x00
const GPFSEL1: u64 = GPIO_BASE + 0x04
const GPSET0: u64 = GPIO_BASE + 0x1C
const GPCLR0: u64 = GPIO_BASE + 0x28
const GPPUD: u64 = GPIO_BASE + 0x94
const GPPUDCLK0: u64 = GPIO_BASE + 0x98

// Mailbox
const MBOX_BASE: u64 = PERIPH_BASE + 0xB880
const MBOX_READ: u64 = MBOX_BASE + 0x00
const MBOX_STATUS: u64 = MBOX_BASE + 0x18
const MBOX_WRITE: u64 = MBOX_BASE + 0x20

// Mailbox channels
const MBOX_CH_POWER: u32 = 0
const MBOX_CH_FB: u32 = 1
const MBOX_CH_VUART: u32 = 2
const MBOX_CH_VCHIQ: u32 = 3
const MBOX_CH_LEDS: u32 = 4
const MBOX_CH_BTNS: u32 = 5
const MBOX_CH_TOUCH: u32 = 6
const MBOX_CH_PROP: u32 = 8

var rpi4_initialized: u32 = 0

export fn rpi4_init() {
  if rpi4_initialized == 1 { return }
  
  foundation.serial_write_string("[RPI4] Initializing Raspberry Pi 4...\n")
  
  // Initialize UART
  rpi4_uart_init()
  
  // Initialize GPIO
  rpi4_gpio_init()
  
  // Initialize mailbox
  rpi4_mailbox_init()
  
  rpi4_initialized = 1
  foundation.serial_write_string("[RPI4] Initialization complete\n")
}

fn rpi4_uart_init() {
  // Enable mini UART
  var enables: u32 = @intToPtr(AUX_ENABLES, u32)
  @intToPtr(AUX_ENABLES, u32) = enables | 1
  
  // Disable UART during configuration
  @intToPtr(AUX_MU_CNTL, u32) = 0
  
  // Configure UART
  @intToPtr(AUX_MU_LCR, u32) = 3  // 8-bit mode
  @intToPtr(AUX_MU_MCR, u32) = 0
  @intToPtr(AUX_MU_IER, u32) = 0
  @intToPtr(AUX_MU_IIR, u32) = 0xC6  // Clear FIFOs
  
  // Set baud rate to 115200
  @intToPtr(AUX_MU_BAUD, u32) = 270  // (500MHz / (8 * 115200)) - 1
  
  // Configure GPIO pins 14 and 15 for UART
  var sel: u32 = @intToPtr(GPFSEL1, u32)
  sel = sel & ~(7 << 12)  // Clear GPIO14
  sel = sel | (2 << 12)   // Alt5
  sel = sel & ~(7 << 15)  // Clear GPIO15
  sel = sel | (2 << 15)   // Alt5
  @intToPtr(GPFSEL1, u32) = sel
  
  // Disable pull-up/down
  @intToPtr(GPPUD, u32) = 0
  rpi4_delay(150)
  @intToPtr(GPPUDCLK0, u32) = (1 << 14) | (1 << 15)
  rpi4_delay(150)
  @intToPtr(GPPUDCLK0, u32) = 0
  
  // Enable UART
  @intToPtr(AUX_MU_CNTL, u32) = 3  // Enable TX and RX
  
  foundation.serial_write_string("[RPI4] UART initialized\n")
}

fn rpi4_gpio_init() {
  foundation.serial_write_string("[RPI4] GPIO initialized\n")
}

fn rpi4_mailbox_init() {
  foundation.serial_write_string("[RPI4] Mailbox initialized\n")
}

export fn rpi4_uart_putc(c: u8) {
  // Wait for UART to be ready
  while (@intToPtr(AUX_MU_LSR, u32) & 0x20) == 0 {}
  
  @intToPtr(AUX_MU_IO, u32) = c
}

export fn rpi4_uart_getc(): u8 {
  // Wait for data
  while (@intToPtr(AUX_MU_LSR, u32) & 0x01) == 0 {}
  
  return @truncate(@intToPtr(AUX_MU_IO, u32), u8)
}

export fn rpi4_uart_write(data: u64, len: u32) {
  var i: u32 = 0
  while i < len {
    rpi4_uart_putc(@intToPtr(data + i, u8))
    i = i + 1
  }
}

export fn rpi4_gpio_set(pin: u32) {
  if pin < 32 {
    @intToPtr(GPSET0, u32) = 1 << pin
  }
}

export fn rpi4_gpio_clear(pin: u32) {
  if pin < 32 {
    @intToPtr(GPCLR0, u32) = 1 << pin
  }
}

export fn rpi4_gpio_function(pin: u32, func: u32) {
  var reg: u64 = GPFSEL0 + ((pin / 10) * 4)
  var shift: u32 = (pin % 10) * 3
  
  var val: u32 = @intToPtr(reg, u32)
  val = val & ~(7 << shift)
  val = val | (func << shift)
  @intToPtr(reg, u32) = val
}

export fn rpi4_mailbox_call(channel: u32, data: u64): u32 {
  // Align to 16 bytes and add channel
  var msg: u32 = @truncate((data & ~0xF) | (channel & 0xF), u32)
  
  // Wait for mailbox to be ready
  while (@intToPtr(MBOX_STATUS, u32) & 0x80000000) != 0 {}
  
  // Write message
  @intToPtr(MBOX_WRITE, u32) = msg
  
  // Wait for response
  while 1 == 1 {
    while (@intToPtr(MBOX_STATUS, u32) & 0x40000000) != 0 {}
    
    var response: u32 = @intToPtr(MBOX_READ, u32)
    if response == msg {
      return @intToPtr(data + 4, u32)  // Return status
    }
  }
  
  return 0
}

export fn rpi4_get_board_revision(): u32 {
  var buffer: [u32; 8]
  buffer[0] = 32  // Buffer size
  buffer[1] = 0   // Request
  buffer[2] = 0x00010002  // Get board revision
  buffer[3] = 4   // Value size
  buffer[4] = 0   // Request/response
  buffer[5] = 0   // Revision
  buffer[6] = 0   // End tag
  
  rpi4_mailbox_call(MBOX_CH_PROP, @ptrFromInt(buffer))
  
  return buffer[5]
}

export fn rpi4_get_arm_memory(): u64 {
  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00010005  // Get ARM memory
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0  // Base
  buffer[6] = 0  // Size
  buffer[7] = 0
  
  rpi4_mailbox_call(MBOX_CH_PROP, @ptrFromInt(buffer))
  
  return @intToPtr(buffer + 24, u64)
}

fn rpi4_delay(count: u32) {
  var i: u32 = 0
  while i < count {
    foundation.nop()
    i = i + 1
  }
}

export fn rpi4_get_clock_rate(clock_id: u32): u32 {
  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00030002  // Get clock rate
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = clock_id
  buffer[6] = 0  // Rate
  buffer[7] = 0
  
  rpi4_mailbox_call(MBOX_CH_PROP, @ptrFromInt(buffer))
  
  return buffer[6]
}
