// home-os Kernel - ARM64 MMU
// Memory Management Unit for ARM64

import "../../core/foundation.home" as foundation

// Page table entry bits
const PTE_VALID: u64 = 1 << 0
const PTE_TABLE: u64 = 1 << 1
const PTE_USER: u64 = 1 << 6
const PTE_READONLY: u64 = 1 << 7
const PTE_SHARED: u64 = 3 << 8
const PTE_AF: u64 = 1 << 10  // Access flag
const PTE_NG: u64 = 1 << 11  // Not global
const PTE_PXN: u64 = 1 << 53  // Privileged execute never
const PTE_UXN: u64 = 1 << 54  // User execute never

// Page sizes
const PAGE_SIZE_4K: u64 = 4096
const PAGE_SIZE_2M: u64 = 2097152
const PAGE_SIZE_1G: u64 = 1073741824

// Page table levels
const PT_LEVEL_0: u32 = 0  // PGD
const PT_LEVEL_1: u32 = 1  // PUD
const PT_LEVEL_2: u32 = 2  // PMD
const PT_LEVEL_3: u32 = 3  // PTE

const PAGE_TABLE_ENTRIES: u32 = 512

var mmu_initialized: u32 = 0
var kernel_pgd: u64 = 0

export fn arm64_mmu_init() {
  if mmu_initialized == 1 { return }
  
  // Allocate page global directory
  kernel_pgd = foundation.alloc_phys_page()
  
  // Clear PGD
  arm64_clear_page_table(kernel_pgd)
  
  // Map kernel
  arm64_map_kernel()
  
  // Map peripherals
  arm64_map_peripherals()
  
  mmu_initialized = 1
  foundation.serial_write_string("[ARM64-MMU] Initialized\n")
}

fn arm64_clear_page_table(table: u64) {
  var i: u32 = 0
  while i < PAGE_TABLE_ENTRIES {
    @intToPtr(table + (i * 8), u64) = 0
    i = i + 1
  }
}

fn arm64_map_kernel() {
  // Map kernel at high address (0xFFFF000000000000)
  var kernel_start: u64 = 0xFFFF000000000000
  var kernel_size: u64 = 16 * 1024 * 1024  // 16MB
  
  var phys: u64 = 0x80000  // Kernel physical address
  var virt: u64 = kernel_start
  var end: u64 = kernel_start + kernel_size
  
  while virt < end {
    arm64_map_page(kernel_pgd, virt, phys, PTE_VALID | PTE_AF)
    virt = virt + PAGE_SIZE_4K
    phys = phys + PAGE_SIZE_4K
  }
  
  foundation.serial_write_string("[ARM64-MMU] Kernel mapped\n")
}

fn arm64_map_peripherals() {
  // Map Raspberry Pi 4 peripherals (BCM2711)
  var periph_base: u64 = 0xFE000000
  var periph_size: u64 = 16 * 1024 * 1024  // 16MB
  
  var phys: u64 = periph_base
  var virt: u64 = periph_base  // Identity map
  var end: u64 = periph_base + periph_size
  
  while virt < end {
    // Device memory, no execute
    arm64_map_page(kernel_pgd, virt, phys, PTE_VALID | PTE_AF | PTE_PXN | PTE_UXN)
    virt = virt + PAGE_SIZE_4K
    phys = phys + PAGE_SIZE_4K
  }
  
  foundation.serial_write_string("[ARM64-MMU] Peripherals mapped\n")
}

export fn arm64_map_page(pgd: u64, virt: u64, phys: u64, flags: u64) -> u32 {
  // 4-level page table walk
  var pgd_idx: u32 = @truncate((virt >> 39) & 0x1FF, u32)
  var pud_idx: u32 = @truncate((virt >> 30) & 0x1FF, u32)
  var pmd_idx: u32 = @truncate((virt >> 21) & 0x1FF, u32)
  var pte_idx: u32 = @truncate((virt >> 12) & 0x1FF, u32)
  
  // Get or create PUD
  var pgd_entry: u64 = @intToPtr(pgd + (pgd_idx * 8), u64)
  var pud: u64 = 0
  
  if (pgd_entry & PTE_VALID) == 0 {
    pud = foundation.alloc_phys_page()
    arm64_clear_page_table(pud)
    @intToPtr(pgd + (pgd_idx * 8), u64) = pud | PTE_VALID | PTE_TABLE
  } else {
    pud = pgd_entry & ~0xFFF
  }
  
  // Get or create PMD
  var pud_entry: u64 = @intToPtr(pud + (pud_idx * 8), u64)
  var pmd: u64 = 0
  
  if (pud_entry & PTE_VALID) == 0 {
    pmd = foundation.alloc_phys_page()
    arm64_clear_page_table(pmd)
    @intToPtr(pud + (pud_idx * 8), u64) = pmd | PTE_VALID | PTE_TABLE
  } else {
    pmd = pud_entry & ~0xFFF
  }
  
  // Get or create PTE
  var pmd_entry: u64 = @intToPtr(pmd + (pmd_idx * 8), u64)
  var pte: u64 = 0
  
  if (pmd_entry & PTE_VALID) == 0 {
    pte = foundation.alloc_phys_page()
    arm64_clear_page_table(pte)
    @intToPtr(pmd + (pmd_idx * 8), u64) = pte | PTE_VALID | PTE_TABLE
  } else {
    pte = pmd_entry & ~0xFFF
  }
  
  // Set PTE
  @intToPtr(pte + (pte_idx * 8), u64) = phys | flags
  
  return 1
}

export fn arm64_unmap_page(pgd: u64, virt: u64) -> u32 {
  var pgd_idx: u32 = @truncate((virt >> 39) & 0x1FF, u32)
  var pud_idx: u32 = @truncate((virt >> 30) & 0x1FF, u32)
  var pmd_idx: u32 = @truncate((virt >> 21) & 0x1FF, u32)
  var pte_idx: u32 = @truncate((virt >> 12) & 0x1FF, u32)
  
  var pgd_entry: u64 = @intToPtr(pgd + (pgd_idx * 8), u64)
  if (pgd_entry & PTE_VALID) == 0 { return 0 }
  
  var pud: u64 = pgd_entry & ~0xFFF
  var pud_entry: u64 = @intToPtr(pud + (pud_idx * 8), u64)
  if (pud_entry & PTE_VALID) == 0 { return 0 }
  
  var pmd: u64 = pud_entry & ~0xFFF
  var pmd_entry: u64 = @intToPtr(pmd + (pmd_idx * 8), u64)
  if (pmd_entry & PTE_VALID) == 0 { return 0 }
  
  var pte: u64 = pmd_entry & ~0xFFF
  @intToPtr(pte + (pte_idx * 8), u64) = 0
  
  // Invalidate TLB
  foundation.arm64_tlbi_vae1(virt)
  
  return 1
}

export fn arm64_get_pgd() -> u64 {
  return kernel_pgd
}

export fn arm64_switch_pgd(pgd: u64) {
  foundation.arm64_write_ttbr0_el1(pgd)
  foundation.arm64_tlbi_vmalle1()
  foundation.arm64_dsb()
  foundation.arm64_isb()
}
