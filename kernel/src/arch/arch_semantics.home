// home-os Cross-Architecture Semantics Parity
// Ensures identical semantics for signals, traps, and timers across x86-64 and ARM64
// This module provides architecture-agnostic interfaces with consistent behavior

import "../core/foundation.home" as foundation
import "../sys/signal.home" as signal

// ============================================================================
// ARCHITECTURE DETECTION
// ============================================================================

// Architecture identifiers
export const ARCH_X86_64: u32 = 1
export const ARCH_ARM64: u32 = 2
export const ARCH_UNKNOWN: u32 = 0

// Current architecture (set at compile time or boot)
var current_arch: u32 = ARCH_UNKNOWN

// ============================================================================
// UNIFIED TRAP CODES
// ============================================================================

// Architecture-agnostic trap codes for consistent exception handling
// These map to both x86-64 exceptions and ARM64 ESR exception classes

export const TRAP_DIVIDE_ERROR: u32 = 0
export const TRAP_DEBUG: u32 = 1
export const TRAP_NMI: u32 = 2
export const TRAP_BREAKPOINT: u32 = 3
export const TRAP_OVERFLOW: u32 = 4
export const TRAP_BOUND: u32 = 5
export const TRAP_INVALID_OPCODE: u32 = 6
export const TRAP_DEVICE_NOT_AVAIL: u32 = 7
export const TRAP_DOUBLE_FAULT: u32 = 8
export const TRAP_INVALID_TSS: u32 = 10
export const TRAP_SEGMENT_NOT_PRESENT: u32 = 11
export const TRAP_STACK_FAULT: u32 = 12
export const TRAP_GENERAL_PROTECTION: u32 = 13
export const TRAP_PAGE_FAULT: u32 = 14
export const TRAP_FPU_ERROR: u32 = 16
export const TRAP_ALIGNMENT_CHECK: u32 = 17
export const TRAP_MACHINE_CHECK: u32 = 18
export const TRAP_SIMD_ERROR: u32 = 19

// ARM64-specific trap codes (unified mapping)
export const TRAP_SYSCALL: u32 = 32
export const TRAP_INSTRUCTION_ABORT: u32 = 33
export const TRAP_DATA_ABORT: u32 = 34
export const TRAP_PC_ALIGNMENT: u32 = 35
export const TRAP_SP_ALIGNMENT: u32 = 36
export const TRAP_SERROR: u32 = 37
export const TRAP_BRK: u32 = 38
export const TRAP_WFI_WFE: u32 = 39

// ============================================================================
// UNIFIED TRAP INFO STRUCTURE
// ============================================================================

// Architecture-agnostic trap information
export struct TrapInfo {
  trap_code: u32,        // Unified trap code
  error_code: u64,       // Architecture-specific error code
  fault_addr: u64,       // Faulting address (if applicable)
  instruction_addr: u64, // Address of faulting instruction
  is_user: u32,          // 1 if from user mode, 0 if kernel
  is_write: u32,         // 1 if write fault, 0 if read
  is_exec: u32           // 1 if execute fault
}

// ============================================================================
// TRAP TO SIGNAL MAPPING
// ============================================================================

// Maps unified trap codes to POSIX signals - identical across architectures
// This is critical for consistent signal semantics

struct TrapSignalMapping {
  trap_code: u32,
  signal: u32,
  si_code: u32  // siginfo si_code
}

// SI_CODES for trap-generated signals
const SI_KERNEL: u32 = 128
const FPE_INTDIV: u32 = 1
const FPE_INTOVF: u32 = 2
const FPE_FLTDIV: u32 = 3
const FPE_FLTOVF: u32 = 4
const FPE_FLTUND: u32 = 5
const FPE_FLTRES: u32 = 6
const FPE_FLTINV: u32 = 7
const ILL_ILLOPC: u32 = 1
const ILL_ILLOPN: u32 = 2
const ILL_PRVOPC: u32 = 3
const ILL_PRVREG: u32 = 4
const SEGV_MAPERR: u32 = 1
const SEGV_ACCERR: u32 = 2
const BUS_ADRALN: u32 = 1
const BUS_ADRERR: u32 = 2
const TRAP_BRKPT: u32 = 1
const TRAP_TRACE: u32 = 2

// Canonical trap-to-signal mappings
const TRAP_SIGNAL_MAP_SIZE: u32 = 20
var trap_signal_map: [TrapSignalMapping; 20]

// ============================================================================
// INITIALIZATION
// ============================================================================

var semantics_initialized: u32 = 0

export fn arch_semantics_init(arch: u32) {
  if semantics_initialized == 1 { return }

  current_arch = arch

  // Initialize trap-to-signal mappings (same for both architectures)
  init_trap_signal_map()

  foundation.serial_write_string("[ArchSemantics] Initialized for ")
  if arch == ARCH_X86_64 {
    foundation.serial_write_string("x86-64")
  } else if arch == ARCH_ARM64 {
    foundation.serial_write_string("ARM64")
  } else {
    foundation.serial_write_string("unknown architecture")
  }
  foundation.serial_write_string("\n")

  semantics_initialized = 1
}

fn init_trap_signal_map() {
  // These mappings are IDENTICAL for x86-64 and ARM64
  // This ensures consistent signal behavior across architectures

  // Division by zero -> SIGFPE
  trap_signal_map[0].trap_code = TRAP_DIVIDE_ERROR
  trap_signal_map[0].signal = signal.SIGFPE
  trap_signal_map[0].si_code = FPE_INTDIV

  // Debug/Breakpoint -> SIGTRAP
  trap_signal_map[1].trap_code = TRAP_DEBUG
  trap_signal_map[1].signal = signal.SIGTRAP
  trap_signal_map[1].si_code = TRAP_TRACE

  trap_signal_map[2].trap_code = TRAP_BREAKPOINT
  trap_signal_map[2].signal = signal.SIGTRAP
  trap_signal_map[2].si_code = TRAP_BRKPT

  trap_signal_map[3].trap_code = TRAP_BRK
  trap_signal_map[3].signal = signal.SIGTRAP
  trap_signal_map[3].si_code = TRAP_BRKPT

  // Overflow -> SIGFPE
  trap_signal_map[4].trap_code = TRAP_OVERFLOW
  trap_signal_map[4].signal = signal.SIGFPE
  trap_signal_map[4].si_code = FPE_INTOVF

  // Invalid opcode -> SIGILL
  trap_signal_map[5].trap_code = TRAP_INVALID_OPCODE
  trap_signal_map[5].signal = signal.SIGILL
  trap_signal_map[5].si_code = ILL_ILLOPC

  // Page fault -> SIGSEGV
  trap_signal_map[6].trap_code = TRAP_PAGE_FAULT
  trap_signal_map[6].signal = signal.SIGSEGV
  trap_signal_map[6].si_code = SEGV_MAPERR

  trap_signal_map[7].trap_code = TRAP_DATA_ABORT
  trap_signal_map[7].signal = signal.SIGSEGV
  trap_signal_map[7].si_code = SEGV_MAPERR

  trap_signal_map[8].trap_code = TRAP_INSTRUCTION_ABORT
  trap_signal_map[8].signal = signal.SIGSEGV
  trap_signal_map[8].si_code = SEGV_ACCERR

  // Alignment -> SIGBUS
  trap_signal_map[9].trap_code = TRAP_ALIGNMENT_CHECK
  trap_signal_map[9].signal = signal.SIGBUS
  trap_signal_map[9].si_code = BUS_ADRALN

  trap_signal_map[10].trap_code = TRAP_PC_ALIGNMENT
  trap_signal_map[10].signal = signal.SIGBUS
  trap_signal_map[10].si_code = BUS_ADRALN

  trap_signal_map[11].trap_code = TRAP_SP_ALIGNMENT
  trap_signal_map[11].signal = signal.SIGBUS
  trap_signal_map[11].si_code = BUS_ADRALN

  // FPU errors -> SIGFPE
  trap_signal_map[12].trap_code = TRAP_FPU_ERROR
  trap_signal_map[12].signal = signal.SIGFPE
  trap_signal_map[12].si_code = FPE_FLTINV

  trap_signal_map[13].trap_code = TRAP_SIMD_ERROR
  trap_signal_map[13].signal = signal.SIGFPE
  trap_signal_map[13].si_code = FPE_FLTINV

  // General protection -> SIGSEGV
  trap_signal_map[14].trap_code = TRAP_GENERAL_PROTECTION
  trap_signal_map[14].signal = signal.SIGSEGV
  trap_signal_map[14].si_code = SEGV_ACCERR

  // Stack fault -> SIGSEGV
  trap_signal_map[15].trap_code = TRAP_STACK_FAULT
  trap_signal_map[15].signal = signal.SIGSEGV
  trap_signal_map[15].si_code = SEGV_MAPERR

  // Bound check -> SIGSEGV
  trap_signal_map[16].trap_code = TRAP_BOUND
  trap_signal_map[16].signal = signal.SIGSEGV
  trap_signal_map[16].si_code = SEGV_ACCERR

  // SError (ARM64) -> SIGBUS
  trap_signal_map[17].trap_code = TRAP_SERROR
  trap_signal_map[17].signal = signal.SIGBUS
  trap_signal_map[17].si_code = BUS_ADRERR

  // Machine check -> SIGBUS
  trap_signal_map[18].trap_code = TRAP_MACHINE_CHECK
  trap_signal_map[18].signal = signal.SIGBUS
  trap_signal_map[18].si_code = BUS_ADRERR

  // Double fault -> SIGKILL (unrecoverable)
  trap_signal_map[19].trap_code = TRAP_DOUBLE_FAULT
  trap_signal_map[19].signal = signal.SIGKILL
  trap_signal_map[19].si_code = SI_KERNEL
}

// ============================================================================
// TRAP CONVERSION (x86-64 -> Unified)
// ============================================================================

export fn x86_64_to_unified_trap(vector: u32, error_code: u64): TrapInfo {
  var info: TrapInfo
  info.error_code = error_code
  info.fault_addr = 0
  info.instruction_addr = 0
  info.is_user = 0
  info.is_write = 0
  info.is_exec = 0

  // Map x86-64 exception vectors to unified trap codes
  if vector == 0 {
    info.trap_code = TRAP_DIVIDE_ERROR
  } else if vector == 1 {
    info.trap_code = TRAP_DEBUG
  } else if vector == 2 {
    info.trap_code = TRAP_NMI
  } else if vector == 3 {
    info.trap_code = TRAP_BREAKPOINT
  } else if vector == 4 {
    info.trap_code = TRAP_OVERFLOW
  } else if vector == 5 {
    info.trap_code = TRAP_BOUND
  } else if vector == 6 {
    info.trap_code = TRAP_INVALID_OPCODE
  } else if vector == 7 {
    info.trap_code = TRAP_DEVICE_NOT_AVAIL
  } else if vector == 8 {
    info.trap_code = TRAP_DOUBLE_FAULT
  } else if vector == 10 {
    info.trap_code = TRAP_INVALID_TSS
  } else if vector == 11 {
    info.trap_code = TRAP_SEGMENT_NOT_PRESENT
  } else if vector == 12 {
    info.trap_code = TRAP_STACK_FAULT
  } else if vector == 13 {
    info.trap_code = TRAP_GENERAL_PROTECTION
  } else if vector == 14 {
    info.trap_code = TRAP_PAGE_FAULT
    // Parse x86-64 page fault error code
    info.is_write = if (error_code & 2) != 0 { 1 } else { 0 }
    info.is_user = if (error_code & 4) != 0 { 1 } else { 0 }
    info.is_exec = if (error_code & 16) != 0 { 1 } else { 0 }
  } else if vector == 16 {
    info.trap_code = TRAP_FPU_ERROR
  } else if vector == 17 {
    info.trap_code = TRAP_ALIGNMENT_CHECK
  } else if vector == 18 {
    info.trap_code = TRAP_MACHINE_CHECK
  } else if vector == 19 {
    info.trap_code = TRAP_SIMD_ERROR
  } else {
    info.trap_code = TRAP_GENERAL_PROTECTION
  }

  return info
}

// ============================================================================
// TRAP CONVERSION (ARM64 -> Unified)
// ============================================================================

// ARM64 ESR_EL1 exception class values
const ESR_EC_SVC_64: u32 = 0x15
const ESR_EC_IABT_LOW: u32 = 0x20
const ESR_EC_IABT_CUR: u32 = 0x21
const ESR_EC_PC_ALIGN: u32 = 0x22
const ESR_EC_DABT_LOW: u32 = 0x24
const ESR_EC_DABT_CUR: u32 = 0x25
const ESR_EC_SP_ALIGN: u32 = 0x26
const ESR_EC_FP_EXC_64: u32 = 0x2C
const ESR_EC_SERROR: u32 = 0x2F
const ESR_EC_BREAKPT_LOW: u32 = 0x30
const ESR_EC_BREAKPT_CUR: u32 = 0x31
const ESR_EC_SOFTSTP_LOW: u32 = 0x32
const ESR_EC_SOFTSTP_CUR: u32 = 0x33
const ESR_EC_BRK_64: u32 = 0x3C
const ESR_EC_ILL_STATE: u32 = 0x0E

export fn arm64_to_unified_trap(esr: u64, far: u64): TrapInfo {
  var info: TrapInfo
  info.error_code = esr
  info.fault_addr = far
  info.instruction_addr = 0
  info.is_user = 0
  info.is_write = 0
  info.is_exec = 0

  // Extract exception class from ESR
  let ec: u32 = ((esr >> 26) & 0x3F) as u32

  if ec == ESR_EC_SVC_64 {
    info.trap_code = TRAP_SYSCALL
  } else if ec == ESR_EC_IABT_LOW || ec == ESR_EC_IABT_CUR {
    info.trap_code = TRAP_INSTRUCTION_ABORT
    info.is_exec = 1
  } else if ec == ESR_EC_DABT_LOW || ec == ESR_EC_DABT_CUR {
    info.trap_code = TRAP_DATA_ABORT
    // Parse ISS for data abort
    let wnr: u32 = ((esr >> 6) & 1) as u32
    info.is_write = wnr
  } else if ec == ESR_EC_PC_ALIGN {
    info.trap_code = TRAP_PC_ALIGNMENT
  } else if ec == ESR_EC_SP_ALIGN {
    info.trap_code = TRAP_SP_ALIGNMENT
  } else if ec == ESR_EC_FP_EXC_64 {
    info.trap_code = TRAP_FPU_ERROR
  } else if ec == ESR_EC_SERROR {
    info.trap_code = TRAP_SERROR
  } else if ec == ESR_EC_BREAKPT_LOW || ec == ESR_EC_BREAKPT_CUR {
    info.trap_code = TRAP_BREAKPOINT
  } else if ec == ESR_EC_SOFTSTP_LOW || ec == ESR_EC_SOFTSTP_CUR {
    info.trap_code = TRAP_DEBUG
  } else if ec == ESR_EC_BRK_64 {
    info.trap_code = TRAP_BRK
  } else if ec == ESR_EC_ILL_STATE {
    info.trap_code = TRAP_INVALID_OPCODE
  } else {
    info.trap_code = TRAP_GENERAL_PROTECTION
  }

  return info
}

// ============================================================================
// UNIFIED TRAP TO SIGNAL CONVERSION
// ============================================================================

export fn trap_to_signal(trap_code: u32): u32 {
  var i: u32 = 0
  while i < TRAP_SIGNAL_MAP_SIZE {
    if trap_signal_map[i].trap_code == trap_code {
      return trap_signal_map[i].signal
    }
    i = i + 1
  }
  // Default: SIGKILL for unknown traps
  return signal.SIGKILL
}

export fn trap_to_si_code(trap_code: u32): u32 {
  var i: u32 = 0
  while i < TRAP_SIGNAL_MAP_SIZE {
    if trap_signal_map[i].trap_code == trap_code {
      return trap_signal_map[i].si_code
    }
    i = i + 1
  }
  return SI_KERNEL
}

// ============================================================================
// UNIFIED TIMER INTERFACE
// ============================================================================

// Timer types (consistent across architectures)
export const TIMER_TYPE_ONESHOT: u32 = 0
export const TIMER_TYPE_PERIODIC: u32 = 1

// Timer clock sources
export const CLOCK_MONOTONIC: u32 = 0
export const CLOCK_REALTIME: u32 = 1
export const CLOCK_BOOTTIME: u32 = 2

// Unified timer tick structure
export struct TimerTick {
  timestamp_ns: u64,     // Nanoseconds since boot
  elapsed_ns: u64,       // Nanoseconds since last tick
  tick_count: u64,       // Total tick count
  source: u32            // Clock source
}

// Timer resolution constraints (same for both architectures)
const MIN_TIMER_RESOLUTION_NS: u64 = 1000        // 1 microsecond
const MAX_TIMER_RESOLUTION_NS: u64 = 10000000    // 10 milliseconds
const DEFAULT_TICK_RATE_HZ: u64 = 1000           // 1000 Hz

// Timer state
var timer_tick_count: u64 = 0
var timer_ns_per_tick: u64 = 1000000  // 1ms default
var timer_base_timestamp: u64 = 0

// ============================================================================
// UNIFIED TIMER API
// ============================================================================

export fn timer_semantics_init(tick_rate_hz: u64) {
  if tick_rate_hz == 0 {
    timer_ns_per_tick = 1000000000 / DEFAULT_TICK_RATE_HZ
  } else {
    timer_ns_per_tick = 1000000000 / tick_rate_hz
  }

  timer_tick_count = 0
  timer_base_timestamp = 0

  foundation.serial_write_string("[ArchSemantics] Timer configured: ")
  foundation.serial_write_u64(1000000000 / timer_ns_per_tick)
  foundation.serial_write_string(" Hz\n")
}

// Called on each timer interrupt - architecture-agnostic
export fn timer_tick_handler(): TimerTick {
  var tick: TimerTick

  timer_tick_count = timer_tick_count + 1

  tick.tick_count = timer_tick_count
  tick.elapsed_ns = timer_ns_per_tick
  tick.timestamp_ns = timer_tick_count * timer_ns_per_tick
  tick.source = CLOCK_MONOTONIC

  return tick
}

// Get current time in nanoseconds (consistent across architectures)
export fn get_time_ns(clock: u32): u64 {
  if clock == CLOCK_MONOTONIC || clock == CLOCK_BOOTTIME {
    return timer_tick_count * timer_ns_per_tick
  } else if clock == CLOCK_REALTIME {
    // Would add wall clock offset
    return timer_tick_count * timer_ns_per_tick + timer_base_timestamp
  }
  return 0
}

// Set timeout (returns when it should fire in ns from now)
export fn set_timeout_ns(timeout_ns: u64): u64 {
  // Clamp to valid range
  var clamped: u64 = timeout_ns
  if clamped < MIN_TIMER_RESOLUTION_NS {
    clamped = MIN_TIMER_RESOLUTION_NS
  }
  if clamped > MAX_TIMER_RESOLUTION_NS * 1000 {
    clamped = MAX_TIMER_RESOLUTION_NS * 1000
  }

  return get_time_ns(CLOCK_MONOTONIC) + clamped
}

// ============================================================================
// SIGNAL FRAME LAYOUT COMPATIBILITY
// ============================================================================

// Signal frame must have consistent layout for portable signal handlers
// These offsets are the same regardless of architecture

export const SIGFRAME_SIGNUM_OFFSET: u32 = 0
export const SIGFRAME_SIGINFO_OFFSET: u32 = 8
export const SIGFRAME_UCONTEXT_OFFSET: u32 = 136
export const SIGFRAME_RETADDR_OFFSET: u32 = 264

// Portable siginfo_t structure layout
export struct SigInfo {
  si_signo: u32,       // Signal number
  si_errno: u32,       // Error number
  si_code: u32,        // Signal code
  _pad: u32,           // Padding for alignment
  si_pid: u32,         // Sending process ID
  si_uid: u32,         // Sending user ID
  si_status: u32,      // Exit value or signal
  _pad2: u32,
  si_addr: u64,        // Faulting address
  si_value: u64        // Signal value
}

// Build siginfo from trap info (consistent across architectures)
export fn build_siginfo(trap: *TrapInfo, signum: u32): SigInfo {
  var info: SigInfo

  info.si_signo = signum
  info.si_errno = 0
  info.si_code = trap_to_si_code(trap.trap_code)
  info._pad = 0
  info.si_pid = 0  // Kernel-generated
  info.si_uid = 0
  info.si_status = 0
  info._pad2 = 0
  info.si_addr = trap.fault_addr
  info.si_value = 0

  return info
}

// ============================================================================
// INTERRUPT PRIORITY LEVELS
// ============================================================================

// Unified interrupt priority levels (same semantics on both architectures)
export const IPL_NONE: u32 = 0       // All interrupts enabled
export const IPL_SOFTINT: u32 = 1    // Block soft interrupts
export const IPL_BIO: u32 = 2        // Block disk I/O interrupts
export const IPL_NET: u32 = 3        // Block network interrupts
export const IPL_TTY: u32 = 4        // Block terminal interrupts
export const IPL_CLOCK: u32 = 5      // Block clock interrupts
export const IPL_HIGH: u32 = 6       // Block all interrupts

var current_ipl: u32 = IPL_NONE

export fn splraise(level: u32): u32 {
  let old: u32 = current_ipl
  if level > current_ipl {
    current_ipl = level
    // Architecture-specific: disable appropriate interrupts
    if current_arch == ARCH_X86_64 {
      // Would manipulate EFLAGS or APIC TPR
    } else if current_arch == ARCH_ARM64 {
      // Would manipulate DAIF mask
    }
  }
  return old
}

export fn splx(level: u32) {
  current_ipl = level
  // Architecture-specific: restore interrupt state
}

// ============================================================================
// MEMORY BARRIER SEMANTICS
// ============================================================================

// These have identical semantics on both architectures
// The implementation differs but the observable behavior is the same

export fn memory_barrier() {
  if current_arch == ARCH_X86_64 {
    // x86-64: mfence
    // asm volatile("mfence" ::: "memory")
  } else if current_arch == ARCH_ARM64 {
    // ARM64: dmb sy
    // asm volatile("dmb sy" ::: "memory")
  }
}

export fn write_barrier() {
  if current_arch == ARCH_X86_64 {
    // x86-64: sfence
    // asm volatile("sfence" ::: "memory")
  } else if current_arch == ARCH_ARM64 {
    // ARM64: dmb st
    // asm volatile("dmb st" ::: "memory")
  }
}

export fn read_barrier() {
  if current_arch == ARCH_X86_64 {
    // x86-64: lfence
    // asm volatile("lfence" ::: "memory")
  } else if current_arch == ARCH_ARM64 {
    // ARM64: dmb ld
    // asm volatile("dmb ld" ::: "memory")
  }
}

// ============================================================================
// ATOMIC OPERATION SEMANTICS
// ============================================================================

// Ensure atomic operations have identical semantics
// Both architectures use sequential consistency by default

export fn atomic_load_64(addr: *u64): u64 {
  read_barrier()
  let val: u64 = addr.*
  read_barrier()
  return val
}

export fn atomic_store_64(addr: *u64, val: u64) {
  write_barrier()
  addr.* = val
  write_barrier()
}

export fn atomic_add_64(addr: *u64, val: u64): u64 {
  // Would use architecture-specific atomic instruction
  // x86-64: lock xadd
  // ARM64: ldxr/stxr loop or FEAT_LSE atomics
  memory_barrier()
  let old: u64 = addr.*
  addr.* = old + val
  memory_barrier()
  return old
}

export fn atomic_cmpxchg_64(addr: *u64, expected: u64, new_val: u64): u64 {
  // Would use architecture-specific atomic instruction
  // x86-64: lock cmpxchg
  // ARM64: ldxr/stxr loop or FEAT_LSE cas
  memory_barrier()
  let old: u64 = addr.*
  if old == expected {
    addr.* = new_val
  }
  memory_barrier()
  return old
}

// ============================================================================
// SYSCALL RESTART SEMANTICS
// ============================================================================

// Both architectures must handle syscall restart identically
// These error codes trigger restart behavior

export const ERESTARTSYS: u32 = 512       // Restart if SA_RESTART
export const ERESTARTNOINTR: u32 = 513    // Always restart
export const ERESTARTNOHAND: u32 = 514    // Restart if no handler
export const ERESTART_RESTARTBLOCK: u32 = 516  // Restart via restart_syscall

export fn should_restart_syscall(error: u32, sig_flags: u32): u32 {
  if error == ERESTARTNOINTR {
    return 1  // Always restart
  } else if error == ERESTARTSYS {
    // Restart if SA_RESTART is set
    return if (sig_flags & signal.SA_RESTART) != 0 { 1 } else { 0 }
  } else if error == ERESTARTNOHAND {
    // Restart only if no signal handler
    return 1
  }
  return 0
}

// ============================================================================
// VERIFICATION / TESTING
// ============================================================================

// Verify semantic parity is maintained
export fn verify_semantics(): u32 {
  var errors: u32 = 0

  foundation.serial_write_string("[ArchSemantics] Verifying cross-architecture semantics...\n")

  // Verify trap-to-signal mappings exist
  var i: u32 = 0
  while i < TRAP_SIGNAL_MAP_SIZE {
    if trap_signal_map[i].signal == 0 {
      foundation.serial_write_string("  WARN: Unmapped trap code ")
      foundation.serial_write_hex(trap_signal_map[i].trap_code)
      foundation.serial_write_string("\n")
    }
    i = i + 1
  }

  // Verify page fault produces SIGSEGV on both architectures
  let x86_pf: TrapInfo = x86_64_to_unified_trap(14, 0)
  let x86_sig: u32 = trap_to_signal(x86_pf.trap_code)

  let arm_pf: TrapInfo = arm64_to_unified_trap(0x24 << 26, 0)  // ESR with EC=DABT_LOW
  let arm_sig: u32 = trap_to_signal(arm_pf.trap_code)

  if x86_sig != arm_sig {
    foundation.serial_write_string("  ERROR: Page fault signal mismatch!\n")
    errors = errors + 1
  }

  // Verify breakpoint produces SIGTRAP on both architectures
  let x86_bp: TrapInfo = x86_64_to_unified_trap(3, 0)
  let x86_bp_sig: u32 = trap_to_signal(x86_bp.trap_code)

  let arm_bp: TrapInfo = arm64_to_unified_trap(0x3C << 26, 0)  // ESR with EC=BRK_64
  let arm_bp_sig: u32 = trap_to_signal(arm_bp.trap_code)

  if x86_bp_sig != arm_bp_sig {
    foundation.serial_write_string("  ERROR: Breakpoint signal mismatch!\n")
    errors = errors + 1
  }

  // Verify timer tick semantics
  let tick1: TimerTick = timer_tick_handler()
  let tick2: TimerTick = timer_tick_handler()

  if tick2.tick_count != tick1.tick_count + 1 {
    foundation.serial_write_string("  ERROR: Timer tick count inconsistent!\n")
    errors = errors + 1
  }

  if tick2.elapsed_ns != tick1.elapsed_ns {
    foundation.serial_write_string("  ERROR: Timer elapsed time inconsistent!\n")
    errors = errors + 1
  }

  if errors == 0 {
    foundation.serial_write_string("[ArchSemantics] All semantic checks passed\n")
  } else {
    foundation.serial_write_string("[ArchSemantics] ")
    foundation.serial_write_hex(errors)
    foundation.serial_write_string(" semantic checks failed\n")
  }

  return errors
}

// ============================================================================
// STATISTICS
// ============================================================================

var traps_processed: u64 = 0
var signals_generated: u64 = 0
var timer_ticks_processed: u64 = 0

export fn get_semantics_stats(traps: *u64, signals: *u64, ticks: *u64) {
  traps.* = traps_processed
  signals.* = signals_generated
  ticks.* = timer_ticks_processed
}

export fn print_semantics_info() {
  foundation.serial_write_string("\n[ArchSemantics] Configuration:\n")

  foundation.serial_write_string("  Architecture: ")
  if current_arch == ARCH_X86_64 {
    foundation.serial_write_string("x86-64\n")
  } else if current_arch == ARCH_ARM64 {
    foundation.serial_write_string("ARM64\n")
  } else {
    foundation.serial_write_string("Unknown\n")
  }

  foundation.serial_write_string("  Timer resolution: ")
  foundation.serial_write_u64(timer_ns_per_tick)
  foundation.serial_write_string(" ns\n")

  foundation.serial_write_string("  Current IPL: ")
  foundation.serial_write_hex(current_ipl)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Traps processed: ")
  foundation.serial_write_u64(traps_processed)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Signals generated: ")
  foundation.serial_write_u64(signals_generated)
  foundation.serial_write_string("\n")
}
