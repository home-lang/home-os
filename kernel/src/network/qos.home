// home-os Kernel - Quality of Service (QoS)
// Network traffic prioritization and bandwidth management

import "../core/foundation.home" as foundation
import "network.home" as network

// QoS classes
const QOS_CLASS_REALTIME: u32 = 0      // VoIP, gaming
const QOS_CLASS_INTERACTIVE: u32 = 1   // SSH, remote desktop
const QOS_CLASS_STREAMING: u32 = 2     // Video streaming
const QOS_CLASS_BULK: u32 = 3          // File transfers
const QOS_CLASS_BACKGROUND: u32 = 4    // Updates, backups

const MAX_QOS_RULES: u32 = 256

struct QoSRule {
  src_ip: u32,
  dst_ip: u32,
  src_port: u16,
  dst_port: u16,
  protocol: u8,
  class: u32,
  bandwidth_limit: u64,  // bytes per second
  priority: u32,
  enabled: u32
}

struct QoSStats {
  packets_sent: u64,
  packets_dropped: u64,
  bytes_sent: u64,
  avg_latency: u32
}

var qos_rules: [QoSRule; 256]
var qos_rule_count: u32 = 0
var qos_stats: [QoSStats; 5]
var qos_enabled: u32 = 0

export fn qos_init() {
  qos_rule_count = 0
  qos_enabled = 1
  
  // Initialize stats
  var i: u32 = 0
  while i < 5 {
    qos_stats[i].packets_sent = 0
    qos_stats[i].packets_dropped = 0
    qos_stats[i].bytes_sent = 0
    qos_stats[i].avg_latency = 0
    i = i + 1
  }
  
  // Add default rules
  qos_add_default_rules()
  
  foundation.serial_write_string("[QoS] Quality of Service initialized\n")
}

fn qos_add_default_rules() {
  // VoIP (SIP/RTP) - Realtime
  qos_add_rule(0, 0, 5060, 0, 17, QOS_CLASS_REALTIME, 0, 100)
  qos_add_rule(0, 0, 0, 5060, 17, QOS_CLASS_REALTIME, 0, 100)
  
  // SSH - Interactive
  qos_add_rule(0, 0, 22, 0, 6, QOS_CLASS_INTERACTIVE, 0, 90)
  qos_add_rule(0, 0, 0, 22, 6, QOS_CLASS_INTERACTIVE, 0, 90)
  
  // HTTP/HTTPS - Streaming
  qos_add_rule(0, 0, 80, 0, 6, QOS_CLASS_STREAMING, 0, 50)
  qos_add_rule(0, 0, 443, 0, 6, QOS_CLASS_STREAMING, 0, 50)
}

export fn qos_add_rule(src_ip: u32, dst_ip: u32, src_port: u16, dst_port: u16, protocol: u8, class: u32, bandwidth_limit: u64, priority: u32): u32 {
  if qos_rule_count >= MAX_QOS_RULES { return 0xFFFFFFFF }
  
  var rule_id: u32 = qos_rule_count
  
  qos_rules[rule_id].src_ip = src_ip
  qos_rules[rule_id].dst_ip = dst_ip
  qos_rules[rule_id].src_port = src_port
  qos_rules[rule_id].dst_port = dst_port
  qos_rules[rule_id].protocol = protocol
  qos_rules[rule_id].class = class
  qos_rules[rule_id].bandwidth_limit = bandwidth_limit
  qos_rules[rule_id].priority = priority
  qos_rules[rule_id].enabled = 1
  
  qos_rule_count = qos_rule_count + 1
  
  return rule_id
}

export fn qos_classify_packet(src_ip: u32, dst_ip: u32, src_port: u16, dst_port: u16, protocol: u8): u32 {
  if qos_enabled == 0 { return QOS_CLASS_BULK }
  
  // Match against rules
  var i: u32 = 0
  var best_match: u32 = QOS_CLASS_BULK
  var best_priority: u32 = 0
  
  while i < qos_rule_count {
    if qos_rules[i].enabled == 0 {
      i = i + 1
      continue
    }
    
    var match: u32 = 1
    
    // Check source IP
    if qos_rules[i].src_ip != 0 and qos_rules[i].src_ip != src_ip {
      match = 0
    }
    
    // Check destination IP
    if qos_rules[i].dst_ip != 0 and qos_rules[i].dst_ip != dst_ip {
      match = 0
    }
    
    // Check source port
    if qos_rules[i].src_port != 0 and qos_rules[i].src_port != src_port {
      match = 0
    }
    
    // Check destination port
    if qos_rules[i].dst_port != 0 and qos_rules[i].dst_port != dst_port {
      match = 0
    }
    
    // Check protocol
    if qos_rules[i].protocol != 0 and qos_rules[i].protocol != protocol {
      match = 0
    }
    
    if match == 1 and qos_rules[i].priority > best_priority {
      best_match = qos_rules[i].class
      best_priority = qos_rules[i].priority
    }
    
    i = i + 1
  }
  
  return best_match
}

export fn qos_should_send_packet(class: u32, packet_size: u32): u32 {
  // Check bandwidth limits
  // Check queue depth
  
  return 1  // Allow
}

export fn qos_update_stats(class: u32, packet_size: u32, latency: u32) {
  if class >= 5 { return }
  
  qos_stats[class].packets_sent = qos_stats[class].packets_sent + 1
  qos_stats[class].bytes_sent = qos_stats[class].bytes_sent + packet_size
  
  // Update average latency
  var total_packets: u64 = qos_stats[class].packets_sent
  var current_avg: u64 = qos_stats[class].avg_latency
  qos_stats[class].avg_latency = @truncate((current_avg * (total_packets - 1) + latency) / total_packets, u32)
}

export fn qos_get_stats(class: u32, stats_out: u64): u32 {
  if class >= 5 { return 0 }
  
  var i: u32 = 0
  while i < 32 {
    @intToPtr(stats_out + i, u8) = @intToPtr(@ptrFromInt(qos_stats[class]) + i, u8)
    i = i + 1
  }
  
  return 1
}

export fn qos_enable() {
  qos_enabled = 1
  foundation.serial_write_string("[QoS] Enabled\n")
}

export fn qos_disable() {
  qos_enabled = 0
  foundation.serial_write_string("[QoS] Disabled\n")
}

export fn qos_print_stats() {
  foundation.serial_write_string("\n[QoS] Statistics:\n")
  foundation.serial_write_string("Class         Packets    Bytes      Avg Latency\n")
  foundation.serial_write_string("------------------------------------------------\n")
  
  var classes: [u64; 5]
  classes[0] = @ptrFromInt("Realtime    ")
  classes[1] = @ptrFromInt("Interactive ")
  classes[2] = @ptrFromInt("Streaming   ")
  classes[3] = @ptrFromInt("Bulk        ")
  classes[4] = @ptrFromInt("Background  ")
  
  var i: u32 = 0
  while i < 5 {
    foundation.serial_write_string(classes[i])
    foundation.serial_write_hex(@truncate(qos_stats[i].packets_sent, u32))
    foundation.serial_write_string("  ")
    foundation.serial_write_hex(@truncate(qos_stats[i].bytes_sent / 1024, u32))
    foundation.serial_write_string(" KB  ")
    foundation.serial_write_hex(qos_stats[i].avg_latency)
    foundation.serial_write_string(" ms\n")
    
    i = i + 1
  }
}
