// home-os Kernel - RDP Server
// Remote Desktop Protocol server

import "../core/foundation.home" as foundation
import "../drivers/framebuffer.home" as framebuffer
import "network.home" as network

const RDP_PORT: u16 = 3389
const MAX_RDP_SESSIONS: u32 = 4

struct RDPSession {
  socket: u32,
  width: u32,
  height: u32,
  bpp: u32,
  authenticated: u32,
  active: u32
}

var rdp_sessions: [RDPSession; 4]
var rdp_session_count: u32 = 0
var rdp_server_socket: u32 = 0
var rdp_running: u32 = 0

export fn rdp_server_init() {
  rdp_session_count = 0
  rdp_running = 0
  
  foundation.serial_write_string("[RDP] Server initialized\n")
}

export fn rdp_server_start() -> u32 {
  foundation.serial_write_string("[RDP] Starting RDP server on port ")
  foundation.serial_write_hex(RDP_PORT)
  foundation.serial_write_string("\n")
  
  rdp_server_socket = network.socket_create(2, 1, 0)
  if rdp_server_socket == 0xFFFFFFFF {
    return 0
  }
  
  network.socket_bind(rdp_server_socket, 0, RDP_PORT)
  network.socket_listen(rdp_server_socket, 4)
  
  rdp_running = 1
  
  foundation.serial_write_string("[RDP] Server started\n")
  
  return 1
}

export fn rdp_server_accept() -> u32 {
  if rdp_running == 0 { return 0xFFFFFFFF }
  if rdp_session_count >= MAX_RDP_SESSIONS { return 0xFFFFFFFF }
  
  var client_socket: u32 = network.socket_accept(rdp_server_socket)
  if client_socket == 0xFFFFFFFF { return 0xFFFFFFFF }
  
  var session_id: u32 = rdp_session_count
  
  rdp_sessions[session_id].socket = client_socket
  rdp_sessions[session_id].width = 1920
  rdp_sessions[session_id].height = 1080
  rdp_sessions[session_id].bpp = 32
  rdp_sessions[session_id].authenticated = 0
  rdp_sessions[session_id].active = 1
  
  rdp_session_count = rdp_session_count + 1
  
  foundation.serial_write_string("[RDP] New connection\n")
  
  return session_id
}

export fn rdp_send_frame(session_id: u32) -> u32 {
  if session_id >= rdp_session_count { return 0 }
  if rdp_sessions[session_id].authenticated == 0 { return 0 }
  
  // Get framebuffer
  var fb: u64 = framebuffer.framebuffer_get_address()
  var width: u32 = framebuffer.framebuffer_get_width()
  var height: u32 = framebuffer.framebuffer_get_height()
  
  // Compress and send frame
  rdp_compress_and_send(session_id, fb, width, height)
  
  return 1
}

fn rdp_compress_and_send(session_id: u32, fb: u64, width: u32, height: u32) {
  // RLE compression for framebuffer
  var compressed: [u8; 65536]
  var compressed_size: u32 = rdp_compress_rle(fb, @ptrFromInt(compressed), width * height * 4)
  
  // Send compressed data
  network.socket_send(rdp_sessions[session_id].socket, @ptrFromInt(compressed), compressed_size)
}

fn rdp_compress_rle(input: u64, output: u64, size: u32) -> u32 {
  // Simple RLE compression
  var in_pos: u32 = 0
  var out_pos: u32 = 0
  
  while in_pos < size {
    var current: u8 = @intToPtr(input + in_pos, u8)
    var run_length: u32 = 1
    
    while in_pos + run_length < size and run_length < 255 {
      if @intToPtr(input + in_pos + run_length, u8) == current {
        run_length = run_length + 1
      } else {
        break
      }
    }
    
    @intToPtr(output + out_pos, u8) = @truncate(run_length, u8)
    @intToPtr(output + out_pos + 1, u8) = current
    
    out_pos = out_pos + 2
    in_pos = in_pos + run_length
  }
  
  return out_pos
}

export fn rdp_handle_input(session_id: u32, input_type: u32, data: u64) -> u32 {
  if session_id >= rdp_session_count { return 0 }
  
  // Handle keyboard/mouse input from client
  
  return 1
}

export fn rdp_close_session(session_id: u32) {
  if session_id >= rdp_session_count { return }
  
  network.socket_close(rdp_sessions[session_id].socket)
  rdp_sessions[session_id].active = 0
  
  foundation.serial_write_string("[RDP] Session closed\n")
}
