// home-os Kernel - SSH Server
// Secure Shell server for remote access

import "../core/foundation.home" as foundation
import "network.home" as network

const SSH_PORT: u16 = 22
const MAX_SSH_SESSIONS: u32 = 16

struct SSHSession {
  socket: u32,
  authenticated: u32,
  username: [u8; 64],
  client_ip: u32,
  active: u32
}

var ssh_sessions: [SSHSession; 16]
var ssh_session_count: u32 = 0
var ssh_server_socket: u32 = 0
var ssh_running: u32 = 0

export fn ssh_server_init() {
  ssh_session_count = 0
  ssh_running = 0
  
  foundation.serial_write_string("[SSH] Server initialized\n")
}

export fn ssh_server_start() -> u32 {
  foundation.serial_write_string("[SSH] Starting SSH server on port ")
  foundation.serial_write_hex(SSH_PORT)
  foundation.serial_write_string("\n")
  
  ssh_server_socket = network.socket_create(2, 1, 0)
  if ssh_server_socket == 0xFFFFFFFF {
    foundation.serial_write_string("[SSH] Failed to create socket\n")
    return 0
  }
  
  network.socket_bind(ssh_server_socket, 0, SSH_PORT)
  network.socket_listen(ssh_server_socket, 16)
  
  ssh_running = 1
  
  foundation.serial_write_string("[SSH] Server started\n")
  
  return 1
}

export fn ssh_server_accept() -> u32 {
  if ssh_running == 0 { return 0xFFFFFFFF }
  if ssh_session_count >= MAX_SSH_SESSIONS { return 0xFFFFFFFF }
  
  var client_socket: u32 = network.socket_accept(ssh_server_socket)
  if client_socket == 0xFFFFFFFF { return 0xFFFFFFFF }
  
  var session_id: u32 = ssh_session_count
  
  ssh_sessions[session_id].socket = client_socket
  ssh_sessions[session_id].authenticated = 0
  ssh_sessions[session_id].active = 1
  
  ssh_session_count = ssh_session_count + 1
  
  foundation.serial_write_string("[SSH] New connection\n")
  
  // Send SSH banner
  ssh_send_banner(session_id)
  
  return session_id
}

fn ssh_send_banner(session_id: u32) {
  var banner: u64 = @ptrFromInt("SSH-2.0-home-os\r\n")
  network.socket_send(ssh_sessions[session_id].socket, banner, 17)
}

export fn ssh_authenticate(session_id: u32, username: u64, password: u64) -> u32 {
  if session_id >= ssh_session_count { return 0 }
  
  foundation.serial_write_string("[SSH] Authentication attempt for ")
  foundation.serial_write_string(username)
  foundation.serial_write_string("\n")
  
  // Verify credentials
  if ssh_verify_credentials(username, password) == 1 {
    ssh_sessions[session_id].authenticated = 1
    
    // Copy username
    var i: u32 = 0
    while i < 63 {
      var ch: u8 = @intToPtr(username + i, u8)
      ssh_sessions[session_id].username[i] = ch
      if ch == 0 { break }
      i = i + 1
    }
    
    foundation.serial_write_string("[SSH] Authentication successful\n")
    return 1
  }
  
  foundation.serial_write_string("[SSH] Authentication failed\n")
  return 0
}

fn ssh_verify_credentials(username: u64, password: u64) -> u32 {
  // Check against user database
  return 1  // Simplified
}

export fn ssh_execute_command(session_id: u32, command: u64) -> u32 {
  if session_id >= ssh_session_count { return 0 }
  if ssh_sessions[session_id].authenticated == 0 { return 0 }
  
  foundation.serial_write_string("[SSH] Executing: ")
  foundation.serial_write_string(command)
  foundation.serial_write_string("\n")
  
  // Execute command and send output
  var output: [u8; 4096]
  foundation.exec_command_capture(command, @ptrFromInt(output), 4096)
  
  network.socket_send(ssh_sessions[session_id].socket, @ptrFromInt(output), 4096)
  
  return 1
}

export fn ssh_close_session(session_id: u32) {
  if session_id >= ssh_session_count { return }
  
  network.socket_close(ssh_sessions[session_id].socket)
  ssh_sessions[session_id].active = 0
  
  foundation.serial_write_string("[SSH] Session closed\n")
}

export fn ssh_server_stop() {
  ssh_running = 0
  network.socket_close(ssh_server_socket)
  
  foundation.serial_write_string("[SSH] Server stopped\n")
}
