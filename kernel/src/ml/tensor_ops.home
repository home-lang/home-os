// HomeOS Tensor Operations
// Mathematical operations for tensors

const basics = @import("basics")
const tensor = @import("ml/tensor")

// Import tensor types
const Tensor = tensor.Tensor
const DTYPE_F32 = tensor.DTYPE_F32
const DTYPE_F64 = tensor.DTYPE_F64
const DTYPE_I32 = tensor.DTYPE_I32
const DTYPE_I64 = tensor.DTYPE_I64

// ============================================
// Element-wise Arithmetic Operations
// ============================================

// Add two tensors element-wise
export fn tensor_add(a: *Tensor, b: *Tensor): *Tensor {
    if a == null or b == null {
        return null
    }

    // Check shape compatibility (simple version - same shape)
    if a.ndim != b.ndim {
        return null
    }
    var i: u32 = 0
    while i < a.ndim {
        if a.shape[i] != b.shape[i] {
            return null  // TODO: broadcasting
        }
        i = i + 1
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rb = b.data as *f32
        let rc = result.data as *f32
        i = 0
        while i < numel {
            rc[i] = ra[i] + rb[i]
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rb = b.data as *f64
        let rc = result.data as *f64
        i = 0
        while i < numel {
            rc[i] = ra[i] + rb[i]
            i = i + 1
        }
    }

    return result
}

// Subtract two tensors element-wise
export fn tensor_sub(a: *Tensor, b: *Tensor): *Tensor {
    if a == null or b == null {
        return null
    }

    if a.ndim != b.ndim {
        return null
    }
    var i: u32 = 0
    while i < a.ndim {
        if a.shape[i] != b.shape[i] {
            return null
        }
        i = i + 1
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rb = b.data as *f32
        let rc = result.data as *f32
        i = 0
        while i < numel {
            rc[i] = ra[i] - rb[i]
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rb = b.data as *f64
        let rc = result.data as *f64
        i = 0
        while i < numel {
            rc[i] = ra[i] - rb[i]
            i = i + 1
        }
    }

    return result
}

// Multiply two tensors element-wise (Hadamard product)
export fn tensor_mul(a: *Tensor, b: *Tensor): *Tensor {
    if a == null or b == null {
        return null
    }

    if a.ndim != b.ndim {
        return null
    }
    var i: u32 = 0
    while i < a.ndim {
        if a.shape[i] != b.shape[i] {
            return null
        }
        i = i + 1
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rb = b.data as *f32
        let rc = result.data as *f32
        i = 0
        while i < numel {
            rc[i] = ra[i] * rb[i]
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rb = b.data as *f64
        let rc = result.data as *f64
        i = 0
        while i < numel {
            rc[i] = ra[i] * rb[i]
            i = i + 1
        }
    }

    return result
}

// Divide two tensors element-wise
export fn tensor_div(a: *Tensor, b: *Tensor): *Tensor {
    if a == null or b == null {
        return null
    }

    if a.ndim != b.ndim {
        return null
    }
    var i: u32 = 0
    while i < a.ndim {
        if a.shape[i] != b.shape[i] {
            return null
        }
        i = i + 1
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rb = b.data as *f32
        let rc = result.data as *f32
        i = 0
        while i < numel {
            rc[i] = ra[i] / rb[i]
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rb = b.data as *f64
        let rc = result.data as *f64
        i = 0
        while i < numel {
            rc[i] = ra[i] / rb[i]
            i = i + 1
        }
    }

    return result
}

// Negate tensor
export fn tensor_neg(a: *Tensor): *Tensor {
    if a == null {
        return null
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rc = result.data as *f32
        var i: u64 = 0
        while i < numel {
            rc[i] = -ra[i]
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rc = result.data as *f64
        var i: u64 = 0
        while i < numel {
            rc[i] = -ra[i]
            i = i + 1
        }
    }

    return result
}

// Absolute value
export fn tensor_abs(a: *Tensor): *Tensor {
    if a == null {
        return null
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rc = result.data as *f32
        var i: u64 = 0
        while i < numel {
            rc[i] = if ra[i] < 0.0 { -ra[i] } else { ra[i] }
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rc = result.data as *f64
        var i: u64 = 0
        while i < numel {
            rc[i] = if ra[i] < 0.0 { -ra[i] } else { ra[i] }
            i = i + 1
        }
    }

    return result
}

// ============================================
// Scalar Operations
// ============================================

// Add scalar to tensor
export fn tensor_add_scalar(a: *Tensor, scalar: f64): *Tensor {
    if a == null {
        return null
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rc = result.data as *f32
        let s = scalar as f32
        var i: u64 = 0
        while i < numel {
            rc[i] = ra[i] + s
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rc = result.data as *f64
        var i: u64 = 0
        while i < numel {
            rc[i] = ra[i] + scalar
            i = i + 1
        }
    }

    return result
}

// Multiply tensor by scalar
export fn tensor_mul_scalar(a: *Tensor, scalar: f64): *Tensor {
    if a == null {
        return null
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rc = result.data as *f32
        let s = scalar as f32
        var i: u64 = 0
        while i < numel {
            rc[i] = ra[i] * s
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rc = result.data as *f64
        var i: u64 = 0
        while i < numel {
            rc[i] = ra[i] * scalar
            i = i + 1
        }
    }

    return result
}

// Power (element-wise)
export fn tensor_pow(a: *Tensor, exp: f64): *Tensor {
    if a == null {
        return null
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rc = result.data as *f32
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.pow(ra[i] as f64, exp) as f32
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rc = result.data as *f64
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.pow(ra[i], exp)
            i = i + 1
        }
    }

    return result
}

// ============================================
// Mathematical Functions
// ============================================

// Square root
export fn tensor_sqrt(a: *Tensor): *Tensor {
    if a == null {
        return null
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rc = result.data as *f32
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.sqrt(ra[i] as f64) as f32
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rc = result.data as *f64
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.sqrt(ra[i])
            i = i + 1
        }
    }

    return result
}

// Exponential
export fn tensor_exp(a: *Tensor): *Tensor {
    if a == null {
        return null
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rc = result.data as *f32
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.exp(ra[i] as f64) as f32
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rc = result.data as *f64
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.exp(ra[i])
            i = i + 1
        }
    }

    return result
}

// Natural logarithm
export fn tensor_log(a: *Tensor): *Tensor {
    if a == null {
        return null
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rc = result.data as *f32
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.log(ra[i] as f64) as f32
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rc = result.data as *f64
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.log(ra[i])
            i = i + 1
        }
    }

    return result
}

// Sine
export fn tensor_sin(a: *Tensor): *Tensor {
    if a == null {
        return null
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rc = result.data as *f32
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.sin(ra[i] as f64) as f32
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rc = result.data as *f64
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.sin(ra[i])
            i = i + 1
        }
    }

    return result
}

// Cosine
export fn tensor_cos(a: *Tensor): *Tensor {
    if a == null {
        return null
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rc = result.data as *f32
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.cos(ra[i] as f64) as f32
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rc = result.data as *f64
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.cos(ra[i])
            i = i + 1
        }
    }

    return result
}

// Hyperbolic tangent
export fn tensor_tanh(a: *Tensor): *Tensor {
    if a == null {
        return null
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rc = result.data as *f32
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.tanh(ra[i] as f64) as f32
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rc = result.data as *f64
        var i: u64 = 0
        while i < numel {
            rc[i] = basics.tanh(ra[i])
            i = i + 1
        }
    }

    return result
}

// Sigmoid function: 1 / (1 + exp(-x))
export fn tensor_sigmoid(a: *Tensor): *Tensor {
    if a == null {
        return null
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rc = result.data as *f32
        var i: u64 = 0
        while i < numel {
            let x = ra[i] as f64
            rc[i] = (1.0 / (1.0 + basics.exp(-x))) as f32
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rc = result.data as *f64
        var i: u64 = 0
        while i < numel {
            rc[i] = 1.0 / (1.0 + basics.exp(-ra[i]))
            i = i + 1
        }
    }

    return result
}

// ReLU: max(0, x)
export fn tensor_relu(a: *Tensor): *Tensor {
    if a == null {
        return null
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, a.dtype)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rc = result.data as *f32
        var i: u64 = 0
        while i < numel {
            rc[i] = if ra[i] > 0.0 { ra[i] } else { 0.0 }
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rc = result.data as *f64
        var i: u64 = 0
        while i < numel {
            rc[i] = if ra[i] > 0.0 { ra[i] } else { 0.0 }
            i = i + 1
        }
    }

    return result
}

// ============================================
// Linear Algebra
// ============================================

// Matrix multiplication (2D tensors)
export fn tensor_matmul(a: *Tensor, b: *Tensor): *Tensor {
    if a == null or b == null {
        return null
    }

    // Must be 2D
    if a.ndim != 2 or b.ndim != 2 {
        return null
    }

    // Check compatible dimensions: (M, K) x (K, N) -> (M, N)
    let m = a.shape[0]
    let k = a.shape[1]
    let n = b.shape[1]

    if a.shape[1] != b.shape[0] {
        return null
    }

    var shape: [2]u64 = [m, n]
    let result = tensor.tensor_zeros(&shape, 2, a.dtype)
    if result == null {
        return null
    }

    // Naive O(n^3) matrix multiplication
    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rb = b.data as *f32
        let rc = result.data as *f32

        var i: u64 = 0
        while i < m {
            var j: u64 = 0
            while j < n {
                var sum: f32 = 0.0
                var kk: u64 = 0
                while kk < k {
                    sum = sum + ra[i * k + kk] * rb[kk * n + j]
                    kk = kk + 1
                }
                rc[i * n + j] = sum
                j = j + 1
            }
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rb = b.data as *f64
        let rc = result.data as *f64

        var i: u64 = 0
        while i < m {
            var j: u64 = 0
            while j < n {
                var sum: f64 = 0.0
                var kk: u64 = 0
                while kk < k {
                    sum = sum + ra[i * k + kk] * rb[kk * n + j]
                    kk = kk + 1
                }
                rc[i * n + j] = sum
                j = j + 1
            }
            i = i + 1
        }
    }

    return result
}

// Dot product of 1D tensors
export fn tensor_dot(a: *Tensor, b: *Tensor): f64 {
    if a == null or b == null {
        return 0.0
    }

    if a.ndim != 1 or b.ndim != 1 or a.shape[0] != b.shape[0] {
        return 0.0
    }

    let n = a.shape[0]
    var sum: f64 = 0.0

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rb = b.data as *f32
        var i: u64 = 0
        while i < n {
            sum = sum + (ra[i] * rb[i]) as f64
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        let rb = b.data as *f64
        var i: u64 = 0
        while i < n {
            sum = sum + ra[i] * rb[i]
            i = i + 1
        }
    }

    return sum
}

// ============================================
// Reduction Operations
// ============================================

// Sum all elements
export fn tensor_sum_all(a: *Tensor): f64 {
    if a == null {
        return 0.0
    }

    let numel = tensor.tensor_numel(a)
    var sum: f64 = 0.0

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        var i: u64 = 0
        while i < numel {
            sum = sum + (ra[i] as f64)
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        var i: u64 = 0
        while i < numel {
            sum = sum + ra[i]
            i = i + 1
        }
    }

    return sum
}

// Mean of all elements
export fn tensor_mean_all(a: *Tensor): f64 {
    if a == null {
        return 0.0
    }

    let numel = tensor.tensor_numel(a)
    if numel == 0 {
        return 0.0
    }

    return tensor_sum_all(a) / (numel as f64)
}

// Maximum element
export fn tensor_max_all(a: *Tensor): f64 {
    if a == null {
        return 0.0
    }

    let numel = tensor.tensor_numel(a)
    if numel == 0 {
        return 0.0
    }

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        var max_val: f64 = ra[0] as f64
        var i: u64 = 1
        while i < numel {
            if (ra[i] as f64) > max_val {
                max_val = ra[i] as f64
            }
            i = i + 1
        }
        return max_val
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        var max_val: f64 = ra[0]
        var i: u64 = 1
        while i < numel {
            if ra[i] > max_val {
                max_val = ra[i]
            }
            i = i + 1
        }
        return max_val
    }

    return 0.0
}

// Minimum element
export fn tensor_min_all(a: *Tensor): f64 {
    if a == null {
        return 0.0
    }

    let numel = tensor.tensor_numel(a)
    if numel == 0 {
        return 0.0
    }

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        var min_val: f64 = ra[0] as f64
        var i: u64 = 1
        while i < numel {
            if (ra[i] as f64) < min_val {
                min_val = ra[i] as f64
            }
            i = i + 1
        }
        return min_val
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        var min_val: f64 = ra[0]
        var i: u64 = 1
        while i < numel {
            if ra[i] < min_val {
                min_val = ra[i]
            }
            i = i + 1
        }
        return min_val
    }

    return 0.0
}

// Argmax - return index of maximum element
export fn tensor_argmax_all(a: *Tensor): u64 {
    if a == null {
        return 0
    }

    let numel = tensor.tensor_numel(a)
    if numel == 0 {
        return 0
    }

    var max_idx: u64 = 0

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        var max_val: f32 = ra[0]
        var i: u64 = 1
        while i < numel {
            if ra[i] > max_val {
                max_val = ra[i]
                max_idx = i
            }
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        var max_val: f64 = ra[0]
        var i: u64 = 1
        while i < numel {
            if ra[i] > max_val {
                max_val = ra[i]
                max_idx = i
            }
            i = i + 1
        }
    }

    return max_idx
}

// Argmin - return index of minimum element
export fn tensor_argmin_all(a: *Tensor): u64 {
    if a == null {
        return 0
    }

    let numel = tensor.tensor_numel(a)
    if numel == 0 {
        return 0
    }

    var min_idx: u64 = 0

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        var min_val: f32 = ra[0]
        var i: u64 = 1
        while i < numel {
            if ra[i] < min_val {
                min_val = ra[i]
                min_idx = i
            }
            i = i + 1
        }
    } else if a.dtype == DTYPE_F64 {
        let ra = a.data as *f64
        var min_val: f64 = ra[0]
        var i: u64 = 1
        while i < numel {
            if ra[i] < min_val {
                min_val = ra[i]
                min_idx = i
            }
            i = i + 1
        }
    }

    return min_idx
}

// ============================================
// Comparison Operations
// ============================================

// Element-wise equality
export fn tensor_eq(a: *Tensor, b: *Tensor): *Tensor {
    if a == null or b == null or a.ndim != b.ndim {
        return null
    }

    var i: u32 = 0
    while i < a.ndim {
        if a.shape[i] != b.shape[i] {
            return null
        }
        i = i + 1
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, tensor.DTYPE_BOOL)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)
    let rc = result.data as *u8

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rb = b.data as *f32
        var j: u64 = 0
        while j < numel {
            rc[j] = if ra[j] == rb[j] { 1 } else { 0 }
            j = j + 1
        }
    }

    return result
}

// Element-wise greater than
export fn tensor_gt(a: *Tensor, b: *Tensor): *Tensor {
    if a == null or b == null or a.ndim != b.ndim {
        return null
    }

    var i: u32 = 0
    while i < a.ndim {
        if a.shape[i] != b.shape[i] {
            return null
        }
        i = i + 1
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, tensor.DTYPE_BOOL)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)
    let rc = result.data as *u8

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rb = b.data as *f32
        var j: u64 = 0
        while j < numel {
            rc[j] = if ra[j] > rb[j] { 1 } else { 0 }
            j = j + 1
        }
    }

    return result
}

// Element-wise less than
export fn tensor_lt(a: *Tensor, b: *Tensor): *Tensor {
    if a == null or b == null or a.ndim != b.ndim {
        return null
    }

    var i: u32 = 0
    while i < a.ndim {
        if a.shape[i] != b.shape[i] {
            return null
        }
        i = i + 1
    }

    let result = tensor.tensor_empty(&a.shape, a.ndim, tensor.DTYPE_BOOL)
    if result == null {
        return null
    }

    let numel = tensor.tensor_numel(a)
    let rc = result.data as *u8

    if a.dtype == DTYPE_F32 {
        let ra = a.data as *f32
        let rb = b.data as *f32
        var j: u64 = 0
        while j < numel {
            rc[j] = if ra[j] < rb[j] { 1 } else { 0 }
            j = j + 1
        }
    }

    return result
}

// ============================================
// Concatenation
// ============================================

// Concatenate tensors along dimension
export fn tensor_cat(tensors: **Tensor, count: u32, dim: u32): *Tensor {
    if tensors == null or count == 0 {
        return null
    }

    // Verify all tensors have same ndim and compatible shapes
    let first = tensors[0]
    if first == null or dim >= first.ndim {
        return null
    }

    var total_dim_size: u64 = 0
    var i: u32 = 0
    while i < count {
        let t = tensors[i]
        if t == null or t.ndim != first.ndim or t.dtype != first.dtype {
            return null
        }

        // Check all dims match except the concat dim
        var d: u32 = 0
        while d < first.ndim {
            if d != dim and t.shape[d] != first.shape[d] {
                return null
            }
            d = d + 1
        }

        total_dim_size = total_dim_size + t.shape[dim]
        i = i + 1
    }

    // Create output shape
    var out_shape: [tensor.MAX_DIMS]u64
    basics.memcpy(&out_shape, &first.shape, first.ndim * 8)
    out_shape[dim] = total_dim_size

    let result = tensor.tensor_empty(&out_shape, first.ndim, first.dtype)
    if result == null {
        return null
    }

    // Copy data (simplified - assumes contiguous)
    var offset: u64 = 0
    i = 0
    while i < count {
        let t = tensors[i]
        let size = tensor.tensor_numel(t) * tensor.dtype_size(t.dtype)
        basics.memcpy((result.data as u64 + offset) as *void, t.data, size)
        offset = offset + size
        i = i + 1
    }

    return result
}

// Stack tensors along new dimension
export fn tensor_stack(tensors: **Tensor, count: u32, dim: u32): *Tensor {
    if tensors == null or count == 0 {
        return null
    }

    let first = tensors[0]
    if first == null or dim > first.ndim {
        return null
    }

    // Unsqueeze each tensor and concatenate
    var unsqueezed: [32]*Tensor
    if count > 32 {
        return null
    }

    var i: u32 = 0
    while i < count {
        unsqueezed[i] = tensor.tensor_unsqueeze(tensors[i], dim)
        if unsqueezed[i] == null {
            // Cleanup
            var j: u32 = 0
            while j < i {
                tensor.tensor_release(unsqueezed[j])
                j = j + 1
            }
            return null
        }
        i = i + 1
    }

    let result = tensor_cat(&unsqueezed, count, dim)

    // Cleanup unsqueezed tensors
    i = 0
    while i < count {
        tensor.tensor_release(unsqueezed[i])
        i = i + 1
    }

    return result
}
