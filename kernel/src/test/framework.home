// HomeOS Unit Testing Framework
// Provides test case management, assertions, and reporting

const basics = @import("basics")

// Test result status codes
const TEST_PASSED: u32 = 0
const TEST_FAILED: u32 = 1
const TEST_SKIPPED: u32 = 2
const TEST_TIMEOUT: u32 = 3

// Test tags for categorization (bitmask)
const TAG_UNIT: u32 = 1
const TAG_INTEGRATION: u32 = 2
const TAG_STRESS: u32 = 4
const TAG_REGRESSION: u32 = 8
const TAG_PERFORMANCE: u32 = 16

// Maximum limits
const MAX_TESTS_PER_SUITE: u32 = 128
const MAX_SUITES: u32 = 64
const MAX_MESSAGE_LEN: u32 = 256

// Test case structure
struct TestCase {
    name: [u8; 64]
    description: [u8; 128]
    test_fn: fn() -> u32
    setup_fn: fn() -> void
    teardown_fn: fn() -> void
    timeout_ms: u32
    tags: u32
    enabled: bool
}

// Test result structure
struct TestResult {
    test_name: [u8; 64]
    status: u32
    duration_us: u64
    message: [u8; MAX_MESSAGE_LEN]
    file: [u8; 128]
    line: u32
    assertions_passed: u32
    assertions_failed: u32
}

// Test suite structure
struct TestSuite {
    name: [u8; 64]
    description: [u8; 128]
    tests: [TestCase; MAX_TESTS_PER_SUITE]
    results: [TestResult; MAX_TESTS_PER_SUITE]
    test_count: u32
    suite_setup_fn: fn() -> void
    suite_teardown_fn: fn() -> void
    passed: u32
    failed: u32
    skipped: u32
    total_duration_us: u64
}

// Global test registry
struct TestRegistry {
    suites: [*TestSuite; MAX_SUITES]
    suite_count: u32
    current_suite: *TestSuite
    current_test: *TestCase
    current_result: *TestResult
    verbose: bool
    fail_fast: bool
    filter_tags: u32
}

var test_registry: TestRegistry = TestRegistry {
    suites: [null; MAX_SUITES],
    suite_count: 0,
    current_suite: null,
    current_test: null,
    current_result: null,
    verbose: true,
    fail_fast: false,
    filter_tags: 0xFFFFFFFF
}

// Assertion context for better error messages
struct AssertionContext {
    file: [u8; 128]
    line: u32
    function: [u8; 64]
}

var current_assertion_ctx: AssertionContext = AssertionContext {
    file: [0; 128],
    line: 0,
    function: [0; 64]
}

// Initialize testing framework
export fn test_init(): void {
    test_registry.suite_count = 0
    test_registry.current_suite = null
    test_registry.current_test = null
    test_registry.verbose = true
    test_registry.fail_fast = false
    test_registry.filter_tags = 0xFFFFFFFF
}

// Create a new test suite
export fn test_suite_create(name: *u8, description: *u8): *TestSuite {
    if test_registry.suite_count >= MAX_SUITES {
        return null
    }

    let suite = basics.alloc(TestSuite)
    if suite == null {
        return null
    }

    // Copy name
    let name_len = basics.strlen(name)
    if name_len > 63 {
        name_len = 63
    }
    basics.memcpy(&suite.name, name, name_len)
    suite.name[name_len] = 0

    // Copy description
    let desc_len = basics.strlen(description)
    if desc_len > 127 {
        desc_len = 127
    }
    basics.memcpy(&suite.description, description, desc_len)
    suite.description[desc_len] = 0

    suite.test_count = 0
    suite.passed = 0
    suite.failed = 0
    suite.skipped = 0
    suite.total_duration_us = 0
    suite.suite_setup_fn = null
    suite.suite_teardown_fn = null

    test_registry.suites[test_registry.suite_count] = suite
    test_registry.suite_count = test_registry.suite_count + 1

    return suite
}

// Add a test case to a suite
export fn test_add(suite: *TestSuite, name: *u8, test_fn: fn() -> u32, tags: u32): bool {
    if suite == null or suite.test_count >= MAX_TESTS_PER_SUITE {
        return false
    }

    let idx = suite.test_count
    let test = &suite.tests[idx]

    // Copy name
    let name_len = basics.strlen(name)
    if name_len > 63 {
        name_len = 63
    }
    basics.memcpy(&test.name, name, name_len)
    test.name[name_len] = 0

    test.test_fn = test_fn
    test.setup_fn = null
    test.teardown_fn = null
    test.timeout_ms = 5000  // Default 5 second timeout
    test.tags = tags
    test.enabled = true

    suite.test_count = suite.test_count + 1
    return true
}

// Add a test with setup/teardown
export fn test_add_with_fixtures(
    suite: *TestSuite,
    name: *u8,
    test_fn: fn() -> u32,
    setup_fn: fn() -> void,
    teardown_fn: fn() -> void,
    tags: u32
): bool {
    if !test_add(suite, name, test_fn, tags) {
        return false
    }

    let idx = suite.test_count - 1
    suite.tests[idx].setup_fn = setup_fn
    suite.tests[idx].teardown_fn = teardown_fn
    return true
}

// Set test timeout
export fn test_set_timeout(suite: *TestSuite, test_idx: u32, timeout_ms: u32): void {
    if suite != null and test_idx < suite.test_count {
        suite.tests[test_idx].timeout_ms = timeout_ms
    }
}

// Get current timestamp in microseconds (placeholder - needs kernel timer)
fn get_timestamp_us(): u64 {
    // TODO: Integrate with kernel timer
    return 0
}

// Run a single test
fn run_single_test(suite: *TestSuite, test_idx: u32): u32 {
    let test = &suite.tests[test_idx]
    let result = &suite.results[test_idx]

    // Initialize result
    basics.memcpy(&result.test_name, &test.name, 64)
    result.status = TEST_PASSED
    result.duration_us = 0
    result.assertions_passed = 0
    result.assertions_failed = 0
    result.message[0] = 0

    // Check if test should be skipped
    if !test.enabled {
        result.status = TEST_SKIPPED
        return TEST_SKIPPED
    }

    // Check tag filter
    if (test.tags & test_registry.filter_tags) == 0 {
        result.status = TEST_SKIPPED
        return TEST_SKIPPED
    }

    // Set current test context
    test_registry.current_test = test
    test_registry.current_result = result

    let start_time = get_timestamp_us()

    // Run setup if provided
    if test.setup_fn != null {
        test.setup_fn()
    }

    // Run the actual test
    let test_result = test.test_fn()

    // Run teardown if provided
    if test.teardown_fn != null {
        test.teardown_fn()
    }

    let end_time = get_timestamp_us()
    result.duration_us = end_time - start_time

    // Determine final status
    if test_result != TEST_PASSED or result.assertions_failed > 0 {
        result.status = TEST_FAILED
    }

    // Clear current test context
    test_registry.current_test = null
    test_registry.current_result = null

    return result.status
}

// Run all tests in a suite
export fn test_run_suite(suite: *TestSuite): void {
    if suite == null {
        return
    }

    test_registry.current_suite = suite
    suite.passed = 0
    suite.failed = 0
    suite.skipped = 0
    suite.total_duration_us = 0

    if test_registry.verbose {
        basics.print("Running test suite: ")
        basics.print(&suite.name)
        basics.print("\n")
    }

    // Run suite setup
    if suite.suite_setup_fn != null {
        suite.suite_setup_fn()
    }

    // Run each test
    var i: u32 = 0
    while i < suite.test_count {
        if test_registry.verbose {
            basics.print("  [")
            basics.print_int(i + 1)
            basics.print("/")
            basics.print_int(suite.test_count)
            basics.print("] ")
            basics.print(&suite.tests[i].name)
            basics.print(" ... ")
        }

        let result = run_single_test(suite, i)

        if result == TEST_PASSED {
            suite.passed = suite.passed + 1
            if test_registry.verbose {
                basics.print("PASSED\n")
            }
        } else if result == TEST_SKIPPED {
            suite.skipped = suite.skipped + 1
            if test_registry.verbose {
                basics.print("SKIPPED\n")
            }
        } else {
            suite.failed = suite.failed + 1
            if test_registry.verbose {
                basics.print("FAILED\n")
                if suite.results[i].message[0] != 0 {
                    basics.print("    Reason: ")
                    basics.print(&suite.results[i].message)
                    basics.print("\n")
                }
            }

            if test_registry.fail_fast {
                break
            }
        }

        suite.total_duration_us = suite.total_duration_us + suite.results[i].duration_us
        i = i + 1
    }

    // Run suite teardown
    if suite.suite_teardown_fn != null {
        suite.suite_teardown_fn()
    }

    test_registry.current_suite = null
}

// Run all registered suites
export fn test_run_all(): void {
    var total_passed: u32 = 0
    var total_failed: u32 = 0
    var total_skipped: u32 = 0

    var i: u32 = 0
    while i < test_registry.suite_count {
        let suite = test_registry.suites[i]
        test_run_suite(suite)

        total_passed = total_passed + suite.passed
        total_failed = total_failed + suite.failed
        total_skipped = total_skipped + suite.skipped
        i = i + 1
    }

    // Print summary
    basics.print("\n========================================\n")
    basics.print("Test Summary:\n")
    basics.print("  Suites run: ")
    basics.print_int(test_registry.suite_count)
    basics.print("\n  Tests passed: ")
    basics.print_int(total_passed)
    basics.print("\n  Tests failed: ")
    basics.print_int(total_failed)
    basics.print("\n  Tests skipped: ")
    basics.print_int(total_skipped)
    basics.print("\n========================================\n")
}

// Run tests matching specific tags
export fn test_run_tagged(tag_mask: u32): void {
    let old_filter = test_registry.filter_tags
    test_registry.filter_tags = tag_mask
    test_run_all()
    test_registry.filter_tags = old_filter
}

// Assertion functions

// Basic assertion
export fn assert_true(condition: bool, message: *u8): void {
    let result = test_registry.current_result
    if result == null {
        return
    }

    if condition {
        result.assertions_passed = result.assertions_passed + 1
    } else {
        result.assertions_failed = result.assertions_failed + 1
        if message != null and result.message[0] == 0 {
            let msg_len = basics.strlen(message)
            if msg_len > MAX_MESSAGE_LEN - 1 {
                msg_len = MAX_MESSAGE_LEN - 1
            }
            basics.memcpy(&result.message, message, msg_len)
            result.message[msg_len] = 0
        }
    }
}

export fn assert_false(condition: bool, message: *u8): void {
    assert_true(!condition, message)
}

// Equality assertions
export fn assert_eq_u32(actual: u32, expected: u32, message: *u8): void {
    assert_true(actual == expected, message)
}

export fn assert_eq_u64(actual: u64, expected: u64, message: *u8): void {
    assert_true(actual == expected, message)
}

export fn assert_eq_i32(actual: i32, expected: i32, message: *u8): void {
    assert_true(actual == expected, message)
}

export fn assert_eq_i64(actual: i64, expected: i64, message: *u8): void {
    assert_true(actual == expected, message)
}

export fn assert_eq_ptr(actual: *void, expected: *void, message: *u8): void {
    assert_true(actual == expected, message)
}

// Inequality assertions
export fn assert_ne_u32(actual: u32, expected: u32, message: *u8): void {
    assert_true(actual != expected, message)
}

export fn assert_ne_u64(actual: u64, expected: u64, message: *u8): void {
    assert_true(actual != expected, message)
}

// Comparison assertions
export fn assert_lt_u32(actual: u32, expected: u32, message: *u8): void {
    assert_true(actual < expected, message)
}

export fn assert_le_u32(actual: u32, expected: u32, message: *u8): void {
    assert_true(actual <= expected, message)
}

export fn assert_gt_u32(actual: u32, expected: u32, message: *u8): void {
    assert_true(actual > expected, message)
}

export fn assert_ge_u32(actual: u32, expected: u32, message: *u8): void {
    assert_true(actual >= expected, message)
}

// Null pointer assertions
export fn assert_null(ptr: *void, message: *u8): void {
    assert_true(ptr == null, message)
}

export fn assert_not_null(ptr: *void, message: *u8): void {
    assert_true(ptr != null, message)
}

// String assertions
export fn assert_eq_str(actual: *u8, expected: *u8, message: *u8): void {
    let result = basics.strcmp(actual, expected) == 0
    assert_true(result, message)
}

// Memory assertions
export fn assert_mem_eq(actual: *void, expected: *void, size: u32, message: *u8): void {
    let result = basics.memcmp(actual, expected, size) == 0
    assert_true(result, message)
}

// Range assertions
export fn assert_in_range_u32(value: u32, min: u32, max: u32, message: *u8): void {
    assert_true(value >= min and value <= max, message)
}

// Configuration functions

export fn test_set_verbose(verbose: bool): void {
    test_registry.verbose = verbose
}

export fn test_set_fail_fast(fail_fast: bool): void {
    test_registry.fail_fast = fail_fast
}

export fn test_set_filter(tag_mask: u32): void {
    test_registry.filter_tags = tag_mask
}

// Get test results
export fn test_get_suite_results(suite: *TestSuite, passed: *u32, failed: *u32, skipped: *u32): void {
    if suite != null {
        *passed = suite.passed
        *failed = suite.failed
        *skipped = suite.skipped
    }
}

// Print detailed results for a suite
export fn test_print_results(suite: *TestSuite): void {
    if suite == null {
        return
    }

    basics.print("\nDetailed results for: ")
    basics.print(&suite.name)
    basics.print("\n")
    basics.print("----------------------------------------\n")

    var i: u32 = 0
    while i < suite.test_count {
        let result = &suite.results[i]
        basics.print("  ")
        basics.print(&result.test_name)
        basics.print(": ")

        if result.status == TEST_PASSED {
            basics.print("PASSED")
        } else if result.status == TEST_FAILED {
            basics.print("FAILED")
        } else if result.status == TEST_SKIPPED {
            basics.print("SKIPPED")
        } else {
            basics.print("TIMEOUT")
        }

        basics.print(" (")
        basics.print_int(result.assertions_passed)
        basics.print(" passed, ")
        basics.print_int(result.assertions_failed)
        basics.print(" failed)\n")

        if result.message[0] != 0 {
            basics.print("    Message: ")
            basics.print(&result.message)
            basics.print("\n")
        }

        i = i + 1
    }

    basics.print("----------------------------------------\n")
    basics.print("Total: ")
    basics.print_int(suite.passed)
    basics.print(" passed, ")
    basics.print_int(suite.failed)
    basics.print(" failed, ")
    basics.print_int(suite.skipped)
    basics.print(" skipped\n")
}

// Export results in JSON format
export fn test_export_json(suite: *TestSuite, buffer: *u8, max_len: u32): u32 {
    if suite == null or buffer == null or max_len < 100 {
        return 0
    }

    var pos: u32 = 0

    // Start JSON object
    pos = basics.sprintf(buffer, "{\n  \"suite\": \"%s\",\n", &suite.name)
    pos = pos + basics.sprintf(buffer + pos, "  \"passed\": %d,\n", suite.passed)
    pos = pos + basics.sprintf(buffer + pos, "  \"failed\": %d,\n", suite.failed)
    pos = pos + basics.sprintf(buffer + pos, "  \"skipped\": %d,\n", suite.skipped)
    pos = pos + basics.sprintf(buffer + pos, "  \"tests\": [\n")

    var i: u32 = 0
    while i < suite.test_count and pos < max_len - 200 {
        let result = &suite.results[i]
        let status_str = if result.status == TEST_PASSED { "passed" }
                        else if result.status == TEST_FAILED { "failed" }
                        else if result.status == TEST_SKIPPED { "skipped" }
                        else { "timeout" }

        pos = pos + basics.sprintf(buffer + pos, "    {\n")
        pos = pos + basics.sprintf(buffer + pos, "      \"name\": \"%s\",\n", &result.test_name)
        pos = pos + basics.sprintf(buffer + pos, "      \"status\": \"%s\",\n", status_str)
        pos = pos + basics.sprintf(buffer + pos, "      \"duration_us\": %d\n", result.duration_us)

        if i < suite.test_count - 1 {
            pos = pos + basics.sprintf(buffer + pos, "    },\n")
        } else {
            pos = pos + basics.sprintf(buffer + pos, "    }\n")
        }

        i = i + 1
    }

    pos = pos + basics.sprintf(buffer + pos, "  ]\n}\n")

    return pos
}

// TAP (Test Anything Protocol) output for CI
export fn test_export_tap(suite: *TestSuite, buffer: *u8, max_len: u32): u32 {
    if suite == null or buffer == null or max_len < 100 {
        return 0
    }

    var pos: u32 = 0

    // TAP version and plan
    pos = basics.sprintf(buffer, "TAP version 13\n")
    pos = pos + basics.sprintf(buffer + pos, "1..%d\n", suite.test_count)

    var i: u32 = 0
    while i < suite.test_count and pos < max_len - 100 {
        let result = &suite.results[i]

        if result.status == TEST_PASSED {
            pos = pos + basics.sprintf(buffer + pos, "ok %d - %s\n", i + 1, &result.test_name)
        } else if result.status == TEST_SKIPPED {
            pos = pos + basics.sprintf(buffer + pos, "ok %d - %s # SKIP\n", i + 1, &result.test_name)
        } else {
            pos = pos + basics.sprintf(buffer + pos, "not ok %d - %s\n", i + 1, &result.test_name)
            if result.message[0] != 0 {
                pos = pos + basics.sprintf(buffer + pos, "  ---\n  message: %s\n  ...\n", &result.message)
            }
        }

        i = i + 1
    }

    return pos
}

// Quick test macro-like function for simple tests
export fn test_quick(name: *u8, condition: bool): void {
    if condition {
        basics.print("[PASS] ")
    } else {
        basics.print("[FAIL] ")
    }
    basics.print(name)
    basics.print("\n")
}
