// home-os HDMI CEC (Consumer Electronics Control) Driver
// Allows control of TV/monitor via HDMI and receiving remote commands
// Works with LG 27UP850-W and other CEC-capable displays

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "./rp1_hdmi.home" as hdmi

// CEC register offsets (within HDMI block)
const CEC_CTRL: u64 = 0x140
const CEC_STATUS: u64 = 0x144
const CEC_TX_DATA: u64 = 0x148
const CEC_RX_DATA: u64 = 0x14C
const CEC_TX_CNT: u64 = 0x150
const CEC_RX_CNT: u64 = 0x154
const CEC_ADDR: u64 = 0x158
const CEC_INT_EN: u64 = 0x15C
const CEC_INT_STATUS: u64 = 0x160

// CEC logical addresses
const CEC_ADDR_TV: u8 = 0
const CEC_ADDR_RECORDING1: u8 = 1
const CEC_ADDR_RECORDING2: u8 = 2
const CEC_ADDR_TUNER1: u8 = 3
const CEC_ADDR_PLAYBACK1: u8 = 4
const CEC_ADDR_AUDIO: u8 = 5
const CEC_ADDR_TUNER2: u8 = 6
const CEC_ADDR_TUNER3: u8 = 7
const CEC_ADDR_PLAYBACK2: u8 = 8
const CEC_ADDR_RECORDING3: u8 = 9
const CEC_ADDR_TUNER4: u8 = 10
const CEC_ADDR_PLAYBACK3: u8 = 11
const CEC_ADDR_RESERVED1: u8 = 12
const CEC_ADDR_RESERVED2: u8 = 13
const CEC_ADDR_SPECIFIC: u8 = 14
const CEC_ADDR_BROADCAST: u8 = 15

// CEC opcodes
const CEC_OP_FEATURE_ABORT: u8 = 0x00
const CEC_OP_IMAGE_VIEW_ON: u8 = 0x04
const CEC_OP_TUNER_STEP_INC: u8 = 0x05
const CEC_OP_TUNER_STEP_DEC: u8 = 0x06
const CEC_OP_GIVE_TUNER_STATUS: u8 = 0x08
const CEC_OP_RECORD_ON: u8 = 0x09
const CEC_OP_RECORD_STATUS: u8 = 0x0A
const CEC_OP_RECORD_OFF: u8 = 0x0B
const CEC_OP_TEXT_VIEW_ON: u8 = 0x0D
const CEC_OP_RECORD_TV_SCREEN: u8 = 0x0F
const CEC_OP_GIVE_DECK_STATUS: u8 = 0x1A
const CEC_OP_DECK_STATUS: u8 = 0x1B
const CEC_OP_SET_MENU_LANG: u8 = 0x32
const CEC_OP_CLEAR_ANALOG_TIMER: u8 = 0x33
const CEC_OP_SET_ANALOG_TIMER: u8 = 0x34
const CEC_OP_TIMER_STATUS: u8 = 0x35
const CEC_OP_STANDBY: u8 = 0x36
const CEC_OP_PLAY: u8 = 0x41
const CEC_OP_DECK_CONTROL: u8 = 0x42
const CEC_OP_TIMER_CLEARED_STATUS: u8 = 0x43
const CEC_OP_USER_CONTROL_PRESSED: u8 = 0x44
const CEC_OP_USER_CONTROL_RELEASED: u8 = 0x45
const CEC_OP_GIVE_OSD_NAME: u8 = 0x46
const CEC_OP_SET_OSD_NAME: u8 = 0x47
const CEC_OP_SET_OSD_STRING: u8 = 0x64
const CEC_OP_SET_TIMER_PROGRAM_TITLE: u8 = 0x67
const CEC_OP_SYSTEM_AUDIO_MODE_REQ: u8 = 0x70
const CEC_OP_GIVE_AUDIO_STATUS: u8 = 0x71
const CEC_OP_SET_SYSTEM_AUDIO_MODE: u8 = 0x72
const CEC_OP_REPORT_AUDIO_STATUS: u8 = 0x7A
const CEC_OP_GIVE_SYSTEM_AUDIO_MODE: u8 = 0x7D
const CEC_OP_SYSTEM_AUDIO_MODE_STATUS: u8 = 0x7E
const CEC_OP_ROUTING_CHANGE: u8 = 0x80
const CEC_OP_ROUTING_INFO: u8 = 0x81
const CEC_OP_ACTIVE_SOURCE: u8 = 0x82
const CEC_OP_GIVE_PHYSICAL_ADDR: u8 = 0x83
const CEC_OP_REPORT_PHYSICAL_ADDR: u8 = 0x84
const CEC_OP_REQUEST_ACTIVE_SOURCE: u8 = 0x85
const CEC_OP_SET_STREAM_PATH: u8 = 0x86
const CEC_OP_DEVICE_VENDOR_ID: u8 = 0x87
const CEC_OP_VENDOR_COMMAND: u8 = 0x89
const CEC_OP_VENDOR_REMOTE_BUTTON_DOWN: u8 = 0x8A
const CEC_OP_VENDOR_REMOTE_BUTTON_UP: u8 = 0x8B
const CEC_OP_GIVE_DEVICE_VENDOR_ID: u8 = 0x8C
const CEC_OP_MENU_REQUEST: u8 = 0x8D
const CEC_OP_MENU_STATUS: u8 = 0x8E
const CEC_OP_GIVE_DEVICE_POWER_STATUS: u8 = 0x8F
const CEC_OP_REPORT_POWER_STATUS: u8 = 0x90
const CEC_OP_GET_MENU_LANG: u8 = 0x91
const CEC_OP_SELECT_ANALOG_SERVICE: u8 = 0x92
const CEC_OP_SELECT_DIGITAL_SERVICE: u8 = 0x93
const CEC_OP_SET_DIGITAL_TIMER: u8 = 0x97
const CEC_OP_CLEAR_DIGITAL_TIMER: u8 = 0x99
const CEC_OP_SET_AUDIO_RATE: u8 = 0x9A
const CEC_OP_INACTIVE_SOURCE: u8 = 0x9D
const CEC_OP_CEC_VERSION: u8 = 0x9E
const CEC_OP_GET_CEC_VERSION: u8 = 0x9F
const CEC_OP_VENDOR_COMMAND_WITH_ID: u8 = 0xA0
const CEC_OP_CLEAR_EXT_TIMER: u8 = 0xA1
const CEC_OP_SET_EXT_TIMER: u8 = 0xA2
const CEC_OP_ABORT: u8 = 0xFF

// Remote control button codes
const CEC_RC_SELECT: u8 = 0x00
const CEC_RC_UP: u8 = 0x01
const CEC_RC_DOWN: u8 = 0x02
const CEC_RC_LEFT: u8 = 0x03
const CEC_RC_RIGHT: u8 = 0x04
const CEC_RC_RIGHT_UP: u8 = 0x05
const CEC_RC_RIGHT_DOWN: u8 = 0x06
const CEC_RC_LEFT_UP: u8 = 0x07
const CEC_RC_LEFT_DOWN: u8 = 0x08
const CEC_RC_ROOT_MENU: u8 = 0x09
const CEC_RC_SETUP_MENU: u8 = 0x0A
const CEC_RC_CONTENTS_MENU: u8 = 0x0B
const CEC_RC_EXIT: u8 = 0x0D
const CEC_RC_NUMBER_0: u8 = 0x20
const CEC_RC_NUMBER_1: u8 = 0x21
const CEC_RC_NUMBER_2: u8 = 0x22
const CEC_RC_NUMBER_3: u8 = 0x23
const CEC_RC_NUMBER_4: u8 = 0x24
const CEC_RC_NUMBER_5: u8 = 0x25
const CEC_RC_NUMBER_6: u8 = 0x26
const CEC_RC_NUMBER_7: u8 = 0x27
const CEC_RC_NUMBER_8: u8 = 0x28
const CEC_RC_NUMBER_9: u8 = 0x29
const CEC_RC_CHANNEL_UP: u8 = 0x30
const CEC_RC_CHANNEL_DOWN: u8 = 0x31
const CEC_RC_PREVIOUS_CHANNEL: u8 = 0x32
const CEC_RC_SOUND_SELECT: u8 = 0x33
const CEC_RC_INPUT_SELECT: u8 = 0x34
const CEC_RC_DISPLAY_INFO: u8 = 0x35
const CEC_RC_POWER: u8 = 0x40
const CEC_RC_VOLUME_UP: u8 = 0x41
const CEC_RC_VOLUME_DOWN: u8 = 0x42
const CEC_RC_MUTE: u8 = 0x43
const CEC_RC_PLAY: u8 = 0x44
const CEC_RC_STOP: u8 = 0x45
const CEC_RC_PAUSE: u8 = 0x46
const CEC_RC_RECORD: u8 = 0x47
const CEC_RC_REWIND: u8 = 0x48
const CEC_RC_FAST_FORWARD: u8 = 0x49
const CEC_RC_EJECT: u8 = 0x4A
const CEC_RC_FORWARD: u8 = 0x4B
const CEC_RC_BACKWARD: u8 = 0x4C
const CEC_RC_F1_BLUE: u8 = 0x71
const CEC_RC_F2_RED: u8 = 0x72
const CEC_RC_F3_GREEN: u8 = 0x73
const CEC_RC_F4_YELLOW: u8 = 0x74

// CEC message
struct CecMessage {
    src: u8
    dst: u8
    opcode: u8
    data: [14]u8
    len: u8
}

// CEC controller state
struct CecController {
    initialized: u32
    port: u32
    logical_addr: u8
    physical_addr: u16
    osd_name: [14]u8
    vendor_id: u32
    enabled: u32
    active_source: u32
}

var cec: CecController

// Callback for received remote commands
var remote_callback: fn(u8) = null

// Statistics
var cec_tx_count: u64 = 0
var cec_rx_count: u64 = 0
var cec_errors: u64 = 0

// Read CEC register
fn cec_read(offset: u64): u32 {
    var base: u64 = hdmi.hdmi_get_base(cec.port)
    return memory.read_volatile_u32(base + offset)
}

// Write CEC register
fn cec_write(offset: u64, value: u32) {
    var base: u64 = hdmi.hdmi_get_base(cec.port)
    memory.write_volatile_u32(base + offset, value)
}

// Initialize CEC
export fn cec_init(port: u32): u32 {
    if port >= 2 { return 1 }

    foundation.serial_write_string("[CEC] Initializing on HDMI")
    foundation.serial_write_u64(port)
    foundation.serial_write_string("\n")

    cec.port = port
    cec.logical_addr = CEC_ADDR_PLAYBACK1  // Default to playback device
    cec.physical_addr = 0x1000  // Default physical address (1.0.0.0)
    cec.vendor_id = 0x000000  // No vendor ID set

    // Set OSD name to "HomeOS"
    cec.osd_name[0] = 'H'
    cec.osd_name[1] = 'o'
    cec.osd_name[2] = 'm'
    cec.osd_name[3] = 'e'
    cec.osd_name[4] = 'O'
    cec.osd_name[5] = 'S'
    cec.osd_name[6] = 0

    // Enable CEC controller
    cec_write(CEC_CTRL, 0x01)

    // Set logical address
    cec_write(CEC_ADDR, cec.logical_addr)

    // Enable interrupts
    cec_write(CEC_INT_EN, 0x07)  // TX done, RX done, error

    cec.initialized = 1
    cec.enabled = 1

    foundation.serial_write_string("[CEC] Initialized as playback device\n")
    return 0
}

// Send CEC message
export fn cec_send(msg: *CecMessage): u32 {
    if cec.initialized == 0 { return 1 }
    if cec.enabled == 0 { return 1 }

    // Wait for TX ready
    var timeout: u32 = 10000
    while timeout > 0 {
        var status: u32 = cec_read(CEC_STATUS)
        if (status & 0x01) == 0 {  // TX not busy
            break
        }
        timeout = timeout - 1
    }

    if timeout == 0 {
        cec_errors = cec_errors + 1
        return 1
    }

    // Build header byte: src << 4 | dst
    var header: u8 = (msg.src << 4) | (msg.dst & 0x0F)

    // Write data
    cec_write(CEC_TX_DATA, header)

    if msg.len > 0 {
        cec_write(CEC_TX_DATA + 4, msg.opcode)

        var i: u32 = 0
        while i < msg.len - 1 and i < 14 {
            cec_write(CEC_TX_DATA + 8 + (i * 4), msg.data[i])
            i = i + 1
        }
    }

    // Set TX count and start
    cec_write(CEC_TX_CNT, msg.len + 1)  // +1 for header
    cec_write(CEC_CTRL, cec_read(CEC_CTRL) | 0x02)  // Start TX

    cec_tx_count = cec_tx_count + 1

    return 0
}

// Receive CEC message (called from interrupt or poll)
export fn cec_receive(msg: *CecMessage): u32 {
    if cec.initialized == 0 { return 1 }

    // Check for received message
    var status: u32 = cec_read(CEC_STATUS)
    if (status & 0x02) == 0 {  // No RX data
        return 1
    }

    // Read message length
    var len: u32 = cec_read(CEC_RX_CNT) & 0x1F

    if len == 0 { return 1 }

    // Read header
    var header: u32 = cec_read(CEC_RX_DATA)
    msg.src = (header >> 4) & 0x0F
    msg.dst = header & 0x0F

    if len > 1 {
        msg.opcode = cec_read(CEC_RX_DATA + 4) & 0xFF
        msg.len = len - 1

        var i: u32 = 0
        while i < len - 2 and i < 14 {
            msg.data[i] = cec_read(CEC_RX_DATA + 8 + (i * 4)) & 0xFF
            i = i + 1
        }
    } else {
        msg.opcode = 0
        msg.len = 0
    }

    // Clear RX flag
    cec_write(CEC_INT_STATUS, 0x02)

    cec_rx_count = cec_rx_count + 1

    return 0
}

// Handle received message
export fn cec_handle_message(msg: *CecMessage) {
    if msg.dst != cec.logical_addr and msg.dst != CEC_ADDR_BROADCAST {
        return
    }

    if msg.opcode == CEC_OP_GIVE_PHYSICAL_ADDR {
        cec_report_physical_addr()
    } else if msg.opcode == CEC_OP_GIVE_OSD_NAME {
        cec_send_osd_name(msg.src)
    } else if msg.opcode == CEC_OP_GIVE_DEVICE_VENDOR_ID {
        cec_send_vendor_id()
    } else if msg.opcode == CEC_OP_GET_CEC_VERSION {
        cec_send_version(msg.src)
    } else if msg.opcode == CEC_OP_GIVE_DEVICE_POWER_STATUS {
        cec_send_power_status(msg.src)
    } else if msg.opcode == CEC_OP_USER_CONTROL_PRESSED {
        if msg.len > 0 and remote_callback != null {
            remote_callback(msg.data[0])
        }
    } else if msg.opcode == CEC_OP_STANDBY {
        // Monitor requesting standby
        foundation.serial_write_string("[CEC] Standby requested\n")
    } else if msg.opcode == CEC_OP_SET_STREAM_PATH {
        // Check if it's for us
        if msg.len >= 2 {
            var addr: u16 = (msg.data[0] << 8) | msg.data[1]
            if addr == cec.physical_addr {
                cec_set_active_source()
            }
        }
    }
}

// Report physical address
fn cec_report_physical_addr() {
    var msg: CecMessage
    msg.src = cec.logical_addr
    msg.dst = CEC_ADDR_BROADCAST
    msg.opcode = CEC_OP_REPORT_PHYSICAL_ADDR
    msg.data[0] = (cec.physical_addr >> 8) & 0xFF
    msg.data[1] = cec.physical_addr & 0xFF
    msg.data[2] = 4  // Device type: Playback
    msg.len = 4

    cec_send(&msg)
}

// Send OSD name
fn cec_send_osd_name(dst: u8) {
    var msg: CecMessage
    msg.src = cec.logical_addr
    msg.dst = dst
    msg.opcode = CEC_OP_SET_OSD_NAME
    msg.len = 1

    var i: u32 = 0
    while i < 14 and cec.osd_name[i] != 0 {
        msg.data[i] = cec.osd_name[i]
        msg.len = msg.len + 1
        i = i + 1
    }

    cec_send(&msg)
}

// Send vendor ID
fn cec_send_vendor_id() {
    var msg: CecMessage
    msg.src = cec.logical_addr
    msg.dst = CEC_ADDR_BROADCAST
    msg.opcode = CEC_OP_DEVICE_VENDOR_ID
    msg.data[0] = (cec.vendor_id >> 16) & 0xFF
    msg.data[1] = (cec.vendor_id >> 8) & 0xFF
    msg.data[2] = cec.vendor_id & 0xFF
    msg.len = 4

    cec_send(&msg)
}

// Send CEC version
fn cec_send_version(dst: u8) {
    var msg: CecMessage
    msg.src = cec.logical_addr
    msg.dst = dst
    msg.opcode = CEC_OP_CEC_VERSION
    msg.data[0] = 0x05  // CEC 1.4
    msg.len = 2

    cec_send(&msg)
}

// Send power status
fn cec_send_power_status(dst: u8) {
    var msg: CecMessage
    msg.src = cec.logical_addr
    msg.dst = dst
    msg.opcode = CEC_OP_REPORT_POWER_STATUS
    msg.data[0] = 0x00  // Power on
    msg.len = 2

    cec_send(&msg)
}

// Set as active source
export fn cec_set_active_source(): u32 {
    if cec.initialized == 0 { return 1 }

    foundation.serial_write_string("[CEC] Setting as active source\n")

    var msg: CecMessage
    msg.src = cec.logical_addr
    msg.dst = CEC_ADDR_BROADCAST
    msg.opcode = CEC_OP_ACTIVE_SOURCE
    msg.data[0] = (cec.physical_addr >> 8) & 0xFF
    msg.data[1] = cec.physical_addr & 0xFF
    msg.len = 3

    cec.active_source = 1

    return cec_send(&msg)
}

// Power on TV
export fn cec_power_on_tv(): u32 {
    if cec.initialized == 0 { return 1 }

    foundation.serial_write_string("[CEC] Powering on TV\n")

    var msg: CecMessage
    msg.src = cec.logical_addr
    msg.dst = CEC_ADDR_TV
    msg.opcode = CEC_OP_IMAGE_VIEW_ON
    msg.len = 1

    return cec_send(&msg)
}

// Put TV to standby
export fn cec_standby_tv(): u32 {
    if cec.initialized == 0 { return 1 }

    foundation.serial_write_string("[CEC] Putting TV to standby\n")

    var msg: CecMessage
    msg.src = cec.logical_addr
    msg.dst = CEC_ADDR_BROADCAST
    msg.opcode = CEC_OP_STANDBY
    msg.len = 1

    return cec_send(&msg)
}

// Set remote callback
export fn cec_set_remote_callback(callback: fn(u8)) {
    remote_callback = callback
}

// Set OSD name
export fn cec_set_osd_name(name: *u8) {
    var i: u32 = 0
    while i < 13 and name[i] != 0 {
        cec.osd_name[i] = name[i]
        i = i + 1
    }
    cec.osd_name[i] = 0
}

// Poll for messages
export fn cec_poll() {
    if cec.initialized == 0 { return }
    if cec.enabled == 0 { return }

    var msg: CecMessage
    if cec_receive(&msg) == 0 {
        cec_handle_message(&msg)
    }
}

// Print statistics
export fn cec_print_stats() {
    foundation.serial_write_string("\n[CEC] Statistics:\n")

    foundation.serial_write_string("  Logical address: ")
    foundation.serial_write_u64(cec.logical_addr)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  Physical address: ")
    foundation.serial_write_u64(cec.physical_addr >> 8)
    foundation.serial_write_string(".")
    foundation.serial_write_u64((cec.physical_addr >> 4) & 0xF)
    foundation.serial_write_string(".")
    foundation.serial_write_u64(cec.physical_addr & 0xF)
    foundation.serial_write_string(".0\n")

    foundation.serial_write_string("  OSD name: ")
    foundation.serial_write_string(&cec.osd_name[0])
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  TX count: ")
    foundation.serial_write_u64(cec_tx_count)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  RX count: ")
    foundation.serial_write_u64(cec_rx_count)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  Errors: ")
    foundation.serial_write_u64(cec_errors)
    foundation.serial_write_string("\n")

    if cec.active_source == 1 {
        foundation.serial_write_string("  Status: Active source\n")
    }
}
