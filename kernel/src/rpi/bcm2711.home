// home-os Raspberry Pi BCM2711 Support
// Broadcom BCM2711 SoC (Raspberry Pi 4, Pi 400, CM4)
// ARM Cortex-A72 quad-core @ 1.5GHz (1.8GHz turbo)
// VideoCore VI GPU, GIC-400 interrupt controller

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

// BCM2711 Memory Map
// Different from previous SoCs - 35-bit address space
const BCM2711_PERI_BASE: u64 = 0xFE000000      // Low peripheral base (legacy)
const BCM2711_PERI_BASE_HIGH: u64 = 0x47C000000 // High peripheral base (full 35-bit)
const BCM2711_ARM_LOCAL_BASE: u64 = 0xFF800000  // ARM local peripherals

// Peripheral Base Addresses (low peripheral mode)
const GPIO_BASE: u64 = BCM2711_PERI_BASE + 0x200000
const UART0_BASE: u64 = BCM2711_PERI_BASE + 0x201000   // PL011 UART
const UART2_BASE: u64 = BCM2711_PERI_BASE + 0x201400   // PL011 UART2
const UART3_BASE: u64 = BCM2711_PERI_BASE + 0x201600   // PL011 UART3
const UART4_BASE: u64 = BCM2711_PERI_BASE + 0x201800   // PL011 UART4
const UART5_BASE: u64 = BCM2711_PERI_BASE + 0x201A00   // PL011 UART5
const AUX_BASE: u64 = BCM2711_PERI_BASE + 0x215000     // Mini UART, SPI1, SPI2
const SPI0_BASE: u64 = BCM2711_PERI_BASE + 0x204000
const SPI3_BASE: u64 = BCM2711_PERI_BASE + 0x204600
const SPI4_BASE: u64 = BCM2711_PERI_BASE + 0x204800
const SPI5_BASE: u64 = BCM2711_PERI_BASE + 0x204A00
const SPI6_BASE: u64 = BCM2711_PERI_BASE + 0x204C00
const BSC0_BASE: u64 = BCM2711_PERI_BASE + 0x205000    // I2C0
const BSC1_BASE: u64 = BCM2711_PERI_BASE + 0x804000    // I2C1
const BSC3_BASE: u64 = BCM2711_PERI_BASE + 0x205600    // I2C3
const BSC4_BASE: u64 = BCM2711_PERI_BASE + 0x205800    // I2C4
const BSC5_BASE: u64 = BCM2711_PERI_BASE + 0x205A00    // I2C5
const BSC6_BASE: u64 = BCM2711_PERI_BASE + 0x205C00    // I2C6
const PWM0_BASE: u64 = BCM2711_PERI_BASE + 0x20C000
const PWM1_BASE: u64 = BCM2711_PERI_BASE + 0x20C800
const PCM_BASE: u64 = BCM2711_PERI_BASE + 0x203000     // I2S/PCM
const TIMER_BASE: u64 = BCM2711_PERI_BASE + 0x003000   // System Timer
const MBOX_BASE: u64 = BCM2711_PERI_BASE + 0x00B880    // Mailbox
const PM_BASE: u64 = BCM2711_PERI_BASE + 0x100000      // Power Management
const CM_BASE: u64 = BCM2711_PERI_BASE + 0x101000      // Clock Manager
const DMA_BASE: u64 = BCM2711_PERI_BASE + 0x007000     // DMA Controller
const DMA15_BASE: u64 = BCM2711_PERI_BASE + 0xE05000   // DMA15 (lite)
const EMMC2_BASE: u64 = BCM2711_PERI_BASE + 0x340000   // EMMC2 (SD card)
const HDMI0_BASE: u64 = BCM2711_PERI_BASE + 0x808000   // HDMI0
const HDMI1_BASE: u64 = BCM2711_PERI_BASE + 0x908000   // HDMI1
const PIXVALVE0_BASE: u64 = BCM2711_PERI_BASE + 0x206000
const PIXVALVE1_BASE: u64 = BCM2711_PERI_BASE + 0x207000
const PIXVALVE2_BASE: u64 = BCM2711_PERI_BASE + 0x20A000
const PIXVALVE3_BASE: u64 = BCM2711_PERI_BASE + 0x20F000
const PIXVALVE4_BASE: u64 = BCM2711_PERI_BASE + 0x216000
const HVS_BASE: u64 = BCM2711_PERI_BASE + 0x400000     // Hardware Video Scaler
const USB_BASE: u64 = BCM2711_PERI_BASE + 0x980000     // USB (DesignWare DWC2)
const ARGON_BASE: u64 = BCM2711_PERI_BASE + 0x00C000   // Argon memory controller
const THERMAL_BASE: u64 = BCM2711_PERI_BASE + 0x212000 // Thermal sensor

// GIC-400 Interrupt Controller
const GIC_DIST_BASE: u64 = 0xFF841000   // Distributor
const GIC_CPU_BASE: u64 = 0xFF842000    // CPU Interface

// PCIe Controller
const PCIE_BASE: u64 = 0xFD500000       // PCIe RC
const PCIE_MEM_BASE: u64 = 0x600000000  // PCIe memory window (64-bit)
const PCIE_MEM_SIZE: u64 = 0x3BFFFFFF   // ~960MB window

// USB 3.0 Controller (via VL805 on PCIe)
const XHCI_BASE: u64 = 0x600000000      // After PCIe enumeration

// VideoCore VI GPU
const VC6_BASE: u64 = 0xFEC00000
const V3D_BASE: u64 = 0xFEC04000        // V3D GPU (OpenGL ES 3.1)

// GPIO Register Offsets (same as BCM2835/2836/2837)
const GPFSEL0: u32 = 0x00
const GPFSEL1: u32 = 0x04
const GPFSEL2: u32 = 0x08
const GPFSEL3: u32 = 0x0C
const GPFSEL4: u32 = 0x10
const GPFSEL5: u32 = 0x14
const GPSET0: u32 = 0x1C
const GPSET1: u32 = 0x20
const GPCLR0: u32 = 0x28
const GPCLR1: u32 = 0x2C
const GPLEV0: u32 = 0x34
const GPLEV1: u32 = 0x38
const GPEDS0: u32 = 0x40
const GPEDS1: u32 = 0x44
const GPREN0: u32 = 0x4C
const GPREN1: u32 = 0x50
const GPFEN0: u32 = 0x58
const GPFEN1: u32 = 0x5C
const GPHEN0: u32 = 0x64
const GPHEN1: u32 = 0x68
const GPLEN0: u32 = 0x70
const GPLEN1: u32 = 0x74
const GPAREN0: u32 = 0x7C
const GPAREN1: u32 = 0x80
const GPAFEN0: u32 = 0x88
const GPAFEN1: u32 = 0x8C

// BCM2711 uses different pull-up/down registers
const GPIO_PUP_PDN_CNTRL_REG0: u32 = 0xE4
const GPIO_PUP_PDN_CNTRL_REG1: u32 = 0xE8
const GPIO_PUP_PDN_CNTRL_REG2: u32 = 0xEC
const GPIO_PUP_PDN_CNTRL_REG3: u32 = 0xF0

// GPIO Function Select Values
const GPIO_FSEL_INPUT: u32 = 0
const GPIO_FSEL_OUTPUT: u32 = 1
const GPIO_FSEL_ALT0: u32 = 4
const GPIO_FSEL_ALT1: u32 = 5
const GPIO_FSEL_ALT2: u32 = 6
const GPIO_FSEL_ALT3: u32 = 7
const GPIO_FSEL_ALT4: u32 = 3
const GPIO_FSEL_ALT5: u32 = 2

// Pull-up/down values (BCM2711 style)
const GPIO_PUD_NONE: u32 = 0
const GPIO_PUD_UP: u32 = 1
const GPIO_PUD_DOWN: u32 = 2

// UART0 (PL011) Register Offsets
const UART_DR: u32 = 0x00
const UART_RSRECR: u32 = 0x04
const UART_FR: u32 = 0x18
const UART_ILPR: u32 = 0x20
const UART_IBRD: u32 = 0x24
const UART_FBRD: u32 = 0x28
const UART_LCRH: u32 = 0x2C
const UART_CR: u32 = 0x30
const UART_IFLS: u32 = 0x34
const UART_IMSC: u32 = 0x38
const UART_RIS: u32 = 0x3C
const UART_MIS: u32 = 0x40
const UART_ICR: u32 = 0x44
const UART_DMACR: u32 = 0x48

// UART Flag Register bits
const UART_FR_TXFE: u32 = 0x80
const UART_FR_RXFF: u32 = 0x40
const UART_FR_TXFF: u32 = 0x20
const UART_FR_RXFE: u32 = 0x10
const UART_FR_BUSY: u32 = 0x08

// Mailbox Channels
const MBOX_CH_POWER: u32 = 0
const MBOX_CH_FB: u32 = 1
const MBOX_CH_VUART: u32 = 2
const MBOX_CH_VCHIQ: u32 = 3
const MBOX_CH_LEDS: u32 = 4
const MBOX_CH_BTNS: u32 = 5
const MBOX_CH_TOUCH: u32 = 6
const MBOX_CH_PROP: u32 = 8

// Mailbox Register Offsets
const MBOX_READ: u32 = 0x00
const MBOX_POLL: u32 = 0x10
const MBOX_SENDER: u32 = 0x14
const MBOX_STATUS: u32 = 0x18
const MBOX_CONFIG: u32 = 0x1C
const MBOX_WRITE: u32 = 0x20

const MBOX_FULL: u32 = 0x80000000
const MBOX_EMPTY: u32 = 0x40000000

// GIC-400 Distributor Registers
const GICD_CTLR: u32 = 0x000       // Distributor Control
const GICD_TYPER: u32 = 0x004     // Interrupt Controller Type
const GICD_IIDR: u32 = 0x008      // Distributor Implementer ID
const GICD_IGROUPR: u32 = 0x080   // Interrupt Group (base)
const GICD_ISENABLER: u32 = 0x100 // Interrupt Set-Enable (base)
const GICD_ICENABLER: u32 = 0x180 // Interrupt Clear-Enable (base)
const GICD_ISPENDR: u32 = 0x200   // Interrupt Set-Pending (base)
const GICD_ICPENDR: u32 = 0x280   // Interrupt Clear-Pending (base)
const GICD_ISACTIVER: u32 = 0x300 // Interrupt Set-Active (base)
const GICD_ICACTIVER: u32 = 0x380 // Interrupt Clear-Active (base)
const GICD_IPRIORITYR: u32 = 0x400 // Interrupt Priority (base)
const GICD_ITARGETSR: u32 = 0x800 // Interrupt Processor Targets (base)
const GICD_ICFGR: u32 = 0xC00     // Interrupt Configuration (base)
const GICD_SGIR: u32 = 0xF00      // Software Generated Interrupt

// GIC-400 CPU Interface Registers
const GICC_CTLR: u32 = 0x000      // CPU Interface Control
const GICC_PMR: u32 = 0x004       // Interrupt Priority Mask
const GICC_BPR: u32 = 0x008       // Binary Point
const GICC_IAR: u32 = 0x00C       // Interrupt Acknowledge
const GICC_EOIR: u32 = 0x010      // End of Interrupt
const GICC_RPR: u32 = 0x014       // Running Priority
const GICC_HPPIR: u32 = 0x018     // Highest Priority Pending Interrupt
const GICC_ABPR: u32 = 0x01C      // Aliased Binary Point
const GICC_AIAR: u32 = 0x020      // Aliased Interrupt Acknowledge
const GICC_AEOIR: u32 = 0x024     // Aliased End of Interrupt
const GICC_AHPPIR: u32 = 0x028    // Aliased Highest Priority Pending

// ARM Local Peripherals
const LOCAL_TIMER_CTRL: u32 = 0x34
const LOCAL_TIMER_IRQ_CTRL: u32 = 0x38
const CORE0_TIMER_IRQCNTL: u32 = 0x40
const CORE1_TIMER_IRQCNTL: u32 = 0x44
const CORE2_TIMER_IRQCNTL: u32 = 0x48
const CORE3_TIMER_IRQCNTL: u32 = 0x4C
const CORE0_MBOX_IRQCNTL: u32 = 0x50
const CORE1_MBOX_IRQCNTL: u32 = 0x54
const CORE2_MBOX_IRQCNTL: u32 = 0x58
const CORE3_MBOX_IRQCNTL: u32 = 0x5C
const CORE0_IRQ_SOURCE: u32 = 0x60
const CORE1_IRQ_SOURCE: u32 = 0x64
const CORE2_IRQ_SOURCE: u32 = 0x68
const CORE3_IRQ_SOURCE: u32 = 0x6C

// IRQ Numbers (GIC-400 SPI numbers)
const IRQ_TIMER0: u32 = 64
const IRQ_TIMER1: u32 = 65
const IRQ_TIMER2: u32 = 66
const IRQ_TIMER3: u32 = 67
const IRQ_USB: u32 = 73
const IRQ_DMA0: u32 = 80
const IRQ_DMA1: u32 = 81
const IRQ_DMA2: u32 = 82
const IRQ_DMA3: u32 = 83
const IRQ_DMA4: u32 = 84
const IRQ_DMA5: u32 = 85
const IRQ_DMA6: u32 = 86
const IRQ_DMA7_8: u32 = 87
const IRQ_DMA9_10: u32 = 88
const IRQ_DMA11: u32 = 89
const IRQ_DMA12: u32 = 90
const IRQ_DMA13: u32 = 91
const IRQ_DMA14: u32 = 92
const IRQ_AUX: u32 = 93
const IRQ_GPIO0: u32 = 145
const IRQ_GPIO1: u32 = 146
const IRQ_GPIO2: u32 = 147
const IRQ_GPIO3: u32 = 148
const IRQ_I2C: u32 = 149
const IRQ_SPI: u32 = 150
const IRQ_PCM: u32 = 151
const IRQ_UART: u32 = 153
const IRQ_EMMC: u32 = 158
const IRQ_ETH: u32 = 157
const IRQ_PCIE: u32 = 148
const IRQ_HDMI0: u32 = 168
const IRQ_HDMI1: u32 = 169

// PCIe Register Offsets
const PCIE_MISC_CTRL: u32 = 0x4008
const PCIE_MISC_STATUS: u32 = 0x4068
const PCIE_MISC_REVISION: u32 = 0x406C
const PCIE_MISC_CPU_2_PCIE_MEM_WIN0_LO: u32 = 0x400C
const PCIE_MISC_CPU_2_PCIE_MEM_WIN0_HI: u32 = 0x4010
const PCIE_MISC_RC_BAR1_CONFIG_LO: u32 = 0x402C
const PCIE_MISC_RC_BAR1_CONFIG_HI: u32 = 0x4030
const PCIE_MISC_RC_BAR2_CONFIG_LO: u32 = 0x4034
const PCIE_MISC_RC_BAR2_CONFIG_HI: u32 = 0x4038
const PCIE_MISC_RC_BAR3_CONFIG_LO: u32 = 0x403C
const PCIE_MISC_RC_BAR3_CONFIG_HI: u32 = 0x4040

const PCIE_MISC_CTRL_SCB_ACCESS_EN: u32 = 0x1000
const PCIE_MISC_CTRL_CFG_READ_UR_MODE: u32 = 0x2000
const PCIE_MISC_CTRL_MAX_BURST_SIZE_MASK: u32 = 0x300000
const PCIE_MISC_CTRL_SCB0_SIZE_MASK: u32 = 0xF8000000

// Thermal sensor registers
const THERMAL_STATUS: u32 = 0x00
const THERMAL_CTRL: u32 = 0x04

// Power Management
const PM_RSTC: u32 = 0x1C
const PM_RSTS: u32 = 0x20
const PM_WDOG: u32 = 0x24
const PM_PASSWORD: u32 = 0x5A000000
const PM_RSTC_WRCFG_FULL_RESET: u32 = 0x00000020

// Clock Manager
const CM_VPUCTL: u32 = 0x008
const CM_VPUDIV: u32 = 0x00C
const CM_PWMCTL: u32 = 0x0A0
const CM_PWMDIV: u32 = 0x0A4
const CM_PASSWORD: u32 = 0x5A000000

// State
var initialized: u32 = 0
var board_revision: u32 = 0
var arm_memory_base: u64 = 0
var arm_memory_size: u64 = 0
var gpu_memory_base: u64 = 0
var gpu_memory_size: u64 = 0
var cpu_freq: u32 = 1500000000  // 1.5 GHz default
var pcie_initialized: u32 = 0
var gic_initialized: u32 = 0

// Statistics
var gpio_interrupts: u64 = 0
var timer_interrupts: u64 = 0
var pcie_interrupts: u64 = 0
var uart_rx_bytes: u64 = 0
var uart_tx_bytes: u64 = 0
var mbox_calls: u64 = 0

// Helper functions
fn gpio_read(offset: u32): u32 {
  return memory.read_u32(GPIO_BASE + offset as u64)
}

fn gpio_write(offset: u32, value: u32) {
  memory.write_u32(GPIO_BASE + offset as u64, value)
}

fn uart_read(base: u64, offset: u32): u32 {
  return memory.read_u32(base + offset as u64)
}

fn uart_write(base: u64, offset: u32, value: u32) {
  memory.write_u32(base + offset as u64, value)
}

fn gic_dist_read(offset: u32): u32 {
  return memory.read_u32(GIC_DIST_BASE + offset as u64)
}

fn gic_dist_write(offset: u32, value: u32) {
  memory.write_u32(GIC_DIST_BASE + offset as u64, value)
}

fn gic_cpu_read(offset: u32): u32 {
  return memory.read_u32(GIC_CPU_BASE + offset as u64)
}

fn gic_cpu_write(offset: u32, value: u32) {
  memory.write_u32(GIC_CPU_BASE + offset as u64, value)
}

fn mbox_read_reg(offset: u32): u32 {
  return memory.read_u32(MBOX_BASE + offset as u64)
}

fn mbox_write_reg(offset: u32, value: u32) {
  memory.write_u32(MBOX_BASE + offset as u64, value)
}

fn pcie_read(offset: u32): u32 {
  return memory.read_u32(PCIE_BASE + offset as u64)
}

fn pcie_write(offset: u32, value: u32) {
  memory.write_u32(PCIE_BASE + offset as u64, value)
}

fn delay_cycles(count: u32) {
  var i: u32 = 0
  while i < count {
    foundation.nop()
    i = i + 1
  }
}

fn delay_us(us: u32) {
  // Approximate delay based on CPU frequency
  let cycles: u32 = (cpu_freq / 1000000) * us
  delay_cycles(cycles)
}

// Initialize BCM2711
export fn bcm2711_init(): u32 {
  if initialized == 1 { return 0 }

  foundation.serial_write_string("[BCM2711] Initializing Raspberry Pi 4 support\n")

  // Initialize GIC-400
  bcm2711_gic_init()

  // Initialize GPIO
  bcm2711_gpio_init()

  // Initialize UART0
  bcm2711_uart_init(UART0_BASE, 115200)

  // Initialize mailbox and get board info
  board_revision = bcm2711_get_board_revision()
  bcm2711_get_memory_info()

  // Initialize PCIe (for USB 3.0)
  bcm2711_pcie_init()

  // Initialize thermal sensor
  bcm2711_thermal_init()

  initialized = 1
  foundation.serial_write_string("[BCM2711] Initialization complete\n")

  // Print board info
  foundation.serial_write_string("[BCM2711] Board revision: 0x")
  foundation.serial_write_hex(board_revision)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("[BCM2711] ARM memory: ")
  foundation.serial_write_u64(arm_memory_size / (1024 * 1024))
  foundation.serial_write_string(" MB\n")

  return 0
}

// GIC-400 Initialization
fn bcm2711_gic_init() {
  foundation.serial_write_string("[BCM2711] Initializing GIC-400...\n")

  // Disable distributor
  gic_dist_write(GICD_CTLR, 0)

  // Get number of interrupt lines
  let typer: u32 = gic_dist_read(GICD_TYPER)
  let num_irqs: u32 = ((typer & 0x1F) + 1) * 32

  // Disable all interrupts
  var i: u32 = 0
  while i < num_irqs / 32 {
    gic_dist_write(GICD_ICENABLER + i * 4, 0xFFFFFFFF)
    i = i + 1
  }

  // Clear all pending
  i = 0
  while i < num_irqs / 32 {
    gic_dist_write(GICD_ICPENDR + i * 4, 0xFFFFFFFF)
    i = i + 1
  }

  // Set all to Group 0
  i = 0
  while i < num_irqs / 32 {
    gic_dist_write(GICD_IGROUPR + i * 4, 0)
    i = i + 1
  }

  // Set all to lowest priority
  i = 0
  while i < num_irqs {
    gic_dist_write(GICD_IPRIORITYR + i, 0xA0A0A0A0)
    i = i + 4
  }

  // Set all to target CPU 0
  i = 32  // Skip SGIs and PPIs
  while i < num_irqs {
    gic_dist_write(GICD_ITARGETSR + i, 0x01010101)
    i = i + 4
  }

  // Enable distributor
  gic_dist_write(GICD_CTLR, 1)

  // Initialize CPU interface
  gic_cpu_write(GICC_PMR, 0xFF)    // Accept all priorities
  gic_cpu_write(GICC_BPR, 0)       // No priority grouping
  gic_cpu_write(GICC_CTLR, 1)      // Enable CPU interface

  gic_initialized = 1
  foundation.serial_write_string("[BCM2711] GIC-400 initialized\n")
}

// Enable GIC IRQ
export fn bcm2711_gic_enable_irq(irq: u32) {
  if gic_initialized == 0 { return }

  let reg: u32 = irq / 32
  let bit: u32 = irq % 32

  gic_dist_write(GICD_ISENABLER + reg * 4, 1 << bit)
}

// Disable GIC IRQ
export fn bcm2711_gic_disable_irq(irq: u32) {
  if gic_initialized == 0 { return }

  let reg: u32 = irq / 32
  let bit: u32 = irq % 32

  gic_dist_write(GICD_ICENABLER + reg * 4, 1 << bit)
}

// Set IRQ priority
export fn bcm2711_gic_set_priority(irq: u32, priority: u8) {
  if gic_initialized == 0 { return }

  let reg: u32 = irq / 4
  let shift: u32 = (irq % 4) * 8

  var val: u32 = gic_dist_read(GICD_IPRIORITYR + reg * 4)
  val = val & ~(0xFF << shift)
  val = val | ((priority as u32) << shift)
  gic_dist_write(GICD_IPRIORITYR + reg * 4, val)
}

// Set IRQ target CPU
export fn bcm2711_gic_set_target(irq: u32, cpu_mask: u8) {
  if gic_initialized == 0 { return }

  let reg: u32 = irq / 4
  let shift: u32 = (irq % 4) * 8

  var val: u32 = gic_dist_read(GICD_ITARGETSR + reg * 4)
  val = val & ~(0xFF << shift)
  val = val | ((cpu_mask as u32) << shift)
  gic_dist_write(GICD_ITARGETSR + reg * 4, val)
}

// Acknowledge IRQ
export fn bcm2711_gic_ack(): u32 {
  return gic_cpu_read(GICC_IAR) & 0x3FF
}

// End of interrupt
export fn bcm2711_gic_eoi(irq: u32) {
  gic_cpu_write(GICC_EOIR, irq)
}

// Send software-generated interrupt
export fn bcm2711_gic_send_sgi(target_cpu: u32, irq: u32) {
  // Target filter = use CPU target list, target = cpu, SGI ID = irq
  gic_dist_write(GICD_SGIR, ((1 << (16 + target_cpu)) | (irq & 0xF)))
}

// GPIO Initialization
fn bcm2711_gpio_init() {
  foundation.serial_write_string("[BCM2711] GPIO initialized\n")
}

// Set GPIO function
export fn bcm2711_gpio_function(pin: u32, func: u32) {
  if pin > 57 { return }

  let reg_offset: u32 = (pin / 10) * 4
  let shift: u32 = (pin % 10) * 3

  var val: u32 = gpio_read(reg_offset)
  val = val & ~(7 << shift)
  val = val | ((func & 7) << shift)
  gpio_write(reg_offset, val)
}

// Set GPIO output high
export fn bcm2711_gpio_set(pin: u32) {
  if pin > 57 { return }

  if pin < 32 {
    gpio_write(GPSET0, 1 << pin)
  } else {
    gpio_write(GPSET1, 1 << (pin - 32))
  }
}

// Set GPIO output low
export fn bcm2711_gpio_clear(pin: u32) {
  if pin > 57 { return }

  if pin < 32 {
    gpio_write(GPCLR0, 1 << pin)
  } else {
    gpio_write(GPCLR1, 1 << (pin - 32))
  }
}

// Read GPIO level
export fn bcm2711_gpio_level(pin: u32): u32 {
  if pin > 57 { return 0 }

  if pin < 32 {
    return (gpio_read(GPLEV0) >> pin) & 1
  } else {
    return (gpio_read(GPLEV1) >> (pin - 32)) & 1
  }
}

// Set GPIO pull-up/down (BCM2711 has new registers)
export fn bcm2711_gpio_pud(pin: u32, pud: u32) {
  if pin > 57 { return }

  let reg_offset: u32 = GPIO_PUP_PDN_CNTRL_REG0 + (pin / 16) * 4
  let shift: u32 = (pin % 16) * 2

  var val: u32 = gpio_read(reg_offset)
  val = val & ~(3 << shift)
  val = val | ((pud & 3) << shift)
  gpio_write(reg_offset, val)
}

// UART Initialization
fn bcm2711_uart_init(base: u64, baud_rate: u32) {
  // Disable UART
  uart_write(base, UART_CR, 0)

  // Setup GPIO pins 14 (TX) and 15 (RX) for UART0
  if base == UART0_BASE {
    bcm2711_gpio_function(14, GPIO_FSEL_ALT0)
    bcm2711_gpio_function(15, GPIO_FSEL_ALT0)
    bcm2711_gpio_pud(14, GPIO_PUD_NONE)
    bcm2711_gpio_pud(15, GPIO_PUD_UP)
  }

  // Clear pending interrupts
  uart_write(base, UART_ICR, 0x7FF)

  // Calculate baud rate divisor (48MHz UART clock on BCM2711)
  let uart_clock: u32 = 48000000
  let divisor: u32 = uart_clock * 4 / baud_rate
  let ibrd: u32 = divisor / 64
  let fbrd: u32 = divisor % 64

  uart_write(base, UART_IBRD, ibrd)
  uart_write(base, UART_FBRD, fbrd)

  // 8 bits, no parity, 1 stop bit, FIFO enabled
  uart_write(base, UART_LCRH, 0x70)

  // Enable UART, TX and RX
  uart_write(base, UART_CR, 0x301)

  foundation.serial_write_string("[BCM2711] UART0 initialized at 115200 baud\n")
}

// Send character via UART
export fn bcm2711_uart_putc(c: u8) {
  bcm2711_uart_putc_base(UART0_BASE, c)
}

export fn bcm2711_uart_putc_base(base: u64, c: u8) {
  while (uart_read(base, UART_FR) & UART_FR_TXFF) != 0 {}

  uart_write(base, UART_DR, c as u32)
  uart_tx_bytes = uart_tx_bytes + 1
}

// Receive character via UART
export fn bcm2711_uart_getc(): u8 {
  return bcm2711_uart_getc_base(UART0_BASE)
}

export fn bcm2711_uart_getc_base(base: u64): u8 {
  while (uart_read(base, UART_FR) & UART_FR_RXFE) != 0 {}

  uart_rx_bytes = uart_rx_bytes + 1
  return (uart_read(base, UART_DR) & 0xFF) as u8
}

// Check UART data available
export fn bcm2711_uart_available(): u32 {
  return if (uart_read(UART0_BASE, UART_FR) & UART_FR_RXFE) == 0 { 1 } else { 0 }
}

// PCIe Initialization (for VL805 USB 3.0 controller)
fn bcm2711_pcie_init() {
  foundation.serial_write_string("[BCM2711] Initializing PCIe...\n")

  // Enable PCIe bridge
  var ctrl: u32 = pcie_read(PCIE_MISC_CTRL)

  // Set SCB access and configure mode
  ctrl = ctrl | PCIE_MISC_CTRL_SCB_ACCESS_EN
  ctrl = ctrl | PCIE_MISC_CTRL_CFG_READ_UR_MODE

  // Set burst size to 256 bytes
  ctrl = ctrl & ~PCIE_MISC_CTRL_MAX_BURST_SIZE_MASK
  ctrl = ctrl | (1 << 20)  // 256 bytes

  // Set SCB size (1GB window)
  ctrl = ctrl & ~PCIE_MISC_CTRL_SCB0_SIZE_MASK
  ctrl = ctrl | (0x17 << 27)  // 1GB

  pcie_write(PCIE_MISC_CTRL, ctrl)

  // Configure CPU to PCIe address translation
  pcie_write(PCIE_MISC_CPU_2_PCIE_MEM_WIN0_LO, PCIE_MEM_BASE as u32)
  pcie_write(PCIE_MISC_CPU_2_PCIE_MEM_WIN0_HI, (PCIE_MEM_BASE >> 32) as u32)

  // Wait for link up
  var timeout: u32 = 100000
  while timeout > 0 {
    let status: u32 = pcie_read(PCIE_MISC_STATUS)
    if (status & 0x30) == 0x30 {  // Link up and DL active
      break
    }
    timeout = timeout - 1
    delay_us(10)
  }

  if timeout == 0 {
    foundation.serial_write_string("[BCM2711] PCIe link timeout\n")
    return
  }

  pcie_initialized = 1
  foundation.serial_write_string("[BCM2711] PCIe initialized, link up\n")

  // Scan for VL805 USB 3.0 controller
  bcm2711_pcie_scan()
}

// PCIe configuration space access
fn bcm2711_pcie_config_read(bus: u32, dev: u32, func: u32, offset: u32): u32 {
  if pcie_initialized == 0 { return 0xFFFFFFFF }

  let addr: u64 = PCIE_MEM_BASE + (bus << 20) as u64 + (dev << 15) as u64 + (func << 12) as u64 + offset as u64
  return memory.read_u32(addr)
}

fn bcm2711_pcie_config_write(bus: u32, dev: u32, func: u32, offset: u32, value: u32) {
  if pcie_initialized == 0 { return }

  let addr: u64 = PCIE_MEM_BASE + (bus << 20) as u64 + (dev << 15) as u64 + (func << 12) as u64 + offset as u64
  memory.write_u32(addr, value)
}

// Scan PCIe bus
fn bcm2711_pcie_scan() {
  foundation.serial_write_string("[BCM2711] Scanning PCIe bus...\n")

  // Check bus 0, device 0 (root port)
  let vendor: u32 = bcm2711_pcie_config_read(0, 0, 0, 0)

  if vendor != 0xFFFFFFFF and vendor != 0 {
    foundation.serial_write_string("[BCM2711] PCIe device at 0:0.0: ")
    foundation.serial_write_hex(vendor)
    foundation.serial_write_string("\n")

    // Check for VL805 (VIA USB 3.0)
    if vendor == 0x31001912 {  // VIA VL805
      foundation.serial_write_string("[BCM2711] Found VL805 USB 3.0 controller\n")
    }
  }

  // Scan bus 1 (behind root port)
  var dev: u32 = 0
  while dev < 32 {
    let vendor: u32 = bcm2711_pcie_config_read(1, dev, 0, 0)

    if vendor != 0xFFFFFFFF and vendor != 0 {
      foundation.serial_write_string("[BCM2711] PCIe device at 1:")
      foundation.serial_write_hex(dev)
      foundation.serial_write_string(".0: ")
      foundation.serial_write_hex(vendor)
      foundation.serial_write_string("\n")

      // Get class code
      let class_code: u32 = bcm2711_pcie_config_read(1, dev, 0, 0x08)
      let class: u32 = (class_code >> 24) & 0xFF
      let subclass: u32 = (class_code >> 16) & 0xFF

      if class == 0x0C and subclass == 0x03 {
        foundation.serial_write_string("[BCM2711] USB controller found\n")
      }
    }

    dev = dev + 1
  }
}

// Mailbox functions
export fn bcm2711_mbox_write(channel: u32, data: u32) {
  while (mbox_read_reg(MBOX_STATUS) & MBOX_FULL) != 0 {}
  mbox_write_reg(MBOX_WRITE, (data & 0xFFFFFFF0) | (channel & 0x0F))
}

export fn bcm2711_mbox_read(channel: u32): u32 {
  loop {
    while (mbox_read_reg(MBOX_STATUS) & MBOX_EMPTY) != 0 {}

    let data: u32 = mbox_read_reg(MBOX_READ)
    if (data & 0x0F) == channel {
      return data & 0xFFFFFFF0
    }
  }
}

// Property mailbox call
export fn bcm2711_mbox_call(buffer: *u32): u32 {
  mbox_calls = mbox_calls + 1

  // Data must be 16-byte aligned
  let addr: u32 = (buffer as u64 & 0xFFFFFFFF) as u32

  bcm2711_mbox_write(MBOX_CH_PROP, addr)
  bcm2711_mbox_read(MBOX_CH_PROP)

  return buffer[1]
}

// Get board revision
export fn bcm2711_get_board_revision(): u32 {
  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00010002  // Get board revision
  buffer[3] = 4
  buffer[4] = 0
  buffer[5] = 0
  buffer[6] = 0
  buffer[7] = 0

  bcm2711_mbox_call(&buffer[0])

  return buffer[5]
}

// Get memory info
fn bcm2711_get_memory_info() {
  // Get ARM memory
  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00010005  // Get ARM memory
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0  // Base
  buffer[6] = 0  // Size
  buffer[7] = 0

  bcm2711_mbox_call(&buffer[0])

  arm_memory_base = buffer[5] as u64
  arm_memory_size = buffer[6] as u64

  // Get GPU memory
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00010006  // Get VC memory
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0
  buffer[6] = 0
  buffer[7] = 0

  bcm2711_mbox_call(&buffer[0])

  gpu_memory_base = buffer[5] as u64
  gpu_memory_size = buffer[6] as u64
}

// Get ARM memory size
export fn bcm2711_get_arm_memory(): u64 {
  return arm_memory_size
}

// Get GPU memory size
export fn bcm2711_get_gpu_memory(): u64 {
  return gpu_memory_size
}

// Get temperature (in thousandths of a degree C)
export fn bcm2711_get_temperature(): u32 {
  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00030006  // Get temperature
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0  // Temperature ID
  buffer[6] = 0  // Temperature
  buffer[7] = 0

  bcm2711_mbox_call(&buffer[0])

  return buffer[6]
}

// Get max temperature
export fn bcm2711_get_max_temperature(): u32 {
  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x0003000A  // Get max temperature
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0
  buffer[6] = 0
  buffer[7] = 0

  bcm2711_mbox_call(&buffer[0])

  return buffer[6]
}

// Set CPU frequency
export fn bcm2711_set_cpu_freq(freq_hz: u32): u32 {
  var buffer: [u32; 12]
  buffer[0] = 48
  buffer[1] = 0
  buffer[2] = 0x00038002  // Set clock rate
  buffer[3] = 12
  buffer[4] = 0
  buffer[5] = 3  // ARM clock
  buffer[6] = freq_hz
  buffer[7] = 0  // Skip turbo
  buffer[8] = 0
  buffer[9] = 0
  buffer[10] = 0
  buffer[11] = 0

  bcm2711_mbox_call(&buffer[0])

  if buffer[1] == 0x80000000 {
    cpu_freq = freq_hz
    return 0
  }

  return 1
}

// Get CPU frequency
export fn bcm2711_get_cpu_freq(): u32 {
  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00030002  // Get clock rate
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 3  // ARM clock
  buffer[6] = 0
  buffer[7] = 0

  bcm2711_mbox_call(&buffer[0])

  return buffer[6]
}

// Thermal sensor initialization
fn bcm2711_thermal_init() {
  // Enable thermal sensor
  memory.write_u32(THERMAL_BASE + THERMAL_CTRL, 1)

  foundation.serial_write_string("[BCM2711] Thermal sensor initialized\n")
}

// Read thermal sensor directly
export fn bcm2711_thermal_read(): u32 {
  return memory.read_u32(THERMAL_BASE + THERMAL_STATUS)
}

// Power management - reboot
export fn bcm2711_reboot() {
  foundation.serial_write_string("[BCM2711] Rebooting...\n")

  memory.write_u32(PM_BASE + PM_WDOG, PM_PASSWORD | 10)
  memory.write_u32(PM_BASE + PM_RSTC, PM_PASSWORD | PM_RSTC_WRCFG_FULL_RESET)

  loop {}
}

// Power management - shutdown
export fn bcm2711_shutdown() {
  foundation.serial_write_string("[BCM2711] Shutting down...\n")

  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00028001  // Set power state
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0  // Device 0
  buffer[6] = 0  // Off
  buffer[7] = 0

  bcm2711_mbox_call(&buffer[0])
}

// Get peripheral base
export fn bcm2711_get_peripheral_base(): u64 {
  return BCM2711_PERI_BASE
}

export fn bcm2711_get_gpio_base(): u64 {
  return GPIO_BASE
}

// Print statistics
export fn bcm2711_print_stats() {
  foundation.serial_write_string("\n[BCM2711] Statistics:\n")

  foundation.serial_write_string("  GPIO interrupts: ")
  foundation.serial_write_u64(gpio_interrupts)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Timer interrupts: ")
  foundation.serial_write_u64(timer_interrupts)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  PCIe interrupts: ")
  foundation.serial_write_u64(pcie_interrupts)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  UART RX bytes: ")
  foundation.serial_write_u64(uart_rx_bytes)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  UART TX bytes: ")
  foundation.serial_write_u64(uart_tx_bytes)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Mailbox calls: ")
  foundation.serial_write_u64(mbox_calls)
  foundation.serial_write_string("\n")

  // Print current temperature
  let temp: u32 = bcm2711_get_temperature()
  foundation.serial_write_string("  Temperature: ")
  foundation.serial_write_u64(temp / 1000)
  foundation.serial_write_string(".")
  foundation.serial_write_u64((temp % 1000) / 100)
  foundation.serial_write_string(" C\n")
}

// Print hardware info
export fn bcm2711_print_info() {
  foundation.serial_write_string("\n[BCM2711] Hardware Information:\n")
  foundation.serial_write_string("  SoC: Broadcom BCM2711\n")
  foundation.serial_write_string("  CPU: ARM Cortex-A72 (4 cores)\n")

  foundation.serial_write_string("  CPU Freq: ")
  foundation.serial_write_u64(bcm2711_get_cpu_freq() / 1000000)
  foundation.serial_write_string(" MHz\n")

  foundation.serial_write_string("  ARM Memory: ")
  foundation.serial_write_u64(arm_memory_size / (1024 * 1024))
  foundation.serial_write_string(" MB\n")

  foundation.serial_write_string("  GPU Memory: ")
  foundation.serial_write_u64(gpu_memory_size / (1024 * 1024))
  foundation.serial_write_string(" MB\n")

  foundation.serial_write_string("  Board Rev: 0x")
  foundation.serial_write_hex(board_revision)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  PCIe: ")
  foundation.serial_write_string(if pcie_initialized == 1 { "Initialized" } else { "Not initialized" })
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  GIC: ")
  foundation.serial_write_string(if gic_initialized == 1 { "Initialized" } else { "Not initialized" })
  foundation.serial_write_string("\n")
}
