// home-os Raspberry Pi BCM2712 Support
// Broadcom BCM2712 SoC (Raspberry Pi 5)
// ARM Cortex-A76 quad-core @ 2.4GHz (3.0GHz turbo)
// VideoCore VII GPU, GIC-600 interrupt controller
// RP1 southbridge for I/O

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

// BCM2712 Memory Map - 40-bit address space
const BCM2712_PERI_BASE: u64 = 0x1000000000        // Main peripheral base
const BCM2712_PERI_BASE_LOW: u64 = 0x40000000      // Low peripheral (legacy compat)

// RP1 Southbridge (PCIe-connected I/O controller)
// RP1 provides GPIO, UART, SPI, I2C, PWM, Ethernet, USB, HDMI
const RP1_BAR1_BASE: u64 = 0x1F00000000            // RP1 BAR1 (peripherals)
const RP1_BAR2_BASE: u64 = 0x1F00400000            // RP1 BAR2

// RP1 Peripheral Offsets (from BAR1)
const RP1_IO_BANK0: u64 = RP1_BAR1_BASE + 0x0D0000   // GPIO Bank 0
const RP1_IO_BANK1: u64 = RP1_BAR1_BASE + 0x0D4000   // GPIO Bank 1
const RP1_IO_BANK2: u64 = RP1_BAR1_BASE + 0x0D8000   // GPIO Bank 2
const RP1_SYS_RIO: u64 = RP1_BAR1_BASE + 0x0E0000    // System RIO
const RP1_PADS_BANK0: u64 = RP1_BAR1_BASE + 0x0F0000 // Pad control Bank 0
const RP1_PADS_BANK1: u64 = RP1_BAR1_BASE + 0x0F4000 // Pad control Bank 1
const RP1_PADS_BANK2: u64 = RP1_BAR1_BASE + 0x0F8000 // Pad control Bank 2

// RP1 UART
const RP1_UART0: u64 = RP1_BAR1_BASE + 0x030000
const RP1_UART1: u64 = RP1_BAR1_BASE + 0x034000
const RP1_UART2: u64 = RP1_BAR1_BASE + 0x038000
const RP1_UART3: u64 = RP1_BAR1_BASE + 0x03C000
const RP1_UART4: u64 = RP1_BAR1_BASE + 0x040000
const RP1_UART5: u64 = RP1_BAR1_BASE + 0x044000

// RP1 SPI
const RP1_SPI0: u64 = RP1_BAR1_BASE + 0x050000
const RP1_SPI1: u64 = RP1_BAR1_BASE + 0x054000
const RP1_SPI2: u64 = RP1_BAR1_BASE + 0x058000
const RP1_SPI3: u64 = RP1_BAR1_BASE + 0x05C000
const RP1_SPI4: u64 = RP1_BAR1_BASE + 0x060000
const RP1_SPI5: u64 = RP1_BAR1_BASE + 0x064000

// RP1 I2C
const RP1_I2C0: u64 = RP1_BAR1_BASE + 0x070000
const RP1_I2C1: u64 = RP1_BAR1_BASE + 0x074000
const RP1_I2C2: u64 = RP1_BAR1_BASE + 0x078000
const RP1_I2C3: u64 = RP1_BAR1_BASE + 0x07C000
const RP1_I2C4: u64 = RP1_BAR1_BASE + 0x080000
const RP1_I2C5: u64 = RP1_BAR1_BASE + 0x084000
const RP1_I2C6: u64 = RP1_BAR1_BASE + 0x088000

// RP1 PWM
const RP1_PWM0: u64 = RP1_BAR1_BASE + 0x098000
const RP1_PWM1: u64 = RP1_BAR1_BASE + 0x09C000

// RP1 Ethernet
const RP1_ETH: u64 = RP1_BAR1_BASE + 0x100000

// RP1 DMA
const RP1_DMA: u64 = RP1_BAR1_BASE + 0x104000

// RP1 HDMI (dual HDMI via RP1)
const RP1_HDMI0: u64 = RP1_BAR1_BASE + 0x110000
const RP1_HDMI1: u64 = RP1_BAR1_BASE + 0x118000

// RP1 Display/Video
const RP1_PIXVALVE0: u64 = RP1_BAR1_BASE + 0x120000
const RP1_PIXVALVE1: u64 = RP1_BAR1_BASE + 0x124000
const RP1_MIPICFG: u64 = RP1_BAR1_BASE + 0x128000
const RP1_DSI0: u64 = RP1_BAR1_BASE + 0x130000
const RP1_DSI1: u64 = RP1_BAR1_BASE + 0x134000

// RP1 USB
const RP1_USB: u64 = RP1_BAR1_BASE + 0x200000

// VideoCore VII GPU
const VC7_BASE: u64 = 0x1000800000
const VC7_V3D_BASE: u64 = VC7_BASE + 0x4000         // V3D (Vulkan 1.3, OpenGL ES 3.1)
const VC7_HVS_BASE: u64 = VC7_BASE + 0x8000         // Hardware Video Scaler
const VC7_HEVC_BASE: u64 = VC7_BASE + 0x10000       // HEVC 4K decoder

// GIC-600 Interrupt Controller
const GIC_BASE: u64 = 0x107FFF0000
const GICD_BASE: u64 = GIC_BASE + 0x0000            // Distributor
const GICR_BASE: u64 = GIC_BASE + 0x40000           // Redistributor
const GICC_BASE: u64 = GIC_BASE + 0x80000           // CPU Interface

// Mailbox (VideoCore communication)
const MBOX_BASE: u64 = 0x1000B880

// PCIe Controllers (x1 lane for NVMe, etc.)
const PCIE0_BASE: u64 = 0x1000120000                // RP1 connection
const PCIE1_BASE: u64 = 0x1000130000                // External M.2
const PCIE_MEM_BASE: u64 = 0x1F00000000

// System Timer
const TIMER_BASE: u64 = 0x1000003000

// Thermal
const THERMAL_BASE: u64 = 0x1000212000

// Power Management
const PM_BASE: u64 = 0x1000100000

// Clock Manager
const CM_BASE: u64 = 0x1000101000

// GIC-600 Distributor Registers
const GICD_CTLR: u32 = 0x0000
const GICD_TYPER: u32 = 0x0004
const GICD_IIDR: u32 = 0x0008
const GICD_IGROUPR: u32 = 0x0080
const GICD_ISENABLER: u32 = 0x0100
const GICD_ICENABLER: u32 = 0x0180
const GICD_ISPENDR: u32 = 0x0200
const GICD_ICPENDR: u32 = 0x0280
const GICD_ISACTIVER: u32 = 0x0300
const GICD_ICACTIVER: u32 = 0x0380
const GICD_IPRIORITYR: u32 = 0x0400
const GICD_ITARGETSR: u32 = 0x0800
const GICD_ICFGR: u32 = 0x0C00
const GICD_IGRPMODR: u32 = 0x0D00
const GICD_NSACR: u32 = 0x0E00
const GICD_SGIR: u32 = 0x0F00
const GICD_CPENDSGIR: u32 = 0x0F10
const GICD_SPENDSGIR: u32 = 0x0F20
const GICD_IROUTER: u32 = 0x6000

// GIC-600 Redistributor Registers (per CPU)
const GICR_CTLR: u32 = 0x0000
const GICR_IIDR: u32 = 0x0004
const GICR_TYPER: u32 = 0x0008
const GICR_WAKER: u32 = 0x0014
const GICR_IGROUPR0: u32 = 0x10080
const GICR_ISENABLER0: u32 = 0x10100
const GICR_ICENABLER0: u32 = 0x10180
const GICR_ISPENDR0: u32 = 0x10200
const GICR_ICPENDR0: u32 = 0x10280
const GICR_ISACTIVER0: u32 = 0x10300
const GICR_ICACTIVER0: u32 = 0x10380
const GICR_IPRIORITYR: u32 = 0x10400
const GICR_ICFGR0: u32 = 0x10C00
const GICR_ICFGR1: u32 = 0x10C04

// Mailbox Channels
const MBOX_CH_POWER: u32 = 0
const MBOX_CH_FB: u32 = 1
const MBOX_CH_VUART: u32 = 2
const MBOX_CH_VCHIQ: u32 = 3
const MBOX_CH_LEDS: u32 = 4
const MBOX_CH_BTNS: u32 = 5
const MBOX_CH_TOUCH: u32 = 6
const MBOX_CH_PROP: u32 = 8

// Mailbox Register Offsets
const MBOX_READ: u32 = 0x00
const MBOX_POLL: u32 = 0x10
const MBOX_SENDER: u32 = 0x14
const MBOX_STATUS: u32 = 0x18
const MBOX_CONFIG: u32 = 0x1C
const MBOX_WRITE: u32 = 0x20

const MBOX_FULL: u32 = 0x80000000
const MBOX_EMPTY: u32 = 0x40000000

// UART Register Offsets (PL011 compatible)
const UART_DR: u32 = 0x00
const UART_RSRECR: u32 = 0x04
const UART_FR: u32 = 0x18
const UART_ILPR: u32 = 0x20
const UART_IBRD: u32 = 0x24
const UART_FBRD: u32 = 0x28
const UART_LCRH: u32 = 0x2C
const UART_CR: u32 = 0x30
const UART_IFLS: u32 = 0x34
const UART_IMSC: u32 = 0x38
const UART_RIS: u32 = 0x3C
const UART_MIS: u32 = 0x40
const UART_ICR: u32 = 0x44
const UART_DMACR: u32 = 0x48

// UART Flags
const UART_FR_TXFE: u32 = 0x80
const UART_FR_RXFF: u32 = 0x40
const UART_FR_TXFF: u32 = 0x20
const UART_FR_RXFE: u32 = 0x10
const UART_FR_BUSY: u32 = 0x08

// GPIO Function Select Values
const GPIO_FSEL_INPUT: u32 = 0
const GPIO_FSEL_OUTPUT: u32 = 1
const GPIO_FSEL_ALT0: u32 = 4
const GPIO_FSEL_ALT1: u32 = 5
const GPIO_FSEL_ALT2: u32 = 6
const GPIO_FSEL_ALT3: u32 = 7
const GPIO_FSEL_ALT4: u32 = 3
const GPIO_FSEL_ALT5: u32 = 2

// Pull-up/down
const GPIO_PUD_NONE: u32 = 0
const GPIO_PUD_UP: u32 = 1
const GPIO_PUD_DOWN: u32 = 2

// HDMI Constants
const HDMI_MAX_WIDTH: u32 = 3840
const HDMI_MAX_HEIGHT: u32 = 2160
const HDMI_MAX_REFRESH: u32 = 60

// Platform state
struct BCM2712State {
  initialized: u32
  board_revision: u32
  board_serial: u64
  arm_memory_base: u64
  arm_memory_size: u64
  gpu_memory_base: u64
  gpu_memory_size: u64
  cpu_freq: u32
  cpu_max_freq: u32
  cpu_min_freq: u32
  temperature: u32
  rp1_initialized: u32
  gic_initialized: u32
  hdmi0_active: u32
  hdmi1_active: u32
}

var state: BCM2712State

// Statistics
var gpio_interrupts: u64 = 0
var timer_interrupts: u64 = 0
var hdmi_interrupts: u64 = 0
var uart_rx_bytes: u64 = 0
var uart_tx_bytes: u64 = 0
var mbox_calls: u64 = 0

// Helper functions
fn mbox_read_reg(offset: u32): u32 {
  return memory.read_u32(MBOX_BASE + offset as u64)
}

fn mbox_write_reg(offset: u32, value: u32) {
  memory.write_u32(MBOX_BASE + offset as u64, value)
}

fn gicd_read(offset: u32): u32 {
  return memory.read_u32(GICD_BASE + offset as u64)
}

fn gicd_write(offset: u32, value: u32) {
  memory.write_u32(GICD_BASE + offset as u64, value)
}

fn gicr_read(cpu: u32, offset: u32): u32 {
  let base: u64 = GICR_BASE + (cpu as u64 * 0x20000)
  return memory.read_u32(base + offset as u64)
}

fn gicr_write(cpu: u32, offset: u32, value: u32) {
  let base: u64 = GICR_BASE + (cpu as u64 * 0x20000)
  memory.write_u32(base + offset as u64, value)
}

fn rp1_read(base: u64, offset: u32): u32 {
  return memory.read_u32(base + offset as u64)
}

fn rp1_write(base: u64, offset: u32, value: u32) {
  memory.write_u32(base + offset as u64, value)
}

fn delay_cycles(count: u32) {
  var i: u32 = 0
  while i < count {
    foundation.nop()
    i = i + 1
  }
}

fn delay_us(us: u32) {
  // At 2.4GHz, approx 2400 cycles per microsecond
  delay_cycles(us * 2400)
}

fn delay_ms(ms: u32) {
  delay_us(ms * 1000)
}

// Initialize BCM2712
export fn bcm2712_init(): u32 {
  if state.initialized == 1 { return 0 }

  foundation.serial_write_string("[BCM2712] Initializing Raspberry Pi 5...\n")

  // Initialize GIC-600
  bcm2712_gic_init()

  // Initialize RP1 southbridge
  bcm2712_rp1_init()

  // Initialize UART0 via RP1
  bcm2712_uart_init(0, 115200)

  // Get board info via mailbox
  state.board_revision = bcm2712_get_board_revision()
  bcm2712_get_memory_info()
  bcm2712_get_clock_info()

  // Initialize thermal monitoring
  bcm2712_thermal_init()

  state.initialized = 1

  foundation.serial_write_string("[BCM2712] Raspberry Pi 5 initialized\n")

  // Print system info
  foundation.serial_write_string("[BCM2712] Board revision: 0x")
  foundation.serial_write_hex(state.board_revision)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("[BCM2712] ARM memory: ")
  foundation.serial_write_u64(state.arm_memory_size / (1024 * 1024))
  foundation.serial_write_string(" MB\n")

  foundation.serial_write_string("[BCM2712] CPU frequency: ")
  foundation.serial_write_u64(state.cpu_freq / 1000000)
  foundation.serial_write_string(" MHz\n")

  return 0
}

// GIC-600 Initialization
fn bcm2712_gic_init() {
  foundation.serial_write_string("[BCM2712] Initializing GIC-600...\n")

  // Disable distributor
  gicd_write(GICD_CTLR, 0)

  // Get number of interrupt lines
  let typer: u32 = gicd_read(GICD_TYPER)
  let num_irqs: u32 = ((typer & 0x1F) + 1) * 32

  // Disable all SPIs
  var i: u32 = 1
  while i < num_irqs / 32 {
    gicd_write(GICD_ICENABLER + i * 4, 0xFFFFFFFF)
    i = i + 1
  }

  // Set all SPIs to Group 1 NS
  i = 1
  while i < num_irqs / 32 {
    gicd_write(GICD_IGROUPR + i * 4, 0xFFFFFFFF)
    i = i + 1
  }

  // Set default priority for all SPIs
  i = 32
  while i < num_irqs {
    gicd_write(GICD_IPRIORITYR + i, 0xA0A0A0A0)
    i = i + 4
  }

  // Route all SPIs to CPU 0 (affinity routing)
  i = 32
  while i < num_irqs {
    memory.write_u64(GICD_BASE + GICD_IROUTER as u64 + (i * 8) as u64, 0)
    i = i + 1
  }

  // Enable distributor with affinity routing
  gicd_write(GICD_CTLR, 0x37)  // ARE_NS | ARE_S | EnableGrp1NS | EnableGrp1S | EnableGrp0

  // Initialize redistributor for CPU 0
  bcm2712_gic_init_cpu(0)

  state.gic_initialized = 1
  foundation.serial_write_string("[BCM2712] GIC-600 initialized\n")
}

fn bcm2712_gic_init_cpu(cpu: u32) {
  // Wake up redistributor
  var waker: u32 = gicr_read(cpu, GICR_WAKER)
  waker = waker & ~0x2  // Clear ProcessorSleep
  gicr_write(cpu, GICR_WAKER, waker)

  // Wait for ChildrenAsleep to clear
  var timeout: u32 = 1000000
  while timeout > 0 {
    waker = gicr_read(cpu, GICR_WAKER)
    if (waker & 0x4) == 0 { break }
    timeout = timeout - 1
  }

  // Set SGI/PPI to Group 1 NS
  gicr_write(cpu, GICR_IGROUPR0, 0xFFFFFFFF)

  // Enable all SGIs
  gicr_write(cpu, GICR_ISENABLER0, 0x0000FFFF)

  // Set priority for SGIs/PPIs
  var i: u32 = 0
  while i < 32 {
    gicr_write(cpu, GICR_IPRIORITYR + i, 0xA0A0A0A0)
    i = i + 4
  }
}

// Enable IRQ
export fn bcm2712_gic_enable_irq(irq: u32) {
  if state.gic_initialized == 0 { return }

  if irq < 32 {
    // SGI/PPI - use redistributor
    gicr_write(0, GICR_ISENABLER0, 1 << irq)
  } else {
    // SPI - use distributor
    let reg: u32 = irq / 32
    let bit: u32 = irq % 32
    gicd_write(GICD_ISENABLER + reg * 4, 1 << bit)
  }
}

// Disable IRQ
export fn bcm2712_gic_disable_irq(irq: u32) {
  if state.gic_initialized == 0 { return }

  if irq < 32 {
    gicr_write(0, GICR_ICENABLER0, 1 << irq)
  } else {
    let reg: u32 = irq / 32
    let bit: u32 = irq % 32
    gicd_write(GICD_ICENABLER + reg * 4, 1 << bit)
  }
}

// Set IRQ priority
export fn bcm2712_gic_set_priority(irq: u32, priority: u8) {
  if state.gic_initialized == 0 { return }

  let reg: u32 = irq / 4
  let shift: u32 = (irq % 4) * 8

  if irq < 32 {
    var val: u32 = gicr_read(0, GICR_IPRIORITYR + reg * 4)
    val = val & ~(0xFF << shift)
    val = val | ((priority as u32) << shift)
    gicr_write(0, GICR_IPRIORITYR + reg * 4, val)
  } else {
    var val: u32 = gicd_read(GICD_IPRIORITYR + reg * 4)
    val = val & ~(0xFF << shift)
    val = val | ((priority as u32) << shift)
    gicd_write(GICD_IPRIORITYR + reg * 4, val)
  }
}

// RP1 Southbridge Initialization
fn bcm2712_rp1_init() {
  foundation.serial_write_string("[BCM2712] Initializing RP1 southbridge...\n")

  // RP1 is connected via PCIe - wait for link
  var timeout: u32 = 100000
  while timeout > 0 {
    // Check if RP1 is accessible
    let id: u32 = rp1_read(RP1_SYS_RIO, 0x00)
    if id != 0xFFFFFFFF and id != 0 {
      break
    }
    timeout = timeout - 1
    delay_us(10)
  }

  if timeout == 0 {
    foundation.serial_write_string("[BCM2712] RP1 not responding\n")
    return
  }

  state.rp1_initialized = 1
  foundation.serial_write_string("[BCM2712] RP1 southbridge ready\n")
}

// GPIO via RP1
export fn bcm2712_gpio_function(pin: u32, func: u32) {
  if state.rp1_initialized == 0 { return }
  if pin >= 28 { return }  // GPIO0-27 on 40-pin header

  let ctrl_reg: u64 = RP1_IO_BANK0 + (pin * 8) as u64 + 4
  var val: u32 = memory.read_u32(ctrl_reg)
  val = val & ~0x1F
  val = val | (func & 0x1F)
  memory.write_u32(ctrl_reg, val)
}

export fn bcm2712_gpio_set(pin: u32) {
  if state.rp1_initialized == 0 { return }
  if pin >= 28 { return }

  let set_reg: u64 = RP1_IO_BANK0 + 0x2000 + (pin / 32 * 4) as u64
  memory.write_u32(set_reg, 1 << (pin % 32))
}

export fn bcm2712_gpio_clear(pin: u32) {
  if state.rp1_initialized == 0 { return }
  if pin >= 28 { return }

  let clr_reg: u64 = RP1_IO_BANK0 + 0x3000 + (pin / 32 * 4) as u64
  memory.write_u32(clr_reg, 1 << (pin % 32))
}

export fn bcm2712_gpio_level(pin: u32): u32 {
  if state.rp1_initialized == 0 { return 0 }
  if pin >= 28 { return 0 }

  let lvl_reg: u64 = RP1_IO_BANK0 + 0x4000 + (pin / 32 * 4) as u64
  return (memory.read_u32(lvl_reg) >> (pin % 32)) & 1
}

export fn bcm2712_gpio_pud(pin: u32, pud: u32) {
  if state.rp1_initialized == 0 { return }
  if pin >= 28 { return }

  let pad_reg: u64 = RP1_PADS_BANK0 + 4 + (pin * 4) as u64
  var val: u32 = memory.read_u32(pad_reg)

  // Clear pull bits (bits 3:2)
  val = val & ~0x0C

  if pud == GPIO_PUD_UP {
    val = val | 0x08  // Pull-up
  } else if pud == GPIO_PUD_DOWN {
    val = val | 0x04  // Pull-down
  }

  memory.write_u32(pad_reg, val)
}

// UART via RP1
fn bcm2712_uart_init(uart_num: u32, baud_rate: u32) {
  if state.rp1_initialized == 0 { return }

  let base: u64 = RP1_UART0 + (uart_num * 0x4000) as u64

  // Disable UART
  rp1_write(base, UART_CR, 0)

  // Set up GPIO for UART0 (pins 14=TX, 15=RX)
  if uart_num == 0 {
    bcm2712_gpio_function(14, GPIO_FSEL_ALT0)
    bcm2712_gpio_function(15, GPIO_FSEL_ALT0)
    bcm2712_gpio_pud(14, GPIO_PUD_NONE)
    bcm2712_gpio_pud(15, GPIO_PUD_UP)
  }

  // Clear interrupts
  rp1_write(base, UART_ICR, 0x7FF)

  // Set baud rate (assuming 48MHz UART clock)
  let uart_clock: u32 = 48000000
  let divisor: u32 = uart_clock * 4 / baud_rate
  let ibrd: u32 = divisor / 64
  let fbrd: u32 = divisor % 64

  rp1_write(base, UART_IBRD, ibrd)
  rp1_write(base, UART_FBRD, fbrd)

  // 8N1, FIFO enabled
  rp1_write(base, UART_LCRH, 0x70)

  // Enable UART, TX, RX
  rp1_write(base, UART_CR, 0x301)

  foundation.serial_write_string("[BCM2712] UART")
  foundation.serial_write_u64(uart_num as u64)
  foundation.serial_write_string(" initialized\n")
}

export fn bcm2712_uart_putc(c: u8) {
  bcm2712_uart_putc_n(0, c)
}

export fn bcm2712_uart_putc_n(uart_num: u32, c: u8) {
  let base: u64 = RP1_UART0 + (uart_num * 0x4000) as u64

  // Wait for TX FIFO not full
  while (rp1_read(base, UART_FR) & UART_FR_TXFF) != 0 {}

  rp1_write(base, UART_DR, c as u32)
  uart_tx_bytes = uart_tx_bytes + 1
}

export fn bcm2712_uart_getc(): u8 {
  return bcm2712_uart_getc_n(0)
}

export fn bcm2712_uart_getc_n(uart_num: u32): u8 {
  let base: u64 = RP1_UART0 + (uart_num * 0x4000) as u64

  // Wait for RX FIFO not empty
  while (rp1_read(base, UART_FR) & UART_FR_RXFE) != 0 {}

  uart_rx_bytes = uart_rx_bytes + 1
  return (rp1_read(base, UART_DR) & 0xFF) as u8
}

export fn bcm2712_uart_available(): u32 {
  return bcm2712_uart_available_n(0)
}

export fn bcm2712_uart_available_n(uart_num: u32): u32 {
  let base: u64 = RP1_UART0 + (uart_num * 0x4000) as u64
  return if (rp1_read(base, UART_FR) & UART_FR_RXFE) == 0 { 1 } else { 0 }
}

// Mailbox interface
export fn bcm2712_mbox_write(channel: u32, data: u32) {
  while (mbox_read_reg(MBOX_STATUS) & MBOX_FULL) != 0 {}
  mbox_write_reg(MBOX_WRITE, (data & 0xFFFFFFF0) | (channel & 0x0F))
}

export fn bcm2712_mbox_read(channel: u32): u32 {
  loop {
    while (mbox_read_reg(MBOX_STATUS) & MBOX_EMPTY) != 0 {}

    let data: u32 = mbox_read_reg(MBOX_READ)
    if (data & 0x0F) == channel {
      return data & 0xFFFFFFF0
    }
  }
}

export fn bcm2712_mbox_call(buffer: *u32): u32 {
  mbox_calls = mbox_calls + 1

  let addr: u32 = (buffer as u64 & 0xFFFFFFFF) as u32

  bcm2712_mbox_write(MBOX_CH_PROP, addr)
  bcm2712_mbox_read(MBOX_CH_PROP)

  return buffer[1]
}

// Get board revision
export fn bcm2712_get_board_revision(): u32 {
  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00010002  // Get board revision
  buffer[3] = 4
  buffer[4] = 0
  buffer[5] = 0
  buffer[6] = 0
  buffer[7] = 0

  bcm2712_mbox_call(&buffer[0])

  return buffer[5]
}

// Get memory info
fn bcm2712_get_memory_info() {
  var buffer: [u32; 8]

  // Get ARM memory
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00010005
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0
  buffer[6] = 0
  buffer[7] = 0

  bcm2712_mbox_call(&buffer[0])

  state.arm_memory_base = buffer[5] as u64
  state.arm_memory_size = buffer[6] as u64

  // Get GPU memory
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00010006
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0
  buffer[6] = 0
  buffer[7] = 0

  bcm2712_mbox_call(&buffer[0])

  state.gpu_memory_base = buffer[5] as u64
  state.gpu_memory_size = buffer[6] as u64
}

// Get clock info
fn bcm2712_get_clock_info() {
  var buffer: [u32; 8]

  // Get ARM clock rate
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00030002  // Get clock rate
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 3  // ARM clock
  buffer[6] = 0
  buffer[7] = 0

  bcm2712_mbox_call(&buffer[0])

  state.cpu_freq = buffer[6]

  // Get max ARM clock rate
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00030004  // Get max clock rate
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 3
  buffer[6] = 0
  buffer[7] = 0

  bcm2712_mbox_call(&buffer[0])

  state.cpu_max_freq = buffer[6]

  // Get min ARM clock rate
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00030007  // Get min clock rate
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 3
  buffer[6] = 0
  buffer[7] = 0

  bcm2712_mbox_call(&buffer[0])

  state.cpu_min_freq = buffer[6]
}

// Thermal monitoring
fn bcm2712_thermal_init() {
  foundation.serial_write_string("[BCM2712] Thermal monitoring initialized\n")
}

export fn bcm2712_get_temperature(): u32 {
  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00030006  // Get temperature
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0  // Temperature ID (0 = SoC)
  buffer[6] = 0
  buffer[7] = 0

  bcm2712_mbox_call(&buffer[0])

  state.temperature = buffer[6]
  return buffer[6]
}

export fn bcm2712_get_max_temperature(): u32 {
  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x0003000A  // Get max temperature
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0
  buffer[6] = 0
  buffer[7] = 0

  bcm2712_mbox_call(&buffer[0])

  return buffer[6]
}

// CPU frequency control
export fn bcm2712_set_cpu_freq(freq_hz: u32): u32 {
  var buffer: [u32; 12]
  buffer[0] = 48
  buffer[1] = 0
  buffer[2] = 0x00038002  // Set clock rate
  buffer[3] = 12
  buffer[4] = 0
  buffer[5] = 3  // ARM clock
  buffer[6] = freq_hz
  buffer[7] = 0  // Skip turbo
  buffer[8] = 0
  buffer[9] = 0
  buffer[10] = 0
  buffer[11] = 0

  bcm2712_mbox_call(&buffer[0])

  if buffer[1] == 0x80000000 {
    state.cpu_freq = freq_hz
    return 0
  }

  return 1
}

export fn bcm2712_get_cpu_freq(): u32 {
  return state.cpu_freq
}

export fn bcm2712_get_cpu_max_freq(): u32 {
  return state.cpu_max_freq
}

export fn bcm2712_get_cpu_min_freq(): u32 {
  return state.cpu_min_freq
}

// Get memory sizes
export fn bcm2712_get_arm_memory(): u64 {
  return state.arm_memory_size
}

export fn bcm2712_get_gpu_memory(): u64 {
  return state.gpu_memory_size
}

// Power management
export fn bcm2712_reboot() {
  foundation.serial_write_string("[BCM2712] Rebooting...\n")

  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00042001  // Reboot
  buffer[3] = 4
  buffer[4] = 0
  buffer[5] = 0
  buffer[6] = 0
  buffer[7] = 0

  bcm2712_mbox_call(&buffer[0])

  loop {}
}

export fn bcm2712_shutdown() {
  foundation.serial_write_string("[BCM2712] Shutting down...\n")

  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00028001  // Set power state
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0  // Device 0
  buffer[6] = 0  // Off
  buffer[7] = 0

  bcm2712_mbox_call(&buffer[0])
}

// Get peripheral base
export fn bcm2712_get_peripheral_base(): u64 {
  return BCM2712_PERI_BASE
}

export fn bcm2712_get_rp1_base(): u64 {
  return RP1_BAR1_BASE
}

// Activity LED (GPIO 42 active low on Pi 5)
export fn bcm2712_activity_led(on: u32) {
  if on == 1 {
    bcm2712_gpio_clear(42)  // Active low
  } else {
    bcm2712_gpio_set(42)
  }
}

// Print system info
export fn bcm2712_print_info() {
  foundation.serial_write_string("\n╔════════════════════════════════════════════╗\n")
  foundation.serial_write_string("║      Raspberry Pi 5 System Information     ║\n")
  foundation.serial_write_string("╚════════════════════════════════════════════╝\n\n")

  foundation.serial_write_string("  SoC: Broadcom BCM2712\n")
  foundation.serial_write_string("  CPU: ARM Cortex-A76 (4 cores)\n")

  foundation.serial_write_string("  CPU Freq: ")
  foundation.serial_write_u64(state.cpu_freq / 1000000)
  foundation.serial_write_string(" MHz (")
  foundation.serial_write_u64(state.cpu_min_freq / 1000000)
  foundation.serial_write_string("-")
  foundation.serial_write_u64(state.cpu_max_freq / 1000000)
  foundation.serial_write_string(" MHz range)\n")

  foundation.serial_write_string("  ARM Memory: ")
  foundation.serial_write_u64(state.arm_memory_size / (1024 * 1024))
  foundation.serial_write_string(" MB\n")

  foundation.serial_write_string("  GPU Memory: ")
  foundation.serial_write_u64(state.gpu_memory_size / (1024 * 1024))
  foundation.serial_write_string(" MB\n")

  foundation.serial_write_string("  Board Rev: 0x")
  foundation.serial_write_hex(state.board_revision)
  foundation.serial_write_string("\n")

  let temp: u32 = bcm2712_get_temperature()
  foundation.serial_write_string("  Temperature: ")
  foundation.serial_write_u64(temp / 1000)
  foundation.serial_write_string(".")
  foundation.serial_write_u64((temp % 1000) / 100)
  foundation.serial_write_string(" C\n")

  foundation.serial_write_string("  RP1: ")
  foundation.serial_write_string(if state.rp1_initialized == 1 { "Ready" } else { "Not initialized" })
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  GIC-600: ")
  foundation.serial_write_string(if state.gic_initialized == 1 { "Ready" } else { "Not initialized" })
  foundation.serial_write_string("\n\n")
}

// Print statistics
export fn bcm2712_print_stats() {
  foundation.serial_write_string("\n[BCM2712] Statistics:\n")

  foundation.serial_write_string("  GPIO interrupts: ")
  foundation.serial_write_u64(gpio_interrupts)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Timer interrupts: ")
  foundation.serial_write_u64(timer_interrupts)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  HDMI interrupts: ")
  foundation.serial_write_u64(hdmi_interrupts)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  UART RX bytes: ")
  foundation.serial_write_u64(uart_rx_bytes)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  UART TX bytes: ")
  foundation.serial_write_u64(uart_tx_bytes)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Mailbox calls: ")
  foundation.serial_write_u64(mbox_calls)
  foundation.serial_write_string("\n")
}
