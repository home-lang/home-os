// home-os Raspberry Pi BCM2835 Support
// Broadcom BCM2835 SoC (Raspberry Pi 1, Pi Zero, Pi Zero W)
// ARMv6 ARM1176JZF-S single-core @ 700MHz

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

// BCM2835 Memory Map
// The BCM2835 uses a different bus address space
// Physical: 0x20000000 (32-bit ARM view)
// Bus: 0x7E000000 (VideoCore view)
const BCM2835_PERI_BASE: u64 = 0x20000000
const BCM2835_BUS_OFFSET: u64 = 0x40000000  // Bus to physical offset

// Peripheral Base Addresses (physical)
const GPIO_BASE: u64 = BCM2835_PERI_BASE + 0x200000
const UART0_BASE: u64 = BCM2835_PERI_BASE + 0x201000   // PL011 UART
const AUX_BASE: u64 = BCM2835_PERI_BASE + 0x215000     // Mini UART, SPI1, SPI2
const SPI0_BASE: u64 = BCM2835_PERI_BASE + 0x204000
const BSC0_BASE: u64 = BCM2835_PERI_BASE + 0x205000    // I2C0
const BSC1_BASE: u64 = BCM2835_PERI_BASE + 0x804000    // I2C1
const PWM_BASE: u64 = BCM2835_PERI_BASE + 0x20C000
const PCM_BASE: u64 = BCM2835_PERI_BASE + 0x203000     // I2S/PCM
const TIMER_BASE: u64 = BCM2835_PERI_BASE + 0x003000   // System Timer
const IRQ_BASE: u64 = BCM2835_PERI_BASE + 0x00B200     // Interrupt Controller
const MBOX_BASE: u64 = BCM2835_PERI_BASE + 0x00B880    // Mailbox
const PM_BASE: u64 = BCM2835_PERI_BASE + 0x100000      // Power Management
const CM_BASE: u64 = BCM2835_PERI_BASE + 0x101000      // Clock Manager
const DMA_BASE: u64 = BCM2835_PERI_BASE + 0x007000     // DMA Controller

// GPIO Register Offsets
const GPFSEL0: u32 = 0x00    // GPIO Function Select 0-5
const GPFSEL1: u32 = 0x04
const GPFSEL2: u32 = 0x08
const GPFSEL3: u32 = 0x0C
const GPFSEL4: u32 = 0x10
const GPFSEL5: u32 = 0x14
const GPSET0: u32 = 0x1C     // GPIO Pin Output Set 0-1
const GPSET1: u32 = 0x20
const GPCLR0: u32 = 0x28     // GPIO Pin Output Clear 0-1
const GPCLR1: u32 = 0x2C
const GPLEV0: u32 = 0x34     // GPIO Pin Level 0-1
const GPLEV1: u32 = 0x38
const GPEDS0: u32 = 0x40     // GPIO Pin Event Detect Status 0-1
const GPEDS1: u32 = 0x44
const GPREN0: u32 = 0x4C     // GPIO Pin Rising Edge Detect Enable 0-1
const GPREN1: u32 = 0x50
const GPFEN0: u32 = 0x58     // GPIO Pin Falling Edge Detect Enable 0-1
const GPFEN1: u32 = 0x5C
const GPHEN0: u32 = 0x64     // GPIO Pin High Detect Enable 0-1
const GPHEN1: u32 = 0x68
const GPLEN0: u32 = 0x70     // GPIO Pin Low Detect Enable 0-1
const GPLEN1: u32 = 0x74
const GPAREN0: u32 = 0x7C    // GPIO Pin Async Rising Edge Detect 0-1
const GPAREN1: u32 = 0x80
const GPAFEN0: u32 = 0x88    // GPIO Pin Async Falling Edge Detect 0-1
const GPAFEN1: u32 = 0x8C
const GPPUD: u32 = 0x94      // GPIO Pin Pull-up/down Enable
const GPPUDCLK0: u32 = 0x98  // GPIO Pin Pull-up/down Enable Clock 0-1
const GPPUDCLK1: u32 = 0x9C

// GPIO Function Select Values
const GPIO_FSEL_INPUT: u32 = 0
const GPIO_FSEL_OUTPUT: u32 = 1
const GPIO_FSEL_ALT0: u32 = 4
const GPIO_FSEL_ALT1: u32 = 5
const GPIO_FSEL_ALT2: u32 = 6
const GPIO_FSEL_ALT3: u32 = 7
const GPIO_FSEL_ALT4: u32 = 3
const GPIO_FSEL_ALT5: u32 = 2

// Pull-up/down values
const GPIO_PUD_OFF: u32 = 0
const GPIO_PUD_DOWN: u32 = 1
const GPIO_PUD_UP: u32 = 2

// UART0 (PL011) Register Offsets
const UART_DR: u32 = 0x00       // Data Register
const UART_RSRECR: u32 = 0x04   // Receive Status/Error Clear
const UART_FR: u32 = 0x18       // Flag Register
const UART_ILPR: u32 = 0x20     // IrDA Low-Power Counter
const UART_IBRD: u32 = 0x24     // Integer Baud Rate Divisor
const UART_FBRD: u32 = 0x28     // Fractional Baud Rate Divisor
const UART_LCRH: u32 = 0x2C     // Line Control Register
const UART_CR: u32 = 0x30       // Control Register
const UART_IFLS: u32 = 0x34     // Interrupt FIFO Level Select
const UART_IMSC: u32 = 0x38     // Interrupt Mask Set/Clear
const UART_RIS: u32 = 0x3C      // Raw Interrupt Status
const UART_MIS: u32 = 0x40      // Masked Interrupt Status
const UART_ICR: u32 = 0x44      // Interrupt Clear Register
const UART_DMACR: u32 = 0x48    // DMA Control Register

// UART Flag Register bits
const UART_FR_TXFE: u32 = 0x80  // TX FIFO Empty
const UART_FR_RXFF: u32 = 0x40  // RX FIFO Full
const UART_FR_TXFF: u32 = 0x20  // TX FIFO Full
const UART_FR_RXFE: u32 = 0x10  // RX FIFO Empty
const UART_FR_BUSY: u32 = 0x08  // UART Busy

// System Timer Registers
const TIMER_CS: u32 = 0x00      // Control/Status
const TIMER_CLO: u32 = 0x04     // Counter Lower 32 bits
const TIMER_CHI: u32 = 0x08     // Counter Upper 32 bits
const TIMER_C0: u32 = 0x0C      // Compare 0 (GPU)
const TIMER_C1: u32 = 0x10      // Compare 1
const TIMER_C2: u32 = 0x14      // Compare 2 (GPU)
const TIMER_C3: u32 = 0x18      // Compare 3

// Interrupt Controller Registers
const IRQ_BASIC_PENDING: u32 = 0x00
const IRQ_PENDING1: u32 = 0x04
const IRQ_PENDING2: u32 = 0x08
const IRQ_FIQ_CTRL: u32 = 0x0C
const IRQ_ENABLE1: u32 = 0x10
const IRQ_ENABLE2: u32 = 0x14
const IRQ_ENABLE_BASIC: u32 = 0x18
const IRQ_DISABLE1: u32 = 0x1C
const IRQ_DISABLE2: u32 = 0x20
const IRQ_DISABLE_BASIC: u32 = 0x24

// IRQ Numbers
const IRQ_TIMER0: u32 = 0
const IRQ_TIMER1: u32 = 1
const IRQ_TIMER2: u32 = 2
const IRQ_TIMER3: u32 = 3
const IRQ_USB: u32 = 9
const IRQ_DMA0: u32 = 16
const IRQ_DMA1: u32 = 17
const IRQ_DMA2: u32 = 18
const IRQ_DMA3: u32 = 19
const IRQ_DMA4: u32 = 20
const IRQ_DMA5: u32 = 21
const IRQ_DMA6: u32 = 22
const IRQ_DMA7: u32 = 23
const IRQ_DMA8: u32 = 24
const IRQ_DMA9: u32 = 25
const IRQ_DMA10: u32 = 26
const IRQ_DMA11: u32 = 27
const IRQ_DMA12: u32 = 28
const IRQ_AUX: u32 = 29
const IRQ_I2C_SPI_SLV: u32 = 43
const IRQ_PWA0: u32 = 45
const IRQ_PWA1: u32 = 46
const IRQ_SMI: u32 = 48
const IRQ_GPIO0: u32 = 49
const IRQ_GPIO1: u32 = 50
const IRQ_GPIO2: u32 = 51
const IRQ_GPIO3: u32 = 52
const IRQ_I2C: u32 = 53
const IRQ_SPI: u32 = 54
const IRQ_PCM: u32 = 55
const IRQ_UART: u32 = 57

// Mailbox Channels
const MBOX_CH_POWER: u32 = 0
const MBOX_CH_FB: u32 = 1
const MBOX_CH_VUART: u32 = 2
const MBOX_CH_VCHIQ: u32 = 3
const MBOX_CH_LEDS: u32 = 4
const MBOX_CH_BTNS: u32 = 5
const MBOX_CH_TOUCH: u32 = 6
const MBOX_CH_PROP: u32 = 8

// Mailbox Register Offsets
const MBOX_READ: u32 = 0x00
const MBOX_POLL: u32 = 0x10
const MBOX_SENDER: u32 = 0x14
const MBOX_STATUS: u32 = 0x18
const MBOX_CONFIG: u32 = 0x1C
const MBOX_WRITE: u32 = 0x20

// Mailbox Status bits
const MBOX_FULL: u32 = 0x80000000
const MBOX_EMPTY: u32 = 0x40000000

// DMA Control Block structure (aligned to 32 bytes)
struct DMAControlBlock {
  ti: u32           // Transfer Information
  source_ad: u32    // Source Address
  dest_ad: u32      // Destination Address
  txfr_len: u32     // Transfer Length
  stride: u32       // 2D Mode Stride
  nextconbk: u32    // Next Control Block Address
  reserved0: u32
  reserved1: u32
}

// DMA Channel Registers
const DMA_CS: u32 = 0x00        // Control and Status
const DMA_CONBLK_AD: u32 = 0x04 // Control Block Address
const DMA_TI: u32 = 0x08        // Transfer Information
const DMA_SOURCE_AD: u32 = 0x0C // Source Address
const DMA_DEST_AD: u32 = 0x10   // Destination Address
const DMA_TXFR_LEN: u32 = 0x14  // Transfer Length
const DMA_STRIDE: u32 = 0x18    // 2D Stride
const DMA_NEXTCONBK: u32 = 0x1C // Next Control Block Address
const DMA_DEBUG: u32 = 0x20     // Debug

// DMA CS Register bits
const DMA_CS_RESET: u32 = 0x80000000
const DMA_CS_ABORT: u32 = 0x40000000
const DMA_CS_DISDEBUG: u32 = 0x20000000
const DMA_CS_WAIT_FOR_OUTSTANDING_WRITES: u32 = 0x10000000
const DMA_CS_PANIC_PRIORITY: u32 = 0x00F00000
const DMA_CS_PRIORITY: u32 = 0x000F0000
const DMA_CS_ERROR: u32 = 0x00000100
const DMA_CS_WAITING_FOR_OUTSTANDING_WRITES: u32 = 0x00000040
const DMA_CS_DREQ_STOPS_DMA: u32 = 0x00000020
const DMA_CS_PAUSED: u32 = 0x00000010
const DMA_CS_DREQ: u32 = 0x00000008
const DMA_CS_INT: u32 = 0x00000004
const DMA_CS_END: u32 = 0x00000002
const DMA_CS_ACTIVE: u32 = 0x00000001

// DMA Transfer Information bits
const DMA_TI_NO_WIDE_BURSTS: u32 = 0x04000000
const DMA_TI_WAITS: u32 = 0x03E00000
const DMA_TI_PERMAP: u32 = 0x001F0000
const DMA_TI_BURST_LENGTH: u32 = 0x0000F000
const DMA_TI_SRC_IGNORE: u32 = 0x00000800
const DMA_TI_SRC_DREQ: u32 = 0x00000400
const DMA_TI_SRC_WIDTH: u32 = 0x00000200
const DMA_TI_SRC_INC: u32 = 0x00000100
const DMA_TI_DEST_IGNORE: u32 = 0x00000080
const DMA_TI_DEST_DREQ: u32 = 0x00000040
const DMA_TI_DEST_WIDTH: u32 = 0x00000020
const DMA_TI_DEST_INC: u32 = 0x00000010
const DMA_TI_WAIT_RESP: u32 = 0x00000008
const DMA_TI_TDMODE: u32 = 0x00000002
const DMA_TI_INTEN: u32 = 0x00000001

// Power Management Registers
const PM_RSTC: u32 = 0x1C
const PM_RSTS: u32 = 0x20
const PM_WDOG: u32 = 0x24

const PM_PASSWORD: u32 = 0x5A000000
const PM_RSTC_WRCFG_CLR: u32 = 0xFFFFFFCF
const PM_RSTC_WRCFG_FULL_RESET: u32 = 0x00000020

// Clock Manager
const CM_GP0CTL: u32 = 0x70
const CM_GP0DIV: u32 = 0x74
const CM_GP1CTL: u32 = 0x78
const CM_GP1DIV: u32 = 0x7C
const CM_GP2CTL: u32 = 0x80
const CM_GP2DIV: u32 = 0x84
const CM_PWMCTL: u32 = 0xA0
const CM_PWMDIV: u32 = 0xA4
const CM_PASSWORD: u32 = 0x5A000000

// SPI0 Register Offsets
const SPI_CS: u32 = 0x00      // Control and Status
const SPI_FIFO: u32 = 0x04    // TX and RX FIFOs
const SPI_CLK: u32 = 0x08     // Clock Divider
const SPI_DLEN: u32 = 0x0C    // Data Length
const SPI_LTOH: u32 = 0x10    // LoSSI mode TOH
const SPI_DC: u32 = 0x14      // DMA DREQ Controls

// SPI CS Register bits
const SPI_CS_LEN_LONG: u32 = 0x02000000
const SPI_CS_DMA_LEN: u32 = 0x01000000
const SPI_CS_CSPOL2: u32 = 0x00800000
const SPI_CS_CSPOL1: u32 = 0x00400000
const SPI_CS_CSPOL0: u32 = 0x00200000
const SPI_CS_RXF: u32 = 0x00100000
const SPI_CS_RXR: u32 = 0x00080000
const SPI_CS_TXD: u32 = 0x00040000
const SPI_CS_RXD: u32 = 0x00020000
const SPI_CS_DONE: u32 = 0x00010000
const SPI_CS_TE_EN: u32 = 0x00008000
const SPI_CS_LMONO: u32 = 0x00004000
const SPI_CS_LEN: u32 = 0x00002000
const SPI_CS_REN: u32 = 0x00001000
const SPI_CS_ADCS: u32 = 0x00000800
const SPI_CS_INTR: u32 = 0x00000400
const SPI_CS_INTD: u32 = 0x00000200
const SPI_CS_DMAEN: u32 = 0x00000100
const SPI_CS_TA: u32 = 0x00000080
const SPI_CS_CSPOL: u32 = 0x00000040
const SPI_CS_CLEAR: u32 = 0x00000030
const SPI_CS_CLEAR_RX: u32 = 0x00000020
const SPI_CS_CLEAR_TX: u32 = 0x00000010
const SPI_CS_CPOL: u32 = 0x00000008
const SPI_CS_CPHA: u32 = 0x00000004
const SPI_CS_CS: u32 = 0x00000003

// I2C (BSC) Register Offsets
const BSC_C: u32 = 0x00       // Control
const BSC_S: u32 = 0x04       // Status
const BSC_DLEN: u32 = 0x08    // Data Length
const BSC_A: u32 = 0x0C       // Slave Address
const BSC_FIFO: u32 = 0x10    // Data FIFO
const BSC_DIV: u32 = 0x14     // Clock Divider
const BSC_DEL: u32 = 0x18     // Data Delay
const BSC_CLKT: u32 = 0x1C    // Clock Stretch Timeout

// I2C Control Register bits
const BSC_C_I2CEN: u32 = 0x00008000
const BSC_C_INTR: u32 = 0x00000400
const BSC_C_INTT: u32 = 0x00000200
const BSC_C_INTD: u32 = 0x00000100
const BSC_C_ST: u32 = 0x00000080
const BSC_C_CLEAR: u32 = 0x00000030
const BSC_C_READ: u32 = 0x00000001

// I2C Status Register bits
const BSC_S_CLKT: u32 = 0x00000200
const BSC_S_ERR: u32 = 0x00000100
const BSC_S_RXF: u32 = 0x00000080
const BSC_S_TXE: u32 = 0x00000040
const BSC_S_RXD: u32 = 0x00000020
const BSC_S_TXD: u32 = 0x00000010
const BSC_S_RXR: u32 = 0x00000008
const BSC_S_TXW: u32 = 0x00000004
const BSC_S_DONE: u32 = 0x00000002
const BSC_S_TA: u32 = 0x00000001

// PWM Register Offsets
const PWM_CTL: u32 = 0x00
const PWM_STA: u32 = 0x04
const PWM_DMAC: u32 = 0x08
const PWM_RNG1: u32 = 0x10
const PWM_DAT1: u32 = 0x14
const PWM_FIF1: u32 = 0x18
const PWM_RNG2: u32 = 0x20
const PWM_DAT2: u32 = 0x24

// PWM Control bits
const PWM_CTL_MSEN2: u32 = 0x8000
const PWM_CTL_USEF2: u32 = 0x2000
const PWM_CTL_POLA2: u32 = 0x1000
const PWM_CTL_SBIT2: u32 = 0x0800
const PWM_CTL_RPTL2: u32 = 0x0400
const PWM_CTL_MODE2: u32 = 0x0200
const PWM_CTL_PWEN2: u32 = 0x0100
const PWM_CTL_MSEN1: u32 = 0x0080
const PWM_CTL_CLRF1: u32 = 0x0040
const PWM_CTL_USEF1: u32 = 0x0020
const PWM_CTL_POLA1: u32 = 0x0010
const PWM_CTL_SBIT1: u32 = 0x0008
const PWM_CTL_RPTL1: u32 = 0x0004
const PWM_CTL_MODE1: u32 = 0x0002
const PWM_CTL_PWEN1: u32 = 0x0001

// State
var initialized: u32 = 0
var board_revision: u32 = 0
var cpu_freq: u32 = 700000000  // 700 MHz default

// Statistics
var gpio_interrupts: u64 = 0
var timer_interrupts: u64 = 0
var dma_transfers: u64 = 0
var uart_rx_bytes: u64 = 0
var uart_tx_bytes: u64 = 0

// Helper functions
fn gpio_read(offset: u32): u32 {
  return memory.read_u32(GPIO_BASE + offset as u64)
}

fn gpio_write(offset: u32, value: u32) {
  memory.write_u32(GPIO_BASE + offset as u64, value)
}

fn uart_read(offset: u32): u32 {
  return memory.read_u32(UART0_BASE + offset as u64)
}

fn uart_write(offset: u32, value: u32) {
  memory.write_u32(UART0_BASE + offset as u64, value)
}

fn timer_read(offset: u32): u32 {
  return memory.read_u32(TIMER_BASE + offset as u64)
}

fn timer_write(offset: u32, value: u32) {
  memory.write_u32(TIMER_BASE + offset as u64, value)
}

fn mbox_read_reg(offset: u32): u32 {
  return memory.read_u32(MBOX_BASE + offset as u64)
}

fn mbox_write_reg(offset: u32, value: u32) {
  memory.write_u32(MBOX_BASE + offset as u64, value)
}

fn delay_cycles(count: u32) {
  var i: u32 = 0
  while i < count {
    foundation.nop()
    i = i + 1
  }
}

// Initialize BCM2835
export fn bcm2835_init(): u32 {
  if initialized == 1 { return 0 }

  foundation.serial_write_string("[BCM2835] Initializing Raspberry Pi 1/Zero support\n")

  // Initialize GPIO
  bcm2835_gpio_init()

  // Initialize UART
  bcm2835_uart_init(115200)

  // Initialize system timer
  bcm2835_timer_init()

  // Initialize interrupt controller
  bcm2835_irq_init()

  // Get board revision
  board_revision = bcm2835_get_board_revision()

  initialized = 1
  foundation.serial_write_string("[BCM2835] Initialization complete\n")

  return 0
}

// GPIO Initialization
fn bcm2835_gpio_init() {
  // All GPIOs start as inputs with pull-down
  foundation.serial_write_string("[BCM2835] GPIO initialized\n")
}

// Set GPIO function (input, output, alt0-5)
export fn bcm2835_gpio_function(pin: u32, func: u32) {
  if pin > 53 { return }

  let reg_offset: u32 = (pin / 10) * 4
  let shift: u32 = (pin % 10) * 3

  var val: u32 = gpio_read(reg_offset)
  val = val & ~(7 << shift)
  val = val | ((func & 7) << shift)
  gpio_write(reg_offset, val)
}

// Set GPIO output high
export fn bcm2835_gpio_set(pin: u32) {
  if pin > 53 { return }

  if pin < 32 {
    gpio_write(GPSET0, 1 << pin)
  } else {
    gpio_write(GPSET1, 1 << (pin - 32))
  }
}

// Set GPIO output low
export fn bcm2835_gpio_clear(pin: u32) {
  if pin > 53 { return }

  if pin < 32 {
    gpio_write(GPCLR0, 1 << pin)
  } else {
    gpio_write(GPCLR1, 1 << (pin - 32))
  }
}

// Read GPIO level
export fn bcm2835_gpio_level(pin: u32): u32 {
  if pin > 53 { return 0 }

  if pin < 32 {
    return (gpio_read(GPLEV0) >> pin) & 1
  } else {
    return (gpio_read(GPLEV1) >> (pin - 32)) & 1
  }
}

// Set GPIO pull-up/down
export fn bcm2835_gpio_pud(pin: u32, pud: u32) {
  if pin > 53 { return }

  // Set pull-up/down mode
  gpio_write(GPPUD, pud & 3)
  delay_cycles(150)

  // Clock it in for the specific pin
  if pin < 32 {
    gpio_write(GPPUDCLK0, 1 << pin)
  } else {
    gpio_write(GPPUDCLK1, 1 << (pin - 32))
  }
  delay_cycles(150)

  // Clear
  gpio_write(GPPUD, 0)
  if pin < 32 {
    gpio_write(GPPUDCLK0, 0)
  } else {
    gpio_write(GPPUDCLK1, 0)
  }
}

// Enable rising edge detect
export fn bcm2835_gpio_rising_edge(pin: u32, enable: u32) {
  if pin > 53 { return }

  if pin < 32 {
    var val: u32 = gpio_read(GPREN0)
    if enable == 1 {
      val = val | (1 << pin)
    } else {
      val = val & ~(1 << pin)
    }
    gpio_write(GPREN0, val)
  } else {
    var val: u32 = gpio_read(GPREN1)
    if enable == 1 {
      val = val | (1 << (pin - 32))
    } else {
      val = val & ~(1 << (pin - 32))
    }
    gpio_write(GPREN1, val)
  }
}

// Enable falling edge detect
export fn bcm2835_gpio_falling_edge(pin: u32, enable: u32) {
  if pin > 53 { return }

  if pin < 32 {
    var val: u32 = gpio_read(GPFEN0)
    if enable == 1 {
      val = val | (1 << pin)
    } else {
      val = val & ~(1 << pin)
    }
    gpio_write(GPFEN0, val)
  } else {
    var val: u32 = gpio_read(GPFEN1)
    if enable == 1 {
      val = val | (1 << (pin - 32))
    } else {
      val = val & ~(1 << (pin - 32))
    }
    gpio_write(GPFEN1, val)
  }
}

// Check and clear GPIO event
export fn bcm2835_gpio_event(pin: u32): u32 {
  if pin > 53 { return 0 }

  var detected: u32 = 0

  if pin < 32 {
    if (gpio_read(GPEDS0) & (1 << pin)) != 0 {
      detected = 1
      gpio_write(GPEDS0, 1 << pin)  // Clear by writing 1
    }
  } else {
    if (gpio_read(GPEDS1) & (1 << (pin - 32))) != 0 {
      detected = 1
      gpio_write(GPEDS1, 1 << (pin - 32))
    }
  }

  if detected == 1 {
    gpio_interrupts = gpio_interrupts + 1
  }

  return detected
}

// UART Initialization
fn bcm2835_uart_init(baud_rate: u32) {
  // Disable UART
  uart_write(UART_CR, 0)

  // Setup GPIO pins 14 (TX) and 15 (RX)
  bcm2835_gpio_function(14, GPIO_FSEL_ALT0)
  bcm2835_gpio_function(15, GPIO_FSEL_ALT0)
  bcm2835_gpio_pud(14, GPIO_PUD_OFF)
  bcm2835_gpio_pud(15, GPIO_PUD_OFF)

  // Clear pending interrupts
  uart_write(UART_ICR, 0x7FF)

  // Calculate baud rate divisor
  // UART clock = 3MHz on BCM2835
  let uart_clock: u32 = 3000000
  let divisor: u32 = uart_clock * 4 / baud_rate
  let ibrd: u32 = divisor / 64
  let fbrd: u32 = divisor % 64

  uart_write(UART_IBRD, ibrd)
  uart_write(UART_FBRD, fbrd)

  // 8 bits, no parity, 1 stop bit, FIFO enabled
  uart_write(UART_LCRH, 0x70)

  // Enable UART, TX and RX
  uart_write(UART_CR, 0x301)

  foundation.serial_write_string("[BCM2835] UART initialized at 115200 baud\n")
}

// Send character via UART
export fn bcm2835_uart_putc(c: u8) {
  // Wait for TX FIFO to have space
  while (uart_read(UART_FR) & UART_FR_TXFF) != 0 {}

  uart_write(UART_DR, c as u32)
  uart_tx_bytes = uart_tx_bytes + 1
}

// Receive character via UART
export fn bcm2835_uart_getc(): u8 {
  // Wait for RX FIFO to have data
  while (uart_read(UART_FR) & UART_FR_RXFE) != 0 {}

  uart_rx_bytes = uart_rx_bytes + 1
  return (uart_read(UART_DR) & 0xFF) as u8
}

// Check if UART has data available
export fn bcm2835_uart_available(): u32 {
  return if (uart_read(UART_FR) & UART_FR_RXFE) == 0 { 1 } else { 0 }
}

// Send string via UART
export fn bcm2835_uart_puts(s: *u8) {
  var i: u32 = 0
  while s[i] != 0 {
    bcm2835_uart_putc(s[i])
    i = i + 1
  }
}

// System Timer Initialization
fn bcm2835_timer_init() {
  // Clear all compare match flags
  timer_write(TIMER_CS, 0x0F)

  foundation.serial_write_string("[BCM2835] System timer initialized\n")
}

// Get system timer counter (64-bit, 1MHz)
export fn bcm2835_timer_read(): u64 {
  // Read low first, then high
  let lo: u32 = timer_read(TIMER_CLO)
  let hi: u32 = timer_read(TIMER_CHI)

  return (hi as u64 << 32) | lo as u64
}

// Set timer compare value (channel 1 or 3, 0/2 are GPU)
export fn bcm2835_timer_set_compare(channel: u32, value: u32) {
  if channel == 1 {
    timer_write(TIMER_C1, value)
  } else if channel == 3 {
    timer_write(TIMER_C3, value)
  }
}

// Clear timer match flag
export fn bcm2835_timer_clear_match(channel: u32) {
  timer_write(TIMER_CS, 1 << channel)
  timer_interrupts = timer_interrupts + 1
}

// Check timer match flag
export fn bcm2835_timer_match(channel: u32): u32 {
  return (timer_read(TIMER_CS) >> channel) & 1
}

// Delay microseconds
export fn bcm2835_delay_us(us: u32) {
  let start: u64 = bcm2835_timer_read()
  while (bcm2835_timer_read() - start) < us as u64 {}
}

// Delay milliseconds
export fn bcm2835_delay_ms(ms: u32) {
  bcm2835_delay_us(ms * 1000)
}

// Interrupt Controller Initialization
fn bcm2835_irq_init() {
  // Disable all interrupts initially
  memory.write_u32(IRQ_BASE + IRQ_DISABLE1, 0xFFFFFFFF)
  memory.write_u32(IRQ_BASE + IRQ_DISABLE2, 0xFFFFFFFF)
  memory.write_u32(IRQ_BASE + IRQ_DISABLE_BASIC, 0xFFFFFFFF)

  foundation.serial_write_string("[BCM2835] Interrupt controller initialized\n")
}

// Enable IRQ
export fn bcm2835_irq_enable(irq: u32) {
  if irq < 32 {
    memory.write_u32(IRQ_BASE + IRQ_ENABLE1, 1 << irq)
  } else if irq < 64 {
    memory.write_u32(IRQ_BASE + IRQ_ENABLE2, 1 << (irq - 32))
  }
}

// Disable IRQ
export fn bcm2835_irq_disable(irq: u32) {
  if irq < 32 {
    memory.write_u32(IRQ_BASE + IRQ_DISABLE1, 1 << irq)
  } else if irq < 64 {
    memory.write_u32(IRQ_BASE + IRQ_DISABLE2, 1 << (irq - 32))
  }
}

// Check pending IRQ
export fn bcm2835_irq_pending(irq: u32): u32 {
  if irq < 32 {
    return (memory.read_u32(IRQ_BASE + IRQ_PENDING1) >> irq) & 1
  } else if irq < 64 {
    return (memory.read_u32(IRQ_BASE + IRQ_PENDING2) >> (irq - 32)) & 1
  }
  return 0
}

// Mailbox functions
export fn bcm2835_mbox_write(channel: u32, data: u32) {
  // Wait for mailbox not full
  while (mbox_read_reg(MBOX_STATUS) & MBOX_FULL) != 0 {}

  // Write data with channel in lower 4 bits
  mbox_write_reg(MBOX_WRITE, (data & 0xFFFFFFF0) | (channel & 0x0F))
}

export fn bcm2835_mbox_read(channel: u32): u32 {
  loop {
    // Wait for mailbox not empty
    while (mbox_read_reg(MBOX_STATUS) & MBOX_EMPTY) != 0 {}

    // Read data
    let data: u32 = mbox_read_reg(MBOX_READ)

    // Check channel
    if (data & 0x0F) == channel {
      return data & 0xFFFFFFF0
    }
  }
}

// Property mailbox call
export fn bcm2835_mbox_call(buffer: *u32): u32 {
  // Convert to bus address
  let addr: u32 = (buffer as u64 + BCM2835_BUS_OFFSET) as u32

  // Write to property channel
  bcm2835_mbox_write(MBOX_CH_PROP, addr)

  // Read response
  let response: u32 = bcm2835_mbox_read(MBOX_CH_PROP)

  // Check response code
  return buffer[1]
}

// Get board revision via mailbox
export fn bcm2835_get_board_revision(): u32 {
  var buffer: [u32; 8]
  buffer[0] = 32      // Buffer size
  buffer[1] = 0       // Request code
  buffer[2] = 0x00010002  // Get board revision
  buffer[3] = 4       // Value buffer size
  buffer[4] = 0       // Request/response code
  buffer[5] = 0       // Value (revision)
  buffer[6] = 0       // End tag
  buffer[7] = 0

  bcm2835_mbox_call(&buffer[0])

  return buffer[5]
}

// Get ARM memory via mailbox
export fn bcm2835_get_arm_memory(): u64 {
  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00010005  // Get ARM memory
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0  // Base
  buffer[6] = 0  // Size
  buffer[7] = 0

  bcm2835_mbox_call(&buffer[0])

  return buffer[6] as u64
}

// Get temperature (in thousandths of a degree C)
export fn bcm2835_get_temperature(): u32 {
  var buffer: [u32; 8]
  buffer[0] = 32
  buffer[1] = 0
  buffer[2] = 0x00030006  // Get temperature
  buffer[3] = 8
  buffer[4] = 0
  buffer[5] = 0  // Temperature ID (0 = SoC)
  buffer[6] = 0  // Temperature
  buffer[7] = 0

  bcm2835_mbox_call(&buffer[0])

  return buffer[6]
}

// SPI functions
export fn bcm2835_spi_init() {
  // Set GPIO pins for SPI0
  // GPIO 7-11 as ALT0
  bcm2835_gpio_function(7, GPIO_FSEL_ALT0)   // CE1
  bcm2835_gpio_function(8, GPIO_FSEL_ALT0)   // CE0
  bcm2835_gpio_function(9, GPIO_FSEL_ALT0)   // MISO
  bcm2835_gpio_function(10, GPIO_FSEL_ALT0)  // MOSI
  bcm2835_gpio_function(11, GPIO_FSEL_ALT0)  // SCLK

  // Clear FIFOs
  memory.write_u32(SPI0_BASE + SPI_CS, SPI_CS_CLEAR)

  foundation.serial_write_string("[BCM2835] SPI0 initialized\n")
}

export fn bcm2835_spi_set_clock(divider: u32) {
  memory.write_u32(SPI0_BASE + SPI_CLK, divider)
}

export fn bcm2835_spi_transfer(data: u8): u8 {
  // Set TA (Transfer Active)
  memory.write_u32(SPI0_BASE + SPI_CS, memory.read_u32(SPI0_BASE + SPI_CS) | SPI_CS_TA)

  // Wait for TXD
  while (memory.read_u32(SPI0_BASE + SPI_CS) & SPI_CS_TXD) == 0 {}

  // Write data
  memory.write_u32(SPI0_BASE + SPI_FIFO, data as u32)

  // Wait for DONE
  while (memory.read_u32(SPI0_BASE + SPI_CS) & SPI_CS_DONE) == 0 {}

  // Read data
  let result: u8 = (memory.read_u32(SPI0_BASE + SPI_FIFO) & 0xFF) as u8

  // Clear TA
  memory.write_u32(SPI0_BASE + SPI_CS, memory.read_u32(SPI0_BASE + SPI_CS) & ~SPI_CS_TA)

  return result
}

// I2C functions
export fn bcm2835_i2c_init(controller: u32) {
  let base: u64 = if controller == 0 { BSC0_BASE } else { BSC1_BASE }

  // Set GPIO pins for I2C
  if controller == 0 {
    bcm2835_gpio_function(0, GPIO_FSEL_ALT0)  // SDA0
    bcm2835_gpio_function(1, GPIO_FSEL_ALT0)  // SCL0
  } else {
    bcm2835_gpio_function(2, GPIO_FSEL_ALT0)  // SDA1
    bcm2835_gpio_function(3, GPIO_FSEL_ALT0)  // SCL1
  }

  // Enable I2C
  memory.write_u32(base + BSC_C, BSC_C_I2CEN)

  foundation.serial_write_string("[BCM2835] I2C")
  foundation.serial_write_string(if controller == 0 { "0" } else { "1" })
  foundation.serial_write_string(" initialized\n")
}

export fn bcm2835_i2c_set_clock(controller: u32, divider: u32) {
  let base: u64 = if controller == 0 { BSC0_BASE } else { BSC1_BASE }
  memory.write_u32(base + BSC_DIV, divider)
}

export fn bcm2835_i2c_read(controller: u32, addr: u8, buffer: *u8, len: u32): u32 {
  let base: u64 = if controller == 0 { BSC0_BASE } else { BSC1_BASE }

  // Set slave address
  memory.write_u32(base + BSC_A, addr as u32)

  // Set data length
  memory.write_u32(base + BSC_DLEN, len)

  // Clear status, start read
  memory.write_u32(base + BSC_S, BSC_S_CLKT | BSC_S_ERR | BSC_S_DONE)
  memory.write_u32(base + BSC_C, BSC_C_I2CEN | BSC_C_ST | BSC_C_CLEAR | BSC_C_READ)

  // Read data
  var i: u32 = 0
  while i < len {
    // Wait for data
    while (memory.read_u32(base + BSC_S) & BSC_S_RXD) == 0 {
      if (memory.read_u32(base + BSC_S) & (BSC_S_ERR | BSC_S_CLKT)) != 0 {
        return 1  // Error
      }
    }

    buffer[i] = (memory.read_u32(base + BSC_FIFO) & 0xFF) as u8
    i = i + 1
  }

  // Wait for done
  while (memory.read_u32(base + BSC_S) & BSC_S_DONE) == 0 {}

  return 0
}

export fn bcm2835_i2c_write(controller: u32, addr: u8, buffer: *u8, len: u32): u32 {
  let base: u64 = if controller == 0 { BSC0_BASE } else { BSC1_BASE }

  // Set slave address
  memory.write_u32(base + BSC_A, addr as u32)

  // Set data length
  memory.write_u32(base + BSC_DLEN, len)

  // Clear status, start write
  memory.write_u32(base + BSC_S, BSC_S_CLKT | BSC_S_ERR | BSC_S_DONE)
  memory.write_u32(base + BSC_C, BSC_C_I2CEN | BSC_C_ST | BSC_C_CLEAR)

  // Write data
  var i: u32 = 0
  while i < len {
    // Wait for space
    while (memory.read_u32(base + BSC_S) & BSC_S_TXD) == 0 {
      if (memory.read_u32(base + BSC_S) & (BSC_S_ERR | BSC_S_CLKT)) != 0 {
        return 1  // Error
      }
    }

    memory.write_u32(base + BSC_FIFO, buffer[i] as u32)
    i = i + 1
  }

  // Wait for done
  while (memory.read_u32(base + BSC_S) & BSC_S_DONE) == 0 {}

  return 0
}

// PWM functions
export fn bcm2835_pwm_init(channel: u32) {
  // Set GPIO for PWM
  if channel == 0 {
    bcm2835_gpio_function(12, GPIO_FSEL_ALT0)  // PWM0
  } else {
    bcm2835_gpio_function(13, GPIO_FSEL_ALT0)  // PWM1
  }

  foundation.serial_write_string("[BCM2835] PWM")
  foundation.serial_write_string(if channel == 0 { "0" } else { "1" })
  foundation.serial_write_string(" initialized\n")
}

export fn bcm2835_pwm_set_clock(divider: u32) {
  // Stop PWM
  memory.write_u32(PWM_BASE + PWM_CTL, 0)

  // Set clock divider
  memory.write_u32(CM_BASE + CM_PWMCTL, CM_PASSWORD | 0x01)  // Stop
  delay_cycles(100)
  memory.write_u32(CM_BASE + CM_PWMDIV, CM_PASSWORD | (divider << 12))
  memory.write_u32(CM_BASE + CM_PWMCTL, CM_PASSWORD | 0x11)  // Enable
  delay_cycles(100)
}

export fn bcm2835_pwm_set_range(channel: u32, range: u32) {
  if channel == 0 {
    memory.write_u32(PWM_BASE + PWM_RNG1, range)
  } else {
    memory.write_u32(PWM_BASE + PWM_RNG2, range)
  }
}

export fn bcm2835_pwm_set_data(channel: u32, data: u32) {
  if channel == 0 {
    memory.write_u32(PWM_BASE + PWM_DAT1, data)
  } else {
    memory.write_u32(PWM_BASE + PWM_DAT2, data)
  }
}

export fn bcm2835_pwm_enable(channel: u32, enable: u32) {
  var ctl: u32 = memory.read_u32(PWM_BASE + PWM_CTL)

  if channel == 0 {
    if enable == 1 {
      ctl = ctl | PWM_CTL_PWEN1 | PWM_CTL_MSEN1
    } else {
      ctl = ctl & ~PWM_CTL_PWEN1
    }
  } else {
    if enable == 1 {
      ctl = ctl | PWM_CTL_PWEN2 | PWM_CTL_MSEN2
    } else {
      ctl = ctl & ~PWM_CTL_PWEN2
    }
  }

  memory.write_u32(PWM_BASE + PWM_CTL, ctl)
}

// Power management
export fn bcm2835_reboot() {
  foundation.serial_write_string("[BCM2835] Rebooting...\n")

  // Use watchdog to reset
  let pm_base: u64 = PM_BASE
  memory.write_u32(pm_base + PM_WDOG, PM_PASSWORD | 10)  // 10 ticks
  memory.write_u32(pm_base + PM_RSTC, PM_PASSWORD | PM_RSTC_WRCFG_FULL_RESET)

  // Wait for reset
  loop {}
}

// Get base addresses
export fn bcm2835_get_peripheral_base(): u64 {
  return BCM2835_PERI_BASE
}

export fn bcm2835_get_gpio_base(): u64 {
  return GPIO_BASE
}

export fn bcm2835_get_uart_base(): u64 {
  return UART0_BASE
}

// Print statistics
export fn bcm2835_print_stats() {
  foundation.serial_write_string("\n[BCM2835] Statistics:\n")

  foundation.serial_write_string("  GPIO interrupts: ")
  foundation.serial_write_u64(gpio_interrupts)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Timer interrupts: ")
  foundation.serial_write_u64(timer_interrupts)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  DMA transfers: ")
  foundation.serial_write_u64(dma_transfers)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  UART RX bytes: ")
  foundation.serial_write_u64(uart_rx_bytes)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  UART TX bytes: ")
  foundation.serial_write_u64(uart_tx_bytes)
  foundation.serial_write_string("\n")
}
