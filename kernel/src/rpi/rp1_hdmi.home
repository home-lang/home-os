// home-os Raspberry Pi 5 HDMI Driver via RP1
// Complete HDMI controller for dual 4K@60Hz output
// Supports LG 27UP850-W and similar 4K monitors

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "./rp1.home" as rp1

// RP1 HDMI controller offsets (from BAR1)
const RP1_PCIE_BAR1: u64 = 0x1F00000000
const RP1_HDMI0_OFFSET: u64 = 0x00110000
const RP1_HDMI1_OFFSET: u64 = 0x00118000
const RP1_HDMI_PIXELVALVE0: u64 = 0x00120000
const RP1_HDMI_PIXELVALVE1: u64 = 0x00128000
const RP1_HDMI_VEC: u64 = 0x00130000

// HDMI register offsets (within each HDMI block)
const HDMI_CORE_REV: u64 = 0x000
const HDMI_SW_RESET: u64 = 0x004
const HDMI_HOTPLUG: u64 = 0x008
const HDMI_HOTPLUG_INT: u64 = 0x00C
const HDMI_VIDEO_CTL: u64 = 0x010
const HDMI_VIDEO_CTL2: u64 = 0x014
const HDMI_TIMING_H: u64 = 0x020
const HDMI_TIMING_V: u64 = 0x024
const HDMI_TIMING_HSYNC: u64 = 0x028
const HDMI_TIMING_VSYNC: u64 = 0x02C
const HDMI_FRAME_CTL: u64 = 0x030
const HDMI_DEEP_COLOR: u64 = 0x034
const HDMI_GCP_CONFIG: u64 = 0x038
const HDMI_GCP_WORD1: u64 = 0x03C
const HDMI_PACKET_STRIDE: u64 = 0x040
const HDMI_AUDIO_CTL: u64 = 0x050
const HDMI_AUDIO_PACKET: u64 = 0x054
const HDMI_ACR_CTL: u64 = 0x058
const HDMI_ACR_N: u64 = 0x05C
const HDMI_ACR_CTS: u64 = 0x060
const HDMI_INFOFRAME_CTL: u64 = 0x070
const HDMI_AVI_INFOFRAME: u64 = 0x080
const HDMI_SPD_INFOFRAME: u64 = 0x0A0
const HDMI_AUDIO_INFOFRAME: u64 = 0x0C0
const HDMI_PHY_CTL: u64 = 0x100
const HDMI_PHY_STATUS: u64 = 0x104
const HDMI_PHY_RESET: u64 = 0x108
const HDMI_PLL_CTL: u64 = 0x110
const HDMI_PLL_STATUS: u64 = 0x114
const HDMI_TMDS_CTL: u64 = 0x120
const HDMI_TMDS_CLK: u64 = 0x124
const HDMI_CEC_CTL: u64 = 0x140
const HDMI_CEC_TX: u64 = 0x144
const HDMI_CEC_RX: u64 = 0x148
const HDMI_DDC_CTL: u64 = 0x150
const HDMI_DDC_STATUS: u64 = 0x154
const HDMI_DDC_DATA: u64 = 0x158
const HDMI_SCRAMBLER_CTL: u64 = 0x160
const HDMI_SCDC_CTL: u64 = 0x164

// HDMI video modes
const HDMI_MODE_480P: u32 = 1
const HDMI_MODE_720P: u32 = 2
const HDMI_MODE_1080P: u32 = 3
const HDMI_MODE_4K30: u32 = 4
const HDMI_MODE_4K60: u32 = 5

// Color depths
const HDMI_COLOR_8BIT: u32 = 0
const HDMI_COLOR_10BIT: u32 = 1
const HDMI_COLOR_12BIT: u32 = 2

// Color formats
const HDMI_COLOR_RGB: u32 = 0
const HDMI_COLOR_YCBCR444: u32 = 1
const HDMI_COLOR_YCBCR422: u32 = 2
const HDMI_COLOR_YCBCR420: u32 = 3

// Video timing structure
struct VideoTiming {
    width: u32
    height: u32
    h_front_porch: u32
    h_sync_width: u32
    h_back_porch: u32
    v_front_porch: u32
    v_sync_width: u32
    v_back_porch: u32
    pixel_clock: u32      // In kHz
    h_sync_polarity: u32  // 0 = negative, 1 = positive
    v_sync_polarity: u32  // 0 = negative, 1 = positive
    refresh_rate: u32     // Hz
}

// Predefined video modes
const TIMING_480P: VideoTiming = VideoTiming {
    width: 720,
    height: 480,
    h_front_porch: 16,
    h_sync_width: 62,
    h_back_porch: 60,
    v_front_porch: 9,
    v_sync_width: 6,
    v_back_porch: 30,
    pixel_clock: 27000,
    h_sync_polarity: 0,
    v_sync_polarity: 0,
    refresh_rate: 60
}

const TIMING_720P: VideoTiming = VideoTiming {
    width: 1280,
    height: 720,
    h_front_porch: 110,
    h_sync_width: 40,
    h_back_porch: 220,
    v_front_porch: 5,
    v_sync_width: 5,
    v_back_porch: 20,
    pixel_clock: 74250,
    h_sync_polarity: 1,
    v_sync_polarity: 1,
    refresh_rate: 60
}

const TIMING_1080P: VideoTiming = VideoTiming {
    width: 1920,
    height: 1080,
    h_front_porch: 88,
    h_sync_width: 44,
    h_back_porch: 148,
    v_front_porch: 4,
    v_sync_width: 5,
    v_back_porch: 36,
    pixel_clock: 148500,
    h_sync_polarity: 1,
    v_sync_polarity: 1,
    refresh_rate: 60
}

const TIMING_4K30: VideoTiming = VideoTiming {
    width: 3840,
    height: 2160,
    h_front_porch: 176,
    h_sync_width: 88,
    h_back_porch: 296,
    v_front_porch: 8,
    v_sync_width: 10,
    v_back_porch: 72,
    pixel_clock: 297000,
    h_sync_polarity: 1,
    v_sync_polarity: 1,
    refresh_rate: 30
}

// 4K @ 60Hz - Primary mode for LG 27UP850-W
const TIMING_4K60: VideoTiming = VideoTiming {
    width: 3840,
    height: 2160,
    h_front_porch: 176,
    h_sync_width: 88,
    h_back_porch: 296,
    v_front_porch: 8,
    v_sync_width: 10,
    v_back_porch: 72,
    pixel_clock: 594000,   // 594 MHz for 4K@60
    h_sync_polarity: 1,
    v_sync_polarity: 1,
    refresh_rate: 60
}

// EDID data structure
struct EdidBlock {
    raw: [128]u8
    valid: u32
}

struct EdidInfo {
    manufacturer: [4]u8
    product_code: u16
    serial_number: u32
    preferred_width: u32
    preferred_height: u32
    preferred_refresh: u32
    max_width: u32
    max_height: u32
    supports_4k60: u32
    supports_hdr: u32
    supports_audio: u32
    hdmi_version: u32      // 1 = HDMI 1.4, 2 = HDMI 2.0, 3 = HDMI 2.1
    block_count: u32
    blocks: [4]EdidBlock
}

// HDMI port state
struct HdmiPort {
    base_addr: u64
    port_id: u32
    enabled: u32
    connected: u32
    current_mode: u32
    width: u32
    height: u32
    refresh_rate: u32
    color_depth: u32
    color_format: u32
    audio_enabled: u32
    edid: EdidInfo
    framebuffer_addr: u64
    framebuffer_size: u64
    phy_initialized: u32
    scrambling_enabled: u32
}

// Global HDMI controller state
struct HdmiController {
    bar1_base: u64
    ports: [2]HdmiPort     // HDMI0 and HDMI1
    initialized: u32
    active_port: u32
}

var hdmi_ctrl: HdmiController

// Statistics
var hdmi_mode_changes: u64 = 0
var hdmi_edid_reads: u64 = 0
var hdmi_hotplug_events: u64 = 0

// Register access helpers
fn hdmi_read32(port: u32, offset: u64): u32 {
    if port >= 2 { return 0 }
    var addr: u64 = hdmi_ctrl.ports[port].base_addr + offset
    return memory.read_volatile_u32(addr)
}

fn hdmi_write32(port: u32, offset: u64, value: u32) {
    if port >= 2 { return }
    var addr: u64 = hdmi_ctrl.ports[port].base_addr + offset
    memory.write_volatile_u32(addr, value)
}

// Initialize HDMI controller
export fn hdmi_init(): u32 {
    if hdmi_ctrl.initialized == 1 {
        foundation.serial_write_string("[HDMI] Already initialized\n")
        return 0
    }

    foundation.serial_write_string("[HDMI] Initializing Raspberry Pi 5 HDMI controller\n")

    // Ensure RP1 is initialized first
    if rp1.rp1_get_base() == 0 {
        var result: u32 = rp1.rp1_init()
        if result != 0 {
            foundation.serial_write_string("[HDMI] Failed to initialize RP1\n")
            return 1
        }
    }

    // Get BAR1 base from RP1
    hdmi_ctrl.bar1_base = RP1_PCIE_BAR1

    // Setup port base addresses
    hdmi_ctrl.ports[0].base_addr = hdmi_ctrl.bar1_base + RP1_HDMI0_OFFSET
    hdmi_ctrl.ports[0].port_id = 0
    hdmi_ctrl.ports[1].base_addr = hdmi_ctrl.bar1_base + RP1_HDMI1_OFFSET
    hdmi_ctrl.ports[1].port_id = 1

    // Initialize both ports
    var i: u32 = 0
    while i < 2 {
        hdmi_port_init(i)
        i = i + 1
    }

    hdmi_ctrl.initialized = 1
    hdmi_ctrl.active_port = 0

    foundation.serial_write_string("[HDMI] Controller initialized - 2 ports available\n")
    return 0
}

// Initialize a specific HDMI port
fn hdmi_port_init(port: u32): u32 {
    if port >= 2 { return 1 }

    foundation.serial_write_string("[HDMI] Initializing port ")
    foundation.serial_write_u64(port)
    foundation.serial_write_string("\n")

    // Reset the port
    hdmi_write32(port, HDMI_SW_RESET, 0x1)
    foundation.delay_us(1000)
    hdmi_write32(port, HDMI_SW_RESET, 0x0)
    foundation.delay_us(1000)

    // Initialize PHY
    var result: u32 = hdmi_phy_init(port)
    if result != 0 {
        foundation.serial_write_string("[HDMI] PHY init failed for port ")
        foundation.serial_write_u64(port)
        foundation.serial_write_string("\n")
        return 1
    }

    // Check hotplug status
    hdmi_ctrl.ports[port].connected = hdmi_check_hotplug(port)

    if hdmi_ctrl.ports[port].connected == 1 {
        foundation.serial_write_string("[HDMI] Display connected on port ")
        foundation.serial_write_u64(port)
        foundation.serial_write_string("\n")

        // Read EDID
        hdmi_read_edid(port)
    }

    hdmi_ctrl.ports[port].enabled = 0
    hdmi_ctrl.ports[port].current_mode = 0

    return 0
}

// Initialize HDMI PHY (Physical Layer)
fn hdmi_phy_init(port: u32): u32 {
    if port >= 2 { return 1 }

    // Power up PHY
    hdmi_write32(port, HDMI_PHY_CTL, 0x01)
    foundation.delay_us(100)

    // Reset PHY
    hdmi_write32(port, HDMI_PHY_RESET, 0x01)
    foundation.delay_us(100)
    hdmi_write32(port, HDMI_PHY_RESET, 0x00)
    foundation.delay_us(100)

    // Wait for PHY to stabilize
    var timeout: u32 = 1000
    while timeout > 0 {
        var status: u32 = hdmi_read32(port, HDMI_PHY_STATUS)
        if (status & 0x01) == 0x01 {
            hdmi_ctrl.ports[port].phy_initialized = 1
            return 0
        }
        foundation.delay_us(10)
        timeout = timeout - 1
    }

    foundation.serial_write_string("[HDMI] PHY timeout on port ")
    foundation.serial_write_u64(port)
    foundation.serial_write_string("\n")

    return 1
}

// Check hotplug status
fn hdmi_check_hotplug(port: u32): u32 {
    if port >= 2 { return 0 }

    var status: u32 = hdmi_read32(port, HDMI_HOTPLUG)
    return status & 0x01
}

// Read EDID from connected display
export fn hdmi_read_edid(port: u32): u32 {
    if port >= 2 { return 1 }
    if hdmi_ctrl.ports[port].connected == 0 { return 1 }

    foundation.serial_write_string("[HDMI] Reading EDID from port ")
    foundation.serial_write_u64(port)
    foundation.serial_write_string("\n")

    // Initialize DDC (Display Data Channel)
    hdmi_write32(port, HDMI_DDC_CTL, 0x01)  // Enable DDC
    foundation.delay_us(100)

    // Read base EDID block (128 bytes at address 0x50)
    var edid_addr: u8 = 0x50
    var block: u32 = 0

    while block < 4 {
        var result: u32 = hdmi_read_edid_block(port, block, edid_addr)
        if result != 0 {
            if block == 0 {
                foundation.serial_write_string("[HDMI] Failed to read base EDID\n")
                return 1
            }
            break
        }
        hdmi_ctrl.ports[port].edid.blocks[block].valid = 1
        block = block + 1
    }

    hdmi_ctrl.ports[port].edid.block_count = block

    // Parse EDID data
    hdmi_parse_edid(port)

    hdmi_edid_reads = hdmi_edid_reads + 1

    return 0
}

// Read a single EDID block
fn hdmi_read_edid_block(port: u32, block: u32, i2c_addr: u8): u32 {
    if port >= 2 { return 1 }
    if block >= 4 { return 1 }

    // Set segment pointer for blocks > 1
    if block >= 2 {
        hdmi_ddc_write_byte(port, 0x30, block / 2)
    }

    // Set DDC address offset
    var offset: u8 = (block % 2) * 128
    hdmi_ddc_write_byte(port, i2c_addr, offset)

    // Read 128 bytes
    var i: u32 = 0
    while i < 128 {
        var byte: u8 = hdmi_ddc_read_byte(port, i2c_addr)
        hdmi_ctrl.ports[port].edid.blocks[block].raw[i] = byte
        i = i + 1
    }

    // Verify checksum
    var checksum: u32 = 0
    i = 0
    while i < 128 {
        checksum = checksum + hdmi_ctrl.ports[port].edid.blocks[block].raw[i]
        i = i + 1
    }

    if (checksum & 0xFF) != 0 {
        foundation.serial_write_string("[HDMI] EDID checksum error for block ")
        foundation.serial_write_u64(block)
        foundation.serial_write_string("\n")
        return 1
    }

    return 0
}

// DDC byte write
fn hdmi_ddc_write_byte(port: u32, addr: u8, data: u8) {
    // Set I2C address
    hdmi_write32(port, HDMI_DDC_CTL, (addr << 8) | 0x01)
    // Write data
    hdmi_write32(port, HDMI_DDC_DATA, data)
    // Wait for completion
    foundation.delay_us(50)
}

// DDC byte read
fn hdmi_ddc_read_byte(port: u32, addr: u8): u8 {
    // Set read mode
    hdmi_write32(port, HDMI_DDC_CTL, (addr << 8) | 0x03)
    foundation.delay_us(50)

    // Read data
    var data: u32 = hdmi_read32(port, HDMI_DDC_DATA)
    return data & 0xFF
}

// Parse EDID data
fn hdmi_parse_edid(port: u32) {
    if port >= 2 { return }
    if hdmi_ctrl.ports[port].edid.blocks[0].valid == 0 { return }

    var raw: *u8 = &hdmi_ctrl.ports[port].edid.blocks[0].raw[0]

    // Verify EDID header (bytes 0-7 should be 00 FF FF FF FF FF FF 00)
    if raw[0] != 0x00 or raw[7] != 0x00 {
        foundation.serial_write_string("[HDMI] Invalid EDID header\n")
        return
    }

    // Extract manufacturer ID (bytes 8-9, compressed ASCII)
    var mfg: u16 = (raw[8] << 8) | raw[9]
    hdmi_ctrl.ports[port].edid.manufacturer[0] = ((mfg >> 10) & 0x1F) + 'A' - 1
    hdmi_ctrl.ports[port].edid.manufacturer[1] = ((mfg >> 5) & 0x1F) + 'A' - 1
    hdmi_ctrl.ports[port].edid.manufacturer[2] = (mfg & 0x1F) + 'A' - 1
    hdmi_ctrl.ports[port].edid.manufacturer[3] = 0

    // Product code (bytes 10-11)
    hdmi_ctrl.ports[port].edid.product_code = raw[10] | (raw[11] << 8)

    // Serial number (bytes 12-15)
    hdmi_ctrl.ports[port].edid.serial_number = raw[12] | (raw[13] << 8) |
                                                (raw[14] << 16) | (raw[15] << 24)

    // Parse detailed timing descriptors (bytes 54-125)
    var desc_offset: u32 = 54
    var first_timing: u32 = 1

    while desc_offset < 126 {
        var pixel_clock: u16 = raw[desc_offset] | (raw[desc_offset + 1] << 8)

        if pixel_clock != 0 {
            // This is a detailed timing descriptor
            var h_active: u32 = raw[desc_offset + 2] | ((raw[desc_offset + 4] & 0xF0) << 4)
            var v_active: u32 = raw[desc_offset + 5] | ((raw[desc_offset + 7] & 0xF0) << 4)

            if first_timing == 1 {
                hdmi_ctrl.ports[port].edid.preferred_width = h_active
                hdmi_ctrl.ports[port].edid.preferred_height = v_active
                // Calculate approximate refresh rate
                var total_h: u32 = h_active + (raw[desc_offset + 3] | ((raw[desc_offset + 4] & 0x0F) << 8))
                var total_v: u32 = v_active + (raw[desc_offset + 6] | ((raw[desc_offset + 7] & 0x0F) << 8))
                var clock_khz: u32 = pixel_clock * 10
                if total_h > 0 and total_v > 0 {
                    hdmi_ctrl.ports[port].edid.preferred_refresh =
                        (clock_khz * 1000) / (total_h * total_v)
                }
                first_timing = 0
            }

            if h_active > hdmi_ctrl.ports[port].edid.max_width {
                hdmi_ctrl.ports[port].edid.max_width = h_active
            }
            if v_active > hdmi_ctrl.ports[port].edid.max_height {
                hdmi_ctrl.ports[port].edid.max_height = v_active
            }
        }

        desc_offset = desc_offset + 18
    }

    // Check for 4K@60 support (if max resolution is 3840x2160)
    if hdmi_ctrl.ports[port].edid.max_width >= 3840 and
       hdmi_ctrl.ports[port].edid.max_height >= 2160 {
        hdmi_ctrl.ports[port].edid.supports_4k60 = 1
    }

    // Parse extension blocks for HDMI 2.0/2.1 and HDR support
    if hdmi_ctrl.ports[port].edid.block_count > 1 {
        hdmi_parse_cea_extension(port)
    }

    // Log detected display
    foundation.serial_write_string("[HDMI] Display: ")
    foundation.serial_write_string(&hdmi_ctrl.ports[port].edid.manufacturer[0])
    foundation.serial_write_string(" - ")
    foundation.serial_write_u64(hdmi_ctrl.ports[port].edid.preferred_width)
    foundation.serial_write_string("x")
    foundation.serial_write_u64(hdmi_ctrl.ports[port].edid.preferred_height)
    foundation.serial_write_string("@")
    foundation.serial_write_u64(hdmi_ctrl.ports[port].edid.preferred_refresh)
    foundation.serial_write_string("Hz\n")
}

// Parse CEA extension block for HDMI capabilities
fn hdmi_parse_cea_extension(port: u32) {
    if port >= 2 { return }
    if hdmi_ctrl.ports[port].edid.block_count < 2 { return }

    var raw: *u8 = &hdmi_ctrl.ports[port].edid.blocks[1].raw[0]

    // Check for CEA extension tag (0x02)
    if raw[0] != 0x02 { return }

    // Parse data blocks
    var dtd_offset: u32 = raw[2]
    var offset: u32 = 4

    while offset < dtd_offset {
        var tag: u32 = (raw[offset] >> 5) & 0x07
        var len: u32 = raw[offset] & 0x1F
        offset = offset + 1

        if tag == 1 {
            // Audio data block
            hdmi_ctrl.ports[port].edid.supports_audio = 1
        } else if tag == 3 {
            // Vendor-specific data block
            // Check for HDMI LLC OUI (0x000C03)
            if len >= 3 {
                if raw[offset] == 0x03 and raw[offset + 1] == 0x0C and raw[offset + 2] == 0x00 {
                    hdmi_ctrl.ports[port].edid.hdmi_version = 1  // HDMI 1.4
                }
            }
            // Check for HDMI Forum OUI (0xC45DD8) for HDMI 2.0+
            if len >= 3 {
                if raw[offset] == 0xD8 and raw[offset + 1] == 0x5D and raw[offset + 2] == 0xC4 {
                    hdmi_ctrl.ports[port].edid.hdmi_version = 2  // HDMI 2.0
                }
            }
        } else if tag == 7 {
            // Extended tag
            var ext_tag: u32 = raw[offset]
            if ext_tag == 0x06 {
                // HDR static metadata
                hdmi_ctrl.ports[port].edid.supports_hdr = 1
            }
        }

        offset = offset + len
    }
}

// Set video mode on HDMI port
export fn hdmi_set_mode(port: u32, mode: u32): u32 {
    if port >= 2 { return 1 }
    if hdmi_ctrl.initialized == 0 { return 1 }
    if hdmi_ctrl.ports[port].connected == 0 { return 1 }

    foundation.serial_write_string("[HDMI] Setting mode ")
    foundation.serial_write_u64(mode)
    foundation.serial_write_string(" on port ")
    foundation.serial_write_u64(port)
    foundation.serial_write_string("\n")

    var timing: VideoTiming

    if mode == HDMI_MODE_480P {
        timing = TIMING_480P
    } else if mode == HDMI_MODE_720P {
        timing = TIMING_720P
    } else if mode == HDMI_MODE_1080P {
        timing = TIMING_1080P
    } else if mode == HDMI_MODE_4K30 {
        timing = TIMING_4K30
    } else if mode == HDMI_MODE_4K60 {
        timing = TIMING_4K60
    } else {
        foundation.serial_write_string("[HDMI] Invalid mode\n")
        return 1
    }

    // Configure PLL for pixel clock
    var result: u32 = hdmi_configure_pll(port, timing.pixel_clock)
    if result != 0 {
        foundation.serial_write_string("[HDMI] PLL configuration failed\n")
        return 1
    }

    // Configure video timing
    hdmi_configure_timing(port, &timing)

    // Enable scrambling for 4K@60 (requires >340 MHz)
    if timing.pixel_clock > 340000 {
        hdmi_enable_scrambling(port)
    }

    // Configure color settings
    hdmi_write32(port, HDMI_DEEP_COLOR, HDMI_COLOR_8BIT)
    hdmi_write32(port, HDMI_GCP_CONFIG, HDMI_COLOR_RGB)

    // Enable video output
    hdmi_write32(port, HDMI_VIDEO_CTL, 0x01)

    // Update port state
    hdmi_ctrl.ports[port].enabled = 1
    hdmi_ctrl.ports[port].current_mode = mode
    hdmi_ctrl.ports[port].width = timing.width
    hdmi_ctrl.ports[port].height = timing.height
    hdmi_ctrl.ports[port].refresh_rate = timing.refresh_rate

    hdmi_mode_changes = hdmi_mode_changes + 1

    foundation.serial_write_string("[HDMI] Mode set: ")
    foundation.serial_write_u64(timing.width)
    foundation.serial_write_string("x")
    foundation.serial_write_u64(timing.height)
    foundation.serial_write_string("@")
    foundation.serial_write_u64(timing.refresh_rate)
    foundation.serial_write_string("Hz\n")

    return 0
}

// Set custom video mode with specific timing
export fn hdmi_set_custom_mode(port: u32, timing: *VideoTiming): u32 {
    if port >= 2 { return 1 }
    if hdmi_ctrl.initialized == 0 { return 1 }
    if hdmi_ctrl.ports[port].connected == 0 { return 1 }

    foundation.serial_write_string("[HDMI] Setting custom mode on port ")
    foundation.serial_write_u64(port)
    foundation.serial_write_string("\n")

    // Configure PLL
    var result: u32 = hdmi_configure_pll(port, timing.pixel_clock)
    if result != 0 { return 1 }

    // Configure timing
    hdmi_configure_timing(port, timing)

    // Enable scrambling if needed
    if timing.pixel_clock > 340000 {
        hdmi_enable_scrambling(port)
    }

    // Enable video output
    hdmi_write32(port, HDMI_VIDEO_CTL, 0x01)

    // Update state
    hdmi_ctrl.ports[port].enabled = 1
    hdmi_ctrl.ports[port].width = timing.width
    hdmi_ctrl.ports[port].height = timing.height
    hdmi_ctrl.ports[port].refresh_rate = timing.refresh_rate

    return 0
}

// Configure PLL for desired pixel clock
fn hdmi_configure_pll(port: u32, pixel_clock_khz: u32): u32 {
    if port >= 2 { return 1 }

    foundation.serial_write_string("[HDMI] Configuring PLL for ")
    foundation.serial_write_u64(pixel_clock_khz)
    foundation.serial_write_string(" kHz\n")

    // Calculate PLL dividers
    // Reference clock is typically 27 MHz on Pi 5
    var ref_clock: u32 = 27000  // 27 MHz in kHz

    // Simple PLL calculation (real implementation would be more complex)
    var mult: u32 = pixel_clock_khz / ref_clock
    var frac: u32 = ((pixel_clock_khz % ref_clock) * 256) / ref_clock

    // Program PLL
    hdmi_write32(port, HDMI_PLL_CTL, (mult << 16) | (frac << 8) | 0x01)

    // Wait for PLL lock
    var timeout: u32 = 1000
    while timeout > 0 {
        var status: u32 = hdmi_read32(port, HDMI_PLL_STATUS)
        if (status & 0x01) == 0x01 {
            return 0
        }
        foundation.delay_us(10)
        timeout = timeout - 1
    }

    foundation.serial_write_string("[HDMI] PLL lock timeout\n")
    return 1
}

// Configure video timing registers
fn hdmi_configure_timing(port: u32, timing: *VideoTiming) {
    if port >= 2 { return }

    var h_total: u32 = timing.width + timing.h_front_porch +
                       timing.h_sync_width + timing.h_back_porch
    var v_total: u32 = timing.height + timing.v_front_porch +
                       timing.v_sync_width + timing.v_back_porch

    // Horizontal timing
    hdmi_write32(port, HDMI_TIMING_H, (timing.width << 16) | h_total)
    hdmi_write32(port, HDMI_TIMING_HSYNC,
                 (timing.h_sync_polarity << 31) |
                 ((timing.h_front_porch + timing.width) << 16) |
                 (timing.h_front_porch + timing.width + timing.h_sync_width))

    // Vertical timing
    hdmi_write32(port, HDMI_TIMING_V, (timing.height << 16) | v_total)
    hdmi_write32(port, HDMI_TIMING_VSYNC,
                 (timing.v_sync_polarity << 31) |
                 ((timing.v_front_porch + timing.height) << 16) |
                 (timing.v_front_porch + timing.height + timing.v_sync_width))
}

// Enable HDMI 2.0 scrambling for high bandwidth modes
fn hdmi_enable_scrambling(port: u32) {
    if port >= 2 { return }

    foundation.serial_write_string("[HDMI] Enabling scrambling for high-bandwidth mode\n")

    // Enable scrambler
    hdmi_write32(port, HDMI_SCRAMBLER_CTL, 0x01)

    // Enable SCDC (Status and Control Data Channel)
    hdmi_write32(port, HDMI_SCDC_CTL, 0x01)

    hdmi_ctrl.ports[port].scrambling_enabled = 1
}

// Set framebuffer address for HDMI output
export fn hdmi_set_framebuffer(port: u32, addr: u64, size: u64): u32 {
    if port >= 2 { return 1 }
    if hdmi_ctrl.initialized == 0 { return 1 }

    hdmi_ctrl.ports[port].framebuffer_addr = addr
    hdmi_ctrl.ports[port].framebuffer_size = size

    // Configure frame control register with framebuffer address
    hdmi_write32(port, HDMI_FRAME_CTL, addr & 0xFFFFFFFF)

    foundation.serial_write_string("[HDMI] Framebuffer set at 0x")
    foundation.serial_write_u64(addr)
    foundation.serial_write_string("\n")

    return 0
}

// Audio sample formats
const AUDIO_FORMAT_PCM: u32 = 0
const AUDIO_FORMAT_AC3: u32 = 1
const AUDIO_FORMAT_DTS: u32 = 2
const AUDIO_FORMAT_AAC: u32 = 3

// Audio channel configurations
const AUDIO_2CH: u32 = 2
const AUDIO_6CH: u32 = 6   // 5.1
const AUDIO_8CH: u32 = 8   // 7.1

// Audio state per port
struct AudioState {
    enabled: u32
    sample_rate: u32
    channels: u32
    format: u32
    bit_depth: u32
    buffer_addr: u64
    buffer_size: u64
    write_pos: u64
    playing: u32
}

var audio_state: [2]AudioState

// Enable/disable audio on HDMI port
export fn hdmi_set_audio(port: u32, enabled: u32, sample_rate: u32): u32 {
    if port >= 2 { return 1 }
    if hdmi_ctrl.initialized == 0 { return 1 }
    if hdmi_ctrl.ports[port].edid.supports_audio == 0 { return 1 }

    if enabled == 1 {
        foundation.serial_write_string("[HDMI] Enabling audio at ")
        foundation.serial_write_u64(sample_rate)
        foundation.serial_write_string(" Hz\n")

        // Configure ACR (Audio Clock Regeneration)
        // N value calculation based on sample rate and pixel clock
        var n_value: u32 = 6144  // Default for 48kHz
        if sample_rate == 44100 {
            n_value = 6272
        } else if sample_rate == 32000 {
            n_value = 4096
        } else if sample_rate == 96000 {
            n_value = 12288
        } else if sample_rate == 192000 {
            n_value = 24576
        }

        hdmi_write32(port, HDMI_ACR_N, n_value)
        hdmi_write32(port, HDMI_ACR_CTL, 0x01)

        // Enable audio
        hdmi_write32(port, HDMI_AUDIO_CTL, 0x01)

        // Send audio InfoFrame
        hdmi_send_audio_infoframe(port, AUDIO_2CH, sample_rate)

        hdmi_ctrl.ports[port].audio_enabled = 1
        audio_state[port].enabled = 1
        audio_state[port].sample_rate = sample_rate
        audio_state[port].channels = 2
        audio_state[port].format = AUDIO_FORMAT_PCM
        audio_state[port].bit_depth = 16
    } else {
        hdmi_write32(port, HDMI_AUDIO_CTL, 0x00)
        hdmi_ctrl.ports[port].audio_enabled = 0
        audio_state[port].enabled = 0
        audio_state[port].playing = 0
    }

    return 0
}

// Configure audio with full parameters
export fn hdmi_configure_audio(port: u32, channels: u32, sample_rate: u32, bit_depth: u32): u32 {
    if port >= 2 { return 1 }
    if hdmi_ctrl.initialized == 0 { return 1 }
    if hdmi_ctrl.ports[port].edid.supports_audio == 0 { return 1 }

    foundation.serial_write_string("[HDMI] Configuring audio: ")
    foundation.serial_write_u64(channels)
    foundation.serial_write_string("ch, ")
    foundation.serial_write_u64(sample_rate)
    foundation.serial_write_string("Hz, ")
    foundation.serial_write_u64(bit_depth)
    foundation.serial_write_string("-bit\n")

    // Calculate N value for ACR
    var n_value: u32 = 6144
    if sample_rate == 32000 {
        n_value = 4096
    } else if sample_rate == 44100 {
        n_value = 6272
    } else if sample_rate == 48000 {
        n_value = 6144
    } else if sample_rate == 88200 {
        n_value = 12544
    } else if sample_rate == 96000 {
        n_value = 12288
    } else if sample_rate == 176400 {
        n_value = 25088
    } else if sample_rate == 192000 {
        n_value = 24576
    }

    // Configure ACR
    hdmi_write32(port, HDMI_ACR_N, n_value)
    hdmi_write32(port, HDMI_ACR_CTL, 0x01)

    // Configure audio packet
    var audio_cfg: u32 = 0
    audio_cfg = audio_cfg | (channels - 1)  // Channel count - 1
    if bit_depth == 24 {
        audio_cfg = audio_cfg | (0x0B << 4)  // 24-bit
    } else if bit_depth == 20 {
        audio_cfg = audio_cfg | (0x0A << 4)  // 20-bit
    } else {
        audio_cfg = audio_cfg | (0x02 << 4)  // 16-bit
    }
    hdmi_write32(port, HDMI_AUDIO_PACKET, audio_cfg)

    // Send audio InfoFrame
    hdmi_send_audio_infoframe(port, channels, sample_rate)

    // Enable audio
    hdmi_write32(port, HDMI_AUDIO_CTL, 0x01)

    audio_state[port].enabled = 1
    audio_state[port].sample_rate = sample_rate
    audio_state[port].channels = channels
    audio_state[port].bit_depth = bit_depth
    audio_state[port].format = AUDIO_FORMAT_PCM
    hdmi_ctrl.ports[port].audio_enabled = 1

    return 0
}

// Send Audio InfoFrame
fn hdmi_send_audio_infoframe(port: u32, channels: u32, sample_rate: u32) {
    if port >= 2 { return }

    // Audio InfoFrame structure
    // Type: 0x84, Version: 0x01, Length: 0x0A
    var header: u32 = 0x0A0184

    // CC (channel count - 1) in bits 0-2
    // CT (coding type) in bits 4-7 (0 = refer to stream header)
    var data1: u32 = (channels - 1) & 0x07

    // SS (sample size) and SF (sample frequency) - refer to stream header
    var data2: u32 = 0

    // CA (channel allocation) based on channel count
    var ca: u32 = 0
    if channels == 2 {
        ca = 0x00  // Stereo
    } else if channels == 6 {
        ca = 0x0B  // 5.1
    } else if channels == 8 {
        ca = 0x13  // 7.1
    }
    var data3: u32 = ca

    hdmi_write32(port, HDMI_AUDIO_INFOFRAME, header)
    hdmi_write32(port, HDMI_AUDIO_INFOFRAME + 4, data1)
    hdmi_write32(port, HDMI_AUDIO_INFOFRAME + 8, data2)
    hdmi_write32(port, HDMI_AUDIO_INFOFRAME + 12, data3)

    // Enable Audio InfoFrame transmission
    var ctl: u32 = hdmi_read32(port, HDMI_INFOFRAME_CTL)
    hdmi_write32(port, HDMI_INFOFRAME_CTL, ctl | 0x04)  // Bit 2 = audio infoframe
}

// Set audio volume (0-100)
export fn hdmi_set_audio_volume(port: u32, volume: u32): u32 {
    if port >= 2 { return 1 }
    if audio_state[port].enabled == 0 { return 1 }

    // HDMI doesn't have hardware volume - this would be handled by
    // software mixing before sending to HDMI
    // For now, just log the volume change
    foundation.serial_write_string("[HDMI] Audio volume: ")
    foundation.serial_write_u64(volume)
    foundation.serial_write_string("%\n")

    return 0
}

// Mute/unmute audio
export fn hdmi_set_audio_mute(port: u32, muted: u32): u32 {
    if port >= 2 { return 1 }
    if audio_state[port].enabled == 0 { return 1 }

    if muted == 1 {
        // Set audio mute via GCP (General Control Packet)
        var gcp: u32 = hdmi_read32(port, HDMI_GCP_WORD1)
        hdmi_write32(port, HDMI_GCP_WORD1, gcp | 0x01)  // Set mute bit
        foundation.serial_write_string("[HDMI] Audio muted\n")
    } else {
        var gcp: u32 = hdmi_read32(port, HDMI_GCP_WORD1)
        hdmi_write32(port, HDMI_GCP_WORD1, gcp & ~0x01)  // Clear mute bit
        foundation.serial_write_string("[HDMI] Audio unmuted\n")
    }

    return 0
}

// Get audio capabilities
export fn hdmi_get_audio_channels(port: u32): u32 {
    if port >= 2 { return 0 }
    return hdmi_ctrl.ports[port].edid.max_audio_channels
}

// Send AVI InfoFrame (required for proper display detection)
fn hdmi_send_avi_infoframe(port: u32) {
    if port >= 2 { return }

    // AVI InfoFrame structure
    // Type: 0x82, Version: 0x02, Length: 0x0D
    var header: u32 = 0x0D0282

    // Data bytes based on current mode
    var format: u32 = 0  // RGB
    var colorimetry: u32 = 0  // Default
    var picture_aspect: u32 = 2  // 16:9
    var active_aspect: u32 = 8  // Same as picture

    var data1: u32 = format | (active_aspect << 8) | (picture_aspect << 12)
    var data2: u32 = colorimetry

    hdmi_write32(port, HDMI_AVI_INFOFRAME, header)
    hdmi_write32(port, HDMI_AVI_INFOFRAME + 4, data1)
    hdmi_write32(port, HDMI_AVI_INFOFRAME + 8, data2)

    // Enable AVI InfoFrame transmission
    var ctl: u32 = hdmi_read32(port, HDMI_INFOFRAME_CTL)
    hdmi_write32(port, HDMI_INFOFRAME_CTL, ctl | 0x01)
}

// Hotplug interrupt handler
export fn hdmi_hotplug_handler(port: u32) {
    if port >= 2 { return }

    var connected: u32 = hdmi_check_hotplug(port)

    if connected != hdmi_ctrl.ports[port].connected {
        hdmi_hotplug_events = hdmi_hotplug_events + 1

        if connected == 1 {
            foundation.serial_write_string("[HDMI] Display connected on port ")
            foundation.serial_write_u64(port)
            foundation.serial_write_string("\n")

            // Read EDID
            hdmi_read_edid(port)

            // Set preferred mode if available
            if hdmi_ctrl.ports[port].edid.supports_4k60 == 1 {
                hdmi_set_mode(port, HDMI_MODE_4K60)
            } else if hdmi_ctrl.ports[port].edid.preferred_width >= 1920 {
                hdmi_set_mode(port, HDMI_MODE_1080P)
            } else {
                hdmi_set_mode(port, HDMI_MODE_720P)
            }
        } else {
            foundation.serial_write_string("[HDMI] Display disconnected from port ")
            foundation.serial_write_u64(port)
            foundation.serial_write_string("\n")

            // Disable output
            hdmi_write32(port, HDMI_VIDEO_CTL, 0x00)
            hdmi_ctrl.ports[port].enabled = 0
        }

        hdmi_ctrl.ports[port].connected = connected
    }

    // Clear interrupt
    hdmi_write32(port, HDMI_HOTPLUG_INT, 0x01)
}

// Get port info
export fn hdmi_get_width(port: u32): u32 {
    if port >= 2 { return 0 }
    return hdmi_ctrl.ports[port].width
}

export fn hdmi_get_height(port: u32): u32 {
    if port >= 2 { return 0 }
    return hdmi_ctrl.ports[port].height
}

export fn hdmi_get_refresh(port: u32): u32 {
    if port >= 2 { return 0 }
    return hdmi_ctrl.ports[port].refresh_rate
}

export fn hdmi_is_connected(port: u32): u32 {
    if port >= 2 { return 0 }
    return hdmi_ctrl.ports[port].connected
}

export fn hdmi_is_enabled(port: u32): u32 {
    if port >= 2 { return 0 }
    return hdmi_ctrl.ports[port].enabled
}

export fn hdmi_supports_4k60(port: u32): u32 {
    if port >= 2 { return 0 }
    return hdmi_ctrl.ports[port].edid.supports_4k60
}

export fn hdmi_supports_hdr(port: u32): u32 {
    if port >= 2 { return 0 }
    return hdmi_ctrl.ports[port].edid.supports_hdr
}

// Print HDMI statistics
export fn hdmi_print_stats() {
    foundation.serial_write_string("\n[HDMI] Statistics:\n")

    foundation.serial_write_string("  Mode changes: ")
    foundation.serial_write_u64(hdmi_mode_changes)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  EDID reads: ")
    foundation.serial_write_u64(hdmi_edid_reads)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  Hotplug events: ")
    foundation.serial_write_u64(hdmi_hotplug_events)
    foundation.serial_write_string("\n")

    var i: u32 = 0
    while i < 2 {
        foundation.serial_write_string("  Port ")
        foundation.serial_write_u64(i)
        foundation.serial_write_string(": ")

        if hdmi_ctrl.ports[i].connected == 1 {
            foundation.serial_write_u64(hdmi_ctrl.ports[i].width)
            foundation.serial_write_string("x")
            foundation.serial_write_u64(hdmi_ctrl.ports[i].height)
            foundation.serial_write_string("@")
            foundation.serial_write_u64(hdmi_ctrl.ports[i].refresh_rate)
            foundation.serial_write_string("Hz")
            if hdmi_ctrl.ports[i].edid.supports_4k60 == 1 {
                foundation.serial_write_string(" (4K60)")
            }
            if hdmi_ctrl.ports[i].edid.supports_hdr == 1 {
                foundation.serial_write_string(" (HDR)")
            }
        } else {
            foundation.serial_write_string("disconnected")
        }
        foundation.serial_write_string("\n")

        i = i + 1
    }
}

// LG 27UP850-W specific initialization
// This monitor supports 3840x2160@60Hz via HDMI 2.0
export fn hdmi_init_lg_27up850w(port: u32): u32 {
    if port >= 2 { return 1 }
    if hdmi_ctrl.initialized == 0 { return 1 }

    foundation.serial_write_string("[HDMI] Initializing for LG 27UP850-W monitor\n")

    // Read EDID to confirm monitor
    if hdmi_ctrl.ports[port].connected == 0 {
        foundation.serial_write_string("[HDMI] No display connected\n")
        return 1
    }

    // Check manufacturer code for LG (GSM = GoldStar Manufacturing = LG)
    var mfg: *u8 = &hdmi_ctrl.ports[port].edid.manufacturer[0]
    if mfg[0] != 'G' or mfg[1] != 'S' or mfg[2] != 'M' {
        foundation.serial_write_string("[HDMI] Warning: Connected display is not LG\n")
    }

    // Set 4K@60Hz mode
    var result: u32 = hdmi_set_mode(port, HDMI_MODE_4K60)
    if result != 0 {
        foundation.serial_write_string("[HDMI] Failed to set 4K60 mode, trying 4K30\n")
        result = hdmi_set_mode(port, HDMI_MODE_4K30)
    }

    if result != 0 {
        foundation.serial_write_string("[HDMI] Failed to set 4K mode\n")
        return 1
    }

    // Configure 8-bit RGB color
    hdmi_write32(port, HDMI_DEEP_COLOR, HDMI_COLOR_8BIT)
    hdmi_write32(port, HDMI_GCP_CONFIG, HDMI_COLOR_RGB)

    // Send AVI InfoFrame
    hdmi_send_avi_infoframe(port)

    foundation.serial_write_string("[HDMI] LG 27UP850-W initialized successfully\n")
    return 0
}
