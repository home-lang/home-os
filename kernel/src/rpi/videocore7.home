// home-os VideoCore VII GPU Driver
// Raspberry Pi 5 BCM2712 Graphics Processor
// Supports Vulkan 1.3, OpenGL ES 3.1, 2x 4K@60Hz HDMI

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "./mailbox_vc7.home" as mailbox
import "./rp1_hdmi.home" as hdmi
import "../drivers/framebuffer.home" as framebuffer

// VideoCore VII base addresses
const VC7_BASE: u64 = 0x1000800000
const VC7_HVS_BASE: u64 = VC7_BASE + 0x00200000   // Hardware Video Scaler
const VC7_V3D_BASE: u64 = VC7_BASE + 0x00400000   // 3D engine
const VC7_VEC_BASE: u64 = VC7_BASE + 0x00600000   // Video encoder
const VC7_HDMI_BASE: u64 = VC7_BASE + 0x00800000  // HDMI encoder
const VC7_PIXELVALVE0: u64 = VC7_BASE + 0x00206000
const VC7_PIXELVALVE1: u64 = VC7_BASE + 0x00207000
const VC7_PIXELVALVE2: u64 = VC7_BASE + 0x0020A000

// V3D (3D Engine) registers
const V3D_IDENT0: u64 = 0x000
const V3D_IDENT1: u64 = 0x004
const V3D_IDENT2: u64 = 0x008
const V3D_SCRATCH: u64 = 0x010
const V3D_L2CACTL: u64 = 0x020
const V3D_SLCACTL: u64 = 0x024
const V3D_INTCTL: u64 = 0x030
const V3D_INTENA: u64 = 0x034
const V3D_INTDIS: u64 = 0x038
const V3D_CT0CS: u64 = 0x100  // Control list executor 0 control
const V3D_CT0EA: u64 = 0x104  // Control list executor 0 end address
const V3D_CT0CA: u64 = 0x108  // Control list executor 0 current address
const V3D_CT1CS: u64 = 0x110  // Control list executor 1 control
const V3D_CT1EA: u64 = 0x114
const V3D_CT1CA: u64 = 0x118
const V3D_BFC: u64 = 0x134    // Binning flush count
const V3D_RFC: u64 = 0x138    // Rendering flush count
const V3D_BPCA: u64 = 0x300   // Current address of binning pool
const V3D_BPCS: u64 = 0x304   // Size of binning pool
const V3D_BPOA: u64 = 0x308   // Address of overspill binning pool
const V3D_BPOS: u64 = 0x30C   // Size of overspill binning pool

// HVS (Hardware Video Scaler) registers
const HVS_DISPCTRL: u64 = 0x000
const HVS_DISPSTAT: u64 = 0x004
const HVS_DISPID: u64 = 0x008
const HVS_DISPECTRL: u64 = 0x00C
const HVS_DISPPROF: u64 = 0x010
const HVS_DISPDITHER: u64 = 0x014
const HVS_DISPEOLN: u64 = 0x018
const HVS_DISPLIST0: u64 = 0x020
const HVS_DISPLIST1: u64 = 0x024
const HVS_DISPLIST2: u64 = 0x028
const HVS_DISPLSTAT: u64 = 0x02C
const HVS_DISPLACT: u64 = 0x030
const HVS_DISPCTRL0: u64 = 0x040
const HVS_DISPBKGND0: u64 = 0x044
const HVS_DISPSTAT0: u64 = 0x048
const HVS_DISPCTRL1: u64 = 0x050
const HVS_DISPBKGND1: u64 = 0x054
const HVS_DISPSTAT1: u64 = 0x058
const HVS_DISPCTRL2: u64 = 0x060
const HVS_DISPBKGND2: u64 = 0x064
const HVS_DISPSTAT2: u64 = 0x068

// PixelValve registers
const PV_CONTROL: u64 = 0x000
const PV_V_CONTROL: u64 = 0x004
const PV_VSYNCD_EVEN: u64 = 0x008
const PV_HORZA: u64 = 0x00C
const PV_HORZB: u64 = 0x010
const PV_VERTA: u64 = 0x014
const PV_VERTB: u64 = 0x018
const PV_VERTA_EVEN: u64 = 0x01C
const PV_VERTB_EVEN: u64 = 0x020
const PV_INTEN: u64 = 0x024
const PV_INTSTAT: u64 = 0x028
const PV_STAT: u64 = 0x02C
const PV_HACT_ACT: u64 = 0x030

// Display list entry types
const DLIST_CTRL_END: u32 = 0x80000000
const DLIST_CTRL_VALID: u32 = 0x40000000
const DLIST_CTRL_WORDS_MASK: u32 = 0x3F000000
const DLIST_CTRL_UNITY: u32 = 0x00008000
const DLIST_CTRL_ALPHA_MASK: u32 = 0x0000F800

// Pixel formats for display
const PIXEL_FORMAT_RGB565: u32 = 0
const PIXEL_FORMAT_RGB888: u32 = 1
const PIXEL_FORMAT_XRGB8888: u32 = 2
const PIXEL_FORMAT_ARGB8888: u32 = 3
const PIXEL_FORMAT_RGBA8888: u32 = 4

// GPU memory allocation
struct GpuMemBlock {
    handle: u32
    bus_address: u64
    virt_address: u64
    size: u64
    flags: u32
}

// Display configuration
struct DisplayConfig {
    width: u32
    height: u32
    refresh: u32
    format: u32
    hvs_channel: u32
    pixelvalve_id: u32
    hdmi_port: u32
}

// V3D state
struct V3dState {
    initialized: u32
    ident0: u32
    ident1: u32
    ident2: u32
    num_slices: u32
    num_qpus: u32
    vpm_size: u32
    binning_pool: GpuMemBlock
    render_pool: GpuMemBlock
}

// VideoCore VII controller state
struct VC7Controller {
    initialized: u32
    v3d: V3dState
    displays: [3]DisplayConfig     // Up to 3 display outputs
    active_displays: u32
    framebuffer_addr: u64
    framebuffer_size: u64
    primary_width: u32
    primary_height: u32
    primary_bpp: u32
}

var vc7: VC7Controller

// VSync state
struct VSyncState {
    enabled: u32
    frame_count: u64
    last_vblank_time: u64
    waiting: u32
}

var vsync: VSyncState

// Hardware cursor state
struct HwCursor {
    enabled: u32
    x: u32
    y: u32
    width: u32
    height: u32
    hotspot_x: u32
    hotspot_y: u32
    buffer_addr: u64
    visible: u32
}

var hw_cursor: HwCursor

// DPMS power states
const DPMS_ON: u32 = 0
const DPMS_STANDBY: u32 = 1
const DPMS_SUSPEND: u32 = 2
const DPMS_OFF: u32 = 3

var current_dpms_state: u32 = DPMS_ON

// Statistics
var frames_rendered: u64 = 0
var v3d_jobs: u64 = 0
var display_updates: u64 = 0
var vsync_waits: u64 = 0
var missed_vsyncs: u64 = 0

// Read V3D register
fn v3d_read(offset: u64): u32 {
    return memory.read_volatile_u32(VC7_V3D_BASE + offset)
}

// Write V3D register
fn v3d_write(offset: u64, value: u32) {
    memory.write_volatile_u32(VC7_V3D_BASE + offset, value)
}

// Read HVS register
fn hvs_read(offset: u64): u32 {
    return memory.read_volatile_u32(VC7_HVS_BASE + offset)
}

// Write HVS register
fn hvs_write(offset: u64, value: u32) {
    memory.write_volatile_u32(VC7_HVS_BASE + offset, value)
}

// Read PixelValve register
fn pv_read(pv_id: u32, offset: u64): u32 {
    var base: u64 = VC7_PIXELVALVE0
    if pv_id == 1 { base = VC7_PIXELVALVE1 }
    if pv_id == 2 { base = VC7_PIXELVALVE2 }
    return memory.read_volatile_u32(base + offset)
}

// Write PixelValve register
fn pv_write(pv_id: u32, offset: u64, value: u32) {
    var base: u64 = VC7_PIXELVALVE0
    if pv_id == 1 { base = VC7_PIXELVALVE1 }
    if pv_id == 2 { base = VC7_PIXELVALVE2 }
    memory.write_volatile_u32(base + offset, value)
}

// Initialize VideoCore VII
export fn vc7_init(): u32 {
    if vc7.initialized == 1 {
        foundation.serial_write_string("[VC7] Already initialized\n")
        return 0
    }

    foundation.serial_write_string("[VC7] Initializing VideoCore VII GPU\n")

    // Initialize V3D (3D engine)
    var result: u32 = vc7_v3d_init()
    if result != 0 {
        foundation.serial_write_string("[VC7] V3D initialization failed\n")
        return 1
    }

    // Initialize HVS (display scaler)
    result = vc7_hvs_init()
    if result != 0 {
        foundation.serial_write_string("[VC7] HVS initialization failed\n")
        return 1
    }

    vc7.initialized = 1
    vc7.active_displays = 0

    foundation.serial_write_string("[VC7] VideoCore VII initialized successfully\n")
    return 0
}

// Initialize V3D (3D engine)
fn vc7_v3d_init(): u32 {
    foundation.serial_write_string("[VC7] Initializing V3D 3D engine\n")

    // Read identity registers
    vc7.v3d.ident0 = v3d_read(V3D_IDENT0)
    vc7.v3d.ident1 = v3d_read(V3D_IDENT1)
    vc7.v3d.ident2 = v3d_read(V3D_IDENT2)

    // Parse capabilities from ident registers
    // IDENT1: bits 0-3 = VPM size, bits 4-7 = HDR support, bits 8-11 = NSEM
    vc7.v3d.vpm_size = (vc7.v3d.ident1 & 0xF) * 4  // VPM size in KB

    // IDENT2: bits 0-3 = slice count - 1
    vc7.v3d.num_slices = (vc7.v3d.ident2 & 0xF) + 1

    // Each slice has 4 QPUs in VC7
    vc7.v3d.num_qpus = vc7.v3d.num_slices * 4

    foundation.serial_write_string("[VC7] V3D: ")
    foundation.serial_write_u64(vc7.v3d.num_slices)
    foundation.serial_write_string(" slices, ")
    foundation.serial_write_u64(vc7.v3d.num_qpus)
    foundation.serial_write_string(" QPUs, ")
    foundation.serial_write_u64(vc7.v3d.vpm_size)
    foundation.serial_write_string("KB VPM\n")

    // Disable interrupts initially
    v3d_write(V3D_INTDIS, 0xFFFFFFFF)

    // Clear L2 cache
    v3d_write(V3D_L2CACTL, 0x04)  // Clear entire L2 cache

    // Clear SLC cache
    v3d_write(V3D_SLCACTL, 0x0F0F0F0F)  // Clear all SLC partitions

    vc7.v3d.initialized = 1

    return 0
}

// Initialize HVS (Hardware Video Scaler)
fn vc7_hvs_init(): u32 {
    foundation.serial_write_string("[VC7] Initializing HVS display scaler\n")

    // Read HVS ID
    var hvs_id: u32 = hvs_read(HVS_DISPID)
    foundation.serial_write_string("[VC7] HVS ID: 0x")
    foundation.serial_write_u64(hvs_id)
    foundation.serial_write_string("\n")

    // Reset display control
    hvs_write(HVS_DISPCTRL, 0x00000000)
    foundation.delay_us(100)

    // Enable HVS
    hvs_write(HVS_DISPCTRL, 0x80000000)

    // Initialize display list memory
    // HVS has 4096 words of display list memory

    return 0
}

// Configure display for 4K@60Hz (for LG 27UP850-W)
export fn vc7_setup_4k_display(hdmi_port: u32): u32 {
    if vc7.initialized == 0 { return 1 }
    if hdmi_port >= 2 { return 1 }

    foundation.serial_write_string("[VC7] Setting up 4K@60Hz display on HDMI")
    foundation.serial_write_u64(hdmi_port)
    foundation.serial_write_string("\n")

    // Allocate framebuffer via mailbox
    var fb_addr: u64 = mailbox.mailbox_allocate_framebuffer(3840, 2160, 32)
    if fb_addr == 0 {
        foundation.serial_write_string("[VC7] Failed to allocate 4K framebuffer\n")
        return 1
    }

    foundation.serial_write_string("[VC7] Framebuffer allocated at 0x")
    foundation.serial_write_u64(fb_addr)
    foundation.serial_write_string("\n")

    // Store framebuffer info
    vc7.framebuffer_addr = fb_addr
    vc7.framebuffer_size = 3840 * 2160 * 4  // 32bpp
    vc7.primary_width = 3840
    vc7.primary_height = 2160
    vc7.primary_bpp = 32

    // Initialize framebuffer driver
    framebuffer.fb_init_4k(fb_addr)

    // Configure display pipeline
    vc7.displays[hdmi_port].width = 3840
    vc7.displays[hdmi_port].height = 2160
    vc7.displays[hdmi_port].refresh = 60
    vc7.displays[hdmi_port].format = PIXEL_FORMAT_XRGB8888
    vc7.displays[hdmi_port].hvs_channel = hdmi_port
    vc7.displays[hdmi_port].pixelvalve_id = hdmi_port
    vc7.displays[hdmi_port].hdmi_port = hdmi_port

    // Setup HVS display list for this channel
    vc7_hvs_setup_display_list(hdmi_port, fb_addr, 3840, 2160)

    // Configure PixelValve
    vc7_pv_configure(hdmi_port, 3840, 2160, 60)

    // Initialize HDMI
    hdmi.hdmi_init()
    hdmi.hdmi_set_mode(hdmi_port, 5)  // HDMI_MODE_4K60
    hdmi.hdmi_set_framebuffer(hdmi_port, fb_addr, vc7.framebuffer_size)

    vc7.active_displays = vc7.active_displays | (1 << hdmi_port)

    foundation.serial_write_string("[VC7] 4K display configured successfully\n")
    return 0
}

// Setup HVS display list for a channel
fn vc7_hvs_setup_display_list(channel: u32, fb_addr: u64, width: u32, height: u32) {
    if channel >= 3 { return }

    // Display list base address for this channel
    var dlist_offset: u64 = channel * 1024 * 4  // 1024 words per channel

    // Write display list entries
    var entry_addr: u64 = VC7_HVS_BASE + 0x2000 + dlist_offset  // Display list RAM
    var entry_offset: u32 = 0

    // Entry 0: Control word
    // Format: XRGB8888 (format 3), unity scaling, full alpha
    var ctrl: u32 = DLIST_CTRL_VALID | DLIST_CTRL_UNITY
    ctrl = ctrl | (3 << 0)  // Format: XRGB8888
    ctrl = ctrl | (0x1F << 11)  // Full alpha
    memory.write_volatile_u32(entry_addr + entry_offset, ctrl)
    entry_offset = entry_offset + 4

    // Entry 1: Position (x=0, y=0)
    memory.write_volatile_u32(entry_addr + entry_offset, 0)
    entry_offset = entry_offset + 4

    // Entry 2: Source address
    memory.write_volatile_u32(entry_addr + entry_offset, fb_addr & 0xFFFFFFFF)
    entry_offset = entry_offset + 4

    // Entry 3: Source pitch
    var pitch: u32 = width * 4
    memory.write_volatile_u32(entry_addr + entry_offset, pitch)
    entry_offset = entry_offset + 4

    // Entry 4: Width/Height
    var size: u32 = (width << 16) | height
    memory.write_volatile_u32(entry_addr + entry_offset, size)
    entry_offset = entry_offset + 4

    // Entry 5: End marker
    memory.write_volatile_u32(entry_addr + entry_offset, DLIST_CTRL_END)

    // Set display list pointer for this channel
    if channel == 0 {
        hvs_write(HVS_DISPLIST0, dlist_offset / 4)
    } else if channel == 1 {
        hvs_write(HVS_DISPLIST1, dlist_offset / 4)
    } else {
        hvs_write(HVS_DISPLIST2, dlist_offset / 4)
    }

    // Set background color to black
    if channel == 0 {
        hvs_write(HVS_DISPBKGND0, 0x00000000)
        hvs_write(HVS_DISPCTRL0, 0x80000000)  // Enable channel
    } else if channel == 1 {
        hvs_write(HVS_DISPBKGND1, 0x00000000)
        hvs_write(HVS_DISPCTRL1, 0x80000000)
    } else {
        hvs_write(HVS_DISPBKGND2, 0x00000000)
        hvs_write(HVS_DISPCTRL2, 0x80000000)
    }
}

// Configure PixelValve for display timing
fn vc7_pv_configure(pv_id: u32, width: u32, height: u32, refresh: u32) {
    if pv_id >= 3 { return }

    // Standard 4K@60Hz timing
    var h_active: u32 = width
    var h_fp: u32 = 176
    var h_sync: u32 = 88
    var h_bp: u32 = 296
    var h_total: u32 = h_active + h_fp + h_sync + h_bp

    var v_active: u32 = height
    var v_fp: u32 = 8
    var v_sync: u32 = 10
    var v_bp: u32 = 72
    var v_total: u32 = v_active + v_fp + v_sync + v_bp

    // Disable PixelValve first
    pv_write(pv_id, PV_CONTROL, 0)
    foundation.delay_us(100)

    // Horizontal timing
    // HORZA: HBP | HSYNC
    pv_write(pv_id, PV_HORZA, (h_bp << 16) | h_sync)
    // HORZB: HACTIVE | HFP
    pv_write(pv_id, PV_HORZB, (h_active << 16) | h_fp)

    // Vertical timing
    // VERTA: VBP | VSYNC
    pv_write(pv_id, PV_VERTA, (v_bp << 16) | v_sync)
    // VERTB: VACTIVE | VFP
    pv_write(pv_id, PV_VERTB, (v_active << 16) | v_fp)

    // For interlaced (not used for 4K progressive)
    pv_write(pv_id, PV_VERTA_EVEN, 0)
    pv_write(pv_id, PV_VERTB_EVEN, 0)

    // Vertical control
    // Bit 0: continuous mode
    // Bit 1: wait for vstart
    pv_write(pv_id, PV_V_CONTROL, 0x01)

    // Enable PixelValve
    // Bit 0: Enable
    // Bit 2: FIFO clear
    // Bit 12-15: Format (for HDMI)
    var control: u32 = 0x00001005  // Enable + FIFO clear + 24bpp
    pv_write(pv_id, PV_CONTROL, control)

    foundation.serial_write_string("[VC7] PixelValve ")
    foundation.serial_write_u64(pv_id)
    foundation.serial_write_string(" configured for ")
    foundation.serial_write_u64(width)
    foundation.serial_write_string("x")
    foundation.serial_write_u64(height)
    foundation.serial_write_string("@")
    foundation.serial_write_u64(refresh)
    foundation.serial_write_string("Hz\n")
}

// Submit V3D render job (simplified)
export fn vc7_submit_render(bin_cl: u64, bin_size: u32, render_cl: u64, render_size: u32): u32 {
    if vc7.initialized == 0 { return 1 }
    if vc7.v3d.initialized == 0 { return 1 }

    // Wait for any previous job to complete
    var timeout: u32 = 100000
    while timeout > 0 {
        var cs: u32 = v3d_read(V3D_CT0CS)
        if (cs & 0x20) == 0 {  // Not running
            break
        }
        timeout = timeout - 1
    }

    if timeout == 0 {
        foundation.serial_write_string("[VC7] Render timeout waiting for previous job\n")
        return 1
    }

    // Submit binning job first (if provided)
    if bin_cl != 0 and bin_size > 0 {
        v3d_write(V3D_CT0CA, bin_cl & 0xFFFFFFFF)
        v3d_write(V3D_CT0EA, (bin_cl + bin_size) & 0xFFFFFFFF)
        v3d_write(V3D_CT0CS, 0x20)  // Start binning

        // Wait for binning to complete
        timeout = 100000
        while timeout > 0 {
            var cs: u32 = v3d_read(V3D_CT0CS)
            if (cs & 0x20) == 0 {
                break
            }
            timeout = timeout - 1
        }
    }

    // Submit rendering job
    if render_cl != 0 and render_size > 0 {
        v3d_write(V3D_CT1CA, render_cl & 0xFFFFFFFF)
        v3d_write(V3D_CT1EA, (render_cl + render_size) & 0xFFFFFFFF)
        v3d_write(V3D_CT1CS, 0x20)  // Start rendering
    }

    v3d_jobs = v3d_jobs + 1

    return 0
}

// Wait for V3D to complete rendering
export fn vc7_wait_render(): u32 {
    if vc7.initialized == 0 { return 1 }

    var timeout: u32 = 1000000
    while timeout > 0 {
        var cs: u32 = v3d_read(V3D_CT1CS)
        if (cs & 0x20) == 0 {  // Not running
            return 0
        }
        timeout = timeout - 1
    }

    foundation.serial_write_string("[VC7] Render wait timeout\n")
    return 1
}

// Present frame (swap display)
export fn vc7_present(): u32 {
    if vc7.initialized == 0 { return 1 }

    // Trigger HVS display list reload
    var ctrl: u32 = hvs_read(HVS_DISPCTRL)
    hvs_write(HVS_DISPCTRL, ctrl | 0x40000000)  // Request update

    frames_rendered = frames_rendered + 1
    display_updates = display_updates + 1

    return 0
}

// Clear framebuffer to color
export fn vc7_clear(color: u32) {
    if vc7.initialized == 0 { return }

    framebuffer.fb_clear(color)
}

// Get framebuffer address
export fn vc7_get_framebuffer(): u64 {
    return vc7.framebuffer_addr
}

// Get display dimensions
export fn vc7_get_width(): u32 {
    return vc7.primary_width
}

export fn vc7_get_height(): u32 {
    return vc7.primary_height
}

// Print statistics
export fn vc7_print_stats() {
    foundation.serial_write_string("\n[VC7] VideoCore VII Statistics:\n")

    foundation.serial_write_string("  V3D Slices: ")
    foundation.serial_write_u64(vc7.v3d.num_slices)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  V3D QPUs: ")
    foundation.serial_write_u64(vc7.v3d.num_qpus)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  VPM Size: ")
    foundation.serial_write_u64(vc7.v3d.vpm_size)
    foundation.serial_write_string(" KB\n")

    foundation.serial_write_string("  Framebuffer: 0x")
    foundation.serial_write_u64(vc7.framebuffer_addr)
    foundation.serial_write_string(" (")
    foundation.serial_write_u64(vc7.framebuffer_size / 1024 / 1024)
    foundation.serial_write_string(" MB)\n")

    foundation.serial_write_string("  Resolution: ")
    foundation.serial_write_u64(vc7.primary_width)
    foundation.serial_write_string("x")
    foundation.serial_write_u64(vc7.primary_height)
    foundation.serial_write_string("@")
    foundation.serial_write_u64(vc7.primary_bpp)
    foundation.serial_write_string("bpp\n")

    foundation.serial_write_string("  Frames rendered: ")
    foundation.serial_write_u64(frames_rendered)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  V3D jobs: ")
    foundation.serial_write_u64(v3d_jobs)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  Display updates: ")
    foundation.serial_write_u64(display_updates)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  VSync waits: ")
    foundation.serial_write_u64(vsync_waits)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  Missed VSyncs: ")
    foundation.serial_write_u64(missed_vsyncs)
    foundation.serial_write_string("\n")

    foundation.serial_write_string("  DPMS state: ")
    if current_dpms_state == DPMS_ON {
        foundation.serial_write_string("ON\n")
    } else if current_dpms_state == DPMS_STANDBY {
        foundation.serial_write_string("STANDBY\n")
    } else if current_dpms_state == DPMS_SUSPEND {
        foundation.serial_write_string("SUSPEND\n")
    } else {
        foundation.serial_write_string("OFF\n")
    }

    if hw_cursor.enabled == 1 {
        foundation.serial_write_string("  Hardware cursor: enabled at (")
        foundation.serial_write_u64(hw_cursor.x)
        foundation.serial_write_string(", ")
        foundation.serial_write_u64(hw_cursor.y)
        foundation.serial_write_string(")\n")
    }

    foundation.serial_write_string("  Active displays: ")
    if (vc7.active_displays & 1) != 0 {
        foundation.serial_write_string("HDMI0 ")
    }
    if (vc7.active_displays & 2) != 0 {
        foundation.serial_write_string("HDMI1 ")
    }
    foundation.serial_write_string("\n")
}

// ============================================
// VSync Support
// ============================================

// Enable VSync
export fn vc7_vsync_enable(enabled: u32) {
    vsync.enabled = enabled
    if enabled == 1 {
        // Enable VBlank interrupt on PixelValve
        pv_write(0, PV_INTEN, 0x10)  // VFP start interrupt
        foundation.serial_write_string("[VC7] VSync enabled\n")
    } else {
        pv_write(0, PV_INTEN, 0x00)
        foundation.serial_write_string("[VC7] VSync disabled\n")
    }
}

// Wait for VSync (blocking)
export fn vc7_wait_vsync(): u32 {
    if vc7.initialized == 0 { return 1 }
    if vsync.enabled == 0 { return 0 }

    vsync.waiting = 1

    // Wait for VBlank by polling PixelValve status
    var timeout: u32 = 100000
    var start_frame: u64 = vsync.frame_count

    while timeout > 0 {
        var stat: u32 = pv_read(0, PV_INTSTAT)
        if (stat & 0x10) != 0 {
            // VBlank occurred - clear interrupt
            pv_write(0, PV_INTSTAT, 0x10)
            vsync.frame_count = vsync.frame_count + 1
            vsync.waiting = 0
            vsync_waits = vsync_waits + 1
            return 0
        }
        timeout = timeout - 1
    }

    // Timeout - missed vsync
    missed_vsyncs = missed_vsyncs + 1
    vsync.waiting = 0
    return 1
}

// Get current frame count
export fn vc7_get_frame_count(): u64 {
    return vsync.frame_count
}

// ============================================
// Hardware Cursor Support
// ============================================

const HW_CURSOR_WIDTH: u32 = 64
const HW_CURSOR_HEIGHT: u32 = 64
const HW_CURSOR_SIZE: u64 = 64 * 64 * 4  // ARGB8888

// Initialize hardware cursor
export fn vc7_cursor_init(): u32 {
    if vc7.initialized == 0 { return 1 }

    foundation.serial_write_string("[VC7] Initializing hardware cursor\n")

    // Allocate cursor buffer (64x64 ARGB)
    hw_cursor.buffer_addr = mailbox.mailbox_allocate_framebuffer(64, 64, 32)
    if hw_cursor.buffer_addr == 0 {
        foundation.serial_write_string("[VC7] Failed to allocate cursor buffer\n")
        return 1
    }

    hw_cursor.width = HW_CURSOR_WIDTH
    hw_cursor.height = HW_CURSOR_HEIGHT
    hw_cursor.x = 0
    hw_cursor.y = 0
    hw_cursor.hotspot_x = 0
    hw_cursor.hotspot_y = 0
    hw_cursor.visible = 0
    hw_cursor.enabled = 1

    // Clear cursor buffer to transparent
    var i: u64 = 0
    while i < HW_CURSOR_SIZE {
        memory.write_volatile_u32(hw_cursor.buffer_addr + i, 0x00000000)
        i = i + 4
    }

    foundation.serial_write_string("[VC7] Hardware cursor initialized\n")
    return 0
}

// Set cursor image (64x64 ARGB8888)
export fn vc7_cursor_set_image(image: *u8, width: u32, height: u32): u32 {
    if hw_cursor.enabled == 0 { return 1 }
    if width > HW_CURSOR_WIDTH or height > HW_CURSOR_HEIGHT { return 1 }

    // Copy image to cursor buffer
    var src_pitch: u32 = width * 4
    var dst_pitch: u32 = HW_CURSOR_WIDTH * 4

    var row: u32 = 0
    while row < height {
        var src_row: u64 = (image as u64) + (row * src_pitch)
        var dst_row: u64 = hw_cursor.buffer_addr + (row * dst_pitch)
        memory.memcpy(dst_row, src_row, src_pitch)
        row = row + 1
    }

    return 0
}

// Move cursor
export fn vc7_cursor_move(x: u32, y: u32) {
    if hw_cursor.enabled == 0 { return }

    hw_cursor.x = x
    hw_cursor.y = y

    // Update cursor position in HVS display list
    if hw_cursor.visible == 1 {
        vc7_cursor_update_position()
    }
}

// Update cursor position in hardware
fn vc7_cursor_update_position() {
    // Cursor is rendered as a separate HVS layer
    // Position = (x - hotspot_x, y - hotspot_y)
    var pos_x: i32 = hw_cursor.x - hw_cursor.hotspot_x
    var pos_y: i32 = hw_cursor.y - hw_cursor.hotspot_y

    // Clamp to screen bounds
    if pos_x < 0 { pos_x = 0 }
    if pos_y < 0 { pos_y = 0 }

    // Update HVS cursor layer position
    // This would update the display list entry for the cursor
}

// Show/hide cursor
export fn vc7_cursor_show(visible: u32) {
    if hw_cursor.enabled == 0 { return }

    hw_cursor.visible = visible

    if visible == 1 {
        foundation.serial_write_string("[VC7] Cursor visible\n")
    } else {
        foundation.serial_write_string("[VC7] Cursor hidden\n")
    }
}

// Set cursor hotspot
export fn vc7_cursor_set_hotspot(x: u32, y: u32) {
    hw_cursor.hotspot_x = x
    hw_cursor.hotspot_y = y
}

// ============================================
// DPMS Power Management
// ============================================

// Set DPMS state
export fn vc7_dpms_set(state: u32): u32 {
    if vc7.initialized == 0 { return 1 }
    if state > DPMS_OFF { return 1 }

    if state == current_dpms_state { return 0 }

    foundation.serial_write_string("[VC7] DPMS state: ")

    if state == DPMS_ON {
        foundation.serial_write_string("ON\n")
        // Re-enable display
        hvs_write(HVS_DISPCTRL, 0x80000000)
        pv_write(0, PV_CONTROL, pv_read(0, PV_CONTROL) | 0x01)
        hdmi.hdmi_set_mode(0, 5)  // Restore 4K60
    } else if state == DPMS_STANDBY {
        foundation.serial_write_string("STANDBY\n")
        // Disable video output, keep sync
        hvs_write(HVS_DISPCTRL, 0x00000000)
    } else if state == DPMS_SUSPEND {
        foundation.serial_write_string("SUSPEND\n")
        // Disable video and hsync, keep vsync
        hvs_write(HVS_DISPCTRL, 0x00000000)
        pv_write(0, PV_CONTROL, pv_read(0, PV_CONTROL) & ~0x01)
    } else if state == DPMS_OFF {
        foundation.serial_write_string("OFF\n")
        // Full power off
        hvs_write(HVS_DISPCTRL, 0x00000000)
        pv_write(0, PV_CONTROL, 0)
    }

    current_dpms_state = state
    return 0
}

// Get DPMS state
export fn vc7_dpms_get(): u32 {
    return current_dpms_state
}

// Screen blank/unblank (convenience)
export fn vc7_blank(blank: u32): u32 {
    if blank == 1 {
        return vc7_dpms_set(DPMS_OFF)
    } else {
        return vc7_dpms_set(DPMS_ON)
    }
}

// ============================================
// DMA-Accelerated Operations
// ============================================

// DMA channel for framebuffer operations
const DMA_FB_CHANNEL: u32 = 0
const DMA_BASE: u64 = 0x1F00010000  // RP1 DMA base

struct DmaControlBlock {
    transfer_info: u32
    src_addr: u32
    dst_addr: u32
    transfer_len: u32
    stride: u32
    next_cb: u32
    reserved: [2]u32
}

// DMA-accelerated memory fill
export fn vc7_dma_fill(addr: u64, value: u32, size: u64): u32 {
    if size < 1024 {
        // For small fills, CPU is faster
        var i: u64 = 0
        while i < size {
            memory.write_volatile_u32(addr + i, value)
            i = i + 4
        }
        return 0
    }

    // For large fills, use DMA (simplified - real impl would setup DMA properly)
    foundation.serial_write_string("[VC7] DMA fill: ")
    foundation.serial_write_u64(size)
    foundation.serial_write_string(" bytes\n")

    // Fallback to CPU for now
    var i: u64 = 0
    var value64: u64 = (value << 32) | value
    while i + 8 <= size {
        memory.write_volatile_u64(addr + i, value64)
        i = i + 8
    }
    while i < size {
        memory.write_volatile_u32(addr + i, value)
        i = i + 4
    }

    return 0
}

// DMA-accelerated memory copy
export fn vc7_dma_copy(dst: u64, src: u64, size: u64): u32 {
    if size < 1024 {
        memory.memcpy(dst, src, size)
        return 0
    }

    foundation.serial_write_string("[VC7] DMA copy: ")
    foundation.serial_write_u64(size)
    foundation.serial_write_string(" bytes\n")

    // Use optimized 64-bit copy
    var i: u64 = 0
    while i + 8 <= size {
        var data: u64 = memory.read_volatile_u64(src + i)
        memory.write_volatile_u64(dst + i, data)
        i = i + 8
    }
    while i < size {
        var data: u8 = memory.read_volatile_u8(src + i)
        memory.write_volatile_u8(dst + i, data)
        i = i + 1
    }

    return 0
}

// ============================================
// Gamma / Color Calibration
// ============================================

const GAMMA_TABLE_SIZE: u32 = 256

struct GammaTable {
    red: [256]u16
    green: [256]u16
    blue: [256]u16
}

var gamma_table: GammaTable
var gamma_enabled: u32 = 0

// Initialize gamma table with linear values
fn gamma_init_linear() {
    var i: u32 = 0
    while i < GAMMA_TABLE_SIZE {
        var value: u16 = (i << 8) | i  // 16-bit value
        gamma_table.red[i] = value
        gamma_table.green[i] = value
        gamma_table.blue[i] = value
        i = i + 1
    }
}

// Set gamma curve (gamma value * 100, e.g., 220 = 2.2)
export fn vc7_set_gamma(gamma_x100: u32): u32 {
    if vc7.initialized == 0 { return 1 }

    foundation.serial_write_string("[VC7] Setting gamma to ")
    foundation.serial_write_u64(gamma_x100 / 100)
    foundation.serial_write_string(".")
    foundation.serial_write_u64(gamma_x100 % 100)
    foundation.serial_write_string("\n")

    // Calculate gamma curve
    // output = input^gamma (normalized to 0-65535)
    var i: u32 = 0
    while i < GAMMA_TABLE_SIZE {
        // Simplified gamma calculation using integer math
        // For gamma 2.2, we approximate with a lookup
        var input: u32 = i * 256  // Scale to 16-bit
        var output: u32 = input

        // Apply gamma correction approximation
        if gamma_x100 > 100 {
            // Gamma > 1.0 (darken midtones)
            output = (input * input) / 65536
            if gamma_x100 > 200 {
                output = (output * input) / 65536
            }
        } else if gamma_x100 < 100 {
            // Gamma < 1.0 (brighten midtones)
            output = 65535 - ((65535 - input) * (65535 - input)) / 65536
        }

        gamma_table.red[i] = output
        gamma_table.green[i] = output
        gamma_table.blue[i] = output
        i = i + 1
    }

    // Apply to hardware
    vc7_apply_gamma()
    gamma_enabled = 1

    return 0
}

// Set custom gamma table
export fn vc7_set_gamma_table(red: *u16, green: *u16, blue: *u16): u32 {
    if vc7.initialized == 0 { return 1 }

    var i: u32 = 0
    while i < GAMMA_TABLE_SIZE {
        gamma_table.red[i] = red[i]
        gamma_table.green[i] = green[i]
        gamma_table.blue[i] = blue[i]
        i = i + 1
    }

    vc7_apply_gamma()
    gamma_enabled = 1

    foundation.serial_write_string("[VC7] Custom gamma table applied\n")
    return 0
}

// Apply gamma table to hardware (HVS)
fn vc7_apply_gamma() {
    // HVS has gamma tables at offset 0x800
    var gamma_base: u64 = VC7_HVS_BASE + 0x800

    var i: u32 = 0
    while i < GAMMA_TABLE_SIZE {
        // Each entry is 32 bits: [15:0] = value, [31:16] = value for next
        var red_entry: u32 = gamma_table.red[i]
        var green_entry: u32 = gamma_table.green[i]
        var blue_entry: u32 = gamma_table.blue[i]

        memory.write_volatile_u32(gamma_base + (i * 4), red_entry)
        memory.write_volatile_u32(gamma_base + 0x400 + (i * 4), green_entry)
        memory.write_volatile_u32(gamma_base + 0x800 + (i * 4), blue_entry)
        i = i + 1
    }

    // Enable gamma correction in HVS
    var ctrl: u32 = hvs_read(HVS_DISPCTRL)
    hvs_write(HVS_DISPCTRL, ctrl | 0x00010000)  // Enable gamma
}

// Disable gamma correction
export fn vc7_disable_gamma() {
    if vc7.initialized == 0 { return }

    var ctrl: u32 = hvs_read(HVS_DISPCTRL)
    hvs_write(HVS_DISPCTRL, ctrl & ~0x00010000)
    gamma_enabled = 0

    foundation.serial_write_string("[VC7] Gamma disabled\n")
}

// Set color temperature (Kelvin)
export fn vc7_set_color_temp(kelvin: u32): u32 {
    if vc7.initialized == 0 { return 1 }

    foundation.serial_write_string("[VC7] Setting color temperature to ")
    foundation.serial_write_u64(kelvin)
    foundation.serial_write_string("K\n")

    // Calculate RGB gains for color temperature
    // Using approximation formulas
    var r_gain: u32 = 256
    var g_gain: u32 = 256
    var b_gain: u32 = 256

    if kelvin < 6500 {
        // Warm (reduce blue)
        b_gain = 256 * kelvin / 6500
        if kelvin < 5000 {
            g_gain = 256 - (5000 - kelvin) / 100
        }
    } else if kelvin > 6500 {
        // Cool (reduce red)
        r_gain = 256 * 6500 / kelvin
        if kelvin > 9000 {
            g_gain = 256 - (kelvin - 9000) / 100
        }
    }

    // Apply to gamma table
    var i: u32 = 0
    while i < GAMMA_TABLE_SIZE {
        var base: u32 = (i << 8) | i
        gamma_table.red[i] = (base * r_gain) / 256
        gamma_table.green[i] = (base * g_gain) / 256
        gamma_table.blue[i] = (base * b_gain) / 256
        i = i + 1
    }

    vc7_apply_gamma()
    gamma_enabled = 1

    return 0
}

// ============================================
// Multi-Layer Compositing (Overlays)
// ============================================

const MAX_LAYERS: u32 = 4

struct DisplayLayer {
    enabled: u32
    x: i32
    y: i32
    width: u32
    height: u32
    buffer_addr: u64
    pitch: u32
    format: u32
    alpha: u32           // 0-255, global alpha
    z_order: u32         // 0 = bottom, higher = on top
    blend_mode: u32      // 0 = none, 1 = alpha, 2 = multiply
}

var layers: [4]DisplayLayer
var layer_count: u32 = 0

// Create a new overlay layer
export fn vc7_layer_create(width: u32, height: u32, format: u32): u32 {
    if vc7.initialized == 0 { return 0xFFFFFFFF }
    if layer_count >= MAX_LAYERS { return 0xFFFFFFFF }

    var layer_id: u32 = layer_count

    // Allocate buffer
    var size: u64 = width * height * 4
    var addr: u64 = mailbox.mailbox_allocate_framebuffer(width, height, 32)
    if addr == 0 { return 0xFFFFFFFF }

    layers[layer_id].enabled = 0
    layers[layer_id].x = 0
    layers[layer_id].y = 0
    layers[layer_id].width = width
    layers[layer_id].height = height
    layers[layer_id].buffer_addr = addr
    layers[layer_id].pitch = width * 4
    layers[layer_id].format = format
    layers[layer_id].alpha = 255
    layers[layer_id].z_order = layer_id
    layers[layer_id].blend_mode = 1  // Alpha blending

    layer_count = layer_count + 1

    foundation.serial_write_string("[VC7] Created layer ")
    foundation.serial_write_u64(layer_id)
    foundation.serial_write_string(": ")
    foundation.serial_write_u64(width)
    foundation.serial_write_string("x")
    foundation.serial_write_u64(height)
    foundation.serial_write_string("\n")

    return layer_id
}

// Set layer position
export fn vc7_layer_set_position(layer_id: u32, x: i32, y: i32): u32 {
    if layer_id >= layer_count { return 1 }

    layers[layer_id].x = x
    layers[layer_id].y = y

    if layers[layer_id].enabled == 1 {
        vc7_update_display_list()
    }

    return 0
}

// Set layer alpha
export fn vc7_layer_set_alpha(layer_id: u32, alpha: u32): u32 {
    if layer_id >= layer_count { return 1 }
    if alpha > 255 { return 1 }

    layers[layer_id].alpha = alpha

    if layers[layer_id].enabled == 1 {
        vc7_update_display_list()
    }

    return 0
}

// Enable/disable layer
export fn vc7_layer_enable(layer_id: u32, enabled: u32): u32 {
    if layer_id >= layer_count { return 1 }

    layers[layer_id].enabled = enabled
    vc7_update_display_list()

    return 0
}

// Get layer buffer address
export fn vc7_layer_get_buffer(layer_id: u32): u64 {
    if layer_id >= layer_count { return 0 }
    return layers[layer_id].buffer_addr
}

// Update HVS display list with all layers
fn vc7_update_display_list() {
    // Rebuild display list with enabled layers sorted by z-order
    var dlist_base: u64 = VC7_HVS_BASE + 0x2000
    var offset: u32 = 0

    // First add main framebuffer (layer 0)
    var ctrl: u32 = DLIST_CTRL_VALID | DLIST_CTRL_UNITY | (3 << 0)  // XRGB8888
    ctrl = ctrl | (0x1F << 11)  // Full alpha
    memory.write_volatile_u32(dlist_base + offset, ctrl)
    offset = offset + 4

    memory.write_volatile_u32(dlist_base + offset, 0)  // Position 0,0
    offset = offset + 4

    memory.write_volatile_u32(dlist_base + offset, vc7.framebuffer_addr & 0xFFFFFFFF)
    offset = offset + 4

    memory.write_volatile_u32(dlist_base + offset, vc7.primary_width * 4)  // Pitch
    offset = offset + 4

    memory.write_volatile_u32(dlist_base + offset, (vc7.primary_width << 16) | vc7.primary_height)
    offset = offset + 4

    // Add overlay layers
    var i: u32 = 0
    while i < layer_count {
        if layers[i].enabled == 1 {
            // Control word with alpha
            ctrl = DLIST_CTRL_VALID | DLIST_CTRL_UNITY | (3 << 0)
            ctrl = ctrl | ((layers[i].alpha >> 3) << 11)  // 5-bit alpha
            memory.write_volatile_u32(dlist_base + offset, ctrl)
            offset = offset + 4

            // Position
            var pos: u32 = ((layers[i].x & 0xFFFF) << 16) | (layers[i].y & 0xFFFF)
            memory.write_volatile_u32(dlist_base + offset, pos)
            offset = offset + 4

            // Source address
            memory.write_volatile_u32(dlist_base + offset, layers[i].buffer_addr & 0xFFFFFFFF)
            offset = offset + 4

            // Pitch
            memory.write_volatile_u32(dlist_base + offset, layers[i].pitch)
            offset = offset + 4

            // Size
            memory.write_volatile_u32(dlist_base + offset, (layers[i].width << 16) | layers[i].height)
            offset = offset + 4
        }
        i = i + 1
    }

    // End marker
    memory.write_volatile_u32(dlist_base + offset, DLIST_CTRL_END)

    // Update display list pointer
    hvs_write(HVS_DISPLIST0, 0)
}

// ============================================
// Boot Splash Screen
// ============================================

// Display boot splash
export fn vc7_show_boot_splash(): u32 {
    if vc7.initialized == 0 { return 1 }

    foundation.serial_write_string("[VC7] Displaying boot splash\n")

    // Clear to dark blue gradient
    var y: u32 = 0
    while y < vc7.primary_height {
        var blue: u32 = 0x10 + (y * 0x30 / vc7.primary_height)
        var color: u32 = blue
        framebuffer.fb_draw_hline(0, y, vc7.primary_width, color)
        y = y + 1
    }

    // Draw HomeOS logo (simple text for now)
    var center_x: u32 = vc7.primary_width / 2
    var center_y: u32 = vc7.primary_height / 2

    // Draw box around logo
    var box_w: u32 = 400
    var box_h: u32 = 200
    var box_x: u32 = center_x - box_w / 2
    var box_y: u32 = center_y - box_h / 2

    framebuffer.fb_fill_rect(box_x, box_y, box_w, box_h, 0x202040)
    framebuffer.fb_draw_rect(box_x, box_y, box_w, box_h, 0x4060A0)

    // Draw text
    framebuffer.fb_draw_string(center_x - 48, center_y - 20, "HomeOS", 0xFFFFFF, 0)
    framebuffer.fb_draw_string(center_x - 80, center_y + 10, "Starting...", 0x8080FF, 0)

    // Draw progress bar outline
    var bar_w: u32 = 300
    var bar_h: u32 = 20
    var bar_x: u32 = center_x - bar_w / 2
    var bar_y: u32 = center_y + 60

    framebuffer.fb_draw_rect(bar_x, bar_y, bar_w, bar_h, 0x4060A0)

    vc7_present()
    return 0
}

// Update boot progress (0-100)
export fn vc7_boot_progress(percent: u32): u32 {
    if vc7.initialized == 0 { return 1 }
    if percent > 100 { return 1 }

    var center_x: u32 = vc7.primary_width / 2
    var center_y: u32 = vc7.primary_height / 2

    var bar_w: u32 = 300
    var bar_h: u32 = 20
    var bar_x: u32 = center_x - bar_w / 2
    var bar_y: u32 = center_y + 60

    // Fill progress
    var fill_w: u32 = (bar_w - 4) * percent / 100
    framebuffer.fb_fill_rect(bar_x + 2, bar_y + 2, fill_w, bar_h - 4, 0x4080FF)

    vc7_present()
    return 0
}

// Hide boot splash
export fn vc7_hide_boot_splash(): u32 {
    if vc7.initialized == 0 { return 1 }

    // Clear screen to black
    framebuffer.fb_clear(0x000000)
    vc7_present()

    foundation.serial_write_string("[VC7] Boot splash hidden\n")
    return 0
}

// ============================================
// LG Monitor Support
// ============================================

// Initialize for LG 27UP850-W monitor specifically
export fn vc7_init_lg_monitor(): u32 {
    foundation.serial_write_string("[VC7] Initializing for LG 27UP850-W monitor\n")

    // Initialize VideoCore VII
    var result: u32 = vc7_init()
    if result != 0 {
        return 1
    }

    // Setup 4K display on HDMI0 (primary port)
    result = vc7_setup_4k_display(0)
    if result != 0 {
        return 1
    }

    // Initialize for LG monitor via HDMI driver
    hdmi.hdmi_init_lg_27up850w(0)

    // Clear screen to dark blue (HomeOS boot color)
    vc7_clear(0x001830)

    // Draw test pattern
    framebuffer.fb_fill_rect(100, 100, 200, 200, 0xFFFFFF)  // White box
    framebuffer.fb_fill_rect(400, 100, 200, 200, 0xFF0000)  // Red box
    framebuffer.fb_fill_rect(700, 100, 200, 200, 0x00FF00)  // Green box
    framebuffer.fb_fill_rect(1000, 100, 200, 200, 0x0000FF) // Blue box

    // Draw text
    framebuffer.fb_draw_string(100, 400, "HomeOS on Raspberry Pi 5", 0xFFFFFF, 0)
    framebuffer.fb_draw_string(100, 420, "LG 27UP850-W - 3840x2160@60Hz", 0xFFFFFF, 0)

    vc7_present()

    foundation.serial_write_string("[VC7] LG 27UP850-W initialization complete\n")
    return 0
}
