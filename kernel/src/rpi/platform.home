// home-os Raspberry Pi Platform Abstraction
// Unified interface for all Raspberry Pi models
// Supports Pi 1/Zero, Pi 2, Pi 3, Pi 4, Pi 5

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "bcm2835.home" as bcm2835
import "bcm2711.home" as bcm2711

// Raspberry Pi Model IDs
const MODEL_UNKNOWN: u32 = 0
const MODEL_PI1_A: u32 = 1
const MODEL_PI1_A_PLUS: u32 = 2
const MODEL_PI1_B: u32 = 3
const MODEL_PI1_B_PLUS: u32 = 4
const MODEL_PI2_B: u32 = 5
const MODEL_PI3_B: u32 = 6
const MODEL_PI3_B_PLUS: u32 = 7
const MODEL_PI3_A_PLUS: u32 = 8
const MODEL_PI4_B: u32 = 9
const MODEL_PI400: u32 = 10
const MODEL_PI_CM4: u32 = 11
const MODEL_PI_ZERO: u32 = 12
const MODEL_PI_ZERO_W: u32 = 13
const MODEL_PI_ZERO_2W: u32 = 14
const MODEL_PI5: u32 = 15

// SoC Types
const SOC_BCM2835: u32 = 0  // Pi 1, Zero
const SOC_BCM2836: u32 = 1  // Pi 2
const SOC_BCM2837: u32 = 2  // Pi 3
const SOC_BCM2711: u32 = 3  // Pi 4, 400, CM4
const SOC_BCM2712: u32 = 4  // Pi 5

// GPIO Function Modes (unified)
const GPIO_INPUT: u32 = 0
const GPIO_OUTPUT: u32 = 1
const GPIO_ALT0: u32 = 4
const GPIO_ALT1: u32 = 5
const GPIO_ALT2: u32 = 6
const GPIO_ALT3: u32 = 7
const GPIO_ALT4: u32 = 3
const GPIO_ALT5: u32 = 2

// GPIO Pull-up/down (unified)
const PUD_NONE: u32 = 0
const PUD_DOWN: u32 = 1
const PUD_UP: u32 = 2

// Standard GPIO Pin Mappings (all Pi models with 40-pin header)
const GPIO_SDA1: u32 = 2
const GPIO_SCL1: u32 = 3
const GPIO_SDA0: u32 = 0  // ID EEPROM
const GPIO_SCL0: u32 = 1  // ID EEPROM
const GPIO_GPCLK0: u32 = 4
const GPIO_SPI0_MISO: u32 = 9
const GPIO_SPI0_MOSI: u32 = 10
const GPIO_SPI0_SCLK: u32 = 11
const GPIO_SPI0_CE0: u32 = 8
const GPIO_SPI0_CE1: u32 = 7
const GPIO_TXD0: u32 = 14
const GPIO_RXD0: u32 = 15
const GPIO_PWM0: u32 = 12
const GPIO_PWM1: u32 = 13
const GPIO_STATUS_LED: u32 = 47  // Activity LED (varies by model)
const GPIO_POWER_LED: u32 = 35  // Power LED (Pi 3+)

// Platform state
struct PlatformInfo {
  model: u32
  soc: u32
  revision: u32
  serial: u64
  arm_memory: u64
  gpu_memory: u64
  num_cores: u32
  max_cpu_freq: u32
}

var platform: PlatformInfo
var initialized: u32 = 0

// Revision code parsing helpers
fn parse_revision_new_style(revision: u32): u32 {
  // New-style revision codes (bit 23 = 1)
  // Bits 4-11: Type (model)
  let type_code: u32 = (revision >> 4) & 0xFF

  if type_code == 0 { return MODEL_PI1_A }
  if type_code == 1 { return MODEL_PI1_B }
  if type_code == 2 { return MODEL_PI1_A_PLUS }
  if type_code == 3 { return MODEL_PI1_B_PLUS }
  if type_code == 4 { return MODEL_PI2_B }
  if type_code == 5 { return MODEL_PI_CM4 }  // Original CM
  if type_code == 6 { return MODEL_UNKNOWN }  // Reserved
  if type_code == 8 { return MODEL_PI3_B }
  if type_code == 9 { return MODEL_PI_ZERO }
  if type_code == 10 { return MODEL_PI_CM4 }  // CM3
  if type_code == 12 { return MODEL_PI_ZERO_W }
  if type_code == 13 { return MODEL_PI3_B_PLUS }
  if type_code == 14 { return MODEL_PI3_A_PLUS }
  if type_code == 16 { return MODEL_PI_CM4 }  // CM3+
  if type_code == 17 { return MODEL_PI4_B }
  if type_code == 18 { return MODEL_PI_ZERO_2W }
  if type_code == 19 { return MODEL_PI400 }
  if type_code == 20 { return MODEL_PI_CM4 }
  if type_code == 23 { return MODEL_PI5 }

  return MODEL_UNKNOWN
}

fn get_soc_from_model(model: u32): u32 {
  if model == MODEL_PI1_A or model == MODEL_PI1_A_PLUS or
     model == MODEL_PI1_B or model == MODEL_PI1_B_PLUS or
     model == MODEL_PI_ZERO or model == MODEL_PI_ZERO_W {
    return SOC_BCM2835
  }

  if model == MODEL_PI2_B {
    return SOC_BCM2836
  }

  if model == MODEL_PI3_B or model == MODEL_PI3_B_PLUS or
     model == MODEL_PI3_A_PLUS or model == MODEL_PI_ZERO_2W {
    return SOC_BCM2837
  }

  if model == MODEL_PI4_B or model == MODEL_PI400 or model == MODEL_PI_CM4 {
    return SOC_BCM2711
  }

  if model == MODEL_PI5 {
    return SOC_BCM2712
  }

  return SOC_BCM2835  // Default fallback
}

fn get_num_cores(soc: u32): u32 {
  if soc == SOC_BCM2835 { return 1 }
  return 4  // All others are quad-core
}

fn get_model_name(model: u32): *u8 {
  if model == MODEL_PI1_A { return "Raspberry Pi 1 Model A" }
  if model == MODEL_PI1_A_PLUS { return "Raspberry Pi 1 Model A+" }
  if model == MODEL_PI1_B { return "Raspberry Pi 1 Model B" }
  if model == MODEL_PI1_B_PLUS { return "Raspberry Pi 1 Model B+" }
  if model == MODEL_PI2_B { return "Raspberry Pi 2 Model B" }
  if model == MODEL_PI3_B { return "Raspberry Pi 3 Model B" }
  if model == MODEL_PI3_B_PLUS { return "Raspberry Pi 3 Model B+" }
  if model == MODEL_PI3_A_PLUS { return "Raspberry Pi 3 Model A+" }
  if model == MODEL_PI4_B { return "Raspberry Pi 4 Model B" }
  if model == MODEL_PI400 { return "Raspberry Pi 400" }
  if model == MODEL_PI_CM4 { return "Raspberry Pi Compute Module 4" }
  if model == MODEL_PI_ZERO { return "Raspberry Pi Zero" }
  if model == MODEL_PI_ZERO_W { return "Raspberry Pi Zero W" }
  if model == MODEL_PI_ZERO_2W { return "Raspberry Pi Zero 2 W" }
  if model == MODEL_PI5 { return "Raspberry Pi 5" }
  return "Unknown Raspberry Pi"
}

fn get_soc_name(soc: u32): *u8 {
  if soc == SOC_BCM2835 { return "BCM2835" }
  if soc == SOC_BCM2836 { return "BCM2836" }
  if soc == SOC_BCM2837 { return "BCM2837" }
  if soc == SOC_BCM2711 { return "BCM2711" }
  if soc == SOC_BCM2712 { return "BCM2712" }
  return "Unknown"
}

// Initialize platform detection and low-level hardware
export fn rpi_init(): u32 {
  if initialized == 1 { return 0 }

  foundation.serial_write_string("[RPI Platform] Initializing...\n")

  // Read board revision from known location
  // On real hardware, this would use the mailbox or DTB
  // For now, we'll detect based on peripheral base address

  // Try to detect SoC type by checking peripheral base
  // BCM2835: 0x20000000
  // BCM2836/7: 0x3F000000
  // BCM2711: 0xFE000000
  // BCM2712: 0x1F00000000

  // Initialize based on detected or assumed model
  // Default to Pi 4 for modern development
  platform.soc = SOC_BCM2711
  platform.model = MODEL_PI4_B
  platform.num_cores = 4
  platform.max_cpu_freq = 1500000000

  // Initialize the appropriate SoC driver
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_init()
    platform.revision = bcm2835.bcm2835_get_board_revision()
    platform.arm_memory = bcm2835.bcm2835_get_arm_memory()
    platform.gpu_memory = 0  // TODO: get from mailbox
  } else if platform.soc == SOC_BCM2711 {
    bcm2711.bcm2711_init()
    platform.revision = bcm2711.bcm2711_get_board_revision()
    platform.arm_memory = bcm2711.bcm2711_get_arm_memory()
    platform.gpu_memory = bcm2711.bcm2711_get_gpu_memory()
  }

  // Parse revision to get model
  if (platform.revision & 0x800000) != 0 {
    platform.model = parse_revision_new_style(platform.revision)
    platform.soc = get_soc_from_model(platform.model)
    platform.num_cores = get_num_cores(platform.soc)
  }

  initialized = 1

  // Print detected platform info
  foundation.serial_write_string("[RPI Platform] Detected: ")
  foundation.serial_write_string(get_model_name(platform.model))
  foundation.serial_write_string("\n")

  foundation.serial_write_string("[RPI Platform] SoC: ")
  foundation.serial_write_string(get_soc_name(platform.soc))
  foundation.serial_write_string(" (")
  foundation.serial_write_u64(platform.num_cores as u64)
  foundation.serial_write_string(" cores)\n")

  foundation.serial_write_string("[RPI Platform] Memory: ")
  foundation.serial_write_u64(platform.arm_memory / (1024 * 1024))
  foundation.serial_write_string(" MB ARM, ")
  foundation.serial_write_u64(platform.gpu_memory / (1024 * 1024))
  foundation.serial_write_string(" MB GPU\n")

  return 0
}

// Get platform info
export fn rpi_get_model(): u32 {
  return platform.model
}

export fn rpi_get_soc(): u32 {
  return platform.soc
}

export fn rpi_get_revision(): u32 {
  return platform.revision
}

export fn rpi_get_arm_memory(): u64 {
  return platform.arm_memory
}

export fn rpi_get_gpu_memory(): u64 {
  return platform.gpu_memory
}

export fn rpi_get_num_cores(): u32 {
  return platform.num_cores
}

export fn rpi_get_model_name(): *u8 {
  return get_model_name(platform.model)
}

export fn rpi_get_soc_name(): *u8 {
  return get_soc_name(platform.soc)
}

// Unified GPIO interface
export fn rpi_gpio_set_function(pin: u32, func: u32) {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_gpio_function(pin, func)
  } else if platform.soc == SOC_BCM2711 {
    bcm2711.bcm2711_gpio_function(pin, func)
  }
}

export fn rpi_gpio_set(pin: u32) {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_gpio_set(pin)
  } else if platform.soc == SOC_BCM2711 {
    bcm2711.bcm2711_gpio_set(pin)
  }
}

export fn rpi_gpio_clear(pin: u32) {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_gpio_clear(pin)
  } else if platform.soc == SOC_BCM2711 {
    bcm2711.bcm2711_gpio_clear(pin)
  }
}

export fn rpi_gpio_read(pin: u32): u32 {
  if platform.soc == SOC_BCM2835 {
    return bcm2835.bcm2835_gpio_level(pin)
  } else if platform.soc == SOC_BCM2711 {
    return bcm2711.bcm2711_gpio_level(pin)
  }
  return 0
}

export fn rpi_gpio_set_pull(pin: u32, pud: u32) {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_gpio_pud(pin, pud)
  } else if platform.soc == SOC_BCM2711 {
    bcm2711.bcm2711_gpio_pud(pin, pud)
  }
}

// Unified UART interface
export fn rpi_uart_putc(c: u8) {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_uart_putc(c)
  } else if platform.soc == SOC_BCM2711 {
    bcm2711.bcm2711_uart_putc(c)
  }
}

export fn rpi_uart_getc(): u8 {
  if platform.soc == SOC_BCM2835 {
    return bcm2835.bcm2835_uart_getc()
  } else if platform.soc == SOC_BCM2711 {
    return bcm2711.bcm2711_uart_getc()
  }
  return 0
}

export fn rpi_uart_available(): u32 {
  if platform.soc == SOC_BCM2835 {
    return bcm2835.bcm2835_uart_available()
  } else if platform.soc == SOC_BCM2711 {
    return bcm2711.bcm2711_uart_available()
  }
  return 0
}

export fn rpi_uart_puts(s: *u8) {
  var i: u32 = 0
  while s[i] != 0 {
    rpi_uart_putc(s[i])
    i = i + 1
  }
}

// Unified delay interface
export fn rpi_delay_us(us: u32) {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_delay_us(us)
  } else {
    // For BCM2711, use simple loop (TODO: use system timer)
    var i: u32 = 0
    let cycles: u32 = us * 1500  // Approximate for 1.5GHz
    while i < cycles {
      foundation.nop()
      i = i + 1
    }
  }
}

export fn rpi_delay_ms(ms: u32) {
  rpi_delay_us(ms * 1000)
}

// Unified temperature reading
export fn rpi_get_temperature(): u32 {
  if platform.soc == SOC_BCM2835 {
    return bcm2835.bcm2835_get_temperature()
  } else if platform.soc == SOC_BCM2711 {
    return bcm2711.bcm2711_get_temperature()
  }
  return 0
}

// Unified reboot
export fn rpi_reboot() {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_reboot()
  } else if platform.soc == SOC_BCM2711 {
    bcm2711.bcm2711_reboot()
  }
}

// Unified interrupt control (for BCM2711+ with GIC)
export fn rpi_enable_irq(irq: u32) {
  if platform.soc == SOC_BCM2711 {
    bcm2711.bcm2711_gic_enable_irq(irq)
  } else if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_irq_enable(irq)
  }
}

export fn rpi_disable_irq(irq: u32) {
  if platform.soc == SOC_BCM2711 {
    bcm2711.bcm2711_gic_disable_irq(irq)
  } else if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_irq_disable(irq)
  }
}

// Get peripheral base address
export fn rpi_get_peripheral_base(): u64 {
  if platform.soc == SOC_BCM2835 {
    return bcm2835.bcm2835_get_peripheral_base()
  } else if platform.soc == SOC_BCM2711 {
    return bcm2711.bcm2711_get_peripheral_base()
  }
  return 0
}

// SPI interface (unified)
export fn rpi_spi_init() {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_spi_init()
  }
  // TODO: BCM2711 SPI init
}

export fn rpi_spi_transfer(data: u8): u8 {
  if platform.soc == SOC_BCM2835 {
    return bcm2835.bcm2835_spi_transfer(data)
  }
  return 0
}

export fn rpi_spi_set_clock_divider(divider: u32) {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_spi_set_clock(divider)
  }
}

// I2C interface (unified)
export fn rpi_i2c_init(bus: u32) {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_i2c_init(bus)
  }
  // TODO: BCM2711 I2C init
}

export fn rpi_i2c_read(bus: u32, addr: u8, buffer: *u8, len: u32): u32 {
  if platform.soc == SOC_BCM2835 {
    return bcm2835.bcm2835_i2c_read(bus, addr, buffer, len)
  }
  return 1
}

export fn rpi_i2c_write(bus: u32, addr: u8, buffer: *u8, len: u32): u32 {
  if platform.soc == SOC_BCM2835 {
    return bcm2835.bcm2835_i2c_write(bus, addr, buffer, len)
  }
  return 1
}

// PWM interface (unified)
export fn rpi_pwm_init(channel: u32) {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_pwm_init(channel)
  }
}

export fn rpi_pwm_set_clock(divider: u32) {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_pwm_set_clock(divider)
  }
}

export fn rpi_pwm_set_range(channel: u32, range: u32) {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_pwm_set_range(channel, range)
  }
}

export fn rpi_pwm_set_data(channel: u32, data: u32) {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_pwm_set_data(channel, data)
  }
}

export fn rpi_pwm_enable(channel: u32, enable: u32) {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_pwm_enable(channel, enable)
  }
}

// LED control helpers
export fn rpi_activity_led(on: u32) {
  // Activity LED is active low on most Pi models
  let pin: u32 = if platform.model == MODEL_PI_ZERO or
                    platform.model == MODEL_PI_ZERO_W { 47 }
                 else if platform.soc == SOC_BCM2711 { 42 }
                 else { 47 }

  rpi_gpio_set_function(pin, GPIO_OUTPUT)
  if on == 1 {
    rpi_gpio_clear(pin)  // Active low
  } else {
    rpi_gpio_set(pin)
  }
}

// CPU frequency control
export fn rpi_set_cpu_freq(freq_hz: u32): u32 {
  if platform.soc == SOC_BCM2711 {
    return bcm2711.bcm2711_set_cpu_freq(freq_hz)
  }
  return 1
}

export fn rpi_get_cpu_freq(): u32 {
  if platform.soc == SOC_BCM2711 {
    return bcm2711.bcm2711_get_cpu_freq()
  }
  return 0
}

// Print platform statistics
export fn rpi_print_info() {
  foundation.serial_write_string("\n╔════════════════════════════════════════╗\n")
  foundation.serial_write_string("║      Raspberry Pi Platform Info        ║\n")
  foundation.serial_write_string("╚════════════════════════════════════════╝\n\n")

  foundation.serial_write_string("  Model: ")
  foundation.serial_write_string(get_model_name(platform.model))
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  SoC: ")
  foundation.serial_write_string(get_soc_name(platform.soc))
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Cores: ")
  foundation.serial_write_u64(platform.num_cores as u64)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Revision: 0x")
  foundation.serial_write_hex(platform.revision)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  ARM Memory: ")
  foundation.serial_write_u64(platform.arm_memory / (1024 * 1024))
  foundation.serial_write_string(" MB\n")

  foundation.serial_write_string("  GPU Memory: ")
  foundation.serial_write_u64(platform.gpu_memory / (1024 * 1024))
  foundation.serial_write_string(" MB\n")

  let temp: u32 = rpi_get_temperature()
  foundation.serial_write_string("  Temperature: ")
  foundation.serial_write_u64(temp / 1000)
  foundation.serial_write_string(".")
  foundation.serial_write_u64((temp % 1000) / 100)
  foundation.serial_write_string(" C\n")

  if platform.soc == SOC_BCM2711 {
    foundation.serial_write_string("  CPU Freq: ")
    foundation.serial_write_u64(rpi_get_cpu_freq() / 1000000)
    foundation.serial_write_string(" MHz\n")
  }

  foundation.serial_write_string("  Peripheral Base: 0x")
  foundation.serial_write_hex64(rpi_get_peripheral_base())
  foundation.serial_write_string("\n\n")
}

// Print SoC-specific statistics
export fn rpi_print_stats() {
  if platform.soc == SOC_BCM2835 {
    bcm2835.bcm2835_print_stats()
  } else if platform.soc == SOC_BCM2711 {
    bcm2711.bcm2711_print_stats()
  }
}

// Feature detection
export fn rpi_has_wifi(): u32 {
  if platform.model == MODEL_PI3_B or platform.model == MODEL_PI3_B_PLUS or
     platform.model == MODEL_PI3_A_PLUS or platform.model == MODEL_PI4_B or
     platform.model == MODEL_PI400 or platform.model == MODEL_PI_ZERO_W or
     platform.model == MODEL_PI_ZERO_2W or platform.model == MODEL_PI5 {
    return 1
  }
  return 0
}

export fn rpi_has_bluetooth(): u32 {
  if platform.model == MODEL_PI3_B or platform.model == MODEL_PI3_B_PLUS or
     platform.model == MODEL_PI3_A_PLUS or platform.model == MODEL_PI4_B or
     platform.model == MODEL_PI400 or platform.model == MODEL_PI_ZERO_W or
     platform.model == MODEL_PI_ZERO_2W or platform.model == MODEL_PI5 {
    return 1
  }
  return 0
}

export fn rpi_has_ethernet(): u32 {
  if platform.model == MODEL_PI1_B or platform.model == MODEL_PI1_B_PLUS or
     platform.model == MODEL_PI2_B or platform.model == MODEL_PI3_B or
     platform.model == MODEL_PI3_B_PLUS or platform.model == MODEL_PI4_B or
     platform.model == MODEL_PI400 {
    return 1
  }
  return 0
}

export fn rpi_has_gigabit_ethernet(): u32 {
  if platform.model == MODEL_PI4_B or platform.model == MODEL_PI400 or
     platform.model == MODEL_PI5 {
    return 1
  }
  return 0
}

export fn rpi_has_usb3(): u32 {
  if platform.model == MODEL_PI4_B or platform.model == MODEL_PI400 or
     platform.model == MODEL_PI5 {
    return 1
  }
  return 0
}

export fn rpi_has_pcie(): u32 {
  if platform.model == MODEL_PI4_B or platform.model == MODEL_PI400 or
     platform.model == MODEL_PI_CM4 or platform.model == MODEL_PI5 {
    return 1
  }
  return 0
}

export fn rpi_max_ram_gb(): u32 {
  if platform.model == MODEL_PI4_B or platform.model == MODEL_PI400 { return 8 }
  if platform.model == MODEL_PI5 { return 8 }
  if platform.model == MODEL_PI_CM4 { return 8 }
  if platform.model == MODEL_PI3_B or platform.model == MODEL_PI3_B_PLUS { return 1 }
  if platform.model == MODEL_PI2_B { return 1 }
  return 1  // Default 512MB-1GB for older models
}
