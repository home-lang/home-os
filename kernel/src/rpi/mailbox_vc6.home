// home-os VideoCore VI GPU Mailbox Interface
// Raspberry Pi 4 BCM2711 mailbox communication
// Handles property tags, framebuffer, memory, power, clocks

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory

// Mailbox base addresses for BCM2711
const MAILBOX_BASE: u64 = 0xFE00B880
const MAILBOX_READ: u64 = MAILBOX_BASE + 0x00
const MAILBOX_POLL: u64 = MAILBOX_BASE + 0x10
const MAILBOX_SENDER: u64 = MAILBOX_BASE + 0x14
const MAILBOX_STATUS: u64 = MAILBOX_BASE + 0x18
const MAILBOX_CONFIG: u64 = MAILBOX_BASE + 0x1C
const MAILBOX_WRITE: u64 = MAILBOX_BASE + 0x20

// Mailbox status bits
const MAILBOX_FULL: u32 = 0x80000000
const MAILBOX_EMPTY: u32 = 0x40000000

// Mailbox channels
const MBOX_CH_POWER: u32 = 0
const MBOX_CH_FRAMEBUFFER: u32 = 1
const MBOX_CH_VIRT_UART: u32 = 2
const MBOX_CH_VCHIQ: u32 = 3
const MBOX_CH_LEDS: u32 = 4
const MBOX_CH_BUTTONS: u32 = 5
const MBOX_CH_TOUCHSCREEN: u32 = 6
const MBOX_CH_COUNT: u32 = 7
const MBOX_CH_PROPERTY: u32 = 8

// Property tag IDs (same as VC7)
const TAG_GET_FIRMWARE_REV: u32 = 0x00000001
const TAG_GET_BOARD_MODEL: u32 = 0x00010001
const TAG_GET_BOARD_REV: u32 = 0x00010002
const TAG_GET_BOARD_MAC: u32 = 0x00010003
const TAG_GET_BOARD_SERIAL: u32 = 0x00010004
const TAG_GET_ARM_MEMORY: u32 = 0x00010005
const TAG_GET_VC_MEMORY: u32 = 0x00010006
const TAG_GET_CLOCKS: u32 = 0x00010007

// Power management tags
const TAG_GET_POWER_STATE: u32 = 0x00020001
const TAG_GET_TIMING: u32 = 0x00020002
const TAG_SET_POWER_STATE: u32 = 0x00028001

// Clock tags
const TAG_GET_CLOCK_STATE: u32 = 0x00030001
const TAG_SET_CLOCK_STATE: u32 = 0x00038001
const TAG_GET_CLOCK_RATE: u32 = 0x00030002
const TAG_SET_CLOCK_RATE: u32 = 0x00038002
const TAG_GET_MAX_CLOCK_RATE: u32 = 0x00030004
const TAG_GET_MIN_CLOCK_RATE: u32 = 0x00030007
const TAG_GET_TURBO: u32 = 0x00030009
const TAG_SET_TURBO: u32 = 0x00038009

// Voltage tags
const TAG_GET_VOLTAGE: u32 = 0x00030003
const TAG_SET_VOLTAGE: u32 = 0x00038003
const TAG_GET_MAX_VOLTAGE: u32 = 0x00030005
const TAG_GET_MIN_VOLTAGE: u32 = 0x00030008

// Temperature tags
const TAG_GET_TEMPERATURE: u32 = 0x00030006
const TAG_GET_MAX_TEMPERATURE: u32 = 0x0003000A

// Framebuffer tags
const TAG_ALLOCATE_BUFFER: u32 = 0x00040001
const TAG_RELEASE_BUFFER: u32 = 0x00048001
const TAG_BLANK_SCREEN: u32 = 0x00040002
const TAG_GET_PHYSICAL_WH: u32 = 0x00040003
const TAG_TEST_PHYSICAL_WH: u32 = 0x00044003
const TAG_SET_PHYSICAL_WH: u32 = 0x00048003
const TAG_GET_VIRTUAL_WH: u32 = 0x00040004
const TAG_TEST_VIRTUAL_WH: u32 = 0x00044004
const TAG_SET_VIRTUAL_WH: u32 = 0x00048004
const TAG_GET_DEPTH: u32 = 0x00040005
const TAG_TEST_DEPTH: u32 = 0x00044005
const TAG_SET_DEPTH: u32 = 0x00048005
const TAG_GET_PIXEL_ORDER: u32 = 0x00040006
const TAG_TEST_PIXEL_ORDER: u32 = 0x00044006
const TAG_SET_PIXEL_ORDER: u32 = 0x00048006
const TAG_GET_ALPHA_MODE: u32 = 0x00040007
const TAG_TEST_ALPHA_MODE: u32 = 0x00044007
const TAG_SET_ALPHA_MODE: u32 = 0x00048007
const TAG_GET_PITCH: u32 = 0x00040008
const TAG_GET_VIRTUAL_OFFSET: u32 = 0x00040009
const TAG_TEST_VIRTUAL_OFFSET: u32 = 0x00044009
const TAG_SET_VIRTUAL_OFFSET: u32 = 0x00048009
const TAG_GET_OVERSCAN: u32 = 0x0004000A
const TAG_TEST_OVERSCAN: u32 = 0x0004400A
const TAG_SET_OVERSCAN: u32 = 0x0004800A
const TAG_GET_PALETTE: u32 = 0x0004000B
const TAG_TEST_PALETTE: u32 = 0x0004400B
const TAG_SET_PALETTE: u32 = 0x0004800B

// Response codes
const MBOX_REQUEST: u32 = 0x00000000
const MBOX_RESPONSE_SUCCESS: u32 = 0x80000000
const MBOX_RESPONSE_ERROR: u32 = 0x80000001

// Tag request/response codes
const TAG_REQUEST: u32 = 0x00000000
const TAG_RESPONSE_SUCCESS: u32 = 0x80000000
const TAG_RESPONSE_ERROR: u32 = 0x80000001

// Clock IDs
const CLOCK_EMMC: u32 = 0x00000001
const CLOCK_UART: u32 = 0x00000002
const CLOCK_ARM: u32 = 0x00000003
const CLOCK_CORE: u32 = 0x00000004
const CLOCK_V3D: u32 = 0x00000005
const CLOCK_H264: u32 = 0x00000006
const CLOCK_ISP: u32 = 0x00000007
const CLOCK_SDRAM: u32 = 0x00000008
const CLOCK_PIXEL: u32 = 0x00000009
const CLOCK_PWM: u32 = 0x0000000A
const CLOCK_HEVC: u32 = 0x0000000B
const CLOCK_EMMC2: u32 = 0x0000000C
const CLOCK_M2MC: u32 = 0x0000000D
const CLOCK_PIXEL_BVB: u32 = 0x0000000E

// Power device IDs
const POWER_SD_CARD: u32 = 0x00000000
const POWER_UART0: u32 = 0x00000001
const POWER_UART1: u32 = 0x00000002
const POWER_USB_HCD: u32 = 0x00000003
const POWER_I2C0: u32 = 0x00000004
const POWER_I2C1: u32 = 0x00000005
const POWER_I2C2: u32 = 0x00000006
const POWER_SPI: u32 = 0x00000007
const POWER_CCP2TX: u32 = 0x00000008

// Mailbox buffer (16-byte aligned)
const MAILBOX_BUFFER_SIZE: u32 = 1024
var mailbox_buffer: [MAILBOX_BUFFER_SIZE]u8 align(16)

// Statistics
var mailbox_calls: u64 = 0
var mailbox_errors: u64 = 0
var mailbox_timeouts: u64 = 0

// Read mailbox register
fn mailbox_read_reg(addr: u64): u32 {
  return memory.read_u32(addr)
}

// Write mailbox register
fn mailbox_write_reg(addr: u64, value: u32) {
  memory.write_u32(addr, value)
}

// Wait for mailbox to be ready for writing
fn mailbox_wait_write(): u32 {
  var timeout: u32 = 1000000
  loop {
    if timeout == 0 {
      mailbox_timeouts = mailbox_timeouts + 1
      return 1
    }

    let status: u32 = mailbox_read_reg(MAILBOX_STATUS)
    if (status & MAILBOX_FULL) == 0 {
      return 0
    }

    timeout = timeout - 1
  }

  return 1
}

// Wait for mailbox to have data to read
fn mailbox_wait_read(): u32 {
  var timeout: u32 = 1000000
  loop {
    if timeout == 0 {
      mailbox_timeouts = mailbox_timeouts + 1
      return 1
    }

    let status: u32 = mailbox_read_reg(MAILBOX_STATUS)
    if (status & MAILBOX_EMPTY) == 0 {
      return 0
    }

    timeout = timeout - 1
  }

  return 1
}

// Send message via mailbox
fn mailbox_send(channel: u32, data: u64): u32 {
  if channel >= 16 { return 1 }

  // Wait for mailbox to be ready
  if mailbox_wait_write() != 0 {
    return 1
  }

  // BCM2711 uses bus address (add 0xC0000000 offset for GPU)
  let bus_addr: u64 = (data & 0x3FFFFFFF) | 0xC0000000

  // Combine data pointer (upper 28 bits) with channel (lower 4 bits)
  let msg: u32 = ((bus_addr & 0xFFFFFFF0) as u32) | (channel & 0xF)

  // Write message
  mailbox_write_reg(MAILBOX_WRITE, msg)

  return 0
}

// Receive message from mailbox
fn mailbox_receive(channel: u32): u32 {
  if channel >= 16 { return 0 }

  loop {
    // Wait for data
    if mailbox_wait_read() != 0 {
      return 0
    }

    // Read message
    let msg: u32 = mailbox_read_reg(MAILBOX_READ)
    let msg_channel: u32 = msg & 0xF

    // Check if it's for our channel
    if msg_channel == channel {
      return msg & 0xFFFFFFF0
    }
  }

  return 0
}

// Make mailbox property call
export fn mailbox_property_call(buffer: *u8, size: u32): u32 {
  if size > MAILBOX_BUFFER_SIZE { return 1 }

  mailbox_calls = mailbox_calls + 1

  // Copy buffer to aligned mailbox buffer
  memory.memcpy(&mailbox_buffer[0], buffer, size)

  // Get physical address of buffer
  let buffer_addr: u64 = &mailbox_buffer[0] as u64

  // Send via property channel
  if mailbox_send(MBOX_CH_PROPERTY, buffer_addr) != 0 {
    mailbox_errors = mailbox_errors + 1
    return 1
  }

  // Wait for response
  let response: u32 = mailbox_receive(MBOX_CH_PROPERTY)
  if response == 0 {
    mailbox_errors = mailbox_errors + 1
    return 1
  }

  // Check response code
  let response_code: u32 = memory.read_u32(&mailbox_buffer[4] as u64)
  if response_code != MBOX_RESPONSE_SUCCESS {
    mailbox_errors = mailbox_errors + 1
    return 1
  }

  // Copy response back
  memory.memcpy(buffer, &mailbox_buffer[0], size)

  return 0
}

// Get board revision
export fn mailbox_get_board_revision(): u32 {
  var buffer: [32]u8

  memory.write_u32(&buffer[0] as u64, 32)  // Buffer size
  memory.write_u32(&buffer[4] as u64, MBOX_REQUEST)  // Request code
  memory.write_u32(&buffer[8] as u64, TAG_GET_BOARD_REV)  // Tag ID
  memory.write_u32(&buffer[12] as u64, 4)  // Value buffer size
  memory.write_u32(&buffer[16] as u64, TAG_REQUEST)  // Request
  memory.write_u32(&buffer[20] as u64, 0)  // Revision (response)
  memory.write_u32(&buffer[24] as u64, 0)  // End tag

  if mailbox_property_call(&buffer[0], 32) != 0 {
    return 0
  }

  return memory.read_u32(&buffer[20] as u64)
}

// Get ARM memory
export fn mailbox_get_arm_memory(base: *u64, size: *u64): u32 {
  var buffer: [32]u8

  memory.write_u32(&buffer[0] as u64, 32)
  memory.write_u32(&buffer[4] as u64, MBOX_REQUEST)
  memory.write_u32(&buffer[8] as u64, TAG_GET_ARM_MEMORY)
  memory.write_u32(&buffer[12] as u64, 8)
  memory.write_u32(&buffer[16] as u64, TAG_REQUEST)
  memory.write_u32(&buffer[20] as u64, 0)  // Base address
  memory.write_u32(&buffer[24] as u64, 0)  // Size
  memory.write_u32(&buffer[28] as u64, 0)  // End tag

  if mailbox_property_call(&buffer[0], 32) != 0 {
    return 1
  }

  *base = memory.read_u32(&buffer[20] as u64) as u64
  *size = memory.read_u32(&buffer[24] as u64) as u64

  return 0
}

// Get clock rate
export fn mailbox_get_clock_rate(clock_id: u32): u32 {
  var buffer: [32]u8

  memory.write_u32(&buffer[0] as u64, 32)
  memory.write_u32(&buffer[4] as u64, MBOX_REQUEST)
  memory.write_u32(&buffer[8] as u64, TAG_GET_CLOCK_RATE)
  memory.write_u32(&buffer[12] as u64, 8)
  memory.write_u32(&buffer[16] as u64, TAG_REQUEST)
  memory.write_u32(&buffer[20] as u64, clock_id)
  memory.write_u32(&buffer[24] as u64, 0)  // Rate (response)
  memory.write_u32(&buffer[28] as u64, 0)  // End tag

  if mailbox_property_call(&buffer[0], 32) != 0 {
    return 0
  }

  return memory.read_u32(&buffer[24] as u64)
}

// Set clock rate
export fn mailbox_set_clock_rate(clock_id: u32, rate_hz: u32, skip_turbo: u32): u32 {
  var buffer: [40]u8

  memory.write_u32(&buffer[0] as u64, 40)
  memory.write_u32(&buffer[4] as u64, MBOX_REQUEST)
  memory.write_u32(&buffer[8] as u64, TAG_SET_CLOCK_RATE)
  memory.write_u32(&buffer[12] as u64, 12)
  memory.write_u32(&buffer[16] as u64, TAG_REQUEST)
  memory.write_u32(&buffer[20] as u64, clock_id)
  memory.write_u32(&buffer[24] as u64, rate_hz)
  memory.write_u32(&buffer[28] as u64, skip_turbo)
  memory.write_u32(&buffer[32] as u64, 0)  // End tag

  if mailbox_property_call(&buffer[0], 40) != 0 {
    return 1
  }

  return 0
}

// Get temperature
export fn mailbox_get_temperature(temp_id: u32): u32 {
  var buffer: [32]u8

  memory.write_u32(&buffer[0] as u64, 32)
  memory.write_u32(&buffer[4] as u64, MBOX_REQUEST)
  memory.write_u32(&buffer[8] as u64, TAG_GET_TEMPERATURE)
  memory.write_u32(&buffer[12] as u64, 8)
  memory.write_u32(&buffer[16] as u64, TAG_REQUEST)
  memory.write_u32(&buffer[20] as u64, temp_id)
  memory.write_u32(&buffer[24] as u64, 0)  // Temperature (response)
  memory.write_u32(&buffer[28] as u64, 0)  // End tag

  if mailbox_property_call(&buffer[0], 32) != 0 {
    return 0
  }

  return memory.read_u32(&buffer[24] as u64)
}

// Set power state
export fn mailbox_set_power_state(device_id: u32, state: u32): u32 {
  var buffer: [32]u8

  memory.write_u32(&buffer[0] as u64, 32)
  memory.write_u32(&buffer[4] as u64, MBOX_REQUEST)
  memory.write_u32(&buffer[8] as u64, TAG_SET_POWER_STATE)
  memory.write_u32(&buffer[12] as u64, 8)
  memory.write_u32(&buffer[16] as u64, TAG_REQUEST)
  memory.write_u32(&buffer[20] as u64, device_id)
  memory.write_u32(&buffer[24] as u64, state | (1 << 1))  // State + wait bit
  memory.write_u32(&buffer[28] as u64, 0)  // End tag

  if mailbox_property_call(&buffer[0], 32) != 0 {
    return 1
  }

  return 0
}

// Allocate framebuffer
export fn mailbox_allocate_framebuffer(width: u32, height: u32, depth: u32): u64 {
  var buffer: [256]u8
  var offset: u32 = 0

  // Buffer size and request code
  memory.write_u32(&buffer[0] as u64, 256)
  memory.write_u32(&buffer[4] as u64, MBOX_REQUEST)
  offset = 8

  // Set physical width/height
  memory.write_u32(&buffer[offset] as u64, TAG_SET_PHYSICAL_WH)
  memory.write_u32(&buffer[offset + 4] as u64, 8)
  memory.write_u32(&buffer[offset + 8] as u64, TAG_REQUEST)
  memory.write_u32(&buffer[offset + 12] as u64, width)
  memory.write_u32(&buffer[offset + 16] as u64, height)
  offset = offset + 20

  // Set virtual width/height
  memory.write_u32(&buffer[offset] as u64, TAG_SET_VIRTUAL_WH)
  memory.write_u32(&buffer[offset + 4] as u64, 8)
  memory.write_u32(&buffer[offset + 8] as u64, TAG_REQUEST)
  memory.write_u32(&buffer[offset + 12] as u64, width)
  memory.write_u32(&buffer[offset + 16] as u64, height)
  offset = offset + 20

  // Set depth
  memory.write_u32(&buffer[offset] as u64, TAG_SET_DEPTH)
  memory.write_u32(&buffer[offset + 4] as u64, 4)
  memory.write_u32(&buffer[offset + 8] as u64, TAG_REQUEST)
  memory.write_u32(&buffer[offset + 12] as u64, depth)
  offset = offset + 16

  // Allocate buffer
  memory.write_u32(&buffer[offset] as u64, TAG_ALLOCATE_BUFFER)
  memory.write_u32(&buffer[offset + 4] as u64, 8)
  memory.write_u32(&buffer[offset + 8] as u64, TAG_REQUEST)
  memory.write_u32(&buffer[offset + 12] as u64, 16)  // Alignment
  memory.write_u32(&buffer[offset + 16] as u64, 0)   // Response: address
  offset = offset + 20

  // End tag
  memory.write_u32(&buffer[offset] as u64, 0)

  if mailbox_property_call(&buffer[0], 256) != 0 {
    return 0
  }

  // Extract framebuffer address and convert from bus to ARM address
  let fb_addr: u32 = memory.read_u32(&buffer[64 + 12] as u64)

  // Convert GPU bus address to ARM physical address
  return (fb_addr & 0x3FFFFFFF) as u64
}

// Print statistics
export fn mailbox_print_stats() {
  foundation.serial_write_string("\n[VC6 Mailbox] Statistics:\n")

  foundation.serial_write_string("  Total calls: ")
  foundation.serial_write_u64(mailbox_calls)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Errors: ")
  foundation.serial_write_u64(mailbox_errors)
  foundation.serial_write_string("\n")

  foundation.serial_write_string("  Timeouts: ")
  foundation.serial_write_u64(mailbox_timeouts)
  foundation.serial_write_string("\n")

  if mailbox_calls > 0 {
    let success_rate: u64 = ((mailbox_calls - mailbox_errors) * 100) / mailbox_calls
    foundation.serial_write_string("  Success rate: ")
    foundation.serial_write_u64(success_rate)
    foundation.serial_write_string("%\n")
  }
}
