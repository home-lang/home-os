// home-os Kernel - Screen Reader
// Text-to-speech for accessibility

import "../core/foundation.home" as foundation

const MAX_SPEECH_QUEUE: u32 = 100

struct SpeechItem {
  text: [u8; 512],
  priority: u32,
  rate: u32,
  pitch: u32,
  volume: u32
}

var speech_queue: [SpeechItem; 100]
var queue_head: u32 = 0
var queue_tail: u32 = 0
var screen_reader_enabled: u32 = 0
var speech_rate: u32 = 150  // words per minute
var speech_pitch: u32 = 100  // percentage
var speech_volume: u32 = 80  // percentage

export fn screen_reader_init() {
  queue_head = 0
  queue_tail = 0
  screen_reader_enabled = 0
  
  foundation.serial_write_string("[ScreenReader] Initialized\n")
}

export fn screen_reader_enable() {
  screen_reader_enabled = 1
  screen_reader_speak(@ptrFromInt("Screen reader enabled"), 1)
}

export fn screen_reader_disable() {
  screen_reader_speak(@ptrFromInt("Screen reader disabled"), 1)
  screen_reader_enabled = 0
}

export fn screen_reader_speak(text: u64, priority: u32) -> u32 {
  if screen_reader_enabled == 0 { return 0 }
  
  var next_tail: u32 = (queue_tail + 1) % MAX_SPEECH_QUEUE
  if next_tail == queue_head { return 0 }  // Queue full
  
  // Copy text
  var i: u32 = 0
  while i < 511 {
    var ch: u8 = @intToPtr(text + i, u8)
    speech_queue[queue_tail].text[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  speech_queue[queue_tail].text[i] = 0
  
  speech_queue[queue_tail].priority = priority
  speech_queue[queue_tail].rate = speech_rate
  speech_queue[queue_tail].pitch = speech_pitch
  speech_queue[queue_tail].volume = speech_volume
  
  queue_tail = next_tail
  
  // Process queue
  screen_reader_process_queue()
  
  return 1
}

fn screen_reader_process_queue() {
  if queue_head == queue_tail { return }
  
  var item: SpeechItem = speech_queue[queue_head]
  
  // Send to TTS engine
  foundation.tts_speak(@ptrFromInt(item.text), item.rate, item.pitch, item.volume)
  
  queue_head = (queue_head + 1) % MAX_SPEECH_QUEUE
}

export fn screen_reader_set_rate(rate: u32) {
  speech_rate = rate
}

export fn screen_reader_set_pitch(pitch: u32) {
  speech_pitch = pitch
}

export fn screen_reader_set_volume(volume: u32) {
  speech_volume = volume
}

export fn screen_reader_is_enabled() -> u32 {
  return screen_reader_enabled
}

// Announce UI elements
export fn screen_reader_announce_focus(element_type: u64, element_text: u64) {
  if screen_reader_enabled == 0 { return }
  
  var announcement: [u8; 512]
  var pos: u32 = 0
  
  // Copy element type
  var i: u32 = 0
  while @intToPtr(element_type + i, u8) != 0 and pos < 500 {
    announcement[pos] = @intToPtr(element_type + i, u8)
    pos = pos + 1
    i = i + 1
  }
  
  announcement[pos] = ' '
  pos = pos + 1
  
  // Copy element text
  i = 0
  while @intToPtr(element_text + i, u8) != 0 and pos < 511 {
    announcement[pos] = @intToPtr(element_text + i, u8)
    pos = pos + 1
    i = i + 1
  }
  
  announcement[pos] = 0
  
  screen_reader_speak(@ptrFromInt(announcement), 0)
}
