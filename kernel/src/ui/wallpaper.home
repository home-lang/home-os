// home-os Kernel - Wallpaper Manager
// Desktop background management

import "../core/foundation.home" as foundation
import "../core/filesystem.home" as filesystem
import "../drivers/framebuffer.home" as framebuffer

const MAX_WALLPAPERS: u32 = 100
const WALLPAPER_DIR: u64 = @ptrFromInt("/usr/share/wallpapers")

struct Wallpaper {
  name: [u8; 128],
  path: [u8; 256],
  width: u32,
  height: u32
}

var wallpapers: [Wallpaper; 100]
var wallpaper_count: u32 = 0
var current_wallpaper: u32 = 0
var wallpaper_mode: u32 = 0  // 0=stretch, 1=fit, 2=fill, 3=tile

export fn wallpaper_init() {
  wallpaper_count = 0
  
  // Scan wallpaper directory
  wallpaper_scan_directory()
  
  foundation.serial_write_string("[Wallpaper] Initialized with ")
  foundation.serial_write_hex(wallpaper_count)
  foundation.serial_write_string(" wallpapers\n")
}

fn wallpaper_scan_directory() {
  // Scan directory for image files
  var entries: [u64; 256]
  var count: u32 = filesystem.vfs_readdir(WALLPAPER_DIR, @ptrFromInt(entries), 256)
  
  var i: u32 = 0
  while i < count and wallpaper_count < MAX_WALLPAPERS {
    var entry: u64 = entries[i]
    
    // Check if it's an image file
    if wallpaper_is_image(entry) == 1 {
      wallpaper_register(entry)
    }
    
    i = i + 1
  }
}

fn wallpaper_is_image(filename: u64): u32 {
  // Check file extension
  var len: u32 = 0
  while @intToPtr(filename + len, u8) != 0 { len = len + 1 }
  
  if len < 4 { return 0 }
  
  // Check for .png, .jpg, .bmp
  var ext: u32 = @intToPtr(filename + len - 3, u32)
  
  if ext == 0x676E70 { return 1 }  // png
  if ext == 0x67706A { return 1 }  // jpg
  if ext == 0x706D62 { return 1 }  // bmp
  
  return 0
}

fn wallpaper_register(filename: u64) {
  var id: u32 = wallpaper_count
  
  // Copy name
  var i: u32 = 0
  while i < 127 {
    var ch: u8 = @intToPtr(filename + i, u8)
    wallpapers[id].name[i] = ch
    if ch == 0 { break }
    i = i + 1
  }
  
  // Build full path
  wallpaper_build_path(@ptrFromInt(wallpapers[id].path), filename)
  
  wallpaper_count = wallpaper_count + 1
}

fn wallpaper_build_path(dest: u64, filename: u64) {
  var i: u32 = 0
  
  // Copy directory
  while @intToPtr(WALLPAPER_DIR + i, u8) != 0 {
    @intToPtr(dest + i, u8) = @intToPtr(WALLPAPER_DIR + i, u8)
    i = i + 1
  }
  
  @intToPtr(dest + i, u8) = '/'
  i = i + 1
  
  // Copy filename
  var j: u32 = 0
  while @intToPtr(filename + j, u8) != 0 {
    @intToPtr(dest + i, u8) = @intToPtr(filename + j, u8)
    i = i + 1
    j = j + 1
  }
  
  @intToPtr(dest + i, u8) = 0
}

export fn wallpaper_set(wallpaper_id: u32): u32 {
  if wallpaper_id >= wallpaper_count { return 0 }
  
  foundation.serial_write_string("[Wallpaper] Setting: ")
  foundation.serial_write_string(@ptrFromInt(wallpapers[wallpaper_id].name))
  foundation.serial_write_string("\n")
  
  current_wallpaper = wallpaper_id
  
  // Load and display wallpaper
  wallpaper_load_and_display(wallpaper_id)
  
  return 1
}

fn wallpaper_load_and_display(wallpaper_id: u32) {
  var path: u64 = @ptrFromInt(wallpapers[wallpaper_id].path)
  
  // Load image file
  var image_data: [u8; 8294400]  // 1920x1080x4
  var size: u32 = wallpaper_load_image(path, @ptrFromInt(image_data))
  
  if size == 0 { return }
  
  // Get framebuffer
  var fb: u64 = framebuffer.framebuffer_get_address()
  var fb_width: u32 = framebuffer.framebuffer_get_width()
  var fb_height: u32 = framebuffer.framebuffer_get_height()
  
  // Apply wallpaper based on mode
  if wallpaper_mode == 0 {
    wallpaper_stretch(@ptrFromInt(image_data), fb, fb_width, fb_height)
  } else if wallpaper_mode == 1 {
    wallpaper_fit(@ptrFromInt(image_data), fb, fb_width, fb_height)
  } else if wallpaper_mode == 2 {
    wallpaper_fill(@ptrFromInt(image_data), fb, fb_width, fb_height)
  } else if wallpaper_mode == 3 {
    wallpaper_tile(@ptrFromInt(image_data), fb, fb_width, fb_height)
  }
}

fn wallpaper_load_image(path: u64, buffer: u64): u32 {
  var fd: u32 = filesystem.vfs_open(path, 0x0000, 0)
  if fd == 0xFFFFFFFF { return 0 }
  
  var size: u32 = filesystem.vfs_read(fd, buffer, 8294400)
  filesystem.vfs_close(fd)
  
  return size
}

fn wallpaper_stretch(src: u64, dest: u64, width: u32, height: u32) {
  // Stretch image to fill screen
  foundation.memcpy(dest, src, width * height * 4)
}

fn wallpaper_fit(src: u64, dest: u64, width: u32, height: u32) {
  // Fit image maintaining aspect ratio
}

fn wallpaper_fill(src: u64, dest: u64, width: u32, height: u32) {
  // Fill screen, crop if needed
}

fn wallpaper_tile(src: u64, dest: u64, width: u32, height: u32) {
  // Tile image across screen
}

export fn wallpaper_set_mode(mode: u32) {
  wallpaper_mode = mode
  
  // Reapply current wallpaper
  wallpaper_load_and_display(current_wallpaper)
}

export fn wallpaper_list() {
  foundation.serial_write_string("\n[Wallpaper] Available wallpapers:\n")
  
  var i: u32 = 0
  while i < wallpaper_count {
    foundation.serial_write_string("  ")
    foundation.serial_write_hex(i)
    foundation.serial_write_string(": ")
    foundation.serial_write_string(@ptrFromInt(wallpapers[i].name))
    
    if i == current_wallpaper {
      foundation.serial_write_string(" (active)")
    }
    
    foundation.serial_write_string("\n")
    i = i + 1
  }
}
