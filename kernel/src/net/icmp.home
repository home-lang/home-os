// home-os ICMP Protocol
// Internet Control Message Protocol - Full Implementation

import "../core/foundation.home" as foundation
import "../drivers/e1000.home" as e1000

// ============================================================================
// Constants - ICMP Types
// ============================================================================

const ICMP_ECHO_REPLY: u8 = 0
const ICMP_DEST_UNREACHABLE: u8 = 3
const ICMP_SOURCE_QUENCH: u8 = 4
const ICMP_REDIRECT: u8 = 5
const ICMP_ECHO_REQUEST: u8 = 8
const ICMP_ROUTER_ADVERTISEMENT: u8 = 9
const ICMP_ROUTER_SOLICITATION: u8 = 10
const ICMP_TIME_EXCEEDED: u8 = 11
const ICMP_PARAM_PROBLEM: u8 = 12
const ICMP_TIMESTAMP_REQUEST: u8 = 13
const ICMP_TIMESTAMP_REPLY: u8 = 14
const ICMP_INFO_REQUEST: u8 = 15
const ICMP_INFO_REPLY: u8 = 16
const ICMP_ADDR_MASK_REQUEST: u8 = 17
const ICMP_ADDR_MASK_REPLY: u8 = 18

// ============================================================================
// Constants - Destination Unreachable Codes
// ============================================================================

const ICMP_NET_UNREACHABLE: u8 = 0
const ICMP_HOST_UNREACHABLE: u8 = 1
const ICMP_PROTOCOL_UNREACHABLE: u8 = 2
const ICMP_PORT_UNREACHABLE: u8 = 3
const ICMP_FRAG_NEEDED: u8 = 4
const ICMP_SOURCE_ROUTE_FAILED: u8 = 5
const ICMP_DEST_NET_UNKNOWN: u8 = 6
const ICMP_DEST_HOST_UNKNOWN: u8 = 7
const ICMP_SOURCE_HOST_ISOLATED: u8 = 8
const ICMP_NET_PROHIBITED: u8 = 9
const ICMP_HOST_PROHIBITED: u8 = 10
const ICMP_NET_UNREACHABLE_TOS: u8 = 11
const ICMP_HOST_UNREACHABLE_TOS: u8 = 12
const ICMP_COMM_PROHIBITED: u8 = 13
const ICMP_HOST_PRECEDENCE_VIOLATION: u8 = 14
const ICMP_PRECEDENCE_CUTOFF: u8 = 15

// ============================================================================
// Constants - Time Exceeded Codes
// ============================================================================

const ICMP_TTL_EXCEEDED: u8 = 0
const ICMP_FRAG_REASSEMBLY_EXCEEDED: u8 = 1

// ============================================================================
// Constants - Redirect Codes
// ============================================================================

const ICMP_REDIRECT_NET: u8 = 0
const ICMP_REDIRECT_HOST: u8 = 1
const ICMP_REDIRECT_TOS_NET: u8 = 2
const ICMP_REDIRECT_TOS_HOST: u8 = 3

// ============================================================================
// Constants - Other
// ============================================================================

const ICMP_HEADER_SIZE: u32 = 8
const MAX_PING_DATA_SIZE: u32 = 1472  // MTU - IP header - ICMP header
const MAX_PENDING_PINGS: u32 = 64
const PING_TIMEOUT_MS: u64 = 5000
const IP_PROTO_ICMP: u8 = 1

// ============================================================================
// Data Structures
// ============================================================================

struct ICMPHeader {
    type_: u8,
    code: u8,
    checksum: u16,
    // Rest depends on message type
}

struct ICMPEchoHeader {
    type_: u8,
    code: u8,
    checksum: u16,
    identifier: u16,
    sequence: u16
}

struct ICMPDestUnreachable {
    type_: u8,
    code: u8,
    checksum: u16,
    unused: u16,
    next_hop_mtu: u16  // Only for code 4 (fragmentation needed)
    // Followed by original IP header + 8 bytes of original datagram
}

struct ICMPTimeExceeded {
    type_: u8,
    code: u8,
    checksum: u16,
    unused: u32
    // Followed by original IP header + 8 bytes of original datagram
}

struct ICMPRedirect {
    type_: u8,
    code: u8,
    checksum: u16,
    gateway: u32  // IP address of better gateway
    // Followed by original IP header + 8 bytes of original datagram
}

struct ICMPTimestamp {
    type_: u8,
    code: u8,
    checksum: u16,
    identifier: u16,
    sequence: u16,
    originate_timestamp: u32,
    receive_timestamp: u32,
    transmit_timestamp: u32
}

struct ICMPAddressMask {
    type_: u8,
    code: u8,
    checksum: u16,
    identifier: u16,
    sequence: u16,
    address_mask: u32
}

struct ICMPRouterAdvertEntry {
    router_addr: u32,
    preference: i32
}

struct ICMPRouterAdvert {
    type_: u8,
    code: u8,
    checksum: u16,
    num_addrs: u8,
    addr_entry_size: u8,  // In 32-bit words
    lifetime: u16
    // Followed by router entries
}

struct PendingPing {
    identifier: u16,
    sequence: u16,
    dst_ip: u32,
    send_time: u64,
    rtt_us: u32,
    received: u32,
    active: u32
}

struct ICMPStats {
    echo_requests_sent: u64,
    echo_requests_received: u64,
    echo_replies_sent: u64,
    echo_replies_received: u64,
    dest_unreachable_sent: u64,
    dest_unreachable_received: u64,
    time_exceeded_sent: u64,
    time_exceeded_received: u64,
    redirect_received: u64,
    timestamp_requests: u64,
    timestamp_replies: u64,
    address_mask_requests: u64,
    address_mask_replies: u64,
    checksum_errors: u64,
    unknown_types: u64,
    total_sent: u64,
    total_received: u64
}

struct ICMPState {
    initialized: u32,
    identifier: u16,
    sequence: u16,
    local_ip: u32,
    netmask: u32,
    gateway: u32,

    // Pending pings for RTT tracking
    pending_pings: [PendingPing; 64],

    // Statistics
    stats: ICMPStats,

    // Callback for received ICMP messages
    // These would be set by higher layers
    on_echo_reply: u64,  // Function pointer
    on_dest_unreachable: u64,
    on_redirect: u64
}

// ============================================================================
// Global State
// ============================================================================

var icmp_state: ICMPState

// ============================================================================
// Utility Functions
// ============================================================================

fn calculate_checksum(data: *u8, length: u32): u16 {
    var sum: u32 = 0
    var i: u32 = 0

    // Sum 16-bit words
    while i + 1 < length {
        let word: u16 = ((data[i] as u16) << 8) | (data[i + 1] as u16)
        sum = sum + word as u32
        i = i + 2
    }

    // Handle odd byte
    if i < length {
        sum = sum + ((data[i] as u32) << 8)
    }

    // Fold 32-bit sum to 16 bits
    while (sum >> 16) != 0 {
        sum = (sum & 0xFFFF) + (sum >> 16)
    }

    return ~(sum as u16)
}

fn get_timestamp_ms(): u64 {
    // Returns milliseconds since midnight UTC
    // In real implementation, would use RTC
    // For now, return a counter
    return foundation.get_ticks() / 1000
}

fn get_time_us(): u64 {
    return foundation.get_ticks()
}

fn htons(x: u16): u16 {
    return ((x & 0xFF) << 8) | ((x >> 8) & 0xFF)
}

fn htonl(x: u32): u32 {
    return ((x & 0xFF) << 24) | ((x & 0xFF00) << 8) | ((x >> 8) & 0xFF00) | ((x >> 24) & 0xFF)
}

fn ntohs(x: u16): u16 {
    return htons(x)
}

fn ntohl(x: u32): u32 {
    return htonl(x)
}

// ============================================================================
// Initialization
// ============================================================================

export fn icmp_init() {
    foundation.mem_set(&icmp_state as *u8, 0, @sizeOf(ICMPState))

    icmp_state.identifier = 0x1234  // Process identifier (simplified)
    icmp_state.sequence = 0
    icmp_state.local_ip = 0x0A000002  // 10.0.0.2 default
    icmp_state.netmask = 0xFFFFFF00  // 255.255.255.0
    icmp_state.gateway = 0x0A000001  // 10.0.0.1

    icmp_state.initialized = 1

    foundation.serial_write_string("[ICMP] Initialized\n")
}

export fn icmp_set_addresses(local_ip: u32, netmask: u32, gateway: u32) {
    icmp_state.local_ip = local_ip
    icmp_state.netmask = netmask
    icmp_state.gateway = gateway
}

// ============================================================================
// Packet Building Helpers
// ============================================================================

fn build_ethernet_header(packet: *u8, dst_ip: u32): u32 {
    var offset: u32 = 0

    // Destination MAC (broadcast for now, should use ARP)
    var i: u32 = 0
    while i < 6 {
        packet[offset + i] = 0xFF
        i = i + 1
    }
    offset = offset + 6

    // Source MAC
    e1000.e1000_get_mac_address(&packet[offset])
    offset = offset + 6

    // EtherType: IPv4
    packet[offset] = 0x08
    packet[offset + 1] = 0x00
    offset = offset + 2

    return offset
}

fn build_ip_header(packet: *u8, offset: u32, dst_ip: u32, payload_len: u32, ttl: u8): u32 {
    let total_len: u16 = (20 + payload_len) as u16

    packet[offset] = 0x45  // Version 4, IHL 5
    packet[offset + 1] = 0x00  // DSCP, ECN
    packet[offset + 2] = ((total_len >> 8) & 0xFF) as u8
    packet[offset + 3] = (total_len & 0xFF) as u8
    packet[offset + 4] = 0x00  // Identification
    packet[offset + 5] = 0x00
    packet[offset + 6] = 0x00  // Flags, fragment offset
    packet[offset + 7] = 0x00
    packet[offset + 8] = ttl
    packet[offset + 9] = IP_PROTO_ICMP
    packet[offset + 10] = 0x00  // Header checksum (placeholder)
    packet[offset + 11] = 0x00

    // Source IP
    packet[offset + 12] = ((icmp_state.local_ip >> 24) & 0xFF) as u8
    packet[offset + 13] = ((icmp_state.local_ip >> 16) & 0xFF) as u8
    packet[offset + 14] = ((icmp_state.local_ip >> 8) & 0xFF) as u8
    packet[offset + 15] = (icmp_state.local_ip & 0xFF) as u8

    // Destination IP
    packet[offset + 16] = ((dst_ip >> 24) & 0xFF) as u8
    packet[offset + 17] = ((dst_ip >> 16) & 0xFF) as u8
    packet[offset + 18] = ((dst_ip >> 8) & 0xFF) as u8
    packet[offset + 19] = (dst_ip & 0xFF) as u8

    // Calculate IP header checksum
    let ip_checksum: u16 = calculate_checksum(&packet[offset], 20)
    packet[offset + 10] = ((ip_checksum >> 8) & 0xFF) as u8
    packet[offset + 11] = (ip_checksum & 0xFF) as u8

    return offset + 20
}

// ============================================================================
// Echo Request/Reply (Ping)
// ============================================================================

export fn icmp_ping(dst_ip: u32): u32 {
    return icmp_ping_with_data(dst_ip, null, 32)
}

export fn icmp_ping_with_data(dst_ip: u32, data: *u8, data_len: u32): u32 {
    if data_len > MAX_PING_DATA_SIZE {
        return 0
    }

    var packet: [u8; 1518]
    var offset: u32 = 0

    // Ethernet header
    offset = build_ethernet_header(&packet[0], dst_ip)

    // IP header
    let icmp_len: u32 = 8 + data_len
    offset = build_ip_header(&packet[0], offset, dst_ip, icmp_len, 64)

    // ICMP Echo Request
    let icmp_start: u32 = offset
    packet[offset] = ICMP_ECHO_REQUEST
    packet[offset + 1] = 0  // Code
    packet[offset + 2] = 0  // Checksum (placeholder)
    packet[offset + 3] = 0
    packet[offset + 4] = ((icmp_state.identifier >> 8) & 0xFF) as u8
    packet[offset + 5] = (icmp_state.identifier & 0xFF) as u8
    packet[offset + 6] = ((icmp_state.sequence >> 8) & 0xFF) as u8
    packet[offset + 7] = (icmp_state.sequence & 0xFF) as u8
    offset = offset + 8

    // Payload data
    if data != null {
        var i: u32 = 0
        while i < data_len {
            packet[offset + i] = data[i]
            i = i + 1
        }
    } else {
        // Default pattern
        var i: u32 = 0
        while i < data_len {
            packet[offset + i] = (i & 0xFF) as u8
            i = i + 1
        }
    }
    offset = offset + data_len

    // Calculate ICMP checksum
    let checksum: u16 = calculate_checksum(&packet[icmp_start], icmp_len)
    packet[icmp_start + 2] = ((checksum >> 8) & 0xFF) as u8
    packet[icmp_start + 3] = (checksum & 0xFF) as u8

    // Record pending ping for RTT measurement
    let ping_idx: u32 = find_free_pending_ping()
    if ping_idx != 0xFFFFFFFF {
        let pending: *PendingPing = &icmp_state.pending_pings[ping_idx]
        pending.identifier = icmp_state.identifier
        pending.sequence = icmp_state.sequence
        pending.dst_ip = dst_ip
        pending.send_time = get_time_us()
        pending.rtt_us = 0
        pending.received = 0
        pending.active = 1
    }

    icmp_state.sequence = icmp_state.sequence + 1
    icmp_state.stats.echo_requests_sent = icmp_state.stats.echo_requests_sent + 1
    icmp_state.stats.total_sent = icmp_state.stats.total_sent + 1

    let result: u32 = e1000.e1000_send_packet(&packet[0], offset)
    return if result != 0 { icmp_state.sequence - 1 } else { 0xFFFF }
}

fn find_free_pending_ping(): u32 {
    var i: u32 = 0
    while i < MAX_PENDING_PINGS {
        if icmp_state.pending_pings[i].active == 0 {
            return i
        }
        i = i + 1
    }
    return 0xFFFFFFFF
}

fn find_pending_ping(identifier: u16, sequence: u16): u32 {
    var i: u32 = 0
    while i < MAX_PENDING_PINGS {
        let pending: *PendingPing = &icmp_state.pending_pings[i]
        if pending.active == 1 and pending.identifier == identifier and pending.sequence == sequence {
            return i
        }
        i = i + 1
    }
    return 0xFFFFFFFF
}

export fn icmp_get_ping_rtt(sequence: u16): i32 {
    var i: u32 = 0
    while i < MAX_PENDING_PINGS {
        let pending: *PendingPing = &icmp_state.pending_pings[i]
        if pending.active == 1 and pending.sequence == sequence {
            if pending.received == 1 {
                return pending.rtt_us as i32
            }
            return -1  // Not received yet
        }
        i = i + 1
    }
    return -2  // Not found
}

fn send_echo_reply(src_ip: u32, identifier: u16, sequence: u16, data: *u8, data_len: u32) {
    var packet: [u8; 1518]
    var offset: u32 = 0

    // Ethernet header
    offset = build_ethernet_header(&packet[0], src_ip)

    // IP header
    let icmp_len: u32 = 8 + data_len
    offset = build_ip_header(&packet[0], offset, src_ip, icmp_len, 64)

    // ICMP Echo Reply
    let icmp_start: u32 = offset
    packet[offset] = ICMP_ECHO_REPLY
    packet[offset + 1] = 0
    packet[offset + 2] = 0  // Checksum placeholder
    packet[offset + 3] = 0
    packet[offset + 4] = ((identifier >> 8) & 0xFF) as u8
    packet[offset + 5] = (identifier & 0xFF) as u8
    packet[offset + 6] = ((sequence >> 8) & 0xFF) as u8
    packet[offset + 7] = (sequence & 0xFF) as u8
    offset = offset + 8

    // Copy payload data
    var i: u32 = 0
    while i < data_len {
        packet[offset + i] = data[i]
        i = i + 1
    }
    offset = offset + data_len

    // Calculate checksum
    let checksum: u16 = calculate_checksum(&packet[icmp_start], icmp_len)
    packet[icmp_start + 2] = ((checksum >> 8) & 0xFF) as u8
    packet[icmp_start + 3] = (checksum & 0xFF) as u8

    e1000.e1000_send_packet(&packet[0], offset)

    icmp_state.stats.echo_replies_sent = icmp_state.stats.echo_replies_sent + 1
    icmp_state.stats.total_sent = icmp_state.stats.total_sent + 1
}

// ============================================================================
// Destination Unreachable
// ============================================================================

export fn icmp_send_dest_unreachable(dst_ip: u32, code: u8, original_ip_header: *u8, mtu: u16) {
    var packet: [u8; 1518]
    var offset: u32 = 0

    // Ethernet header
    offset = build_ethernet_header(&packet[0], dst_ip)

    // IP header - ICMP dest unreachable includes original IP header + 8 bytes
    let icmp_len: u32 = 8 + 20 + 8  // Header + original IP + 8 bytes
    offset = build_ip_header(&packet[0], offset, dst_ip, icmp_len, 64)

    // ICMP Destination Unreachable
    let icmp_start: u32 = offset
    packet[offset] = ICMP_DEST_UNREACHABLE
    packet[offset + 1] = code
    packet[offset + 2] = 0  // Checksum placeholder
    packet[offset + 3] = 0
    packet[offset + 4] = 0  // Unused
    packet[offset + 5] = 0

    // Next-hop MTU for fragmentation needed (code 4)
    if code == ICMP_FRAG_NEEDED {
        packet[offset + 6] = ((mtu >> 8) & 0xFF) as u8
        packet[offset + 7] = (mtu & 0xFF) as u8
    } else {
        packet[offset + 6] = 0
        packet[offset + 7] = 0
    }
    offset = offset + 8

    // Copy original IP header + 8 bytes
    var i: u32 = 0
    while i < 28 {
        packet[offset + i] = original_ip_header[i]
        i = i + 1
    }
    offset = offset + 28

    // Calculate checksum
    let checksum: u16 = calculate_checksum(&packet[icmp_start], icmp_len)
    packet[icmp_start + 2] = ((checksum >> 8) & 0xFF) as u8
    packet[icmp_start + 3] = (checksum & 0xFF) as u8

    e1000.e1000_send_packet(&packet[0], offset)

    icmp_state.stats.dest_unreachable_sent = icmp_state.stats.dest_unreachable_sent + 1
    icmp_state.stats.total_sent = icmp_state.stats.total_sent + 1
}

export fn icmp_send_port_unreachable(dst_ip: u32, original_ip_header: *u8) {
    icmp_send_dest_unreachable(dst_ip, ICMP_PORT_UNREACHABLE, original_ip_header, 0)
}

export fn icmp_send_host_unreachable(dst_ip: u32, original_ip_header: *u8) {
    icmp_send_dest_unreachable(dst_ip, ICMP_HOST_UNREACHABLE, original_ip_header, 0)
}

export fn icmp_send_net_unreachable(dst_ip: u32, original_ip_header: *u8) {
    icmp_send_dest_unreachable(dst_ip, ICMP_NET_UNREACHABLE, original_ip_header, 0)
}

export fn icmp_send_frag_needed(dst_ip: u32, original_ip_header: *u8, mtu: u16) {
    icmp_send_dest_unreachable(dst_ip, ICMP_FRAG_NEEDED, original_ip_header, mtu)
}

// ============================================================================
// Time Exceeded
// ============================================================================

export fn icmp_send_time_exceeded(dst_ip: u32, code: u8, original_ip_header: *u8) {
    var packet: [u8; 1518]
    var offset: u32 = 0

    // Ethernet header
    offset = build_ethernet_header(&packet[0], dst_ip)

    // IP header
    let icmp_len: u32 = 8 + 20 + 8
    offset = build_ip_header(&packet[0], offset, dst_ip, icmp_len, 64)

    // ICMP Time Exceeded
    let icmp_start: u32 = offset
    packet[offset] = ICMP_TIME_EXCEEDED
    packet[offset + 1] = code
    packet[offset + 2] = 0
    packet[offset + 3] = 0
    packet[offset + 4] = 0  // Unused
    packet[offset + 5] = 0
    packet[offset + 6] = 0
    packet[offset + 7] = 0
    offset = offset + 8

    // Copy original IP header + 8 bytes
    var i: u32 = 0
    while i < 28 {
        packet[offset + i] = original_ip_header[i]
        i = i + 1
    }
    offset = offset + 28

    // Calculate checksum
    let checksum: u16 = calculate_checksum(&packet[icmp_start], icmp_len)
    packet[icmp_start + 2] = ((checksum >> 8) & 0xFF) as u8
    packet[icmp_start + 3] = (checksum & 0xFF) as u8

    e1000.e1000_send_packet(&packet[0], offset)

    icmp_state.stats.time_exceeded_sent = icmp_state.stats.time_exceeded_sent + 1
    icmp_state.stats.total_sent = icmp_state.stats.total_sent + 1
}

export fn icmp_send_ttl_exceeded(dst_ip: u32, original_ip_header: *u8) {
    icmp_send_time_exceeded(dst_ip, ICMP_TTL_EXCEEDED, original_ip_header)
}

// ============================================================================
// Timestamp Request/Reply
// ============================================================================

export fn icmp_send_timestamp_request(dst_ip: u32): u16 {
    var packet: [u8; 1518]
    var offset: u32 = 0

    // Ethernet header
    offset = build_ethernet_header(&packet[0], dst_ip)

    // IP header
    let icmp_len: u32 = 20  // Timestamp message is 20 bytes
    offset = build_ip_header(&packet[0], offset, dst_ip, icmp_len, 64)

    // ICMP Timestamp Request
    let icmp_start: u32 = offset
    packet[offset] = ICMP_TIMESTAMP_REQUEST
    packet[offset + 1] = 0
    packet[offset + 2] = 0
    packet[offset + 3] = 0
    packet[offset + 4] = ((icmp_state.identifier >> 8) & 0xFF) as u8
    packet[offset + 5] = (icmp_state.identifier & 0xFF) as u8
    packet[offset + 6] = ((icmp_state.sequence >> 8) & 0xFF) as u8
    packet[offset + 7] = (icmp_state.sequence & 0xFF) as u8

    // Originate timestamp (milliseconds since midnight UTC)
    let timestamp: u32 = (get_timestamp_ms() % 86400000) as u32
    packet[offset + 8] = ((timestamp >> 24) & 0xFF) as u8
    packet[offset + 9] = ((timestamp >> 16) & 0xFF) as u8
    packet[offset + 10] = ((timestamp >> 8) & 0xFF) as u8
    packet[offset + 11] = (timestamp & 0xFF) as u8

    // Receive timestamp (filled by receiver)
    packet[offset + 12] = 0
    packet[offset + 13] = 0
    packet[offset + 14] = 0
    packet[offset + 15] = 0

    // Transmit timestamp (filled by receiver)
    packet[offset + 16] = 0
    packet[offset + 17] = 0
    packet[offset + 18] = 0
    packet[offset + 19] = 0

    offset = offset + 20

    // Calculate checksum
    let checksum: u16 = calculate_checksum(&packet[icmp_start], icmp_len)
    packet[icmp_start + 2] = ((checksum >> 8) & 0xFF) as u8
    packet[icmp_start + 3] = (checksum & 0xFF) as u8

    let seq: u16 = icmp_state.sequence
    icmp_state.sequence = icmp_state.sequence + 1

    e1000.e1000_send_packet(&packet[0], offset)

    icmp_state.stats.timestamp_requests = icmp_state.stats.timestamp_requests + 1
    icmp_state.stats.total_sent = icmp_state.stats.total_sent + 1

    return seq
}

fn send_timestamp_reply(dst_ip: u32, identifier: u16, sequence: u16, originate_ts: u32) {
    var packet: [u8; 1518]
    var offset: u32 = 0

    offset = build_ethernet_header(&packet[0], dst_ip)

    let icmp_len: u32 = 20
    offset = build_ip_header(&packet[0], offset, dst_ip, icmp_len, 64)

    let icmp_start: u32 = offset
    let now: u32 = (get_timestamp_ms() % 86400000) as u32

    packet[offset] = ICMP_TIMESTAMP_REPLY
    packet[offset + 1] = 0
    packet[offset + 2] = 0
    packet[offset + 3] = 0
    packet[offset + 4] = ((identifier >> 8) & 0xFF) as u8
    packet[offset + 5] = (identifier & 0xFF) as u8
    packet[offset + 6] = ((sequence >> 8) & 0xFF) as u8
    packet[offset + 7] = (sequence & 0xFF) as u8

    // Originate timestamp (from request)
    packet[offset + 8] = ((originate_ts >> 24) & 0xFF) as u8
    packet[offset + 9] = ((originate_ts >> 16) & 0xFF) as u8
    packet[offset + 10] = ((originate_ts >> 8) & 0xFF) as u8
    packet[offset + 11] = (originate_ts & 0xFF) as u8

    // Receive timestamp
    packet[offset + 12] = ((now >> 24) & 0xFF) as u8
    packet[offset + 13] = ((now >> 16) & 0xFF) as u8
    packet[offset + 14] = ((now >> 8) & 0xFF) as u8
    packet[offset + 15] = (now & 0xFF) as u8

    // Transmit timestamp
    packet[offset + 16] = ((now >> 24) & 0xFF) as u8
    packet[offset + 17] = ((now >> 16) & 0xFF) as u8
    packet[offset + 18] = ((now >> 8) & 0xFF) as u8
    packet[offset + 19] = (now & 0xFF) as u8

    offset = offset + 20

    let checksum: u16 = calculate_checksum(&packet[icmp_start], icmp_len)
    packet[icmp_start + 2] = ((checksum >> 8) & 0xFF) as u8
    packet[icmp_start + 3] = (checksum & 0xFF) as u8

    e1000.e1000_send_packet(&packet[0], offset)

    icmp_state.stats.timestamp_replies = icmp_state.stats.timestamp_replies + 1
    icmp_state.stats.total_sent = icmp_state.stats.total_sent + 1
}

// ============================================================================
// Address Mask Request/Reply
// ============================================================================

export fn icmp_send_addr_mask_request(dst_ip: u32): u16 {
    var packet: [u8; 1518]
    var offset: u32 = 0

    offset = build_ethernet_header(&packet[0], dst_ip)

    let icmp_len: u32 = 12
    offset = build_ip_header(&packet[0], offset, dst_ip, icmp_len, 64)

    let icmp_start: u32 = offset
    packet[offset] = ICMP_ADDR_MASK_REQUEST
    packet[offset + 1] = 0
    packet[offset + 2] = 0
    packet[offset + 3] = 0
    packet[offset + 4] = ((icmp_state.identifier >> 8) & 0xFF) as u8
    packet[offset + 5] = (icmp_state.identifier & 0xFF) as u8
    packet[offset + 6] = ((icmp_state.sequence >> 8) & 0xFF) as u8
    packet[offset + 7] = (icmp_state.sequence & 0xFF) as u8

    // Address mask (0 in request)
    packet[offset + 8] = 0
    packet[offset + 9] = 0
    packet[offset + 10] = 0
    packet[offset + 11] = 0

    offset = offset + 12

    let checksum: u16 = calculate_checksum(&packet[icmp_start], icmp_len)
    packet[icmp_start + 2] = ((checksum >> 8) & 0xFF) as u8
    packet[icmp_start + 3] = (checksum & 0xFF) as u8

    let seq: u16 = icmp_state.sequence
    icmp_state.sequence = icmp_state.sequence + 1

    e1000.e1000_send_packet(&packet[0], offset)

    icmp_state.stats.address_mask_requests = icmp_state.stats.address_mask_requests + 1
    icmp_state.stats.total_sent = icmp_state.stats.total_sent + 1

    return seq
}

fn send_addr_mask_reply(dst_ip: u32, identifier: u16, sequence: u16) {
    var packet: [u8; 1518]
    var offset: u32 = 0

    offset = build_ethernet_header(&packet[0], dst_ip)

    let icmp_len: u32 = 12
    offset = build_ip_header(&packet[0], offset, dst_ip, icmp_len, 64)

    let icmp_start: u32 = offset
    packet[offset] = ICMP_ADDR_MASK_REPLY
    packet[offset + 1] = 0
    packet[offset + 2] = 0
    packet[offset + 3] = 0
    packet[offset + 4] = ((identifier >> 8) & 0xFF) as u8
    packet[offset + 5] = (identifier & 0xFF) as u8
    packet[offset + 6] = ((sequence >> 8) & 0xFF) as u8
    packet[offset + 7] = (sequence & 0xFF) as u8

    // Address mask
    packet[offset + 8] = ((icmp_state.netmask >> 24) & 0xFF) as u8
    packet[offset + 9] = ((icmp_state.netmask >> 16) & 0xFF) as u8
    packet[offset + 10] = ((icmp_state.netmask >> 8) & 0xFF) as u8
    packet[offset + 11] = (icmp_state.netmask & 0xFF) as u8

    offset = offset + 12

    let checksum: u16 = calculate_checksum(&packet[icmp_start], icmp_len)
    packet[icmp_start + 2] = ((checksum >> 8) & 0xFF) as u8
    packet[icmp_start + 3] = (checksum & 0xFF) as u8

    e1000.e1000_send_packet(&packet[0], offset)

    icmp_state.stats.address_mask_replies = icmp_state.stats.address_mask_replies + 1
    icmp_state.stats.total_sent = icmp_state.stats.total_sent + 1
}

// ============================================================================
// Packet Input Handler
// ============================================================================

export fn icmp_input(src_ip: u32, dst_ip: u32, data: *u8, len: u32) {
    if len < ICMP_HEADER_SIZE {
        return
    }

    // Verify checksum
    let received_checksum: u16 = calculate_checksum(data, len)
    if received_checksum != 0 and received_checksum != 0xFFFF {
        icmp_state.stats.checksum_errors = icmp_state.stats.checksum_errors + 1
        return
    }

    let type_: u8 = data[0]
    let code: u8 = data[1]

    icmp_state.stats.total_received = icmp_state.stats.total_received + 1

    switch type_ {
        ICMP_ECHO_REQUEST => {
            icmp_state.stats.echo_requests_received = icmp_state.stats.echo_requests_received + 1
            handle_echo_request(src_ip, data, len)
        }
        ICMP_ECHO_REPLY => {
            icmp_state.stats.echo_replies_received = icmp_state.stats.echo_replies_received + 1
            handle_echo_reply(src_ip, data, len)
        }
        ICMP_DEST_UNREACHABLE => {
            icmp_state.stats.dest_unreachable_received = icmp_state.stats.dest_unreachable_received + 1
            handle_dest_unreachable(src_ip, data, len)
        }
        ICMP_TIME_EXCEEDED => {
            icmp_state.stats.time_exceeded_received = icmp_state.stats.time_exceeded_received + 1
            handle_time_exceeded(src_ip, data, len)
        }
        ICMP_REDIRECT => {
            icmp_state.stats.redirect_received = icmp_state.stats.redirect_received + 1
            handle_redirect(src_ip, data, len)
        }
        ICMP_TIMESTAMP_REQUEST => {
            handle_timestamp_request(src_ip, data, len)
        }
        ICMP_TIMESTAMP_REPLY => {
            icmp_state.stats.timestamp_replies = icmp_state.stats.timestamp_replies + 1
            handle_timestamp_reply(src_ip, data, len)
        }
        ICMP_ADDR_MASK_REQUEST => {
            handle_addr_mask_request(src_ip, data, len)
        }
        ICMP_ADDR_MASK_REPLY => {
            icmp_state.stats.address_mask_replies = icmp_state.stats.address_mask_replies + 1
            handle_addr_mask_reply(src_ip, data, len)
        }
        else => {
            icmp_state.stats.unknown_types = icmp_state.stats.unknown_types + 1
            foundation.serial_write_string("[ICMP] Unknown type: ")
            foundation.serial_write_u32(type_ as u32)
            foundation.serial_write_string("\n")
        }
    }
}

fn handle_echo_request(src_ip: u32, data: *u8, len: u32) {
    if len < 8 {
        return
    }

    let identifier: u16 = ((data[4] as u16) << 8) | (data[5] as u16)
    let sequence: u16 = ((data[6] as u16) << 8) | (data[7] as u16)
    let data_len: u32 = len - 8

    // Send echo reply with same data
    send_echo_reply(src_ip, identifier, sequence, &data[8], data_len)
}

fn handle_echo_reply(src_ip: u32, data: *u8, len: u32) {
    if len < 8 {
        return
    }

    let identifier: u16 = ((data[4] as u16) << 8) | (data[5] as u16)
    let sequence: u16 = ((data[6] as u16) << 8) | (data[7] as u16)

    // Find pending ping and calculate RTT
    let idx: u32 = find_pending_ping(identifier, sequence)
    if idx != 0xFFFFFFFF {
        let pending: *PendingPing = &icmp_state.pending_pings[idx]
        let now: u64 = get_time_us()
        pending.rtt_us = (now - pending.send_time) as u32
        pending.received = 1

        foundation.serial_write_string("[ICMP] Reply from ")
        print_ip(src_ip)
        foundation.serial_write_string(": seq=")
        foundation.serial_write_u32(sequence as u32)
        foundation.serial_write_string(" time=")
        foundation.serial_write_u32(pending.rtt_us / 1000)
        foundation.serial_write_string(".")
        foundation.serial_write_u32(pending.rtt_us % 1000)
        foundation.serial_write_string("ms\n")
    }
}

fn handle_dest_unreachable(src_ip: u32, data: *u8, len: u32) {
    if len < 8 {
        return
    }

    let code: u8 = data[1]

    foundation.serial_write_string("[ICMP] Destination unreachable from ")
    print_ip(src_ip)
    foundation.serial_write_string(": code=")
    foundation.serial_write_u32(code as u32)
    foundation.serial_write_string("\n")

    // Extract original packet info if available
    if len >= 36 {  // 8 + 20 + 8
        let orig_dst_ip: u32 = ((data[24] as u32) << 24) | ((data[25] as u32) << 16) |
                               ((data[26] as u32) << 8) | (data[27] as u32)
        foundation.serial_write_string("  Original destination: ")
        print_ip(orig_dst_ip)
        foundation.serial_write_string("\n")
    }
}

fn handle_time_exceeded(src_ip: u32, data: *u8, len: u32) {
    let code: u8 = data[1]

    foundation.serial_write_string("[ICMP] Time exceeded from ")
    print_ip(src_ip)
    foundation.serial_write_string(": ")
    if code == ICMP_TTL_EXCEEDED {
        foundation.serial_write_string("TTL exceeded\n")
    } else {
        foundation.serial_write_string("Fragment reassembly exceeded\n")
    }
}

fn handle_redirect(src_ip: u32, data: *u8, len: u32) {
    if len < 8 {
        return
    }

    let code: u8 = data[1]
    let gateway: u32 = ((data[4] as u32) << 24) | ((data[5] as u32) << 16) |
                       ((data[6] as u32) << 8) | (data[7] as u32)

    foundation.serial_write_string("[ICMP] Redirect from ")
    print_ip(src_ip)
    foundation.serial_write_string(": use gateway ")
    print_ip(gateway)
    foundation.serial_write_string("\n")

    // In a real implementation, would update routing table
}

fn handle_timestamp_request(src_ip: u32, data: *u8, len: u32) {
    if len < 20 {
        return
    }

    let identifier: u16 = ((data[4] as u16) << 8) | (data[5] as u16)
    let sequence: u16 = ((data[6] as u16) << 8) | (data[7] as u16)
    let originate_ts: u32 = ((data[8] as u32) << 24) | ((data[9] as u32) << 16) |
                            ((data[10] as u32) << 8) | (data[11] as u32)

    send_timestamp_reply(src_ip, identifier, sequence, originate_ts)
}

fn handle_timestamp_reply(src_ip: u32, data: *u8, len: u32) {
    if len < 20 {
        return
    }

    let originate_ts: u32 = ((data[8] as u32) << 24) | ((data[9] as u32) << 16) |
                            ((data[10] as u32) << 8) | (data[11] as u32)
    let receive_ts: u32 = ((data[12] as u32) << 24) | ((data[13] as u32) << 16) |
                          ((data[14] as u32) << 8) | (data[15] as u32)
    let transmit_ts: u32 = ((data[16] as u32) << 24) | ((data[17] as u32) << 16) |
                           ((data[18] as u32) << 8) | (data[19] as u32)

    foundation.serial_write_string("[ICMP] Timestamp reply from ")
    print_ip(src_ip)
    foundation.serial_write_string(": originate=")
    foundation.serial_write_u32(originate_ts)
    foundation.serial_write_string(" receive=")
    foundation.serial_write_u32(receive_ts)
    foundation.serial_write_string(" transmit=")
    foundation.serial_write_u32(transmit_ts)
    foundation.serial_write_string("\n")
}

fn handle_addr_mask_request(src_ip: u32, data: *u8, len: u32) {
    if len < 12 {
        return
    }

    let identifier: u16 = ((data[4] as u16) << 8) | (data[5] as u16)
    let sequence: u16 = ((data[6] as u16) << 8) | (data[7] as u16)

    send_addr_mask_reply(src_ip, identifier, sequence)
}

fn handle_addr_mask_reply(src_ip: u32, data: *u8, len: u32) {
    if len < 12 {
        return
    }

    let mask: u32 = ((data[8] as u32) << 24) | ((data[9] as u32) << 16) |
                    ((data[10] as u32) << 8) | (data[11] as u32)

    foundation.serial_write_string("[ICMP] Address mask reply from ")
    print_ip(src_ip)
    foundation.serial_write_string(": ")
    print_ip(mask)
    foundation.serial_write_string("\n")
}

// ============================================================================
// Utility
// ============================================================================

fn print_ip(ip: u32) {
    foundation.serial_write_u32((ip >> 24) & 0xFF)
    foundation.serial_write_string(".")
    foundation.serial_write_u32((ip >> 16) & 0xFF)
    foundation.serial_write_string(".")
    foundation.serial_write_u32((ip >> 8) & 0xFF)
    foundation.serial_write_string(".")
    foundation.serial_write_u32(ip & 0xFF)
}

// ============================================================================
// Traceroute Implementation
// ============================================================================

export fn icmp_traceroute(dst_ip: u32, max_hops: u32): u32 {
    foundation.serial_write_string("[ICMP] Traceroute to ")
    print_ip(dst_ip)
    foundation.serial_write_string(", max ")
    foundation.serial_write_u32(max_hops)
    foundation.serial_write_string(" hops\n")

    var ttl: u32 = 1
    while ttl <= max_hops {
        // Send ICMP echo with limited TTL
        var packet: [u8; 1518]
        var offset: u32 = build_ethernet_header(&packet[0], dst_ip)

        let icmp_len: u32 = 8 + 32
        offset = build_ip_header(&packet[0], offset, dst_ip, icmp_len, ttl as u8)

        let icmp_start: u32 = offset
        packet[offset] = ICMP_ECHO_REQUEST
        packet[offset + 1] = 0
        packet[offset + 2] = 0
        packet[offset + 3] = 0
        packet[offset + 4] = ((icmp_state.identifier >> 8) & 0xFF) as u8
        packet[offset + 5] = (icmp_state.identifier & 0xFF) as u8
        packet[offset + 6] = ((icmp_state.sequence >> 8) & 0xFF) as u8
        packet[offset + 7] = (icmp_state.sequence & 0xFF) as u8
        offset = offset + 8

        var i: u32 = 0
        while i < 32 {
            packet[offset + i] = (i & 0xFF) as u8
            i = i + 1
        }
        offset = offset + 32

        let checksum: u16 = calculate_checksum(&packet[icmp_start], icmp_len)
        packet[icmp_start + 2] = ((checksum >> 8) & 0xFF) as u8
        packet[icmp_start + 3] = (checksum & 0xFF) as u8

        icmp_state.sequence = icmp_state.sequence + 1
        e1000.e1000_send_packet(&packet[0], offset)

        foundation.serial_write_u32(ttl)
        foundation.serial_write_string("  ")
        // In real implementation, would wait for response
        foundation.serial_write_string("*\n")

        ttl = ttl + 1
    }

    return max_hops
}

// ============================================================================
// Statistics
// ============================================================================

export fn icmp_get_stats(stats: *ICMPStats) {
    foundation.mem_copy(stats as *u8, &icmp_state.stats as *u8, @sizeOf(ICMPStats))
}

export fn icmp_print_stats() {
    foundation.serial_write_string("[ICMP] Statistics:\n")
    foundation.serial_write_string("  Echo requests sent: ")
    foundation.serial_write_u64(icmp_state.stats.echo_requests_sent)
    foundation.serial_write_string("\n  Echo requests received: ")
    foundation.serial_write_u64(icmp_state.stats.echo_requests_received)
    foundation.serial_write_string("\n  Echo replies sent: ")
    foundation.serial_write_u64(icmp_state.stats.echo_replies_sent)
    foundation.serial_write_string("\n  Echo replies received: ")
    foundation.serial_write_u64(icmp_state.stats.echo_replies_received)
    foundation.serial_write_string("\n  Dest unreachable sent: ")
    foundation.serial_write_u64(icmp_state.stats.dest_unreachable_sent)
    foundation.serial_write_string("\n  Dest unreachable received: ")
    foundation.serial_write_u64(icmp_state.stats.dest_unreachable_received)
    foundation.serial_write_string("\n  Checksum errors: ")
    foundation.serial_write_u64(icmp_state.stats.checksum_errors)
    foundation.serial_write_string("\n  Total sent: ")
    foundation.serial_write_u64(icmp_state.stats.total_sent)
    foundation.serial_write_string("\n  Total received: ")
    foundation.serial_write_u64(icmp_state.stats.total_received)
    foundation.serial_write_string("\n")
}

// ============================================================================
// Cleanup
// ============================================================================

export fn icmp_cleanup_pending_pings() {
    let now: u64 = get_time_us()
    let timeout: u64 = PING_TIMEOUT_MS * 1000

    var i: u32 = 0
    while i < MAX_PENDING_PINGS {
        let pending: *PendingPing = &icmp_state.pending_pings[i]
        if pending.active == 1 and pending.received == 0 {
            if now - pending.send_time > timeout {
                pending.active = 0
            }
        }
        i = i + 1
    }
}
