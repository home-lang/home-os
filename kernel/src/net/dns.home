// home-os DNS Client
// Domain Name System resolver with caching and /etc/resolv.conf support

import "../core/foundation.home" as foundation
import "../core/filesystem.home" as filesystem
import "udp.home" as udp

// DNS record types
const DNS_TYPE_A: u16 = 1       // IPv4 address
const DNS_TYPE_AAAA: u16 = 28   // IPv6 address
const DNS_TYPE_CNAME: u16 = 5   // Canonical name
const DNS_TYPE_MX: u16 = 15     // Mail exchange
const DNS_TYPE_TXT: u16 = 16    // Text record
const DNS_TYPE_NS: u16 = 2      // Name server
const DNS_TYPE_PTR: u16 = 12    // Pointer record

// DNS classes
const DNS_CLASS_IN: u16 = 1     // Internet

// DNS flags
const DNS_FLAG_QR: u16 = 0x8000     // Query/Response
const DNS_FLAG_OPCODE: u16 = 0x7800 // Operation code
const DNS_FLAG_AA: u16 = 0x0400     // Authoritative answer
const DNS_FLAG_TC: u16 = 0x0200     // Truncated
const DNS_FLAG_RD: u16 = 0x0100     // Recursion desired
const DNS_FLAG_RA: u16 = 0x0080     // Recursion available
const DNS_FLAG_RCODE: u16 = 0x000F  // Response code

// DNS response codes
const DNS_RCODE_OK: u16 = 0
const DNS_RCODE_FORMAT_ERROR: u16 = 1
const DNS_RCODE_SERVER_FAILURE: u16 = 2
const DNS_RCODE_NAME_ERROR: u16 = 3
const DNS_RCODE_NOT_IMPLEMENTED: u16 = 4
const DNS_RCODE_REFUSED: u16 = 5

// DNS header structure (12 bytes)
struct DnsHeader {
  id: u16,
  flags: u16,
  qdcount: u16,  // Question count
  ancount: u16,  // Answer count
  nscount: u16,  // Authority count
  arcount: u16   // Additional count
}

// DNS cache entry
struct DnsCacheEntry {
  hostname_hash: u32,
  ip_address: u32,
  ttl: u32,
  timestamp: u32,
  valid: u32
}

// Configuration
const DNS_PORT: u16 = 53
const DNS_TIMEOUT_MS: u32 = 5000
const DNS_MAX_RETRIES: u32 = 3
const DNS_CACHE_SIZE: u32 = 64
const DNS_MAX_PACKET_SIZE: u32 = 512

// State
var dns_server: u32 = 0x08080808  // 8.8.8.8 (Google DNS) - default
var dns_server_alt: u32 = 0x08080404  // 8.8.4.4 (Google DNS alt) - default
var dns_query_id: u16 = 0x1234
var dns_cache: [DnsCacheEntry; 64]
var dns_cache_initialized: u32 = 0
var dns_current_time: u32 = 0

// /etc/resolv.conf support
const DNS_MAX_SERVERS: u32 = 3
const DNS_MAX_SEARCH_DOMAINS: u32 = 6
const DNS_MAX_DOMAIN_LEN: u32 = 256

// DNS server list (populated from resolv.conf)
var dns_servers: [u32; 3]
var dns_server_count: u32 = 0

// Search domains (populated from resolv.conf)
var dns_search_domains: [256][256]u8  // Up to 6 search domains, 256 chars each
var dns_search_count: u32 = 0

// Domain suffix (populated from resolv.conf)
var dns_domain: [256]u8
var dns_domain_set: u32 = 0

// resolv.conf options
var dns_ndots: u32 = 1        // Number of dots before absolute lookup
var dns_timeout: u32 = 5      // Query timeout in seconds
var dns_attempts: u32 = 2     // Number of attempts per server
var dns_rotate: u32 = 0       // Rotate through nameservers

// Track which server to use next (for rotate option)
var dns_current_server: u32 = 0

// ============================================================================
// /etc/resolv.conf Parser
// ============================================================================

// Parse an IP address from string (e.g., "8.8.8.8" -> 0x08080808)
fn dns_parse_ip(str: u64): u32 {
  var ptr: u64 = str
  var result: u32 = 0
  var octet: u32 = 0
  var octet_count: u32 = 0

  var c: u8 = @ptrLoad(ptr, u8)
  while c != 0 and c != '\n' and c != ' ' and c != '\t' {
    if c >= '0' and c <= '9' {
      octet = octet * 10 + (c - '0')
    } else if c == '.' {
      result = (result << 8) | (octet & 0xFF)
      octet = 0
      octet_count = octet_count + 1
    }
    ptr = ptr + 1
    c = @ptrLoad(ptr, u8)
  }

  // Add final octet
  if octet_count == 3 {
    result = (result << 8) | (octet & 0xFF)
    return result
  }

  return 0  // Invalid IP
}

// Skip whitespace
fn dns_skip_whitespace(str: u64): u64 {
  var ptr: u64 = str
  var c: u8 = @ptrLoad(ptr, u8)
  while c == ' ' or c == '\t' {
    ptr = ptr + 1
    c = @ptrLoad(ptr, u8)
  }
  return ptr
}

// Check if line starts with keyword
fn dns_starts_with(str: u64, keyword: u64, keyword_len: u32): u32 {
  var i: u32 = 0
  while i < keyword_len {
    var c1: u8 = @ptrLoad(str + i, u8)
    var c2: u8 = @ptrLoad(keyword + i, u8)
    if c1 != c2 {
      return 0
    }
    i = i + 1
  }
  // Check for whitespace or end after keyword
  var next: u8 = @ptrLoad(str + keyword_len, u8)
  if next == ' ' or next == '\t' or next == '\n' or next == 0 {
    return 1
  }
  return 0
}

// Copy string until whitespace or newline
fn dns_copy_string(src: u64, dst: u64, max_len: u32): u32 {
  var i: u32 = 0
  var c: u8 = @ptrLoad(src + i, u8)
  while c != 0 and c != '\n' and c != ' ' and c != '\t' and i < max_len - 1 {
    @ptrStore(dst + i, u8, c)
    i = i + 1
    c = @ptrLoad(src + i, u8)
  }
  @ptrStore(dst + i, u8, 0)
  return i
}

// Parse a single line from resolv.conf
fn dns_parse_resolv_line(line: u64) {
  var ptr: u64 = dns_skip_whitespace(line)
  var c: u8 = @ptrLoad(ptr, u8)

  // Skip empty lines and comments
  if c == 0 or c == '\n' or c == '#' or c == ';' {
    return
  }

  // Check for "nameserver" directive
  if dns_starts_with(ptr, @ptrFromString("nameserver"), 10) == 1 {
    ptr = dns_skip_whitespace(ptr + 10)
    var ip: u32 = dns_parse_ip(ptr)
    if ip != 0 and dns_server_count < DNS_MAX_SERVERS {
      dns_servers[dns_server_count] = ip
      dns_server_count = dns_server_count + 1
      foundation.serial_write_string("[DNS] Added nameserver: ")
      dns_print_ip(ip)
      foundation.serial_write_string("\n")
    }
    return
  }

  // Check for "search" directive
  if dns_starts_with(ptr, @ptrFromString("search"), 6) == 1 {
    ptr = dns_skip_whitespace(ptr + 6)

    // Parse multiple search domains
    while dns_search_count < DNS_MAX_SEARCH_DOMAINS {
      var c: u8 = @ptrLoad(ptr, u8)
      if c == 0 or c == '\n' or c == '#' {
        break
      }

      var domain_ptr: u64 = @ptrFromInt(&dns_search_domains[dns_search_count])
      var len: u32 = dns_copy_string(ptr, domain_ptr, DNS_MAX_DOMAIN_LEN)

      if len > 0 {
        dns_search_count = dns_search_count + 1
        foundation.serial_write_string("[DNS] Added search domain: ")
        foundation.serial_write_ptr(domain_ptr)
        foundation.serial_write_string("\n")
      }

      // Skip to next domain
      ptr = ptr + len
      ptr = dns_skip_whitespace(ptr)
    }
    return
  }

  // Check for "domain" directive
  if dns_starts_with(ptr, @ptrFromString("domain"), 6) == 1 {
    ptr = dns_skip_whitespace(ptr + 6)
    var len: u32 = dns_copy_string(ptr, @ptrFromInt(&dns_domain), DNS_MAX_DOMAIN_LEN)
    if len > 0 {
      dns_domain_set = 1
      foundation.serial_write_string("[DNS] Set domain: ")
      foundation.serial_write_ptr(@ptrFromInt(&dns_domain))
      foundation.serial_write_string("\n")
    }
    return
  }

  // Check for "options" directive
  if dns_starts_with(ptr, @ptrFromString("options"), 7) == 1 {
    ptr = dns_skip_whitespace(ptr + 7)

    // Parse options
    while true {
      var c: u8 = @ptrLoad(ptr, u8)
      if c == 0 or c == '\n' or c == '#' {
        break
      }

      // Check for ndots:N
      if dns_starts_with(ptr, @ptrFromString("ndots:"), 6) == 1 {
        ptr = ptr + 6
        var n: u32 = 0
        c = @ptrLoad(ptr, u8)
        while c >= '0' and c <= '9' {
          n = n * 10 + (c - '0')
          ptr = ptr + 1
          c = @ptrLoad(ptr, u8)
        }
        if n > 0 and n <= 15 {
          dns_ndots = n
        }
      }

      // Check for timeout:N
      if dns_starts_with(ptr, @ptrFromString("timeout:"), 8) == 1 {
        ptr = ptr + 8
        var n: u32 = 0
        c = @ptrLoad(ptr, u8)
        while c >= '0' and c <= '9' {
          n = n * 10 + (c - '0')
          ptr = ptr + 1
          c = @ptrLoad(ptr, u8)
        }
        if n > 0 and n <= 30 {
          dns_timeout = n
        }
      }

      // Check for attempts:N
      if dns_starts_with(ptr, @ptrFromString("attempts:"), 9) == 1 {
        ptr = ptr + 9
        var n: u32 = 0
        c = @ptrLoad(ptr, u8)
        while c >= '0' and c <= '9' {
          n = n * 10 + (c - '0')
          ptr = ptr + 1
          c = @ptrLoad(ptr, u8)
        }
        if n > 0 and n <= 5 {
          dns_attempts = n
        }
      }

      // Check for rotate
      if dns_starts_with(ptr, @ptrFromString("rotate"), 6) == 1 {
        dns_rotate = 1
        ptr = ptr + 6
      }

      ptr = dns_skip_whitespace(ptr)

      // Skip unknown option
      c = @ptrLoad(ptr, u8)
      while c != 0 and c != '\n' and c != ' ' and c != '\t' {
        ptr = ptr + 1
        c = @ptrLoad(ptr, u8)
      }
      ptr = dns_skip_whitespace(ptr)
    }
    return
  }
}

// Read and parse /etc/resolv.conf
export fn dns_load_resolv_conf(): u32 {
  foundation.serial_write_string("[DNS] Loading /etc/resolv.conf\n")

  // Reset state
  dns_server_count = 0
  dns_search_count = 0
  dns_domain_set = 0

  // Open file
  var path: u64 = @ptrFromString("/etc/resolv.conf")
  var fd: u32 = filesystem.vfs_open(path, 0)  // O_RDONLY

  if fd == 0 or fd == 0xFFFFFFFF {
    foundation.serial_write_string("[DNS] No /etc/resolv.conf found, using defaults\n")
    // Use hardcoded defaults
    dns_servers[0] = 0x08080808  // 8.8.8.8
    dns_servers[1] = 0x08080404  // 8.8.4.4
    dns_server_count = 2
    return 0
  }

  // Read file
  var buffer: [4096]u8
  var bytes_read: u64 = filesystem.vfs_read(fd, @ptrFromInt(&buffer), 4095)
  buffer[bytes_read] = 0  // Null terminate

  filesystem.vfs_close(fd)

  // Parse line by line
  var line_start: u64 = @ptrFromInt(&buffer)
  var i: u64 = 0
  while i < bytes_read {
    var c: u8 = buffer[i]
    if c == '\n' {
      buffer[i] = 0  // Null terminate line
      dns_parse_resolv_line(line_start)
      line_start = @ptrFromInt(&buffer) + i + 1
    }
    i = i + 1
  }

  // Parse final line if no trailing newline
  if line_start < @ptrFromInt(&buffer) + bytes_read {
    dns_parse_resolv_line(line_start)
  }

  // If no nameservers found, use defaults
  if dns_server_count == 0 {
    foundation.serial_write_string("[DNS] No nameservers in resolv.conf, using defaults\n")
    dns_servers[0] = 0x08080808
    dns_servers[1] = 0x08080404
    dns_server_count = 2
  }

  // Update legacy dns_server and dns_server_alt for compatibility
  dns_server = dns_servers[0]
  if dns_server_count > 1 {
    dns_server_alt = dns_servers[1]
  }

  foundation.serial_write_string("[DNS] Loaded ")
  foundation.serial_write_hex(dns_server_count)
  foundation.serial_write_string(" nameservers, ")
  foundation.serial_write_hex(dns_search_count)
  foundation.serial_write_string(" search domains\n")

  return 1
}

// Get current active DNS server (respects rotate option)
fn dns_get_server(): u32 {
  if dns_server_count == 0 {
    return 0x08080808  // Fallback
  }

  var server: u32 = dns_servers[dns_current_server]

  if dns_rotate == 1 {
    dns_current_server = (dns_current_server + 1) % dns_server_count
  }

  return server
}

// Check if hostname needs search domain appended
fn dns_needs_search(hostname: u64): u32 {
  // Count dots in hostname
  var ptr: u64 = hostname
  var dots: u32 = 0
  var c: u8 = @ptrLoad(ptr, u8)

  while c != 0 {
    if c == '.' {
      dots = dots + 1
    }
    ptr = ptr + 1
    c = @ptrLoad(ptr, u8)
  }

  // If dots >= ndots, treat as absolute
  return dots < dns_ndots
}

// Get search domain by index
export fn dns_get_search_domain(index: u32, buf: u64, buf_len: u32): u32 {
  if index >= dns_search_count {
    return 0
  }

  var src: u64 = @ptrFromInt(&dns_search_domains[index])
  var i: u32 = 0
  var c: u8 = @ptrLoad(src + i, u8)

  while c != 0 and i < buf_len - 1 {
    @ptrStore(buf + i, u8, c)
    i = i + 1
    c = @ptrLoad(src + i, u8)
  }
  @ptrStore(buf + i, u8, 0)

  return i
}

// Get configured domain suffix
export fn dns_get_domain(buf: u64, buf_len: u32): u32 {
  if dns_domain_set == 0 {
    return 0
  }

  var src: u64 = @ptrFromInt(&dns_domain)
  var i: u32 = 0
  var c: u8 = @ptrLoad(src + i, u8)

  while c != 0 and i < buf_len - 1 {
    @ptrStore(buf + i, u8, c)
    i = i + 1
    c = @ptrLoad(src + i, u8)
  }
  @ptrStore(buf + i, u8, 0)

  return i
}

// Get DNS statistics
export fn dns_get_config(out_servers: u64, out_search: u64): u32 {
  // Copy server count and addresses to output
  if out_servers != 0 {
    var ptr: *u32 = @ptrFromInt(out_servers)
    ptr[0] = dns_server_count
    var i: u32 = 0
    while i < dns_server_count and i < DNS_MAX_SERVERS {
      ptr[i + 1] = dns_servers[i]
      i = i + 1
    }
  }

  // Copy search domain count to output
  if out_search != 0 {
    var ptr: *u32 = @ptrFromInt(out_search)
    ptr[0] = dns_search_count
  }

  return dns_server_count
}

export fn dns_init() {
  // Initialize cache
  var i: u32 = 0
  while i < DNS_CACHE_SIZE {
    dns_cache[i].valid = 0
    i = i + 1
  }
  dns_cache_initialized = 1

  // Initialize server list with defaults
  dns_servers[0] = 0x08080808  // 8.8.8.8
  dns_servers[1] = 0x08080404  // 8.8.4.4
  dns_server_count = 2

  // Try to load /etc/resolv.conf (will use defaults if not found)
  dns_load_resolv_conf()

  foundation.serial_write_string("[DNS] Initialized with ")
  foundation.serial_write_hex(dns_server_count)
  foundation.serial_write_string(" nameserver(s)\n")
}

export fn dns_set_server(server_ip: u32) {
  dns_server = server_ip
  foundation.serial_write_string("[DNS] Server set to ")
  dns_print_ip(server_ip)
  foundation.serial_write_string("\n")
}

export fn dns_set_alt_server(server_ip: u32) {
  dns_server_alt = server_ip
}

// Set current time for cache TTL management
export fn dns_set_time(time: u32) {
  dns_current_time = time
}

// Simple hash function for hostname
fn dns_hash_hostname(hostname: u64): u32 {
  var hash: u32 = 5381
  var ptr: u64 = hostname
  var c: u8 = @ptrLoad(ptr, u8)

  while c != 0 {
    hash = ((hash << 5) + hash) + c
    ptr = ptr + 1
    c = @ptrLoad(ptr, u8)
  }

  return hash
}

// Check cache for hostname
fn dns_cache_lookup(hostname: u64): u32 {
  var hash: u32 = dns_hash_hostname(hostname)

  var i: u32 = 0
  while i < DNS_CACHE_SIZE {
    if dns_cache[i].valid == 1 {
      if dns_cache[i].hostname_hash == hash {
        // Check TTL
        if dns_current_time < dns_cache[i].timestamp + dns_cache[i].ttl {
          foundation.serial_write_string("[DNS] Cache hit for hash ")
          foundation.serial_write_hex(hash)
          foundation.serial_write_string("\n")
          return dns_cache[i].ip_address
        } else {
          // Expired entry
          dns_cache[i].valid = 0
        }
      }
    }
    i = i + 1
  }

  return 0  // Not found
}

// Add entry to cache
fn dns_cache_add(hostname: u64, ip: u32, ttl: u32) {
  var hash: u32 = dns_hash_hostname(hostname)

  // Find empty slot or oldest entry
  var slot: u32 = 0
  var oldest_time: u32 = 0xFFFFFFFF

  var i: u32 = 0
  while i < DNS_CACHE_SIZE {
    if dns_cache[i].valid == 0 {
      slot = i
      break
    }
    if dns_cache[i].timestamp < oldest_time {
      oldest_time = dns_cache[i].timestamp
      slot = i
    }
    i = i + 1
  }

  dns_cache[slot].hostname_hash = hash
  dns_cache[slot].ip_address = ip
  dns_cache[slot].ttl = ttl
  dns_cache[slot].timestamp = dns_current_time
  dns_cache[slot].valid = 1
}

// Encode hostname to DNS format (e.g., "www.example.com" -> "\x03www\x07example\x03com\x00")
fn dns_encode_hostname(hostname: u64, buffer: u64): u32 {
  var src: u64 = hostname
  var dst: u64 = buffer
  var label_start: u64 = dst
  dst = dst + 1  // Skip length byte for now

  var total_len: u32 = 0
  var label_len: u32 = 0

  var c: u8 = @ptrLoad(src, u8)
  while c != 0 {
    if c == 0x2E {  // '.'
      // Write label length
      @ptrStore(label_start, u8, label_len)
      label_start = dst
      dst = dst + 1
      label_len = 0
    } else {
      @ptrStore(dst, u8, c)
      dst = dst + 1
      label_len = label_len + 1
    }
    total_len = total_len + 1
    src = src + 1
    c = @ptrLoad(src, u8)
  }

  // Write final label length
  @ptrStore(label_start, u8, label_len)

  // Null terminator
  @ptrStore(dst, u8, 0)

  return total_len + 2  // Include length bytes and null terminator
}

// Build DNS query packet
fn dns_build_query(hostname: u64, query_type: u16, buffer: u64): u32 {
  var offset: u32 = 0

  // DNS header (12 bytes)
  dns_query_id = dns_query_id + 1

  // ID (2 bytes)
  @ptrStore(buffer + offset, u8, (dns_query_id >> 8) & 0xFF)
  @ptrStore(buffer + offset + 1, u8, dns_query_id & 0xFF)
  offset = offset + 2

  // Flags: Standard query with recursion desired (2 bytes)
  @ptrStore(buffer + offset, u8, 0x01)  // RD=1
  @ptrStore(buffer + offset + 1, u8, 0x00)
  offset = offset + 2

  // QDCOUNT: 1 question (2 bytes)
  @ptrStore(buffer + offset, u8, 0x00)
  @ptrStore(buffer + offset + 1, u8, 0x01)
  offset = offset + 2

  // ANCOUNT: 0 (2 bytes)
  @ptrStore(buffer + offset, u8, 0x00)
  @ptrStore(buffer + offset + 1, u8, 0x00)
  offset = offset + 2

  // NSCOUNT: 0 (2 bytes)
  @ptrStore(buffer + offset, u8, 0x00)
  @ptrStore(buffer + offset + 1, u8, 0x00)
  offset = offset + 2

  // ARCOUNT: 0 (2 bytes)
  @ptrStore(buffer + offset, u8, 0x00)
  @ptrStore(buffer + offset + 1, u8, 0x00)
  offset = offset + 2

  // Question section
  // QNAME: encoded hostname
  var name_len: u32 = dns_encode_hostname(hostname, buffer + offset)
  offset = offset + name_len

  // QTYPE (2 bytes)
  @ptrStore(buffer + offset, u8, (query_type >> 8) & 0xFF)
  @ptrStore(buffer + offset + 1, u8, query_type & 0xFF)
  offset = offset + 2

  // QCLASS: IN (2 bytes)
  @ptrStore(buffer + offset, u8, 0x00)
  @ptrStore(buffer + offset + 1, u8, 0x01)
  offset = offset + 2

  return offset
}

// Skip DNS name in response (handles compression)
fn dns_skip_name(buffer: u64, offset: u32): u32 {
  var pos: u32 = offset
  var b: u8 = @ptrLoad(buffer + pos, u8)

  while b != 0 {
    if (b & 0xC0) == 0xC0 {
      // Compression pointer - skip 2 bytes
      return pos + 2
    }
    // Regular label - skip label
    pos = pos + 1 + b
    b = @ptrLoad(buffer + pos, u8)
  }

  return pos + 1  // Skip null terminator
}

// Parse DNS response and extract IP address
fn dns_parse_response(buffer: u64, len: u32, expected_id: u16): u32 {
  if len < 12 {
    return 0  // Too short
  }

  // Check ID
  var id: u16 = (@ptrLoad(buffer, u8) << 8) | @ptrLoad(buffer + 1, u8)
  if id != expected_id {
    foundation.serial_write_string("[DNS] ID mismatch\n")
    return 0
  }

  // Check flags
  var flags: u16 = (@ptrLoad(buffer + 2, u8) << 8) | @ptrLoad(buffer + 3, u8)
  if (flags & DNS_FLAG_QR) == 0 {
    foundation.serial_write_string("[DNS] Not a response\n")
    return 0
  }

  var rcode: u16 = flags & DNS_FLAG_RCODE
  if rcode != DNS_RCODE_OK {
    foundation.serial_write_string("[DNS] Error response code: ")
    foundation.serial_write_hex(rcode)
    foundation.serial_write_string("\n")
    return 0
  }

  // Get counts
  var qdcount: u16 = (@ptrLoad(buffer + 4, u8) << 8) | @ptrLoad(buffer + 5, u8)
  var ancount: u16 = (@ptrLoad(buffer + 6, u8) << 8) | @ptrLoad(buffer + 7, u8)

  if ancount == 0 {
    foundation.serial_write_string("[DNS] No answers\n")
    return 0
  }

  // Skip header (12 bytes)
  var offset: u32 = 12

  // Skip questions
  var i: u32 = 0
  while i < qdcount {
    offset = dns_skip_name(buffer, offset)
    offset = offset + 4  // QTYPE + QCLASS
    i = i + 1
  }

  // Parse answers
  i = 0
  while i < ancount {
    // Skip name
    offset = dns_skip_name(buffer, offset)

    // Read type and class
    var rtype: u16 = (@ptrLoad(buffer + offset, u8) << 8) | @ptrLoad(buffer + offset + 1, u8)
    offset = offset + 4  // TYPE + CLASS

    // TTL (4 bytes)
    var ttl: u32 = (@ptrLoad(buffer + offset, u8) << 24) |
                   (@ptrLoad(buffer + offset + 1, u8) << 16) |
                   (@ptrLoad(buffer + offset + 2, u8) << 8) |
                   @ptrLoad(buffer + offset + 3, u8)
    offset = offset + 4

    // RDLENGTH (2 bytes)
    var rdlength: u16 = (@ptrLoad(buffer + offset, u8) << 8) | @ptrLoad(buffer + offset + 1, u8)
    offset = offset + 2

    // Check for A record (IPv4)
    if rtype == DNS_TYPE_A and rdlength == 4 {
      var ip: u32 = (@ptrLoad(buffer + offset, u8) << 24) |
                    (@ptrLoad(buffer + offset + 1, u8) << 16) |
                    (@ptrLoad(buffer + offset + 2, u8) << 8) |
                    @ptrLoad(buffer + offset + 3, u8)

      foundation.serial_write_string("[DNS] Resolved to: ")
      dns_print_ip(ip)
      foundation.serial_write_string(" (TTL: ")
      foundation.serial_write_hex(ttl)
      foundation.serial_write_string(")\n")

      return ip
    }

    // Skip RDATA
    offset = offset + rdlength
    i = i + 1
  }

  return 0  // No A record found
}

// Print IP address in dotted notation
fn dns_print_ip(ip: u32) {
  foundation.serial_write_hex((ip >> 24) & 0xFF)
  foundation.serial_write_string(".")
  foundation.serial_write_hex((ip >> 16) & 0xFF)
  foundation.serial_write_string(".")
  foundation.serial_write_hex((ip >> 8) & 0xFF)
  foundation.serial_write_string(".")
  foundation.serial_write_hex(ip & 0xFF)
}

// Main DNS resolution function
export fn dns_resolve(hostname: u64): u32 {
  foundation.serial_write_string("[DNS] Resolving: ")
  // Print hostname (cast to string pointer)
  var ptr: u64 = hostname
  var c: u8 = @ptrLoad(ptr, u8)
  while c != 0 {
    foundation.serial_write_char(c)
    ptr = ptr + 1
    c = @ptrLoad(ptr, u8)
  }
  foundation.serial_write_string("\n")

  // Check cache first
  var cached_ip: u32 = dns_cache_lookup(hostname)
  if cached_ip != 0 {
    return cached_ip
  }

  // Build query
  var query: [u8; 512]
  var query_len: u32 = dns_build_query(hostname, DNS_TYPE_A, @ptrFromInt(query))

  // Try primary DNS server
  var retries: u32 = 0
  while retries < DNS_MAX_RETRIES {
    foundation.serial_write_string("[DNS] Sending query (attempt ")
    foundation.serial_write_hex(retries + 1)
    foundation.serial_write_string(")\n")

    // Send query via UDP
    udp.udp_send(dns_server, DNS_PORT, 53000, @ptrFromInt(query), query_len)

    // Wait for response (simplified - real implementation needs timeout)
    var response: [u8; 512]
    var response_len: u32 = udp.udp_receive(@ptrFromInt(response), 512)

    if response_len > 0 {
      var ip: u32 = dns_parse_response(@ptrFromInt(response), response_len, dns_query_id)
      if ip != 0 {
        // Cache the result
        dns_cache_add(hostname, ip, 300)  // Default 5 min TTL
        return ip
      }
    }

    retries = retries + 1
  }

  // Try alternate DNS server
  foundation.serial_write_string("[DNS] Trying alternate server\n")
  udp.udp_send(dns_server_alt, DNS_PORT, 53000, @ptrFromInt(query), query_len)

  var response: [u8; 512]
  var response_len: u32 = udp.udp_receive(@ptrFromInt(response), 512)

  if response_len > 0 {
    var ip: u32 = dns_parse_response(@ptrFromInt(response), response_len, dns_query_id)
    if ip != 0 {
      dns_cache_add(hostname, ip, 300)
      return ip
    }
  }

  foundation.serial_write_string("[DNS] Resolution failed\n")
  return 0
}

// Resolve hostname for IPv6 (AAAA record)
export fn dns_resolve_ipv6(hostname: u64, result: u64): u32 {
  // Build AAAA query
  var query: [u8; 512]
  var query_len: u32 = dns_build_query(hostname, DNS_TYPE_AAAA, @ptrFromInt(query))

  udp.udp_send(dns_server, DNS_PORT, 53000, @ptrFromInt(query), query_len)

  var response: [u8; 512]
  var response_len: u32 = udp.udp_receive(@ptrFromInt(response), 512)

  // Parse response (would need to handle 16-byte IPv6 addresses)
  // For now, return 0 to indicate not implemented
  return 0
}

// Clear DNS cache
export fn dns_cache_clear() {
  var i: u32 = 0
  while i < DNS_CACHE_SIZE {
    dns_cache[i].valid = 0
    i = i + 1
  }
  foundation.serial_write_string("[DNS] Cache cleared\n")
}

// Get DNS cache statistics
export fn dns_cache_stats(): u32 {
  var valid_entries: u32 = 0
  var i: u32 = 0
  while i < DNS_CACHE_SIZE {
    if dns_cache[i].valid == 1 {
      valid_entries = valid_entries + 1
    }
    i = i + 1
  }
  return valid_entries
}

// Reverse DNS lookup (PTR record)
export fn dns_reverse_lookup(ip: u32, result: u64, max_len: u32): u32 {
  // Build reverse lookup query
  // Convert IP to in-addr.arpa format (e.g., 8.8.8.8 -> 8.8.8.8.in-addr.arpa)
  // This is a simplified stub - real implementation would build proper query

  foundation.serial_write_string("[DNS] Reverse lookup for ")
  dns_print_ip(ip)
  foundation.serial_write_string(" not yet implemented\n")

  return 0
}
