// home-os DHCP Client
// Dynamic Host Configuration Protocol (RFC 2131)
// Complete implementation with DISCOVER/OFFER/REQUEST/ACK

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "udp.home" as udp

// DHCP message types
const DHCP_DISCOVER: u8 = 1
const DHCP_OFFER: u8 = 2
const DHCP_REQUEST: u8 = 3
const DHCP_DECLINE: u8 = 4
const DHCP_ACK: u8 = 5
const DHCP_NAK: u8 = 6
const DHCP_RELEASE: u8 = 7
const DHCP_INFORM: u8 = 8

// DHCP ports
const DHCP_SERVER_PORT: u16 = 67
const DHCP_CLIENT_PORT: u16 = 68

// DHCP option codes
const DHCP_OPT_SUBNET_MASK: u8 = 1
const DHCP_OPT_ROUTER: u8 = 3
const DHCP_OPT_DNS: u8 = 6
const DHCP_OPT_HOSTNAME: u8 = 12
const DHCP_OPT_REQUESTED_IP: u8 = 50
const DHCP_OPT_LEASE_TIME: u8 = 51
const DHCP_OPT_MESSAGE_TYPE: u8 = 53
const DHCP_OPT_SERVER_ID: u8 = 54
const DHCP_OPT_PARAM_LIST: u8 = 55
const DHCP_OPT_RENEWAL_TIME: u8 = 58
const DHCP_OPT_REBIND_TIME: u8 = 59
const DHCP_OPT_END: u8 = 255

// DHCP magic cookie
const DHCP_MAGIC: u32 = 0x63825363

// DHCP states
const DHCP_STATE_INIT: u32 = 0
const DHCP_STATE_SELECTING: u32 = 1
const DHCP_STATE_REQUESTING: u32 = 2
const DHCP_STATE_BOUND: u32 = 3
const DHCP_STATE_RENEWING: u32 = 4
const DHCP_STATE_REBINDING: u32 = 5

// DHCP packet structure
struct DhcpPacket {
  op: u8           // Message opcode: 1=request, 2=reply
  htype: u8        // Hardware address type: 1=Ethernet
  hlen: u8         // Hardware address length: 6 for Ethernet
  hops: u8         // Hops
  xid: u32         // Transaction ID
  secs: u16        // Seconds elapsed
  flags: u16       // Flags (0x8000 = broadcast)
  ciaddr: u32      // Client IP address
  yiaddr: u32      // Your IP address
  siaddr: u32      // Server IP address
  giaddr: u32      // Gateway IP address
  chaddr: [16]u8   // Client hardware address
  sname: [64]u8    // Server name
  file: [128]u8    // Boot filename
  magic: u32       // Magic cookie
  options: [312]u8 // Options
}

// DHCP client state
struct DhcpClient {
  state: u32
  xid: u32
  client_ip: u32
  server_ip: u32
  subnet_mask: u32
  router_ip: u32
  dns_ip: u32
  lease_time: u32
  renewal_time: u32
  rebind_time: u32
  lease_start: u64
  mac_address: [6]u8
}

var dhcp_client: DhcpClient
var dhcp_initialized: u32 = 0

// Initialize DHCP client
export fn dhcp_init(mac_addr: *u8): u32 {
  foundation.serial_write_string("[DHCP] Initializing client...\n")

  dhcp_client.state = DHCP_STATE_INIT
  dhcp_client.xid = generate_xid()
  dhcp_client.client_ip = 0
  dhcp_client.server_ip = 0
  dhcp_client.subnet_mask = 0
  dhcp_client.router_ip = 0
  dhcp_client.dns_ip = 0
  dhcp_client.lease_time = 0
  dhcp_client.renewal_time = 0
  dhcp_client.rebind_time = 0
  dhcp_client.lease_start = 0

  // Copy MAC address
  var i: u32 = 0
  loop {
    if i >= 6 { break }
    dhcp_client.mac_address[i] = memory.read_u8(mac_addr as u64 + i as u64)
    i = i + 1
  }

  dhcp_initialized = 1

  foundation.serial_write_string("[DHCP] Client initialized with MAC: ")
  print_mac_address(&dhcp_client.mac_address[0])
  foundation.serial_write_string("\n")

  return 0
}

// Generate transaction ID
fn generate_xid(): u32 {
  // Would use timer/random source
  return 0x12345678
}

// Print MAC address
fn print_mac_address(mac: *u8) {
  var i: u32 = 0
  loop {
    if i >= 6 { break }
    let byte: u8 = memory.read_u8(mac as u64 + i as u64)
    foundation.serial_write_byte(to_hex((byte >> 4) & 0xF))
    foundation.serial_write_byte(to_hex(byte & 0xF))
    if i < 5 {
      foundation.serial_write_string(":")
    }
    i = i + 1
  }
}

fn to_hex(n: u8): u8 {
  if n < 10 {
    return ('0' as u8) + n
  } else {
    return ('a' as u8) + (n - 10)
  }
}

// Send DHCP DISCOVER
export fn dhcp_discover(): u32 {
  foundation.serial_write_string("[DHCP] Sending DISCOVER...\n")

  var packet: DhcpPacket

  // Clear packet
  memory.memset(&packet as u64, 0, 576)

  // Fill BOOTP fields
  packet.op = 1  // BOOTREQUEST
  packet.htype = 1  // Ethernet
  packet.hlen = 6
  packet.hops = 0
  packet.xid = dhcp_client.xid
  packet.secs = 0
  packet.flags = 0x8000  // Broadcast flag
  packet.ciaddr = 0
  packet.yiaddr = 0
  packet.siaddr = 0
  packet.giaddr = 0

  // Copy MAC address to chaddr
  var i: u32 = 0
  loop {
    if i >= 6 { break }
    packet.chaddr[i] = dhcp_client.mac_address[i]
    i = i + 1
  }

  // Magic cookie
  packet.magic = DHCP_MAGIC

  // Build options
  var opt_offset: u32 = 0

  // Option: DHCP Message Type (DISCOVER)
  packet.options[opt_offset] = DHCP_OPT_MESSAGE_TYPE
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = 1  // Length
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = DHCP_DISCOVER
  opt_offset = opt_offset + 1

  // Option: Parameter Request List
  packet.options[opt_offset] = DHCP_OPT_PARAM_LIST
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = 4  // Length
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = DHCP_OPT_SUBNET_MASK
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = DHCP_OPT_ROUTER
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = DHCP_OPT_DNS
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = DHCP_OPT_LEASE_TIME
  opt_offset = opt_offset + 1

  // End option
  packet.options[opt_offset] = DHCP_OPT_END
  opt_offset = opt_offset + 1

  // Send via UDP broadcast
  let result: u32 = udp.udp_send(
    0xFFFFFFFF,  // Broadcast
    DHCP_SERVER_PORT,
    DHCP_CLIENT_PORT,
    &packet as u64,
    240 + opt_offset
  )

  if result == 0 {
    foundation.serial_write_string("[DHCP] DISCOVER sent successfully\n")
    dhcp_client.state = DHCP_STATE_SELECTING
    return 0
  } else {
    foundation.serial_write_string("[DHCP] Failed to send DISCOVER\n")
    return 1
  }
}

// Send DHCP REQUEST
export fn dhcp_request(offered_ip: u32, server_ip: u32): u32 {
  foundation.serial_write_string("[DHCP] Sending REQUEST for ")
  print_ip_address(offered_ip)
  foundation.serial_write_string("\n")

  var packet: DhcpPacket

  // Clear packet
  memory.memset(&packet as u64, 0, 576)

  // Fill BOOTP fields
  packet.op = 1
  packet.htype = 1
  packet.hlen = 6
  packet.hops = 0
  packet.xid = dhcp_client.xid
  packet.secs = 0
  packet.flags = 0x8000
  packet.ciaddr = 0
  packet.yiaddr = 0
  packet.siaddr = 0
  packet.giaddr = 0

  // Copy MAC address
  var i: u32 = 0
  loop {
    if i >= 6 { break }
    packet.chaddr[i] = dhcp_client.mac_address[i]
    i = i + 1
  }

  // Magic cookie
  packet.magic = DHCP_MAGIC

  // Build options
  var opt_offset: u32 = 0

  // Option: DHCP Message Type (REQUEST)
  packet.options[opt_offset] = DHCP_OPT_MESSAGE_TYPE
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = 1
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = DHCP_REQUEST
  opt_offset = opt_offset + 1

  // Option: Requested IP Address
  packet.options[opt_offset] = DHCP_OPT_REQUESTED_IP
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = 4
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = (offered_ip >> 24) as u8
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = (offered_ip >> 16) as u8
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = (offered_ip >> 8) as u8
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = offered_ip as u8
  opt_offset = opt_offset + 1

  // Option: Server Identifier
  packet.options[opt_offset] = DHCP_OPT_SERVER_ID
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = 4
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = (server_ip >> 24) as u8
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = (server_ip >> 16) as u8
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = (server_ip >> 8) as u8
  opt_offset = opt_offset + 1
  packet.options[opt_offset] = server_ip as u8
  opt_offset = opt_offset + 1

  // End option
  packet.options[opt_offset] = DHCP_OPT_END

  // Send via UDP broadcast
  let result: u32 = udp.udp_send(
    0xFFFFFFFF,
    DHCP_SERVER_PORT,
    DHCP_CLIENT_PORT,
    &packet as u64,
    240 + opt_offset
  )

  if result == 0 {
    foundation.serial_write_string("[DHCP] REQUEST sent successfully\n")
    dhcp_client.state = DHCP_STATE_REQUESTING
    return 0
  } else {
    foundation.serial_write_string("[DHCP] Failed to send REQUEST\n")
    return 1
  }
}

// Process received DHCP packet
export fn dhcp_process_packet(packet: *u8, len: u32): u32 {
  if len < 240 {
    return 1  // Too small
  }

  let dhcp_packet: *DhcpPacket = packet as *DhcpPacket

  // Verify XID matches
  if dhcp_packet.xid != dhcp_client.xid {
    return 1
  }

  // Verify magic cookie
  if dhcp_packet.magic != DHCP_MAGIC {
    return 1
  }

  // Parse options
  var opt_offset: u32 = 0
  var message_type: u8 = 0

  loop {
    if opt_offset >= 312 { break }

    let opt_code: u8 = dhcp_packet.options[opt_offset]

    if opt_code == DHCP_OPT_END {
      break
    }

    if opt_code == 0 {  // Padding
      opt_offset = opt_offset + 1
      continue
    }

    let opt_len: u8 = dhcp_packet.options[opt_offset + 1]
    opt_offset = opt_offset + 2

    if opt_code == DHCP_OPT_MESSAGE_TYPE {
      message_type = dhcp_packet.options[opt_offset]
    } else if opt_code == DHCP_OPT_SUBNET_MASK {
      dhcp_client.subnet_mask = read_u32_be(&dhcp_packet.options[opt_offset])
    } else if opt_code == DHCP_OPT_ROUTER {
      dhcp_client.router_ip = read_u32_be(&dhcp_packet.options[opt_offset])
    } else if opt_code == DHCP_OPT_DNS {
      dhcp_client.dns_ip = read_u32_be(&dhcp_packet.options[opt_offset])
    } else if opt_code == DHCP_OPT_LEASE_TIME {
      dhcp_client.lease_time = read_u32_be(&dhcp_packet.options[opt_offset])
    } else if opt_code == DHCP_OPT_SERVER_ID {
      dhcp_client.server_ip = read_u32_be(&dhcp_packet.options[opt_offset])
    }

    opt_offset = opt_offset + opt_len as u32
  }

  // Handle message type
  if message_type == DHCP_OFFER {
    handle_dhcp_offer(dhcp_packet)
  } else if message_type == DHCP_ACK {
    handle_dhcp_ack(dhcp_packet)
  } else if message_type == DHCP_NAK {
    handle_dhcp_nak()
  }

  return 0
}

// Handle DHCP OFFER
fn handle_dhcp_offer(packet: *DhcpPacket) {
  foundation.serial_write_string("[DHCP] Received OFFER: ")
  print_ip_address(packet.yiaddr)
  foundation.serial_write_string("\n")

  // Send REQUEST for this IP
  dhcp_request(packet.yiaddr, dhcp_client.server_ip)
}

// Handle DHCP ACK
fn handle_dhcp_ack(packet: *DhcpPacket) {
  dhcp_client.client_ip = packet.yiaddr

  foundation.serial_write_string("[DHCP] Received ACK\n")
  foundation.serial_write_string("[DHCP] IP Address:   ")
  print_ip_address(dhcp_client.client_ip)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("[DHCP] Subnet Mask:  ")
  print_ip_address(dhcp_client.subnet_mask)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("[DHCP] Router:       ")
  print_ip_address(dhcp_client.router_ip)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("[DHCP] DNS Server:   ")
  print_ip_address(dhcp_client.dns_ip)
  foundation.serial_write_string("\n")
  foundation.serial_write_string("[DHCP] Lease Time:   ")
  foundation.serial_write_u64(dhcp_client.lease_time)
  foundation.serial_write_string(" seconds\n")

  dhcp_client.state = DHCP_STATE_BOUND
}

// Handle DHCP NAK
fn handle_dhcp_nak() {
  foundation.serial_write_string("[DHCP] Received NAK - restarting\n")
  dhcp_client.state = DHCP_STATE_INIT
  dhcp_client.xid = generate_xid()
}

// Read 32-bit big-endian value
fn read_u32_be(ptr: *u8): u32 {
  let b0: u32 = memory.read_u8(ptr as u64) as u32
  let b1: u32 = memory.read_u8(ptr as u64 + 1) as u32
  let b2: u32 = memory.read_u8(ptr as u64 + 2) as u32
  let b3: u32 = memory.read_u8(ptr as u64 + 3) as u32
  return (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
}

// Print IP address
fn print_ip_address(ip: u32) {
  foundation.serial_write_u64((ip >> 24) & 0xFF)
  foundation.serial_write_string(".")
  foundation.serial_write_u64((ip >> 16) & 0xFF)
  foundation.serial_write_string(".")
  foundation.serial_write_u64((ip >> 8) & 0xFF)
  foundation.serial_write_string(".")
  foundation.serial_write_u64(ip & 0xFF)
}

// Get current IP address
export fn dhcp_get_ip(): u32 {
  return dhcp_client.client_ip
}

// Get subnet mask
export fn dhcp_get_subnet_mask(): u32 {
  return dhcp_client.subnet_mask
}

// Get router IP
export fn dhcp_get_router(): u32 {
  return dhcp_client.router_ip
}

// Get DNS server IP
export fn dhcp_get_dns(): u32 {
  return dhcp_client.dns_ip
}

// Get current state
export fn dhcp_get_state(): u32 {
  return dhcp_client.state
}

// Release IP address
export fn dhcp_release(): u32 {
  foundation.serial_write_string("[DHCP] Releasing IP address\n")

  dhcp_client.state = DHCP_STATE_INIT
  dhcp_client.client_ip = 0

  return 0
}
