// home-os SMB/CIFS Client
// Server Message Block Protocol - SMB2/3 Implementation

import "../core/foundation.home" as foundation
import "tcp.home" as tcp

// ============================================================================
// SMB Protocol Constants
// ============================================================================

const SMB_PORT: u16 = 445
const NETBIOS_PORT: u16 = 139

// SMB Protocol IDs
const SMB1_MAGIC: u32 = 0x424D53FF  // \xFFSMB
const SMB2_MAGIC: u32 = 0x424D53FE  // \xFESMB

// SMB2 Dialects
const SMB2_DIALECT_202: u16 = 0x0202
const SMB2_DIALECT_210: u16 = 0x0210
const SMB2_DIALECT_300: u16 = 0x0300
const SMB2_DIALECT_302: u16 = 0x0302
const SMB2_DIALECT_311: u16 = 0x0311

// SMB2 Commands
const SMB2_NEGOTIATE: u16 = 0x0000
const SMB2_SESSION_SETUP: u16 = 0x0001
const SMB2_LOGOFF: u16 = 0x0002
const SMB2_TREE_CONNECT: u16 = 0x0003
const SMB2_TREE_DISCONNECT: u16 = 0x0004
const SMB2_CREATE: u16 = 0x0005
const SMB2_CLOSE: u16 = 0x0006
const SMB2_FLUSH: u16 = 0x0007
const SMB2_READ: u16 = 0x0008
const SMB2_WRITE: u16 = 0x0009
const SMB2_LOCK: u16 = 0x000A
const SMB2_IOCTL: u16 = 0x000B
const SMB2_CANCEL: u16 = 0x000C
const SMB2_ECHO: u16 = 0x000D
const SMB2_QUERY_DIRECTORY: u16 = 0x000E
const SMB2_CHANGE_NOTIFY: u16 = 0x000F
const SMB2_QUERY_INFO: u16 = 0x0010
const SMB2_SET_INFO: u16 = 0x0011
const SMB2_OPLOCK_BREAK: u16 = 0x0012

// SMB2 Flags
const SMB2_FLAGS_SERVER_TO_REDIR: u32 = 0x00000001
const SMB2_FLAGS_ASYNC_COMMAND: u32 = 0x00000002
const SMB2_FLAGS_RELATED_OPERATIONS: u32 = 0x00000004
const SMB2_FLAGS_SIGNED: u32 = 0x00000008
const SMB2_FLAGS_DFS_OPERATIONS: u32 = 0x10000000

// Session Setup Flags
const SMB2_SESSION_FLAG_IS_GUEST: u16 = 0x0001
const SMB2_SESSION_FLAG_IS_NULL: u16 = 0x0002
const SMB2_SESSION_FLAG_ENCRYPT_DATA: u16 = 0x0004

// Tree Connect Flags
const SMB2_TREE_CONNECT_FLAG_CLUSTER_RECONNECT: u16 = 0x0001

// Share Types
const SMB2_SHARE_TYPE_DISK: u8 = 0x01
const SMB2_SHARE_TYPE_PIPE: u8 = 0x02
const SMB2_SHARE_TYPE_PRINT: u8 = 0x03

// Create Disposition
const FILE_SUPERSEDE: u32 = 0x00000000
const FILE_OPEN: u32 = 0x00000001
const FILE_CREATE: u32 = 0x00000002
const FILE_OPEN_IF: u32 = 0x00000003
const FILE_OVERWRITE: u32 = 0x00000004
const FILE_OVERWRITE_IF: u32 = 0x00000005

// Access Mask
const FILE_READ_DATA: u32 = 0x00000001
const FILE_WRITE_DATA: u32 = 0x00000002
const FILE_APPEND_DATA: u32 = 0x00000004
const FILE_READ_EA: u32 = 0x00000008
const FILE_WRITE_EA: u32 = 0x00000010
const FILE_EXECUTE: u32 = 0x00000020
const FILE_DELETE_CHILD: u32 = 0x00000040
const FILE_READ_ATTRIBUTES: u32 = 0x00000080
const FILE_WRITE_ATTRIBUTES: u32 = 0x00000100
const DELETE: u32 = 0x00010000
const READ_CONTROL: u32 = 0x00020000
const WRITE_DAC: u32 = 0x00040000
const WRITE_OWNER: u32 = 0x00080000
const SYNCHRONIZE: u32 = 0x00100000

const GENERIC_READ: u32 = 0x80000000
const GENERIC_WRITE: u32 = 0x40000000
const GENERIC_EXECUTE: u32 = 0x20000000
const GENERIC_ALL: u32 = 0x10000000

// File Attributes
const FILE_ATTRIBUTE_READONLY: u32 = 0x00000001
const FILE_ATTRIBUTE_HIDDEN: u32 = 0x00000002
const FILE_ATTRIBUTE_SYSTEM: u32 = 0x00000004
const FILE_ATTRIBUTE_DIRECTORY: u32 = 0x00000010
const FILE_ATTRIBUTE_ARCHIVE: u32 = 0x00000020
const FILE_ATTRIBUTE_NORMAL: u32 = 0x00000080

// Share Access
const FILE_SHARE_READ: u32 = 0x00000001
const FILE_SHARE_WRITE: u32 = 0x00000002
const FILE_SHARE_DELETE: u32 = 0x00000004

// Create Options
const FILE_DIRECTORY_FILE: u32 = 0x00000001
const FILE_NON_DIRECTORY_FILE: u32 = 0x00000040
const FILE_NO_EA_KNOWLEDGE: u32 = 0x00000200
const FILE_SEQUENTIAL_ONLY: u32 = 0x00000004

// NT Status Codes
const STATUS_SUCCESS: u32 = 0x00000000
const STATUS_MORE_PROCESSING_REQUIRED: u32 = 0xC0000016
const STATUS_LOGON_FAILURE: u32 = 0xC000006D
const STATUS_NO_SUCH_FILE: u32 = 0xC000000F
const STATUS_ACCESS_DENIED: u32 = 0xC0000022
const STATUS_OBJECT_NAME_NOT_FOUND: u32 = 0xC0000034
const STATUS_OBJECT_PATH_NOT_FOUND: u32 = 0xC000003A

// ============================================================================
// Constants
// ============================================================================

const MAX_SMB_CONNECTIONS: u32 = 8
const MAX_TREE_CONNECTS: u32 = 32
const MAX_OPEN_FILES: u32 = 128
const SMB_BUFFER_SIZE: u32 = 65536
const MAX_READ_SIZE: u32 = 65536
const MAX_WRITE_SIZE: u32 = 65536

// ============================================================================
// Data Structures
// ============================================================================

struct SmbFileId {
    persistent: u64,
    volatile_: u64
}

struct SmbFileInfo {
    creation_time: u64,
    last_access_time: u64,
    last_write_time: u64,
    change_time: u64,
    file_size: u64,
    allocation_size: u64,
    attributes: u32,
    file_name: [u8; 256],
    name_len: u32
}

struct SmbDirEntry {
    file_index: u32,
    creation_time: u64,
    last_access_time: u64,
    last_write_time: u64,
    change_time: u64,
    file_size: u64,
    allocation_size: u64,
    attributes: u32,
    file_name: [u8; 256],
    name_len: u32
}

struct SmbTreeConnect {
    active: u32,
    connection_id: u32,
    tree_id: u32,
    share_type: u8,
    share_name: [u8; 256],
    share_name_len: u32
}

struct SmbOpenFile {
    active: u32,
    connection_id: u32,
    tree_id: u32,
    file_id: SmbFileId,
    position: u64,
    size: u64,
    access_mask: u32,
    is_directory: u32
}

struct SmbConnection {
    active: u32,
    server_ip: u32,
    tcp_socket: i32,

    // Session info
    session_id: u64,
    dialect: u16,
    max_transact_size: u32,
    max_read_size: u32,
    max_write_size: u32,

    // Sequence numbers
    message_id: u64,

    // Credentials
    username: [u8; 64],
    username_len: u32,
    domain: [u8; 64],
    domain_len: u32,

    // Signing
    signing_required: u32,
    signing_key: [u8; 16],

    // Statistics
    requests_sent: u64,
    responses_received: u64,
    bytes_read: u64,
    bytes_written: u64,
    errors: u64
}

struct SmbState {
    initialized: u32,
    connections: [SmbConnection; 8],
    tree_connects: [SmbTreeConnect; 32],
    open_files: [SmbOpenFile; 128],
    send_buffer: [u8; 65536],
    recv_buffer: [u8; 65536]
}

// ============================================================================
// Global State
// ============================================================================

var smb_state: SmbState

// ============================================================================
// Initialization
// ============================================================================

export fn smb_init() {
    foundation.mem_set(&smb_state as *u8, 0, @sizeOf(SmbState))
    smb_state.initialized = 1
    foundation.serial_write_string("[SMB] Client initialized\n")
}

// ============================================================================
// Utility Functions
// ============================================================================

fn write_u16_le(buffer: *u8, offset: u32, value: u16): u32 {
    buffer[offset] = (value & 0xFF) as u8
    buffer[offset + 1] = ((value >> 8) & 0xFF) as u8
    return offset + 2
}

fn write_u32_le(buffer: *u8, offset: u32, value: u32): u32 {
    buffer[offset] = (value & 0xFF) as u8
    buffer[offset + 1] = ((value >> 8) & 0xFF) as u8
    buffer[offset + 2] = ((value >> 16) & 0xFF) as u8
    buffer[offset + 3] = ((value >> 24) & 0xFF) as u8
    return offset + 4
}

fn write_u64_le(buffer: *u8, offset: u32, value: u64): u32 {
    let low: u32 = (value & 0xFFFFFFFF) as u32
    let high: u32 = ((value >> 32) & 0xFFFFFFFF) as u32
    offset = write_u32_le(buffer, offset, low)
    return write_u32_le(buffer, offset, high)
}

fn read_u16_le(buffer: *u8, offset: u32): u16 {
    return (buffer[offset] as u16) | ((buffer[offset + 1] as u16) << 8)
}

fn read_u32_le(buffer: *u8, offset: u32): u32 {
    return (buffer[offset] as u32) | ((buffer[offset + 1] as u32) << 8) |
           ((buffer[offset + 2] as u32) << 16) | ((buffer[offset + 3] as u32) << 24)
}

fn read_u64_le(buffer: *u8, offset: u32): u64 {
    let low: u32 = read_u32_le(buffer, offset)
    let high: u32 = read_u32_le(buffer, offset + 4)
    return (low as u64) | ((high as u64) << 32)
}

fn write_unicode_string(buffer: *u8, offset: u32, str: *u8, len: u32): u32 {
    // Convert ASCII to UTF-16LE
    var i: u32 = 0
    while i < len {
        buffer[offset + i * 2] = str[i]
        buffer[offset + i * 2 + 1] = 0
        i = i + 1
    }
    return offset + len * 2
}

fn read_unicode_string(buffer: *u8, offset: u32, out: *u8, max_len: u32, char_count: u32): u32 {
    var i: u32 = 0
    while i < char_count and i < max_len {
        out[i] = buffer[offset + i * 2]
        i = i + 1
    }
    if i < max_len {
        out[i] = 0
    }
    return char_count
}

// ============================================================================
// SMB2 Header Building
// ============================================================================

fn build_smb2_header(buffer: *u8, offset: u32, conn: *SmbConnection, command: u16, tree_id: u32): u32 {
    let start: u32 = offset

    // Protocol ID (4 bytes)
    buffer[offset] = 0xFE
    buffer[offset + 1] = 0x53  // 'S'
    buffer[offset + 2] = 0x4D  // 'M'
    buffer[offset + 3] = 0x42  // 'B'
    offset = offset + 4

    // Structure Size (2 bytes) - always 64 for SMB2 header
    offset = write_u16_le(buffer, offset, 64)

    // Credit Charge (2 bytes)
    offset = write_u16_le(buffer, offset, 1)

    // Status (4 bytes) - 0 for requests
    offset = write_u32_le(buffer, offset, 0)

    // Command (2 bytes)
    offset = write_u16_le(buffer, offset, command)

    // Credits Requested (2 bytes)
    offset = write_u16_le(buffer, offset, 31)

    // Flags (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // Next Command (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // Message ID (8 bytes)
    offset = write_u64_le(buffer, offset, conn.message_id)
    conn.message_id = conn.message_id + 1

    // Process ID (4 bytes)
    offset = write_u32_le(buffer, offset, 0xFEFF)

    // Tree ID (4 bytes)
    offset = write_u32_le(buffer, offset, tree_id)

    // Session ID (8 bytes)
    offset = write_u64_le(buffer, offset, conn.session_id)

    // Signature (16 bytes)
    var i: u32 = 0
    while i < 16 {
        buffer[offset + i] = 0
        i = i + 1
    }
    offset = offset + 16

    return offset
}

// ============================================================================
// SMB2 Message Sending/Receiving
// ============================================================================

fn send_smb2_message(conn: *SmbConnection, buffer: *u8, len: u32): i32 {
    // Send via TCP
    let sent: i32 = tcp.tcp_send(conn.tcp_socket, buffer, len)
    if sent < 0 {
        conn.errors = conn.errors + 1
        return -1
    }

    conn.requests_sent = conn.requests_sent + 1
    return sent
}

fn recv_smb2_message(conn: *SmbConnection, buffer: *u8, max_len: u32): i32 {
    // Receive via TCP
    let recvd: i32 = tcp.tcp_recv(conn.tcp_socket, buffer, max_len)
    if recvd < 0 {
        conn.errors = conn.errors + 1
        return -1
    }

    conn.responses_received = conn.responses_received + 1
    return recvd
}

fn parse_smb2_header(buffer: *u8, status: *u32, session_id: *u64): i32 {
    // Verify magic
    if buffer[0] != 0xFE or buffer[1] != 0x53 or buffer[2] != 0x4D or buffer[3] != 0x42 {
        return -1
    }

    *status = read_u32_le(buffer, 8)
    *session_id = read_u64_le(buffer, 40)

    return 64  // Header size
}

// ============================================================================
// Connection Management
// ============================================================================

export fn smb_connect(server_ip: u32, username: *u8, username_len: u32, password: *u8, password_len: u32): i32 {
    // Find free connection slot
    var conn_id: i32 = -1
    var i: u32 = 0
    while i < MAX_SMB_CONNECTIONS {
        if smb_state.connections[i].active == 0 {
            conn_id = i as i32
            break
        }
        i = i + 1
    }

    if conn_id < 0 {
        return -1
    }

    let conn: *SmbConnection = &smb_state.connections[conn_id as u32]
    foundation.mem_set(conn as *u8, 0, @sizeOf(SmbConnection))

    conn.server_ip = server_ip
    conn.message_id = 0

    // Copy username
    conn.username_len = if username_len < 63 { username_len } else { 63 }
    i = 0
    while i < conn.username_len {
        conn.username[i] = username[i]
        i = i + 1
    }

    // Create TCP connection
    conn.tcp_socket = tcp.tcp_socket()
    if conn.tcp_socket < 0 {
        return -1
    }

    if tcp.tcp_connect(conn.tcp_socket, server_ip, SMB_PORT) < 0 {
        tcp.tcp_close(conn.tcp_socket)
        return -1
    }

    // Negotiate protocol
    if negotiate_protocol(conn) < 0 {
        tcp.tcp_close(conn.tcp_socket)
        return -1
    }

    // Session setup
    if session_setup(conn, username, username_len, password, password_len) < 0 {
        tcp.tcp_close(conn.tcp_socket)
        return -1
    }

    conn.active = 1

    foundation.serial_write_string("[SMB] Connected to ")
    print_ip(server_ip)
    foundation.serial_write_string(" as ")
    foundation.serial_write_string(&conn.username[0] as *u8)
    foundation.serial_write_string("\n")

    return conn_id
}

fn negotiate_protocol(conn: *SmbConnection): i32 {
    let buffer: *u8 = &smb_state.send_buffer[0]
    let reply: *u8 = &smb_state.recv_buffer[0]
    var offset: u32 = 0

    // Build SMB2 Negotiate request
    offset = build_smb2_header(buffer, offset, conn, SMB2_NEGOTIATE, 0)

    // Negotiate request body
    // Structure Size (2 bytes)
    offset = write_u16_le(buffer, offset, 36)

    // Dialect Count (2 bytes)
    offset = write_u16_le(buffer, offset, 2)

    // Security Mode (2 bytes) - SIGNING_ENABLED
    offset = write_u16_le(buffer, offset, 0x0001)

    // Reserved (2 bytes)
    offset = write_u16_le(buffer, offset, 0)

    // Capabilities (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // Client GUID (16 bytes)
    var i: u32 = 0
    while i < 16 {
        buffer[offset + i] = (0x12 + i) as u8
        i = i + 1
    }
    offset = offset + 16

    // Negotiate Context Offset (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // Negotiate Context Count (2 bytes)
    offset = write_u16_le(buffer, offset, 0)

    // Reserved2 (2 bytes)
    offset = write_u16_le(buffer, offset, 0)

    // Dialects
    offset = write_u16_le(buffer, offset, SMB2_DIALECT_210)
    offset = write_u16_le(buffer, offset, SMB2_DIALECT_202)

    // Send request
    if send_smb2_message(conn, buffer, offset) < 0 {
        return -1
    }

    // Receive response
    let recv_len: i32 = recv_smb2_message(conn, reply, SMB_BUFFER_SIZE)
    if recv_len < 64 {
        return -1
    }

    // Parse response header
    var status: u32 = 0
    var session_id: u64 = 0
    let header_len: i32 = parse_smb2_header(reply, &status, &session_id)
    if header_len < 0 or status != STATUS_SUCCESS {
        return -1
    }

    // Parse negotiate response
    let resp_offset: u32 = header_len as u32

    // Skip structure size
    let dialect: u16 = read_u16_le(reply, resp_offset + 4)
    conn.dialect = dialect

    conn.max_transact_size = read_u32_le(reply, resp_offset + 28)
    conn.max_read_size = read_u32_le(reply, resp_offset + 32)
    conn.max_write_size = read_u32_le(reply, resp_offset + 36)

    return 0
}

fn session_setup(conn: *SmbConnection, username: *u8, username_len: u32, password: *u8, password_len: u32): i32 {
    let buffer: *u8 = &smb_state.send_buffer[0]
    let reply: *u8 = &smb_state.recv_buffer[0]
    var offset: u32 = 0

    // Build SMB2 Session Setup request
    offset = build_smb2_header(buffer, offset, conn, SMB2_SESSION_SETUP, 0)

    // Session Setup request body
    // Structure Size (2 bytes)
    offset = write_u16_le(buffer, offset, 25)

    // Flags (1 byte)
    buffer[offset] = 0
    offset = offset + 1

    // Security Mode (1 byte)
    buffer[offset] = 0x01  // Signing enabled
    offset = offset + 1

    // Capabilities (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // Channel (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // Security Buffer Offset (2 bytes)
    let sec_buf_offset_pos: u32 = offset
    offset = write_u16_le(buffer, offset, 0)  // Placeholder

    // Security Buffer Length (2 bytes)
    let sec_buf_len_pos: u32 = offset
    offset = write_u16_le(buffer, offset, 0)  // Placeholder

    // Previous Session ID (8 bytes)
    offset = write_u64_le(buffer, offset, 0)

    // Build NTLMSSP security blob (simplified - anonymous/guest auth)
    let sec_buf_start: u32 = offset
    write_u16_le(buffer, sec_buf_offset_pos, sec_buf_start as u16)

    // NTLMSSP Negotiate message (simplified)
    // Signature
    buffer[offset] = 0x4E  // 'N'
    buffer[offset + 1] = 0x54  // 'T'
    buffer[offset + 2] = 0x4C  // 'L'
    buffer[offset + 3] = 0x4D  // 'M'
    buffer[offset + 4] = 0x53  // 'S'
    buffer[offset + 5] = 0x53  // 'S'
    buffer[offset + 6] = 0x50  // 'P'
    buffer[offset + 7] = 0x00
    offset = offset + 8

    // Message Type (4 bytes) - NEGOTIATE = 1
    offset = write_u32_le(buffer, offset, 1)

    // Negotiate Flags (4 bytes)
    offset = write_u32_le(buffer, offset, 0xE2088297)

    // Domain name (empty for now)
    offset = write_u16_le(buffer, offset, 0)  // Len
    offset = write_u16_le(buffer, offset, 0)  // MaxLen
    offset = write_u32_le(buffer, offset, 0)  // Offset

    // Workstation name (empty)
    offset = write_u16_le(buffer, offset, 0)
    offset = write_u16_le(buffer, offset, 0)
    offset = write_u32_le(buffer, offset, 0)

    let sec_buf_len: u32 = offset - sec_buf_start
    write_u16_le(buffer, sec_buf_len_pos, sec_buf_len as u16)

    // Send request
    if send_smb2_message(conn, buffer, offset) < 0 {
        return -1
    }

    // Receive response
    let recv_len: i32 = recv_smb2_message(conn, reply, SMB_BUFFER_SIZE)
    if recv_len < 64 {
        return -1
    }

    // Parse response
    var status: u32 = 0
    var session_id: u64 = 0
    let header_len: i32 = parse_smb2_header(reply, &status, &session_id)
    if header_len < 0 {
        return -1
    }

    // MORE_PROCESSING_REQUIRED is expected for NTLM
    if status != STATUS_SUCCESS and status != STATUS_MORE_PROCESSING_REQUIRED {
        return -1
    }

    conn.session_id = session_id

    // For a full implementation, would need to process NTLM challenge
    // and send NTLM response. For now, accept guest/anonymous session.

    return 0
}

export fn smb_disconnect(conn_id: i32) {
    if conn_id < 0 or conn_id >= MAX_SMB_CONNECTIONS as i32 {
        return
    }

    let conn: *SmbConnection = &smb_state.connections[conn_id as u32]
    if conn.active == 0 {
        return
    }

    // Send logoff request
    let buffer: *u8 = &smb_state.send_buffer[0]
    var offset: u32 = 0

    offset = build_smb2_header(buffer, offset, conn, SMB2_LOGOFF, 0)

    // Logoff request body - Structure Size
    offset = write_u16_le(buffer, offset, 4)
    offset = write_u16_le(buffer, offset, 0)  // Reserved

    send_smb2_message(conn, buffer, offset)

    // Close TCP connection
    tcp.tcp_close(conn.tcp_socket)

    // Close all tree connects for this connection
    var i: u32 = 0
    while i < MAX_TREE_CONNECTS {
        if smb_state.tree_connects[i].active == 1 and smb_state.tree_connects[i].connection_id == conn_id as u32 {
            smb_state.tree_connects[i].active = 0
        }
        i = i + 1
    }

    // Close all open files for this connection
    i = 0
    while i < MAX_OPEN_FILES {
        if smb_state.open_files[i].active == 1 and smb_state.open_files[i].connection_id == conn_id as u32 {
            smb_state.open_files[i].active = 0
        }
        i = i + 1
    }

    conn.active = 0

    foundation.serial_write_string("[SMB] Disconnected from server\n")
}

// ============================================================================
// Share Operations
// ============================================================================

export fn smb_tree_connect(conn_id: i32, share_name: *u8, share_name_len: u32): i32 {
    if conn_id < 0 or conn_id >= MAX_SMB_CONNECTIONS as i32 {
        return -1
    }

    let conn: *SmbConnection = &smb_state.connections[conn_id as u32]
    if conn.active == 0 {
        return -1
    }

    // Find free tree connect slot
    var tree_id: i32 = -1
    var i: u32 = 0
    while i < MAX_TREE_CONNECTS {
        if smb_state.tree_connects[i].active == 0 {
            tree_id = i as i32
            break
        }
        i = i + 1
    }

    if tree_id < 0 {
        return -1
    }

    let buffer: *u8 = &smb_state.send_buffer[0]
    let reply: *u8 = &smb_state.recv_buffer[0]
    var offset: u32 = 0

    offset = build_smb2_header(buffer, offset, conn, SMB2_TREE_CONNECT, 0)

    // Tree Connect request body
    // Structure Size (2 bytes)
    offset = write_u16_le(buffer, offset, 9)

    // Reserved (2 bytes)
    offset = write_u16_le(buffer, offset, 0)

    // Path Offset (2 bytes)
    let path_offset_pos: u32 = offset
    offset = write_u16_le(buffer, offset, 0)

    // Path Length (2 bytes)
    let path_len_pos: u32 = offset
    offset = write_u16_le(buffer, offset, 0)

    // Build UNC path: \\server\share
    let path_start: u32 = offset
    write_u16_le(buffer, path_offset_pos, path_start as u16)

    // Write path in Unicode
    // Backslashes
    buffer[offset] = 0x5C
    buffer[offset + 1] = 0
    buffer[offset + 2] = 0x5C
    buffer[offset + 3] = 0
    offset = offset + 4

    // Server IP as string (simplified - just use share name directly)
    // In real implementation, would include server name
    offset = write_unicode_string(buffer, offset, share_name, share_name_len)

    let path_len: u32 = offset - path_start
    write_u16_le(buffer, path_len_pos, path_len as u16)

    // Send request
    if send_smb2_message(conn, buffer, offset) < 0 {
        return -1
    }

    // Receive response
    let recv_len: i32 = recv_smb2_message(conn, reply, SMB_BUFFER_SIZE)
    if recv_len < 64 {
        return -1
    }

    var status: u32 = 0
    var session_id: u64 = 0
    let header_len: i32 = parse_smb2_header(reply, &status, &session_id)
    if header_len < 0 or status != STATUS_SUCCESS {
        return -1
    }

    // Get tree ID from header
    let resp_tree_id: u32 = read_u32_le(reply, 36)

    // Parse response body
    let resp_offset: u32 = header_len as u32
    let share_type: u8 = reply[resp_offset + 2]

    // Store tree connect info
    let tree: *SmbTreeConnect = &smb_state.tree_connects[tree_id as u32]
    tree.active = 1
    tree.connection_id = conn_id as u32
    tree.tree_id = resp_tree_id
    tree.share_type = share_type

    tree.share_name_len = if share_name_len < 255 { share_name_len } else { 255 }
    i = 0
    while i < tree.share_name_len {
        tree.share_name[i] = share_name[i]
        i = i + 1
    }

    foundation.serial_write_string("[SMB] Connected to share: ")
    foundation.serial_write_string(&tree.share_name[0] as *u8)
    foundation.serial_write_string("\n")

    return tree_id
}

export fn smb_tree_disconnect(tree_id: i32) {
    if tree_id < 0 or tree_id >= MAX_TREE_CONNECTS as i32 {
        return
    }

    let tree: *SmbTreeConnect = &smb_state.tree_connects[tree_id as u32]
    if tree.active == 0 {
        return
    }

    let conn: *SmbConnection = &smb_state.connections[tree.connection_id]
    if conn.active == 0 {
        tree.active = 0
        return
    }

    let buffer: *u8 = &smb_state.send_buffer[0]
    var offset: u32 = 0

    offset = build_smb2_header(buffer, offset, conn, SMB2_TREE_DISCONNECT, tree.tree_id)

    // Tree Disconnect body
    offset = write_u16_le(buffer, offset, 4)  // Structure size
    offset = write_u16_le(buffer, offset, 0)  // Reserved

    send_smb2_message(conn, buffer, offset)

    tree.active = 0
}

// ============================================================================
// File Operations
// ============================================================================

export fn smb_create_file(tree_id: i32, filename: *u8, filename_len: u32, access_mask: u32, disposition: u32): i32 {
    if tree_id < 0 or tree_id >= MAX_TREE_CONNECTS as i32 {
        return -1
    }

    let tree: *SmbTreeConnect = &smb_state.tree_connects[tree_id as u32]
    if tree.active == 0 {
        return -1
    }

    let conn: *SmbConnection = &smb_state.connections[tree.connection_id]
    if conn.active == 0 {
        return -1
    }

    // Find free file slot
    var file_id: i32 = -1
    var i: u32 = 0
    while i < MAX_OPEN_FILES {
        if smb_state.open_files[i].active == 0 {
            file_id = i as i32
            break
        }
        i = i + 1
    }

    if file_id < 0 {
        return -1
    }

    let buffer: *u8 = &smb_state.send_buffer[0]
    let reply: *u8 = &smb_state.recv_buffer[0]
    var offset: u32 = 0

    offset = build_smb2_header(buffer, offset, conn, SMB2_CREATE, tree.tree_id)

    // Create request body
    // Structure Size (2 bytes)
    offset = write_u16_le(buffer, offset, 57)

    // Security Flags (1 byte)
    buffer[offset] = 0
    offset = offset + 1

    // Requested Oplock Level (1 byte)
    buffer[offset] = 0  // No oplock
    offset = offset + 1

    // Impersonation Level (4 bytes)
    offset = write_u32_le(buffer, offset, 0x02)  // Impersonation

    // SMB Create Flags (8 bytes)
    offset = write_u64_le(buffer, offset, 0)

    // Reserved (8 bytes)
    offset = write_u64_le(buffer, offset, 0)

    // Desired Access (4 bytes)
    offset = write_u32_le(buffer, offset, access_mask)

    // File Attributes (4 bytes)
    offset = write_u32_le(buffer, offset, FILE_ATTRIBUTE_NORMAL)

    // Share Access (4 bytes)
    offset = write_u32_le(buffer, offset, FILE_SHARE_READ | FILE_SHARE_WRITE)

    // Create Disposition (4 bytes)
    offset = write_u32_le(buffer, offset, disposition)

    // Create Options (4 bytes)
    offset = write_u32_le(buffer, offset, FILE_NON_DIRECTORY_FILE)

    // Name Offset (2 bytes)
    let name_offset_pos: u32 = offset
    offset = write_u16_le(buffer, offset, 0)

    // Name Length (2 bytes)
    let name_len_pos: u32 = offset
    offset = write_u16_le(buffer, offset, 0)

    // Create Contexts Offset (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // Create Contexts Length (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // File name (Unicode)
    let name_start: u32 = offset
    write_u16_le(buffer, name_offset_pos, name_start as u16)

    offset = write_unicode_string(buffer, offset, filename, filename_len)
    let name_len: u32 = filename_len * 2
    write_u16_le(buffer, name_len_pos, name_len as u16)

    // Send request
    if send_smb2_message(conn, buffer, offset) < 0 {
        return -1
    }

    // Receive response
    let recv_len: i32 = recv_smb2_message(conn, reply, SMB_BUFFER_SIZE)
    if recv_len < 64 {
        return -1
    }

    var status: u32 = 0
    var session_id: u64 = 0
    let header_len: i32 = parse_smb2_header(reply, &status, &session_id)
    if header_len < 0 or status != STATUS_SUCCESS {
        return -(status as i32)
    }

    // Parse Create response
    let resp_offset: u32 = header_len as u32

    // File ID at offset 64 (from start of response body, which is at offset 32)
    let persistent_id: u64 = read_u64_le(reply, resp_offset + 64)
    let volatile_id: u64 = read_u64_le(reply, resp_offset + 72)

    // Store file info
    let file: *SmbOpenFile = &smb_state.open_files[file_id as u32]
    file.active = 1
    file.connection_id = tree.connection_id
    file.tree_id = tree.tree_id
    file.file_id.persistent = persistent_id
    file.file_id.volatile_ = volatile_id
    file.position = 0
    file.access_mask = access_mask
    file.is_directory = 0

    // Get file size from response
    file.size = read_u64_le(reply, resp_offset + 48)  // EndOfFile field

    return file_id
}

export fn smb_close_file(file_id: i32) {
    if file_id < 0 or file_id >= MAX_OPEN_FILES as i32 {
        return
    }

    let file: *SmbOpenFile = &smb_state.open_files[file_id as u32]
    if file.active == 0 {
        return
    }

    let conn: *SmbConnection = &smb_state.connections[file.connection_id]
    if conn.active == 0 {
        file.active = 0
        return
    }

    let buffer: *u8 = &smb_state.send_buffer[0]
    var offset: u32 = 0

    offset = build_smb2_header(buffer, offset, conn, SMB2_CLOSE, file.tree_id)

    // Close request body
    // Structure Size (2 bytes)
    offset = write_u16_le(buffer, offset, 24)

    // Flags (2 bytes)
    offset = write_u16_le(buffer, offset, 0)

    // Reserved (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // File ID
    offset = write_u64_le(buffer, offset, file.file_id.persistent)
    offset = write_u64_le(buffer, offset, file.file_id.volatile_)

    send_smb2_message(conn, buffer, offset)

    file.active = 0
}

export fn smb_read_file(file_id: i32, output_buffer: *u8, count: u32): i32 {
    if file_id < 0 or file_id >= MAX_OPEN_FILES as i32 {
        return -1
    }

    let file: *SmbOpenFile = &smb_state.open_files[file_id as u32]
    if file.active == 0 {
        return -1
    }

    let conn: *SmbConnection = &smb_state.connections[file.connection_id]
    if conn.active == 0 {
        return -1
    }

    let read_count: u32 = if count > conn.max_read_size { conn.max_read_size } else { count }

    let buffer: *u8 = &smb_state.send_buffer[0]
    let reply: *u8 = &smb_state.recv_buffer[0]
    var offset: u32 = 0

    offset = build_smb2_header(buffer, offset, conn, SMB2_READ, file.tree_id)

    // Read request body
    // Structure Size (2 bytes)
    offset = write_u16_le(buffer, offset, 49)

    // Padding (1 byte)
    buffer[offset] = 0
    offset = offset + 1

    // Flags (1 byte)
    buffer[offset] = 0
    offset = offset + 1

    // Length (4 bytes)
    offset = write_u32_le(buffer, offset, read_count)

    // Offset (8 bytes)
    offset = write_u64_le(buffer, offset, file.position)

    // File ID
    offset = write_u64_le(buffer, offset, file.file_id.persistent)
    offset = write_u64_le(buffer, offset, file.file_id.volatile_)

    // Minimum Count (4 bytes)
    offset = write_u32_le(buffer, offset, 1)

    // Channel (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // Remaining Bytes (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // Read Channel Info Offset (2 bytes)
    offset = write_u16_le(buffer, offset, 0)

    // Read Channel Info Length (2 bytes)
    offset = write_u16_le(buffer, offset, 0)

    // Buffer (1 byte minimum)
    buffer[offset] = 0
    offset = offset + 1

    // Send request
    if send_smb2_message(conn, buffer, offset) < 0 {
        return -1
    }

    // Receive response
    let recv_len: i32 = recv_smb2_message(conn, reply, SMB_BUFFER_SIZE)
    if recv_len < 64 {
        return -1
    }

    var status: u32 = 0
    var session_id: u64 = 0
    let header_len: i32 = parse_smb2_header(reply, &status, &session_id)
    if header_len < 0 or status != STATUS_SUCCESS {
        return -1
    }

    // Parse Read response
    let resp_offset: u32 = header_len as u32

    let data_offset: u16 = read_u16_le(reply, resp_offset + 2)
    let data_length: u32 = read_u32_le(reply, resp_offset + 4)

    // Copy data to output buffer
    var i: u32 = 0
    let copy_len: u32 = if data_length < count { data_length } else { count }
    while i < copy_len {
        output_buffer[i] = reply[data_offset as u32 + i]
        i = i + 1
    }

    file.position = file.position + copy_len as u64
    conn.bytes_read = conn.bytes_read + copy_len as u64

    return copy_len as i32
}

export fn smb_write_file(file_id: i32, input_buffer: *u8, count: u32): i32 {
    if file_id < 0 or file_id >= MAX_OPEN_FILES as i32 {
        return -1
    }

    let file: *SmbOpenFile = &smb_state.open_files[file_id as u32]
    if file.active == 0 {
        return -1
    }

    let conn: *SmbConnection = &smb_state.connections[file.connection_id]
    if conn.active == 0 {
        return -1
    }

    let write_count: u32 = if count > conn.max_write_size { conn.max_write_size } else { count }

    let buffer: *u8 = &smb_state.send_buffer[0]
    let reply: *u8 = &smb_state.recv_buffer[0]
    var offset: u32 = 0

    offset = build_smb2_header(buffer, offset, conn, SMB2_WRITE, file.tree_id)

    // Write request body
    // Structure Size (2 bytes)
    offset = write_u16_le(buffer, offset, 49)

    // Data Offset (2 bytes)
    let data_offset_pos: u32 = offset
    offset = write_u16_le(buffer, offset, 0)

    // Length (4 bytes)
    offset = write_u32_le(buffer, offset, write_count)

    // Offset (8 bytes)
    offset = write_u64_le(buffer, offset, file.position)

    // File ID
    offset = write_u64_le(buffer, offset, file.file_id.persistent)
    offset = write_u64_le(buffer, offset, file.file_id.volatile_)

    // Channel (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // Remaining Bytes (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // Write Channel Info Offset (2 bytes)
    offset = write_u16_le(buffer, offset, 0)

    // Write Channel Info Length (2 bytes)
    offset = write_u16_le(buffer, offset, 0)

    // Flags (4 bytes)
    offset = write_u32_le(buffer, offset, 0)

    // Data
    let data_start: u32 = offset
    write_u16_le(buffer, data_offset_pos, data_start as u16)

    var i: u32 = 0
    while i < write_count {
        buffer[offset + i] = input_buffer[i]
        i = i + 1
    }
    offset = offset + write_count

    // Send request
    if send_smb2_message(conn, buffer, offset) < 0 {
        return -1
    }

    // Receive response
    let recv_len: i32 = recv_smb2_message(conn, reply, SMB_BUFFER_SIZE)
    if recv_len < 64 {
        return -1
    }

    var status: u32 = 0
    var session_id: u64 = 0
    let header_len: i32 = parse_smb2_header(reply, &status, &session_id)
    if header_len < 0 or status != STATUS_SUCCESS {
        return -1
    }

    // Parse Write response
    let resp_offset: u32 = header_len as u32
    let bytes_written: u32 = read_u32_le(reply, resp_offset + 4)

    file.position = file.position + bytes_written as u64
    conn.bytes_written = conn.bytes_written + bytes_written as u64

    return bytes_written as i32
}

export fn smb_seek_file(file_id: i32, offset: i64, whence: u32): i64 {
    if file_id < 0 or file_id >= MAX_OPEN_FILES as i32 {
        return -1
    }

    let file: *SmbOpenFile = &smb_state.open_files[file_id as u32]
    if file.active == 0 {
        return -1
    }

    switch whence {
        0 => {  // SEEK_SET
            file.position = offset as u64
        }
        1 => {  // SEEK_CUR
            file.position = (file.position as i64 + offset) as u64
        }
        2 => {  // SEEK_END
            file.position = (file.size as i64 + offset) as u64
        }
        else => {
            return -1
        }
    }

    return file.position as i64
}

// ============================================================================
// Directory Operations
// ============================================================================

export fn smb_list_directory(tree_id: i32, path: *u8, path_len: u32, entries: *SmbDirEntry, max_entries: u32): i32 {
    if tree_id < 0 or tree_id >= MAX_TREE_CONNECTS as i32 {
        return -1
    }

    let tree: *SmbTreeConnect = &smb_state.tree_connects[tree_id as u32]
    if tree.active == 0 {
        return -1
    }

    let conn: *SmbConnection = &smb_state.connections[tree.connection_id]
    if conn.active == 0 {
        return -1
    }

    // Open directory
    let buffer: *u8 = &smb_state.send_buffer[0]
    let reply: *u8 = &smb_state.recv_buffer[0]
    var offset: u32 = 0

    // First, create/open the directory handle
    offset = build_smb2_header(buffer, offset, conn, SMB2_CREATE, tree.tree_id)

    // Create request for directory
    offset = write_u16_le(buffer, offset, 57)  // Structure Size
    buffer[offset] = 0  // Security Flags
    offset = offset + 1
    buffer[offset] = 0  // Oplock
    offset = offset + 1
    offset = write_u32_le(buffer, offset, 0x02)  // Impersonation
    offset = write_u64_le(buffer, offset, 0)  // Flags
    offset = write_u64_le(buffer, offset, 0)  // Reserved
    offset = write_u32_le(buffer, offset, FILE_READ_DATA | FILE_READ_ATTRIBUTES)  // Access
    offset = write_u32_le(buffer, offset, FILE_ATTRIBUTE_DIRECTORY)  // Attributes
    offset = write_u32_le(buffer, offset, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)  // Share
    offset = write_u32_le(buffer, offset, FILE_OPEN)  // Disposition
    offset = write_u32_le(buffer, offset, FILE_DIRECTORY_FILE)  // Options

    let name_offset_pos: u32 = offset
    offset = write_u16_le(buffer, offset, 0)
    let name_len_pos: u32 = offset
    offset = write_u16_le(buffer, offset, 0)
    offset = write_u32_le(buffer, offset, 0)  // Context offset
    offset = write_u32_le(buffer, offset, 0)  // Context length

    let name_start: u32 = offset
    write_u16_le(buffer, name_offset_pos, name_start as u16)

    if path_len > 0 {
        offset = write_unicode_string(buffer, offset, path, path_len)
    }
    write_u16_le(buffer, name_len_pos, (path_len * 2) as u16)

    if send_smb2_message(conn, buffer, offset) < 0 {
        return -1
    }

    let recv_len: i32 = recv_smb2_message(conn, reply, SMB_BUFFER_SIZE)
    if recv_len < 64 {
        return -1
    }

    var status: u32 = 0
    var session_id: u64 = 0
    let header_len: i32 = parse_smb2_header(reply, &status, &session_id)
    if header_len < 0 or status != STATUS_SUCCESS {
        return -1
    }

    // Get file ID from Create response
    let resp_offset: u32 = header_len as u32
    let persistent_id: u64 = read_u64_le(reply, resp_offset + 64)
    let volatile_id: u64 = read_u64_le(reply, resp_offset + 72)

    // Now send Query Directory request
    offset = 0
    offset = build_smb2_header(buffer, offset, conn, SMB2_QUERY_DIRECTORY, tree.tree_id)

    // Query Directory request
    offset = write_u16_le(buffer, offset, 33)  // Structure Size
    buffer[offset] = 0x25  // FileIdBothDirectoryInformation
    offset = offset + 1
    buffer[offset] = 0  // Flags
    offset = offset + 1
    offset = write_u32_le(buffer, offset, 0)  // File Index
    offset = write_u64_le(buffer, offset, persistent_id)
    offset = write_u64_le(buffer, offset, volatile_id)

    let search_offset_pos: u32 = offset
    offset = write_u16_le(buffer, offset, 0)
    let search_len_pos: u32 = offset
    offset = write_u16_le(buffer, offset, 0)
    offset = write_u32_le(buffer, offset, 65536)  // Output buffer size

    // Search pattern "*"
    let search_start: u32 = offset
    write_u16_le(buffer, search_offset_pos, search_start as u16)
    buffer[offset] = 0x2A  // '*'
    buffer[offset + 1] = 0
    offset = offset + 2
    write_u16_le(buffer, search_len_pos, 2)

    if send_smb2_message(conn, buffer, offset) < 0 {
        return -1
    }

    let dir_recv_len: i32 = recv_smb2_message(conn, reply, SMB_BUFFER_SIZE)
    if dir_recv_len < 64 {
        return -1
    }

    let dir_header_len: i32 = parse_smb2_header(reply, &status, &session_id)
    if dir_header_len < 0 or status != STATUS_SUCCESS {
        // Close directory handle
        offset = 0
        offset = build_smb2_header(buffer, offset, conn, SMB2_CLOSE, tree.tree_id)
        offset = write_u16_le(buffer, offset, 24)
        offset = write_u16_le(buffer, offset, 0)
        offset = write_u32_le(buffer, offset, 0)
        offset = write_u64_le(buffer, offset, persistent_id)
        offset = write_u64_le(buffer, offset, volatile_id)
        send_smb2_message(conn, buffer, offset)
        return -1
    }

    // Parse directory entries
    let dir_resp_offset: u32 = dir_header_len as u32
    let output_offset: u16 = read_u16_le(reply, dir_resp_offset + 2)
    let output_length: u32 = read_u32_le(reply, dir_resp_offset + 4)

    var entry_count: u32 = 0
    var data_pos: u32 = output_offset as u32

    while entry_count < max_entries and data_pos < (output_offset as u32 + output_length) {
        let next_offset: u32 = read_u32_le(reply, data_pos)

        let entry: *SmbDirEntry = &entries[entry_count]

        entry.file_index = read_u32_le(reply, data_pos + 4)
        entry.creation_time = read_u64_le(reply, data_pos + 8)
        entry.last_access_time = read_u64_le(reply, data_pos + 16)
        entry.last_write_time = read_u64_le(reply, data_pos + 24)
        entry.change_time = read_u64_le(reply, data_pos + 32)
        entry.file_size = read_u64_le(reply, data_pos + 40)
        entry.allocation_size = read_u64_le(reply, data_pos + 48)
        entry.attributes = read_u32_le(reply, data_pos + 56)

        let file_name_len: u32 = read_u32_le(reply, data_pos + 60)
        let file_name_offset: u32 = data_pos + 104  // After FileId

        entry.name_len = read_unicode_string(reply, file_name_offset, &entry.file_name[0], 255, file_name_len / 2)

        entry_count = entry_count + 1

        if next_offset == 0 {
            break
        }
        data_pos = data_pos + next_offset
    }

    // Close directory handle
    offset = 0
    offset = build_smb2_header(buffer, offset, conn, SMB2_CLOSE, tree.tree_id)
    offset = write_u16_le(buffer, offset, 24)
    offset = write_u16_le(buffer, offset, 0)
    offset = write_u32_le(buffer, offset, 0)
    offset = write_u64_le(buffer, offset, persistent_id)
    offset = write_u64_le(buffer, offset, volatile_id)
    send_smb2_message(conn, buffer, offset)

    return entry_count as i32
}

// ============================================================================
// High-Level API
// ============================================================================

export fn smb_open(conn_id: i32, share_name: *u8, share_len: u32, filename: *u8, filename_len: u32, mode: u32): i32 {
    // Connect to share
    let tree_id: i32 = smb_tree_connect(conn_id, share_name, share_len)
    if tree_id < 0 {
        return -1
    }

    // Determine access and disposition from mode
    var access: u32 = FILE_READ_DATA | FILE_READ_ATTRIBUTES
    var disposition: u32 = FILE_OPEN

    if (mode & 0x02) != 0 {  // Write mode
        access = access | FILE_WRITE_DATA | FILE_APPEND_DATA | FILE_WRITE_ATTRIBUTES
        disposition = FILE_OPEN_IF
    }

    let file_id: i32 = smb_create_file(tree_id, filename, filename_len, access, disposition)
    if file_id < 0 {
        smb_tree_disconnect(tree_id)
        return -1
    }

    return file_id
}

export fn smb_close(file_id: i32) {
    smb_close_file(file_id)
}

export fn smb_read(file_id: i32, buffer: *u8, count: u32): i32 {
    return smb_read_file(file_id, buffer, count)
}

export fn smb_write(file_id: i32, buffer: *u8, count: u32): i32 {
    return smb_write_file(file_id, buffer, count)
}

export fn smb_seek(file_id: i32, offset: i64, whence: u32): i64 {
    return smb_seek_file(file_id, offset, whence)
}

// ============================================================================
// Utility
// ============================================================================

fn print_ip(ip: u32) {
    foundation.serial_write_u32((ip >> 24) & 0xFF)
    foundation.serial_write_string(".")
    foundation.serial_write_u32((ip >> 16) & 0xFF)
    foundation.serial_write_string(".")
    foundation.serial_write_u32((ip >> 8) & 0xFF)
    foundation.serial_write_string(".")
    foundation.serial_write_u32(ip & 0xFF)
}

export fn smb_print_stats(conn_id: i32) {
    if conn_id < 0 or conn_id >= MAX_SMB_CONNECTIONS as i32 {
        return
    }

    let conn: *SmbConnection = &smb_state.connections[conn_id as u32]
    if conn.active == 0 {
        return
    }

    foundation.serial_write_string("[SMB] Connection ")
    foundation.serial_write_u32(conn_id as u32)
    foundation.serial_write_string(" statistics:\n")
    foundation.serial_write_string("  Requests sent: ")
    foundation.serial_write_u64(conn.requests_sent)
    foundation.serial_write_string("\n  Responses received: ")
    foundation.serial_write_u64(conn.responses_received)
    foundation.serial_write_string("\n  Bytes read: ")
    foundation.serial_write_u64(conn.bytes_read)
    foundation.serial_write_string("\n  Bytes written: ")
    foundation.serial_write_u64(conn.bytes_written)
    foundation.serial_write_string("\n  Errors: ")
    foundation.serial_write_u64(conn.errors)
    foundation.serial_write_string("\n")
}
