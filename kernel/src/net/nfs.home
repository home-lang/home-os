// home-os NFS Client
// Network File System v3 and v4 Client Implementation

import "../core/foundation.home" as foundation
import "tcp.home" as tcp
import "udp.home" as udp

// ============================================================================
// NFS Version Constants
// ============================================================================

const NFS_VERSION_3: u32 = 3
const NFS_VERSION_4: u32 = 4

// NFS Ports
const NFS_PORT: u16 = 2049
const MOUNT_PORT: u16 = 20048
const PORTMAP_PORT: u16 = 111

// ============================================================================
// RPC/XDR Constants
// ============================================================================

const RPC_VERSION: u32 = 2
const RPC_CALL: u32 = 0
const RPC_REPLY: u32 = 1

const RPC_MSG_ACCEPTED: u32 = 0
const RPC_MSG_DENIED: u32 = 1

const AUTH_NONE: u32 = 0
const AUTH_SYS: u32 = 1

// NFS Program Numbers
const NFS_PROGRAM: u32 = 100003
const MOUNT_PROGRAM: u32 = 100005
const PORTMAP_PROGRAM: u32 = 100000

// ============================================================================
// NFSv3 Procedure Numbers
// ============================================================================

const NFSPROC3_NULL: u32 = 0
const NFSPROC3_GETATTR: u32 = 1
const NFSPROC3_SETATTR: u32 = 2
const NFSPROC3_LOOKUP: u32 = 3
const NFSPROC3_ACCESS: u32 = 4
const NFSPROC3_READLINK: u32 = 5
const NFSPROC3_READ: u32 = 6
const NFSPROC3_WRITE: u32 = 7
const NFSPROC3_CREATE: u32 = 8
const NFSPROC3_MKDIR: u32 = 9
const NFSPROC3_SYMLINK: u32 = 10
const NFSPROC3_MKNOD: u32 = 11
const NFSPROC3_REMOVE: u32 = 12
const NFSPROC3_RMDIR: u32 = 13
const NFSPROC3_RENAME: u32 = 14
const NFSPROC3_LINK: u32 = 15
const NFSPROC3_READDIR: u32 = 16
const NFSPROC3_READDIRPLUS: u32 = 17
const NFSPROC3_FSSTAT: u32 = 18
const NFSPROC3_FSINFO: u32 = 19
const NFSPROC3_PATHCONF: u32 = 20
const NFSPROC3_COMMIT: u32 = 21

// Mount Procedure Numbers
const MOUNTPROC3_NULL: u32 = 0
const MOUNTPROC3_MNT: u32 = 1
const MOUNTPROC3_DUMP: u32 = 2
const MOUNTPROC3_UMNT: u32 = 3
const MOUNTPROC3_UMNTALL: u32 = 4
const MOUNTPROC3_EXPORT: u32 = 5

// ============================================================================
// NFS Status Codes
// ============================================================================

const NFS3_OK: u32 = 0
const NFS3ERR_PERM: u32 = 1
const NFS3ERR_NOENT: u32 = 2
const NFS3ERR_IO: u32 = 5
const NFS3ERR_NXIO: u32 = 6
const NFS3ERR_ACCES: u32 = 13
const NFS3ERR_EXIST: u32 = 17
const NFS3ERR_XDEV: u32 = 18
const NFS3ERR_NODEV: u32 = 19
const NFS3ERR_NOTDIR: u32 = 20
const NFS3ERR_ISDIR: u32 = 21
const NFS3ERR_INVAL: u32 = 22
const NFS3ERR_FBIG: u32 = 27
const NFS3ERR_NOSPC: u32 = 28
const NFS3ERR_ROFS: u32 = 30
const NFS3ERR_MLINK: u32 = 31
const NFS3ERR_NAMETOOLONG: u32 = 63
const NFS3ERR_NOTEMPTY: u32 = 66
const NFS3ERR_DQUOT: u32 = 69
const NFS3ERR_STALE: u32 = 70
const NFS3ERR_REMOTE: u32 = 71
const NFS3ERR_BADHANDLE: u32 = 10001
const NFS3ERR_NOT_SYNC: u32 = 10002
const NFS3ERR_BAD_COOKIE: u32 = 10003
const NFS3ERR_NOTSUPP: u32 = 10004
const NFS3ERR_TOOSMALL: u32 = 10005
const NFS3ERR_SERVERFAULT: u32 = 10006
const NFS3ERR_BADTYPE: u32 = 10007
const NFS3ERR_JUKEBOX: u32 = 10008

// ============================================================================
// NFS File Types
// ============================================================================

const NF3REG: u32 = 1    // Regular file
const NF3DIR: u32 = 2    // Directory
const NF3BLK: u32 = 3    // Block device
const NF3CHR: u32 = 4    // Character device
const NF3LNK: u32 = 5    // Symbolic link
const NF3SOCK: u32 = 6   // Socket
const NF3FIFO: u32 = 7   // Named pipe

// ============================================================================
// Access Bits
// ============================================================================

const ACCESS3_READ: u32 = 0x0001
const ACCESS3_LOOKUP: u32 = 0x0002
const ACCESS3_MODIFY: u32 = 0x0004
const ACCESS3_EXTEND: u32 = 0x0008
const ACCESS3_DELETE: u32 = 0x0010
const ACCESS3_EXECUTE: u32 = 0x0020

// ============================================================================
// Constants
// ============================================================================

const MAX_NFS_MOUNTS: u32 = 16
const MAX_FILE_HANDLE_SIZE: u32 = 64
const MAX_PATH_LEN: u32 = 1024
const MAX_READ_SIZE: u32 = 65536
const MAX_WRITE_SIZE: u32 = 65536
const RPC_BUFFER_SIZE: u32 = 131072

// ============================================================================
// Data Structures
// ============================================================================

struct NfsFileHandle {
    data: [u8; 64],
    len: u32
}

struct NfsFileAttrs {
    type_: u32,
    mode: u32,
    nlink: u32,
    uid: u32,
    gid: u32,
    size: u64,
    used: u64,
    rdev_major: u32,
    rdev_minor: u32,
    fsid: u64,
    fileid: u64,
    atime_sec: u32,
    atime_nsec: u32,
    mtime_sec: u32,
    mtime_nsec: u32,
    ctime_sec: u32,
    ctime_nsec: u32
}

struct NfsDirEntry {
    fileid: u64,
    name: [u8; 256],
    name_len: u32,
    cookie: u64,
    attrs_valid: u32,
    attrs: NfsFileAttrs,
    handle_valid: u32,
    handle: NfsFileHandle
}

struct NfsMount {
    active: u32,
    server_ip: u32,
    export_path: [u8; 256],
    export_path_len: u32,
    root_handle: NfsFileHandle,
    tcp_socket: i32,
    udp_socket: i32,
    use_tcp: u32,
    nfs_version: u32,
    read_size: u32,
    write_size: u32,
    uid: u32,
    gid: u32,

    // Statistics
    reads: u64,
    writes: u64,
    lookups: u64,
    readdirs: u64,
    errors: u64
}

struct NfsOpenFile {
    active: u32,
    mount_id: u32,
    handle: NfsFileHandle,
    attrs: NfsFileAttrs,
    position: u64,
    flags: u32
}

struct RpcHeader {
    xid: u32,
    msg_type: u32,
    rpc_version: u32,
    program: u32,
    prog_version: u32,
    procedure: u32
}

struct NfsState {
    initialized: u32,
    mounts: [NfsMount; 16],
    open_files: [NfsOpenFile; 64],
    next_xid: u32,
    rpc_buffer: [u8; 131072],
    reply_buffer: [u8; 131072],
    default_uid: u32,
    default_gid: u32
}

// ============================================================================
// Global State
// ============================================================================

var nfs_state: NfsState

// ============================================================================
// XDR Encoding/Decoding
// ============================================================================

fn xdr_encode_u32(buffer: *u8, offset: u32, value: u32): u32 {
    buffer[offset] = ((value >> 24) & 0xFF) as u8
    buffer[offset + 1] = ((value >> 16) & 0xFF) as u8
    buffer[offset + 2] = ((value >> 8) & 0xFF) as u8
    buffer[offset + 3] = (value & 0xFF) as u8
    return offset + 4
}

fn xdr_decode_u32(buffer: *u8, offset: u32): u32 {
    return ((buffer[offset] as u32) << 24) | ((buffer[offset + 1] as u32) << 16) |
           ((buffer[offset + 2] as u32) << 8) | (buffer[offset + 3] as u32)
}

fn xdr_encode_u64(buffer: *u8, offset: u32, value: u64): u32 {
    let high: u32 = (value >> 32) as u32
    let low: u32 = (value & 0xFFFFFFFF) as u32
    offset = xdr_encode_u32(buffer, offset, high)
    return xdr_encode_u32(buffer, offset, low)
}

fn xdr_decode_u64(buffer: *u8, offset: u32): u64 {
    let high: u32 = xdr_decode_u32(buffer, offset)
    let low: u32 = xdr_decode_u32(buffer, offset + 4)
    return ((high as u64) << 32) | (low as u64)
}

fn xdr_encode_opaque(buffer: *u8, offset: u32, data: *u8, len: u32): u32 {
    offset = xdr_encode_u32(buffer, offset, len)

    var i: u32 = 0
    while i < len {
        buffer[offset + i] = data[i]
        i = i + 1
    }
    offset = offset + len

    // Pad to 4-byte boundary
    let padding: u32 = (4 - (len % 4)) % 4
    i = 0
    while i < padding {
        buffer[offset + i] = 0
        i = i + 1
    }

    return offset + padding
}

fn xdr_decode_opaque(buffer: *u8, offset: u32, data: *u8, max_len: u32): u32 {
    let len: u32 = xdr_decode_u32(buffer, offset)
    offset = offset + 4

    let copy_len: u32 = if len < max_len { len } else { max_len }
    var i: u32 = 0
    while i < copy_len {
        data[i] = buffer[offset + i]
        i = i + 1
    }

    let padding: u32 = (4 - (len % 4)) % 4
    return offset + len + padding
}

fn xdr_encode_string(buffer: *u8, offset: u32, str: *u8, len: u32): u32 {
    return xdr_encode_opaque(buffer, offset, str, len)
}

fn xdr_encode_file_handle(buffer: *u8, offset: u32, handle: *NfsFileHandle): u32 {
    return xdr_encode_opaque(buffer, offset, &handle.data[0], handle.len)
}

fn xdr_decode_file_handle(buffer: *u8, offset: u32, handle: *NfsFileHandle): u32 {
    let len: u32 = xdr_decode_u32(buffer, offset)
    handle.len = if len < MAX_FILE_HANDLE_SIZE { len } else { MAX_FILE_HANDLE_SIZE }
    offset = offset + 4

    var i: u32 = 0
    while i < handle.len {
        handle.data[i] = buffer[offset + i]
        i = i + 1
    }

    let padding: u32 = (4 - (len % 4)) % 4
    return offset + len + padding
}

// ============================================================================
// RPC Message Building
// ============================================================================

fn build_rpc_header(buffer: *u8, offset: u32, xid: u32, program: u32, version: u32, procedure: u32): u32 {
    // XID
    offset = xdr_encode_u32(buffer, offset, xid)
    // Message type (Call)
    offset = xdr_encode_u32(buffer, offset, RPC_CALL)
    // RPC version
    offset = xdr_encode_u32(buffer, offset, RPC_VERSION)
    // Program
    offset = xdr_encode_u32(buffer, offset, program)
    // Program version
    offset = xdr_encode_u32(buffer, offset, version)
    // Procedure
    offset = xdr_encode_u32(buffer, offset, procedure)

    return offset
}

fn build_auth_sys(buffer: *u8, offset: u32, uid: u32, gid: u32): u32 {
    // Auth flavor (AUTH_SYS)
    offset = xdr_encode_u32(buffer, offset, AUTH_SYS)

    // Calculate auth body length (will update later)
    let len_offset: u32 = offset
    offset = offset + 4

    let auth_start: u32 = offset

    // Stamp (timestamp)
    offset = xdr_encode_u32(buffer, offset, 0)

    // Machine name (empty)
    offset = xdr_encode_string(buffer, offset, null, 0)

    // UID
    offset = xdr_encode_u32(buffer, offset, uid)

    // GID
    offset = xdr_encode_u32(buffer, offset, gid)

    // Auxiliary GIDs (count = 0)
    offset = xdr_encode_u32(buffer, offset, 0)

    // Update auth body length
    let auth_len: u32 = offset - auth_start
    xdr_encode_u32(buffer, len_offset, auth_len)

    // Verifier (AUTH_NONE)
    offset = xdr_encode_u32(buffer, offset, AUTH_NONE)
    offset = xdr_encode_u32(buffer, offset, 0)  // Length

    return offset
}

fn build_auth_none(buffer: *u8, offset: u32): u32 {
    // Auth flavor (AUTH_NONE)
    offset = xdr_encode_u32(buffer, offset, AUTH_NONE)
    offset = xdr_encode_u32(buffer, offset, 0)  // Length

    // Verifier (AUTH_NONE)
    offset = xdr_encode_u32(buffer, offset, AUTH_NONE)
    offset = xdr_encode_u32(buffer, offset, 0)  // Length

    return offset
}

// ============================================================================
// Initialization
// ============================================================================

export fn nfs_init() {
    foundation.mem_set(&nfs_state as *u8, 0, @sizeOf(NfsState))

    nfs_state.next_xid = 0x12345678
    nfs_state.default_uid = 0
    nfs_state.default_gid = 0

    nfs_state.initialized = 1

    foundation.serial_write_string("[NFS] Client initialized\n")
}

export fn nfs_set_credentials(uid: u32, gid: u32) {
    nfs_state.default_uid = uid
    nfs_state.default_gid = gid
}

fn get_next_xid(): u32 {
    let xid: u32 = nfs_state.next_xid
    nfs_state.next_xid = nfs_state.next_xid + 1
    return xid
}

// ============================================================================
// RPC Communication
// ============================================================================

fn send_rpc(mount: *NfsMount, buffer: *u8, len: u32, reply: *u8, reply_max: u32): i32 {
    if mount.use_tcp == 1 {
        // TCP: Send with record marking
        var tcp_buffer: [u8; 131076]
        let record_len: u32 = len | 0x80000000  // Last fragment

        tcp_buffer[0] = ((record_len >> 24) & 0xFF) as u8
        tcp_buffer[1] = ((record_len >> 16) & 0xFF) as u8
        tcp_buffer[2] = ((record_len >> 8) & 0xFF) as u8
        tcp_buffer[3] = (record_len & 0xFF) as u8

        var i: u32 = 0
        while i < len {
            tcp_buffer[4 + i] = buffer[i]
            i = i + 1
        }

        // Send request
        let sent: i32 = tcp.tcp_send(mount.tcp_socket, &tcp_buffer[0], len + 4)
        if sent < 0 {
            return -1
        }

        // Receive reply
        let recv_len: i32 = tcp.tcp_recv(mount.tcp_socket, &tcp_buffer[0], reply_max + 4)
        if recv_len <= 4 {
            return -1
        }

        // Skip record marker
        i = 0
        while i < (recv_len - 4) as u32 {
            reply[i] = tcp_buffer[4 + i]
            i = i + 1
        }

        return recv_len - 4
    } else {
        // UDP: Send directly
        let sent: i32 = udp.udp_sendto(mount.udp_socket, buffer, len, mount.server_ip, NFS_PORT)
        if sent < 0 {
            return -1
        }

        // Receive reply
        var src_ip: u32 = 0
        var src_port: u16 = 0
        let recv_len: i32 = udp.udp_recvfrom(mount.udp_socket, reply, reply_max, &src_ip, &src_port)

        return recv_len
    }
}

fn parse_rpc_reply(buffer: *u8, len: u32, expected_xid: u32): i32 {
    if len < 24 {
        return -1
    }

    let xid: u32 = xdr_decode_u32(buffer, 0)
    if xid != expected_xid {
        return -1  // XID mismatch
    }

    let msg_type: u32 = xdr_decode_u32(buffer, 4)
    if msg_type != RPC_REPLY {
        return -1  // Not a reply
    }

    let reply_stat: u32 = xdr_decode_u32(buffer, 8)
    if reply_stat != RPC_MSG_ACCEPTED {
        return -1  // Message denied
    }

    // Skip verifier
    let verifier_flavor: u32 = xdr_decode_u32(buffer, 12)
    let verifier_len: u32 = xdr_decode_u32(buffer, 16)

    let data_offset: u32 = 20 + verifier_len

    // Accept status
    let accept_stat: u32 = xdr_decode_u32(buffer, data_offset)
    if accept_stat != 0 {
        return -1  // RPC error
    }

    return (data_offset + 4) as i32  // Return offset to NFS reply data
}

// ============================================================================
// Mount Operations
// ============================================================================

export fn nfs_mount(server_ip: u32, export_path: *u8, path_len: u32, use_tcp: u32): i32 {
    // Find free mount slot
    var mount_id: i32 = -1
    var i: u32 = 0
    while i < MAX_NFS_MOUNTS {
        if nfs_state.mounts[i].active == 0 {
            mount_id = i as i32
            break
        }
        i = i + 1
    }

    if mount_id < 0 {
        return -1  // No free slots
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    foundation.mem_set(mount as *u8, 0, @sizeOf(NfsMount))

    mount.server_ip = server_ip
    mount.nfs_version = NFS_VERSION_3
    mount.use_tcp = use_tcp
    mount.read_size = MAX_READ_SIZE
    mount.write_size = MAX_WRITE_SIZE
    mount.uid = nfs_state.default_uid
    mount.gid = nfs_state.default_gid

    // Copy export path
    mount.export_path_len = if path_len < 255 { path_len } else { 255 }
    i = 0
    while i < mount.export_path_len {
        mount.export_path[i] = export_path[i]
        i = i + 1
    }
    mount.export_path[mount.export_path_len] = 0

    // Create socket
    if use_tcp == 1 {
        mount.tcp_socket = tcp.tcp_socket()
        if mount.tcp_socket < 0 {
            return -1
        }

        if tcp.tcp_connect(mount.tcp_socket, server_ip, NFS_PORT) < 0 {
            tcp.tcp_close(mount.tcp_socket)
            return -1
        }
    } else {
        mount.udp_socket = udp.udp_socket()
        if mount.udp_socket < 0 {
            return -1
        }
        udp.udp_bind(mount.udp_socket, 0, 0)
    }

    // Send MOUNT request
    let buffer: *u8 = &nfs_state.rpc_buffer[0]
    let reply: *u8 = &nfs_state.reply_buffer[0]
    var offset: u32 = 0

    let xid: u32 = get_next_xid()

    offset = build_rpc_header(buffer, offset, xid, MOUNT_PROGRAM, 3, MOUNTPROC3_MNT)
    offset = build_auth_sys(buffer, offset, mount.uid, mount.gid)

    // Mount arguments: directory path
    offset = xdr_encode_string(buffer, offset, &mount.export_path[0], mount.export_path_len)

    // For mount, need to send to mount port
    // Simplified: assume mount daemon is on standard port or same as NFS
    let reply_len: i32 = send_rpc(mount, buffer, offset, reply, RPC_BUFFER_SIZE)
    if reply_len < 0 {
        if use_tcp == 1 {
            tcp.tcp_close(mount.tcp_socket)
        } else {
            udp.udp_close(mount.udp_socket)
        }
        return -1
    }

    // Parse reply
    let data_offset: i32 = parse_rpc_reply(reply, reply_len as u32, xid)
    if data_offset < 0 {
        if use_tcp == 1 {
            tcp.tcp_close(mount.tcp_socket)
        } else {
            udp.udp_close(mount.udp_socket)
        }
        return -1
    }

    // Parse mount reply
    let status: u32 = xdr_decode_u32(reply, data_offset as u32)
    if status != 0 {
        foundation.serial_write_string("[NFS] Mount failed with status ")
        foundation.serial_write_u32(status)
        foundation.serial_write_string("\n")
        if use_tcp == 1 {
            tcp.tcp_close(mount.tcp_socket)
        } else {
            udp.udp_close(mount.udp_socket)
        }
        return -1
    }

    // Extract root file handle
    let handle_offset: u32 = xdr_decode_file_handle(reply, (data_offset + 4) as u32, &mount.root_handle)

    mount.active = 1

    foundation.serial_write_string("[NFS] Mounted ")
    foundation.serial_write_string(&mount.export_path[0] as *u8)
    foundation.serial_write_string(" from ")
    print_ip(server_ip)
    foundation.serial_write_string("\n")

    return mount_id
}

export fn nfs_unmount(mount_id: i32) {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return
    }

    // Send UMNT request (optional)
    let buffer: *u8 = &nfs_state.rpc_buffer[0]
    let reply: *u8 = &nfs_state.reply_buffer[0]
    var offset: u32 = 0

    let xid: u32 = get_next_xid()
    offset = build_rpc_header(buffer, offset, xid, MOUNT_PROGRAM, 3, MOUNTPROC3_UMNT)
    offset = build_auth_sys(buffer, offset, mount.uid, mount.gid)
    offset = xdr_encode_string(buffer, offset, &mount.export_path[0], mount.export_path_len)

    send_rpc(mount, buffer, offset, reply, RPC_BUFFER_SIZE)

    // Close socket
    if mount.use_tcp == 1 {
        tcp.tcp_close(mount.tcp_socket)
    } else {
        udp.udp_close(mount.udp_socket)
    }

    mount.active = 0

    foundation.serial_write_string("[NFS] Unmounted ")
    foundation.serial_write_string(&mount.export_path[0] as *u8)
    foundation.serial_write_string("\n")
}

// ============================================================================
// File Operations
// ============================================================================

export fn nfs_lookup(mount_id: i32, dir_handle: *NfsFileHandle, name: *u8, name_len: u32, result_handle: *NfsFileHandle, attrs: *NfsFileAttrs): i32 {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return -1
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return -1
    }

    let buffer: *u8 = &nfs_state.rpc_buffer[0]
    let reply: *u8 = &nfs_state.reply_buffer[0]
    var offset: u32 = 0

    let xid: u32 = get_next_xid()
    offset = build_rpc_header(buffer, offset, xid, NFS_PROGRAM, NFS_VERSION_3, NFSPROC3_LOOKUP)
    offset = build_auth_sys(buffer, offset, mount.uid, mount.gid)

    // LOOKUP arguments
    offset = xdr_encode_file_handle(buffer, offset, dir_handle)
    offset = xdr_encode_string(buffer, offset, name, name_len)

    let reply_len: i32 = send_rpc(mount, buffer, offset, reply, RPC_BUFFER_SIZE)
    if reply_len < 0 {
        mount.errors = mount.errors + 1
        return -1
    }

    let data_offset: i32 = parse_rpc_reply(reply, reply_len as u32, xid)
    if data_offset < 0 {
        mount.errors = mount.errors + 1
        return -1
    }

    // Parse LOOKUP reply
    let status: u32 = xdr_decode_u32(reply, data_offset as u32)
    if status != NFS3_OK {
        return status as i32
    }

    var pos: u32 = (data_offset + 4) as u32

    // File handle
    pos = xdr_decode_file_handle(reply, pos, result_handle)

    // Post-op attributes (optional)
    let attrs_follow: u32 = xdr_decode_u32(reply, pos)
    pos = pos + 4

    if attrs_follow == 1 and attrs != null {
        pos = decode_file_attrs(reply, pos, attrs)
    }

    mount.lookups = mount.lookups + 1
    return 0
}

fn decode_file_attrs(buffer: *u8, offset: u32, attrs: *NfsFileAttrs): u32 {
    attrs.type_ = xdr_decode_u32(buffer, offset)
    offset = offset + 4

    attrs.mode = xdr_decode_u32(buffer, offset)
    offset = offset + 4

    attrs.nlink = xdr_decode_u32(buffer, offset)
    offset = offset + 4

    attrs.uid = xdr_decode_u32(buffer, offset)
    offset = offset + 4

    attrs.gid = xdr_decode_u32(buffer, offset)
    offset = offset + 4

    attrs.size = xdr_decode_u64(buffer, offset)
    offset = offset + 8

    attrs.used = xdr_decode_u64(buffer, offset)
    offset = offset + 8

    // rdev (specdata3)
    attrs.rdev_major = xdr_decode_u32(buffer, offset)
    attrs.rdev_minor = xdr_decode_u32(buffer, offset + 4)
    offset = offset + 8

    attrs.fsid = xdr_decode_u64(buffer, offset)
    offset = offset + 8

    attrs.fileid = xdr_decode_u64(buffer, offset)
    offset = offset + 8

    // atime
    attrs.atime_sec = xdr_decode_u32(buffer, offset)
    attrs.atime_nsec = xdr_decode_u32(buffer, offset + 4)
    offset = offset + 8

    // mtime
    attrs.mtime_sec = xdr_decode_u32(buffer, offset)
    attrs.mtime_nsec = xdr_decode_u32(buffer, offset + 4)
    offset = offset + 8

    // ctime
    attrs.ctime_sec = xdr_decode_u32(buffer, offset)
    attrs.ctime_nsec = xdr_decode_u32(buffer, offset + 4)
    offset = offset + 8

    return offset
}

export fn nfs_getattr(mount_id: i32, handle: *NfsFileHandle, attrs: *NfsFileAttrs): i32 {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return -1
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return -1
    }

    let buffer: *u8 = &nfs_state.rpc_buffer[0]
    let reply: *u8 = &nfs_state.reply_buffer[0]
    var offset: u32 = 0

    let xid: u32 = get_next_xid()
    offset = build_rpc_header(buffer, offset, xid, NFS_PROGRAM, NFS_VERSION_3, NFSPROC3_GETATTR)
    offset = build_auth_sys(buffer, offset, mount.uid, mount.gid)
    offset = xdr_encode_file_handle(buffer, offset, handle)

    let reply_len: i32 = send_rpc(mount, buffer, offset, reply, RPC_BUFFER_SIZE)
    if reply_len < 0 {
        return -1
    }

    let data_offset: i32 = parse_rpc_reply(reply, reply_len as u32, xid)
    if data_offset < 0 {
        return -1
    }

    let status: u32 = xdr_decode_u32(reply, data_offset as u32)
    if status != NFS3_OK {
        return status as i32
    }

    decode_file_attrs(reply, (data_offset + 4) as u32, attrs)
    return 0
}

export fn nfs_read(mount_id: i32, handle: *NfsFileHandle, offset: u64, count: u32, buffer: *u8): i32 {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return -1
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return -1
    }

    let read_count: u32 = if count > mount.read_size { mount.read_size } else { count }

    let rpc_buffer: *u8 = &nfs_state.rpc_buffer[0]
    let reply: *u8 = &nfs_state.reply_buffer[0]
    var rpc_offset: u32 = 0

    let xid: u32 = get_next_xid()
    rpc_offset = build_rpc_header(rpc_buffer, rpc_offset, xid, NFS_PROGRAM, NFS_VERSION_3, NFSPROC3_READ)
    rpc_offset = build_auth_sys(rpc_buffer, rpc_offset, mount.uid, mount.gid)

    // READ arguments
    rpc_offset = xdr_encode_file_handle(rpc_buffer, rpc_offset, handle)
    rpc_offset = xdr_encode_u64(rpc_buffer, rpc_offset, offset)
    rpc_offset = xdr_encode_u32(rpc_buffer, rpc_offset, read_count)

    let reply_len: i32 = send_rpc(mount, rpc_buffer, rpc_offset, reply, RPC_BUFFER_SIZE)
    if reply_len < 0 {
        mount.errors = mount.errors + 1
        return -1
    }

    let data_offset: i32 = parse_rpc_reply(reply, reply_len as u32, xid)
    if data_offset < 0 {
        mount.errors = mount.errors + 1
        return -1
    }

    let status: u32 = xdr_decode_u32(reply, data_offset as u32)
    if status != NFS3_OK {
        return -(status as i32)
    }

    var pos: u32 = (data_offset + 4) as u32

    // Skip post-op attributes
    let attrs_follow: u32 = xdr_decode_u32(reply, pos)
    pos = pos + 4
    if attrs_follow == 1 {
        pos = pos + 84  // Skip fattr3 (21 * 4 = 84 bytes)
    }

    // count
    let returned_count: u32 = xdr_decode_u32(reply, pos)
    pos = pos + 4

    // eof
    let eof: u32 = xdr_decode_u32(reply, pos)
    pos = pos + 4

    // data
    let data_len: u32 = xdr_decode_u32(reply, pos)
    pos = pos + 4

    var i: u32 = 0
    while i < data_len and i < count {
        buffer[i] = reply[pos + i]
        i = i + 1
    }

    mount.reads = mount.reads + 1
    return data_len as i32
}

export fn nfs_write(mount_id: i32, handle: *NfsFileHandle, offset: u64, count: u32, data: *u8): i32 {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return -1
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return -1
    }

    let write_count: u32 = if count > mount.write_size { mount.write_size } else { count }

    let rpc_buffer: *u8 = &nfs_state.rpc_buffer[0]
    let reply: *u8 = &nfs_state.reply_buffer[0]
    var rpc_offset: u32 = 0

    let xid: u32 = get_next_xid()
    rpc_offset = build_rpc_header(rpc_buffer, rpc_offset, xid, NFS_PROGRAM, NFS_VERSION_3, NFSPROC3_WRITE)
    rpc_offset = build_auth_sys(rpc_buffer, rpc_offset, mount.uid, mount.gid)

    // WRITE arguments
    rpc_offset = xdr_encode_file_handle(rpc_buffer, rpc_offset, handle)
    rpc_offset = xdr_encode_u64(rpc_buffer, rpc_offset, offset)
    rpc_offset = xdr_encode_u32(rpc_buffer, rpc_offset, write_count)

    // Stable (FILE_SYNC = 2)
    rpc_offset = xdr_encode_u32(rpc_buffer, rpc_offset, 2)

    // Data
    rpc_offset = xdr_encode_opaque(rpc_buffer, rpc_offset, data, write_count)

    let reply_len: i32 = send_rpc(mount, rpc_buffer, rpc_offset, reply, RPC_BUFFER_SIZE)
    if reply_len < 0 {
        mount.errors = mount.errors + 1
        return -1
    }

    let data_offset: i32 = parse_rpc_reply(reply, reply_len as u32, xid)
    if data_offset < 0 {
        mount.errors = mount.errors + 1
        return -1
    }

    let status: u32 = xdr_decode_u32(reply, data_offset as u32)
    if status != NFS3_OK {
        return -(status as i32)
    }

    var pos: u32 = (data_offset + 4) as u32

    // Skip wcc_data
    // pre_op_attr
    let pre_attrs: u32 = xdr_decode_u32(reply, pos)
    pos = pos + 4
    if pre_attrs == 1 {
        pos = pos + 24  // Skip wcc_attr
    }
    // post_op_attr
    let post_attrs: u32 = xdr_decode_u32(reply, pos)
    pos = pos + 4
    if post_attrs == 1 {
        pos = pos + 84  // Skip fattr3
    }

    // count
    let written: u32 = xdr_decode_u32(reply, pos)

    mount.writes = mount.writes + 1
    return written as i32
}

export fn nfs_create(mount_id: i32, dir_handle: *NfsFileHandle, name: *u8, name_len: u32, mode: u32, result_handle: *NfsFileHandle): i32 {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return -1
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return -1
    }

    let buffer: *u8 = &nfs_state.rpc_buffer[0]
    let reply: *u8 = &nfs_state.reply_buffer[0]
    var offset: u32 = 0

    let xid: u32 = get_next_xid()
    offset = build_rpc_header(buffer, offset, xid, NFS_PROGRAM, NFS_VERSION_3, NFSPROC3_CREATE)
    offset = build_auth_sys(buffer, offset, mount.uid, mount.gid)

    // CREATE arguments
    offset = xdr_encode_file_handle(buffer, offset, dir_handle)
    offset = xdr_encode_string(buffer, offset, name, name_len)

    // createhow3: UNCHECKED = 0
    offset = xdr_encode_u32(buffer, offset, 0)

    // sattr3
    // mode
    offset = xdr_encode_u32(buffer, offset, 1)  // set_it = TRUE
    offset = xdr_encode_u32(buffer, offset, mode)
    // uid
    offset = xdr_encode_u32(buffer, offset, 1)
    offset = xdr_encode_u32(buffer, offset, mount.uid)
    // gid
    offset = xdr_encode_u32(buffer, offset, 1)
    offset = xdr_encode_u32(buffer, offset, mount.gid)
    // size
    offset = xdr_encode_u32(buffer, offset, 1)
    offset = xdr_encode_u64(buffer, offset, 0)
    // atime: SET_TO_SERVER_TIME = 1
    offset = xdr_encode_u32(buffer, offset, 1)
    // mtime: SET_TO_SERVER_TIME = 1
    offset = xdr_encode_u32(buffer, offset, 1)

    let reply_len: i32 = send_rpc(mount, buffer, offset, reply, RPC_BUFFER_SIZE)
    if reply_len < 0 {
        return -1
    }

    let data_offset: i32 = parse_rpc_reply(reply, reply_len as u32, xid)
    if data_offset < 0 {
        return -1
    }

    let status: u32 = xdr_decode_u32(reply, data_offset as u32)
    if status != NFS3_OK {
        return status as i32
    }

    // Parse result
    var pos: u32 = (data_offset + 4) as u32

    // post_op_fh3
    let handle_follows: u32 = xdr_decode_u32(reply, pos)
    pos = pos + 4

    if handle_follows == 1 {
        xdr_decode_file_handle(reply, pos, result_handle)
    }

    return 0
}

export fn nfs_remove(mount_id: i32, dir_handle: *NfsFileHandle, name: *u8, name_len: u32): i32 {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return -1
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return -1
    }

    let buffer: *u8 = &nfs_state.rpc_buffer[0]
    let reply: *u8 = &nfs_state.reply_buffer[0]
    var offset: u32 = 0

    let xid: u32 = get_next_xid()
    offset = build_rpc_header(buffer, offset, xid, NFS_PROGRAM, NFS_VERSION_3, NFSPROC3_REMOVE)
    offset = build_auth_sys(buffer, offset, mount.uid, mount.gid)

    // REMOVE arguments
    offset = xdr_encode_file_handle(buffer, offset, dir_handle)
    offset = xdr_encode_string(buffer, offset, name, name_len)

    let reply_len: i32 = send_rpc(mount, buffer, offset, reply, RPC_BUFFER_SIZE)
    if reply_len < 0 {
        return -1
    }

    let data_offset: i32 = parse_rpc_reply(reply, reply_len as u32, xid)
    if data_offset < 0 {
        return -1
    }

    let status: u32 = xdr_decode_u32(reply, data_offset as u32)
    return status as i32
}

export fn nfs_mkdir(mount_id: i32, dir_handle: *NfsFileHandle, name: *u8, name_len: u32, mode: u32, result_handle: *NfsFileHandle): i32 {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return -1
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return -1
    }

    let buffer: *u8 = &nfs_state.rpc_buffer[0]
    let reply: *u8 = &nfs_state.reply_buffer[0]
    var offset: u32 = 0

    let xid: u32 = get_next_xid()
    offset = build_rpc_header(buffer, offset, xid, NFS_PROGRAM, NFS_VERSION_3, NFSPROC3_MKDIR)
    offset = build_auth_sys(buffer, offset, mount.uid, mount.gid)

    // MKDIR arguments
    offset = xdr_encode_file_handle(buffer, offset, dir_handle)
    offset = xdr_encode_string(buffer, offset, name, name_len)

    // sattr3
    offset = xdr_encode_u32(buffer, offset, 1)  // mode set
    offset = xdr_encode_u32(buffer, offset, mode)
    offset = xdr_encode_u32(buffer, offset, 1)  // uid set
    offset = xdr_encode_u32(buffer, offset, mount.uid)
    offset = xdr_encode_u32(buffer, offset, 1)  // gid set
    offset = xdr_encode_u32(buffer, offset, mount.gid)
    offset = xdr_encode_u32(buffer, offset, 0)  // size not set
    offset = xdr_encode_u32(buffer, offset, 1)  // atime server
    offset = xdr_encode_u32(buffer, offset, 1)  // mtime server

    let reply_len: i32 = send_rpc(mount, buffer, offset, reply, RPC_BUFFER_SIZE)
    if reply_len < 0 {
        return -1
    }

    let data_offset: i32 = parse_rpc_reply(reply, reply_len as u32, xid)
    if data_offset < 0 {
        return -1
    }

    let status: u32 = xdr_decode_u32(reply, data_offset as u32)
    if status != NFS3_OK {
        return status as i32
    }

    var pos: u32 = (data_offset + 4) as u32
    let handle_follows: u32 = xdr_decode_u32(reply, pos)
    pos = pos + 4

    if handle_follows == 1 {
        xdr_decode_file_handle(reply, pos, result_handle)
    }

    return 0
}

export fn nfs_rmdir(mount_id: i32, dir_handle: *NfsFileHandle, name: *u8, name_len: u32): i32 {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return -1
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return -1
    }

    let buffer: *u8 = &nfs_state.rpc_buffer[0]
    let reply: *u8 = &nfs_state.reply_buffer[0]
    var offset: u32 = 0

    let xid: u32 = get_next_xid()
    offset = build_rpc_header(buffer, offset, xid, NFS_PROGRAM, NFS_VERSION_3, NFSPROC3_RMDIR)
    offset = build_auth_sys(buffer, offset, mount.uid, mount.gid)

    offset = xdr_encode_file_handle(buffer, offset, dir_handle)
    offset = xdr_encode_string(buffer, offset, name, name_len)

    let reply_len: i32 = send_rpc(mount, buffer, offset, reply, RPC_BUFFER_SIZE)
    if reply_len < 0 {
        return -1
    }

    let data_offset: i32 = parse_rpc_reply(reply, reply_len as u32, xid)
    if data_offset < 0 {
        return -1
    }

    let status: u32 = xdr_decode_u32(reply, data_offset as u32)
    return status as i32
}

export fn nfs_rename(mount_id: i32, from_dir: *NfsFileHandle, from_name: *u8, from_len: u32, to_dir: *NfsFileHandle, to_name: *u8, to_len: u32): i32 {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return -1
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return -1
    }

    let buffer: *u8 = &nfs_state.rpc_buffer[0]
    let reply: *u8 = &nfs_state.reply_buffer[0]
    var offset: u32 = 0

    let xid: u32 = get_next_xid()
    offset = build_rpc_header(buffer, offset, xid, NFS_PROGRAM, NFS_VERSION_3, NFSPROC3_RENAME)
    offset = build_auth_sys(buffer, offset, mount.uid, mount.gid)

    // From
    offset = xdr_encode_file_handle(buffer, offset, from_dir)
    offset = xdr_encode_string(buffer, offset, from_name, from_len)

    // To
    offset = xdr_encode_file_handle(buffer, offset, to_dir)
    offset = xdr_encode_string(buffer, offset, to_name, to_len)

    let reply_len: i32 = send_rpc(mount, buffer, offset, reply, RPC_BUFFER_SIZE)
    if reply_len < 0 {
        return -1
    }

    let data_offset: i32 = parse_rpc_reply(reply, reply_len as u32, xid)
    if data_offset < 0 {
        return -1
    }

    let status: u32 = xdr_decode_u32(reply, data_offset as u32)
    return status as i32
}

// ============================================================================
// Directory Reading
// ============================================================================

export fn nfs_readdir(mount_id: i32, dir_handle: *NfsFileHandle, cookie: u64, entries: *NfsDirEntry, max_entries: u32): i32 {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return -1
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return -1
    }

    let buffer: *u8 = &nfs_state.rpc_buffer[0]
    let reply: *u8 = &nfs_state.reply_buffer[0]
    var offset: u32 = 0

    let xid: u32 = get_next_xid()
    offset = build_rpc_header(buffer, offset, xid, NFS_PROGRAM, NFS_VERSION_3, NFSPROC3_READDIR)
    offset = build_auth_sys(buffer, offset, mount.uid, mount.gid)

    // READDIR arguments
    offset = xdr_encode_file_handle(buffer, offset, dir_handle)
    offset = xdr_encode_u64(buffer, offset, cookie)

    // cookieverf (8 bytes, 0 for first call)
    offset = xdr_encode_u64(buffer, offset, 0)

    // count
    offset = xdr_encode_u32(buffer, offset, 8192)

    let reply_len: i32 = send_rpc(mount, buffer, offset, reply, RPC_BUFFER_SIZE)
    if reply_len < 0 {
        mount.errors = mount.errors + 1
        return -1
    }

    let data_offset: i32 = parse_rpc_reply(reply, reply_len as u32, xid)
    if data_offset < 0 {
        mount.errors = mount.errors + 1
        return -1
    }

    let status: u32 = xdr_decode_u32(reply, data_offset as u32)
    if status != NFS3_OK {
        return -(status as i32)
    }

    var pos: u32 = (data_offset + 4) as u32

    // Skip post-op attributes
    let attrs_follow: u32 = xdr_decode_u32(reply, pos)
    pos = pos + 4
    if attrs_follow == 1 {
        pos = pos + 84
    }

    // Skip cookieverf
    pos = pos + 8

    // Parse entries
    var entry_count: u32 = 0
    while entry_count < max_entries {
        let value_follows: u32 = xdr_decode_u32(reply, pos)
        pos = pos + 4

        if value_follows == 0 {
            break
        }

        let entry: *NfsDirEntry = &entries[entry_count]

        // fileid
        entry.fileid = xdr_decode_u64(reply, pos)
        pos = pos + 8

        // name
        let name_len: u32 = xdr_decode_u32(reply, pos)
        pos = pos + 4
        entry.name_len = if name_len < 255 { name_len } else { 255 }

        var i: u32 = 0
        while i < entry.name_len {
            entry.name[i] = reply[pos + i]
            i = i + 1
        }
        entry.name[entry.name_len] = 0

        let padding: u32 = (4 - (name_len % 4)) % 4
        pos = pos + name_len + padding

        // cookie
        entry.cookie = xdr_decode_u64(reply, pos)
        pos = pos + 8

        entry_count = entry_count + 1
    }

    mount.readdirs = mount.readdirs + 1
    return entry_count as i32
}

// ============================================================================
// High-Level File API
// ============================================================================

export fn nfs_open(mount_id: i32, path: *u8, path_len: u32, flags: u32): i32 {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return -1
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return -1
    }

    // Find free file slot
    var file_id: i32 = -1
    var i: u32 = 0
    while i < 64 {
        if nfs_state.open_files[i].active == 0 {
            file_id = i as i32
            break
        }
        i = i + 1
    }

    if file_id < 0 {
        return -1
    }

    let file: *NfsOpenFile = &nfs_state.open_files[file_id as u32]

    // Resolve path to file handle
    var current_handle: NfsFileHandle = mount.root_handle
    var result_handle: NfsFileHandle
    var attrs: NfsFileAttrs

    // Parse path components
    var start: u32 = 0
    if path[0] == 47 {  // Skip leading '/'
        start = 1
    }

    var pos: u32 = start
    while pos <= path_len {
        if pos == path_len or path[pos] == 47 {
            if pos > start {
                let component_len: u32 = pos - start
                let result: i32 = nfs_lookup(mount_id, &current_handle, &path[start], component_len, &result_handle, &attrs)

                if result != 0 {
                    return -1  // Path component not found
                }

                current_handle = result_handle
            }
            start = pos + 1
        }
        pos = pos + 1
    }

    file.active = 1
    file.mount_id = mount_id as u32
    file.handle = current_handle
    file.attrs = attrs
    file.position = 0
    file.flags = flags

    return file_id
}

export fn nfs_close_file(file_id: i32) {
    if file_id < 0 or file_id >= 64 {
        return
    }

    nfs_state.open_files[file_id as u32].active = 0
}

export fn nfs_read_file(file_id: i32, buffer: *u8, count: u32): i32 {
    if file_id < 0 or file_id >= 64 {
        return -1
    }

    let file: *NfsOpenFile = &nfs_state.open_files[file_id as u32]
    if file.active == 0 {
        return -1
    }

    let bytes_read: i32 = nfs_read(file.mount_id as i32, &file.handle, file.position, count, buffer)

    if bytes_read > 0 {
        file.position = file.position + bytes_read as u64
    }

    return bytes_read
}

export fn nfs_write_file(file_id: i32, buffer: *u8, count: u32): i32 {
    if file_id < 0 or file_id >= 64 {
        return -1
    }

    let file: *NfsOpenFile = &nfs_state.open_files[file_id as u32]
    if file.active == 0 {
        return -1
    }

    let bytes_written: i32 = nfs_write(file.mount_id as i32, &file.handle, file.position, count, buffer)

    if bytes_written > 0 {
        file.position = file.position + bytes_written as u64
    }

    return bytes_written
}

export fn nfs_seek(file_id: i32, offset: i64, whence: u32): i64 {
    if file_id < 0 or file_id >= 64 {
        return -1
    }

    let file: *NfsOpenFile = &nfs_state.open_files[file_id as u32]
    if file.active == 0 {
        return -1
    }

    switch whence {
        0 => {  // SEEK_SET
            file.position = offset as u64
        }
        1 => {  // SEEK_CUR
            file.position = (file.position as i64 + offset) as u64
        }
        2 => {  // SEEK_END
            file.position = (file.attrs.size as i64 + offset) as u64
        }
        else => {
            return -1
        }
    }

    return file.position as i64
}

// ============================================================================
// Utility
// ============================================================================

fn print_ip(ip: u32) {
    foundation.serial_write_u32((ip >> 24) & 0xFF)
    foundation.serial_write_string(".")
    foundation.serial_write_u32((ip >> 16) & 0xFF)
    foundation.serial_write_string(".")
    foundation.serial_write_u32((ip >> 8) & 0xFF)
    foundation.serial_write_string(".")
    foundation.serial_write_u32(ip & 0xFF)
}

export fn nfs_get_root_handle(mount_id: i32, handle: *NfsFileHandle): i32 {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return -1
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return -1
    }

    *handle = mount.root_handle
    return 0
}

export fn nfs_print_stats(mount_id: i32) {
    if mount_id < 0 or mount_id >= MAX_NFS_MOUNTS as i32 {
        return
    }

    let mount: *NfsMount = &nfs_state.mounts[mount_id as u32]
    if mount.active == 0 {
        return
    }

    foundation.serial_write_string("[NFS] Mount ")
    foundation.serial_write_u32(mount_id as u32)
    foundation.serial_write_string(" statistics:\n")
    foundation.serial_write_string("  Reads: ")
    foundation.serial_write_u64(mount.reads)
    foundation.serial_write_string("\n  Writes: ")
    foundation.serial_write_u64(mount.writes)
    foundation.serial_write_string("\n  Lookups: ")
    foundation.serial_write_u64(mount.lookups)
    foundation.serial_write_string("\n  Readdirs: ")
    foundation.serial_write_u64(mount.readdirs)
    foundation.serial_write_string("\n  Errors: ")
    foundation.serial_write_u64(mount.errors)
    foundation.serial_write_string("\n")
}
