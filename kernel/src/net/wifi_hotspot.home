// HomeOS WiFi Hotspot (SoftAP) Implementation
// Full Access Point functionality with client management
//
// Features:
// - Software Access Point (SoftAP) mode
// - Multiple security modes (Open, WPA2-PSK, WPA3-SAE)
// - DHCP server for clients
// - Client connection management
// - Bandwidth limiting per client
// - MAC filtering (whitelist/blacklist)
// - Hidden SSID support
// - Channel selection and auto-channel
// - 802.11n/ac/ax support

const std = @import("std")
const net = @import("net")
const wifi = @import("wifi")
const dhcp = @import("dhcp")
const crypto = @import("../crypto/crypto")

// ============================================
// Constants
// ============================================

pub const MAX_CLIENTS: usize = 32
pub const MAX_SSID_LEN: usize = 32
pub const MAX_PASSWORD_LEN: usize = 63
pub const MAX_MAC_FILTER_ENTRIES: usize = 64

// Security modes
pub const SecurityMode = enum {
    OPEN
    WPA2_PSK
    WPA3_SAE
    WPA2_WPA3_MIXED
}

// WiFi bands
pub const WifiBand = enum {
    BAND_2_4GHZ
    BAND_5GHZ
    BAND_6GHZ
    DUAL_BAND
}

// Channel width
pub const ChannelWidth = enum {
    WIDTH_20MHZ
    WIDTH_40MHZ
    WIDTH_80MHZ
    WIDTH_160MHZ
}

// MAC filter mode
pub const MacFilterMode = enum {
    DISABLED
    WHITELIST
    BLACKLIST
}

// ============================================
// Client Information
// ============================================

pub const ClientInfo = struct {
    mac_address: [6]u8
    ip_address: [4]u8
    connected_time: u64
    last_activity: u64

    // Traffic statistics
    rx_bytes: u64
    tx_bytes: u64
    rx_packets: u64
    tx_packets: u64

    // Signal quality
    rssi: i8           // dBm
    tx_rate: u32       // kbps
    rx_rate: u32       // kbps

    // Bandwidth limit (0 = unlimited)
    bandwidth_limit: u32  // kbps

    // State
    authenticated: bool
    associated: bool

    pub fn init(): ClientInfo {
        return ClientInfo{
            .mac_address = [_]u8{0} ** 6,
            .ip_address = [_]u8{0} ** 4,
            .connected_time = 0,
            .last_activity = 0,
            .rx_bytes = 0,
            .tx_bytes = 0,
            .rx_packets = 0,
            .tx_packets = 0,
            .rssi = 0,
            .tx_rate = 0,
            .rx_rate = 0,
            .bandwidth_limit = 0,
            .authenticated = false,
            .associated = false,
        }
    }
}

// ============================================
// Hotspot Configuration
// ============================================

pub const HotspotConfig = struct {
    // Network identity
    ssid: [MAX_SSID_LEN]u8
    ssid_len: usize
    hidden_ssid: bool

    // Security
    security: SecurityMode
    password: [MAX_PASSWORD_LEN]u8
    password_len: usize

    // Radio settings
    band: WifiBand
    channel: u8           // 0 = auto
    channel_width: ChannelWidth
    tx_power: u8          // dBm (0 = auto)

    // DHCP settings
    gateway_ip: [4]u8
    subnet_mask: [4]u8
    dhcp_start: [4]u8
    dhcp_end: [4]u8
    dns_server: [4]u8
    lease_time: u32       // seconds

    // Client limits
    max_clients: u8
    client_isolation: bool  // Prevent client-to-client traffic

    // MAC filtering
    mac_filter_mode: MacFilterMode
    mac_filter_list: [MAX_MAC_FILTER_ENTRIES][6]u8
    mac_filter_count: usize

    // Advanced
    beacon_interval: u16   // TUs (default 100)
    dtim_period: u8       // (default 2)
    rts_threshold: u16    // bytes
    fragmentation_threshold: u16

    // Country code for regulatory
    country_code: [2]u8

    pub fn default(): HotspotConfig {
        var config: HotspotConfig = undefined

        @memset(&config.ssid, 0)
        @memcpy(config.ssid[0..7], "HomeOS")
        config.ssid_len = 6
        config.hidden_ssid = false

        config.security = .WPA2_PSK
        @memset(&config.password, 0)
        config.password_len = 0

        config.band = .BAND_2_4GHZ
        config.channel = 0  // Auto
        config.channel_width = .WIDTH_20MHZ
        config.tx_power = 0  // Auto

        config.gateway_ip = [_]u8{ 192, 168, 4, 1 }
        config.subnet_mask = [_]u8{ 255, 255, 255, 0 }
        config.dhcp_start = [_]u8{ 192, 168, 4, 10 }
        config.dhcp_end = [_]u8{ 192, 168, 4, 100 }
        config.dns_server = [_]u8{ 192, 168, 4, 1 }
        config.lease_time = 3600

        config.max_clients = 10
        config.client_isolation = false

        config.mac_filter_mode = .DISABLED
        @memset(&config.mac_filter_list, 0)
        config.mac_filter_count = 0

        config.beacon_interval = 100
        config.dtim_period = 2
        config.rts_threshold = 2347
        config.fragmentation_threshold = 2346

        config.country_code = [_]u8{ 'U', 'S' }

        return config
    }
}

// ============================================
// Hotspot State
// ============================================

pub const HotspotState = enum {
    STOPPED
    STARTING
    RUNNING
    STOPPING
    ERROR
}

// ============================================
// WiFi Hotspot Manager
// ============================================

pub const WifiHotspot = struct {
    config: HotspotConfig
    state: HotspotState

    // Connected clients
    clients: [MAX_CLIENTS]ClientInfo
    client_count: usize

    // Interface info
    interface_name: [16]u8
    interface_name_len: usize
    bssid: [6]u8

    // DHCP server state
    dhcp_leases: [MAX_CLIENTS]DhcpLease
    dhcp_lease_count: usize

    // WPA state (for each client)
    wpa_states: [MAX_CLIENTS]WpaState
    pmk: [32]u8  // Pairwise Master Key (derived from password)

    // Statistics
    total_rx_bytes: u64
    total_tx_bytes: u64
    total_clients_connected: u64

    // Internal state
    nl80211_socket: i32
    interface_index: u32

    pub fn init(config: HotspotConfig): WifiHotspot {
        var hotspot: WifiHotspot = undefined
        hotspot.config = config
        hotspot.state = .STOPPED
        hotspot.clients = [_]ClientInfo{ClientInfo.init()} ** MAX_CLIENTS
        hotspot.client_count = 0
        @memset(&hotspot.interface_name, 0)
        hotspot.interface_name_len = 0
        @memset(&hotspot.bssid, 0)
        hotspot.dhcp_leases = [_]DhcpLease{DhcpLease.init()} ** MAX_CLIENTS
        hotspot.dhcp_lease_count = 0
        hotspot.wpa_states = [_]WpaState{WpaState.init()} ** MAX_CLIENTS
        @memset(&hotspot.pmk, 0)
        hotspot.total_rx_bytes = 0
        hotspot.total_tx_bytes = 0
        hotspot.total_clients_connected = 0
        hotspot.nl80211_socket = -1
        hotspot.interface_index = 0
        return hotspot
    }

    pub fn start(self: *WifiHotspot, interface: []const u8): bool {
        if self.state != .STOPPED {
            return false
        }

        self.state = .STARTING

        // Store interface name
        @memcpy(self.interface_name[0..interface.len], interface)
        self.interface_name_len = interface.len

        // Derive PMK from password if using WPA
        if self.config.security != .OPEN {
            self.derive_pmk()
        }

        // Initialize nl80211 socket for hostapd-like operations
        if !self.init_nl80211() {
            self.state = .ERROR
            return false
        }

        // Set interface to AP mode
        if !self.set_interface_mode(.AP) {
            self.state = .ERROR
            return false
        }

        // Select channel
        var channel = self.config.channel
        if channel == 0 {
            channel = self.auto_select_channel()
        }

        // Configure radio parameters
        if !self.configure_radio(channel) {
            self.state = .ERROR
            return false
        }

        // Set SSID and security
        if !self.configure_bss() {
            self.state = .ERROR
            return false
        }

        // Configure IP address
        if !self.configure_interface_ip() {
            self.state = .ERROR
            return false
        }

        // Start DHCP server
        if !self.start_dhcp_server() {
            self.state = .ERROR
            return false
        }

        // Enable interface
        if !self.enable_interface() {
            self.state = .ERROR
            return false
        }

        // Start beacon transmission
        if !self.start_beacons() {
            self.state = .ERROR
            return false
        }

        self.state = .RUNNING
        return true
    }

    pub fn stop(self: *WifiHotspot): bool {
        if self.state != .RUNNING {
            return false
        }

        self.state = .STOPPING

        // Disconnect all clients
        for (0..self.client_count) |i| {
            self.disconnect_client(i)
        }

        // Stop beacons
        self.stop_beacons()

        // Stop DHCP server
        self.stop_dhcp_server()

        // Set interface down
        self.disable_interface()

        // Reset interface mode
        self.set_interface_mode(.STATION)

        // Close nl80211 socket
        if self.nl80211_socket >= 0 {
            close_socket(self.nl80211_socket)
            self.nl80211_socket = -1
        }

        self.state = .STOPPED
        return true
    }

    fn derive_pmk(self: *WifiHotspot): void {
        // PBKDF2-SHA1 with 4096 iterations
        crypto.pbkdf2_sha1(
            self.config.password[0..self.config.password_len],
            self.config.ssid[0..self.config.ssid_len],
            4096,
            &self.pmk
        )
    }

    fn init_nl80211(self: *WifiHotspot): bool {
        // Create netlink socket for nl80211
        self.nl80211_socket = create_nl80211_socket()
        if self.nl80211_socket < 0 {
            return false
        }

        // Get interface index
        self.interface_index = get_interface_index(self.interface_name[0..self.interface_name_len])
        if self.interface_index == 0 {
            return false
        }

        // Get BSSID (interface MAC)
        get_interface_mac(self.interface_name[0..self.interface_name_len], &self.bssid)

        return true
    }

    fn set_interface_mode(self: *WifiHotspot, mode: InterfaceMode): bool {
        // Set interface mode via nl80211
        var msg: Nl80211Message = undefined
        msg.init(NL80211_CMD_SET_INTERFACE)
        msg.put_u32(NL80211_ATTR_IFINDEX, self.interface_index)
        msg.put_u32(NL80211_ATTR_IFTYPE, @intFromEnum(mode))

        return send_nl80211_msg(self.nl80211_socket, &msg)
    }

    fn auto_select_channel(self: *WifiHotspot): u8 {
        // Scan for least congested channel
        var channel_scores: [14]u32 = [_]u32{0} ** 14

        // Get list of nearby APs
        const scan_results = wifi.scan(self.interface_name[0..self.interface_name_len])

        for (scan_results) |ap| {
            if ap.channel >= 1 and ap.channel <= 14 {
                // Add interference score based on signal strength
                const score = @as(u32, @intCast(100 + ap.rssi))  // Higher RSSI = more interference
                channel_scores[ap.channel - 1] += score

                // Also affect adjacent channels (co-channel interference)
                if ap.channel > 1 {
                    channel_scores[ap.channel - 2] += score / 2
                }
                if ap.channel < 14 {
                    channel_scores[ap.channel] += score / 2
                }
            }
        }

        // Find channel with lowest score
        var best_channel: u8 = 1
        var best_score: u32 = channel_scores[0]

        // Prefer non-overlapping channels: 1, 6, 11
        const preferred = [_]u8{ 1, 6, 11 }
        for (preferred) |ch| {
            if channel_scores[ch - 1] < best_score {
                best_channel = ch
                best_score = channel_scores[ch - 1]
            }
        }

        return best_channel
    }

    fn configure_radio(self: *WifiHotspot, channel: u8): bool {
        var msg: Nl80211Message = undefined
        msg.init(NL80211_CMD_SET_WIPHY)
        msg.put_u32(NL80211_ATTR_IFINDEX, self.interface_index)

        // Set channel
        const freq = channel_to_frequency(channel)
        msg.put_u32(NL80211_ATTR_WIPHY_FREQ, freq)

        // Set channel width
        const width_type = switch self.config.channel_width {
            .WIDTH_20MHZ => NL80211_CHAN_WIDTH_20,
            .WIDTH_40MHZ => NL80211_CHAN_WIDTH_40,
            .WIDTH_80MHZ => NL80211_CHAN_WIDTH_80,
            .WIDTH_160MHZ => NL80211_CHAN_WIDTH_160,
        }
        msg.put_u32(NL80211_ATTR_CHANNEL_WIDTH, width_type)

        // Set TX power
        if self.config.tx_power > 0 {
            msg.put_u32(NL80211_ATTR_WIPHY_TX_POWER_SETTING, NL80211_TX_POWER_FIXED)
            msg.put_u32(NL80211_ATTR_WIPHY_TX_POWER_LEVEL, @as(u32, self.config.tx_power) * 100)  // mBm
        }

        return send_nl80211_msg(self.nl80211_socket, &msg)
    }

    fn configure_bss(self: *WifiHotspot): bool {
        var msg: Nl80211Message = undefined
        msg.init(NL80211_CMD_START_AP)
        msg.put_u32(NL80211_ATTR_IFINDEX, self.interface_index)

        // SSID
        msg.put(NL80211_ATTR_SSID, self.config.ssid[0..self.config.ssid_len])

        // Hidden SSID
        if self.config.hidden_ssid {
            msg.put_u32(NL80211_ATTR_HIDDEN_SSID, NL80211_HIDDEN_SSID_ZERO_LEN)
        }

        // Beacon interval
        msg.put_u32(NL80211_ATTR_BEACON_INTERVAL, self.config.beacon_interval)

        // DTIM period
        msg.put_u32(NL80211_ATTR_DTIM_PERIOD, self.config.dtim_period)

        // Build and set beacon head/tail with security IEs
        var beacon_head: [256]u8 = undefined
        var beacon_tail: [256]u8 = undefined
        const head_len = self.build_beacon_head(&beacon_head)
        const tail_len = self.build_beacon_tail(&beacon_tail)

        msg.put(NL80211_ATTR_BEACON_HEAD, beacon_head[0..head_len])
        msg.put(NL80211_ATTR_BEACON_TAIL, beacon_tail[0..tail_len])

        // Security settings
        if self.config.security != .OPEN {
            msg.put_u32(NL80211_ATTR_AUTH_TYPE, NL80211_AUTHTYPE_OPEN_SYSTEM)
            msg.put_flag(NL80211_ATTR_PRIVACY)

            // WPA IE
            var wpa_ie: [64]u8 = undefined
            const wpa_ie_len = self.build_wpa_ie(&wpa_ie)
            msg.put(NL80211_ATTR_IE, wpa_ie[0..wpa_ie_len])

            // Cipher suites
            const cipher = if self.config.security == .WPA3_SAE
                WLAN_CIPHER_SUITE_GCMP
            else
                WLAN_CIPHER_SUITE_CCMP

            msg.put_u32(NL80211_ATTR_CIPHER_SUITES_PAIRWISE, cipher)
            msg.put_u32(NL80211_ATTR_CIPHER_SUITE_GROUP, cipher)

            // AKM suite
            const akm = if self.config.security == .WPA3_SAE
                WLAN_AKM_SUITE_SAE
            else
                WLAN_AKM_SUITE_PSK
            msg.put_u32(NL80211_ATTR_AKM_SUITES, akm)
        }

        return send_nl80211_msg(self.nl80211_socket, &msg)
    }

    fn build_beacon_head(self: *WifiHotspot, buffer: []u8): usize {
        var offset: usize = 0

        // Frame control
        buffer[0] = 0x80  // Beacon frame
        buffer[1] = 0x00
        offset = 2

        // Duration
        buffer[offset] = 0x00
        buffer[offset + 1] = 0x00
        offset += 2

        // Destination (broadcast)
        @memset(buffer[offset..offset + 6], 0xFF)
        offset += 6

        // Source (BSSID)
        @memcpy(buffer[offset..offset + 6], &self.bssid)
        offset += 6

        // BSSID
        @memcpy(buffer[offset..offset + 6], &self.bssid)
        offset += 6

        // Sequence control (0)
        buffer[offset] = 0x00
        buffer[offset + 1] = 0x00
        offset += 2

        // Timestamp (filled by hardware)
        @memset(buffer[offset..offset + 8], 0)
        offset += 8

        // Beacon interval
        buffer[offset] = @truncate(self.config.beacon_interval & 0xFF)
        buffer[offset + 1] = @truncate((self.config.beacon_interval >> 8) & 0xFF)
        offset += 2

        // Capability info
        var cap: u16 = 0x0001  // ESS
        if self.config.security != .OPEN {
            cap |= 0x0010  // Privacy
        }
        buffer[offset] = @truncate(cap & 0xFF)
        buffer[offset + 1] = @truncate((cap >> 8) & 0xFF)
        offset += 2

        return offset
    }

    fn build_beacon_tail(self: *WifiHotspot, buffer: []u8): usize {
        var offset: usize = 0

        // SSID element
        buffer[offset] = 0  // Element ID
        if self.config.hidden_ssid {
            buffer[offset + 1] = 0  // Length 0 for hidden
            offset += 2
        } else {
            buffer[offset + 1] = @truncate(self.config.ssid_len)
            offset += 2
            @memcpy(buffer[offset..offset + self.config.ssid_len], self.config.ssid[0..self.config.ssid_len])
            offset += self.config.ssid_len
        }

        // Supported rates
        buffer[offset] = 1  // Element ID
        buffer[offset + 1] = 8  // Length
        offset += 2
        const rates = [_]u8{ 0x82, 0x84, 0x8B, 0x96, 0x0C, 0x12, 0x18, 0x24 }
        @memcpy(buffer[offset..offset + 8], &rates)
        offset += 8

        // DS Parameter Set (channel)
        buffer[offset] = 3  // Element ID
        buffer[offset + 1] = 1  // Length
        buffer[offset + 2] = self.config.channel
        offset += 3

        // Country IE
        buffer[offset] = 7  // Element ID
        buffer[offset + 1] = 6  // Length
        offset += 2
        @memcpy(buffer[offset..offset + 2], &self.config.country_code)
        buffer[offset + 2] = 1   // First channel
        buffer[offset + 3] = 11  // Number of channels
        buffer[offset + 4] = 20  // Max TX power
        buffer[offset + 5] = 0   // Padding
        offset += 6

        return offset
    }

    fn build_wpa_ie(self: *WifiHotspot, buffer: []u8): usize {
        var offset: usize = 0

        // RSN Information Element
        buffer[offset] = 48  // Element ID (RSN)
        offset += 1

        const len_offset = offset
        offset += 1  // Length (fill in later)

        // Version
        buffer[offset] = 1
        buffer[offset + 1] = 0
        offset += 2

        // Group cipher suite
        @memcpy(buffer[offset..offset + 4], &[_]u8{ 0x00, 0x0F, 0xAC, 0x04 })  // CCMP
        offset += 4

        // Pairwise cipher suite count
        buffer[offset] = 1
        buffer[offset + 1] = 0
        offset += 2

        // Pairwise cipher suite
        @memcpy(buffer[offset..offset + 4], &[_]u8{ 0x00, 0x0F, 0xAC, 0x04 })  // CCMP
        offset += 4

        // AKM suite count
        buffer[offset] = 1
        buffer[offset + 1] = 0
        offset += 2

        // AKM suite
        if self.config.security == .WPA3_SAE {
            @memcpy(buffer[offset..offset + 4], &[_]u8{ 0x00, 0x0F, 0xAC, 0x08 })  // SAE
        } else {
            @memcpy(buffer[offset..offset + 4], &[_]u8{ 0x00, 0x0F, 0xAC, 0x02 })  // PSK
        }
        offset += 4

        // RSN capabilities
        buffer[offset] = 0x00
        buffer[offset + 1] = 0x00
        offset += 2

        // Set length
        buffer[len_offset] = @truncate(offset - len_offset - 1)

        return offset
    }

    fn configure_interface_ip(self: *WifiHotspot): bool {
        return net.configure_interface(
            self.interface_name[0..self.interface_name_len],
            self.config.gateway_ip,
            self.config.subnet_mask
        )
    }

    fn start_dhcp_server(self: *WifiHotspot): bool {
        // Start built-in DHCP server
        return dhcp.start_server(
            self.interface_name[0..self.interface_name_len],
            self.config.gateway_ip,
            self.config.dhcp_start,
            self.config.dhcp_end,
            self.config.subnet_mask,
            self.config.dns_server,
            self.config.lease_time
        )
    }

    fn stop_dhcp_server(self: *WifiHotspot): void {
        dhcp.stop_server(self.interface_name[0..self.interface_name_len])
    }

    fn enable_interface(self: *WifiHotspot): bool {
        return net.set_interface_up(self.interface_name[0..self.interface_name_len])
    }

    fn disable_interface(self: *WifiHotspot): void {
        net.set_interface_down(self.interface_name[0..self.interface_name_len])
    }

    fn start_beacons(self: *WifiHotspot): bool {
        // Beacons are started by START_AP command
        return true
    }

    fn stop_beacons(self: *WifiHotspot): void {
        var msg: Nl80211Message = undefined
        msg.init(NL80211_CMD_STOP_AP)
        msg.put_u32(NL80211_ATTR_IFINDEX, self.interface_index)
        _ = send_nl80211_msg(self.nl80211_socket, &msg)
    }

    // ============================================
    // Client Management
    // ============================================

    pub fn handle_new_station(self: *WifiHotspot, mac: [6]u8): bool {
        // Check MAC filter
        if !self.check_mac_filter(&mac) {
            return false
        }

        // Check max clients
        if self.client_count >= self.config.max_clients {
            return false
        }

        // Find or create client slot
        var slot: ?usize = null
        for (0..MAX_CLIENTS) |i| {
            if !self.clients[i].associated {
                slot = i
                break
            }
        }

        if slot == null {
            return false
        }

        const idx = slot.?

        // Initialize client
        self.clients[idx] = ClientInfo.init()
        @memcpy(&self.clients[idx].mac_address, &mac)
        self.clients[idx].connected_time = get_timestamp()
        self.clients[idx].associated = true

        // Initialize WPA state
        self.wpa_states[idx] = WpaState.init()

        self.client_count += 1
        self.total_clients_connected += 1

        return true
    }

    pub fn handle_station_auth(self: *WifiHotspot, mac: [6]u8): bool {
        const idx = self.find_client(&mac) orelse return false

        if self.config.security == .OPEN {
            self.clients[idx].authenticated = true
            return true
        }

        // For WPA, authentication happens during 4-way handshake
        return true
    }

    pub fn handle_eapol(self: *WifiHotspot, mac: [6]u8, data: []const u8): bool {
        const idx = self.find_client(&mac) orelse return false

        // Process EAPOL frame (4-way handshake)
        return self.process_4way_handshake(idx, data)
    }

    fn process_4way_handshake(self: *WifiHotspot, client_idx: usize, data: []const u8): bool {
        var state = &self.wpa_states[client_idx]

        // Parse EAPOL-Key frame
        if data.len < 95 {
            return false
        }

        const key_info = (@as(u16, data[5]) << 8) | @as(u16, data[6])
        const key_type = (key_info >> 3) & 1
        const install = (key_info >> 6) & 1
        const ack = (key_info >> 7) & 1
        const mic = (key_info >> 8) & 1
        const secure = (key_info >> 9) & 1

        if ack == 1 and mic == 0 {
            // Message 1 from AP - should not receive this
            return false
        } else if ack == 0 and mic == 1 {
            // Message 2 or 4 from client
            if state.handshake_step == 1 {
                // Message 2: client sends SNonce
                @memcpy(&state.snonce, data[17..49])

                // Derive PTK
                self.derive_ptk(client_idx)

                // Verify MIC
                if !self.verify_mic(client_idx, data) {
                    return false
                }

                // Send Message 3
                return self.send_message_3(client_idx)
            } else if state.handshake_step == 3 {
                // Message 4: handshake complete
                if !self.verify_mic(client_idx, data) {
                    return false
                }

                self.clients[client_idx].authenticated = true
                state.handshake_complete = true

                // Install keys
                self.install_keys(client_idx)

                return true
            }
        }

        return false
    }

    fn derive_ptk(self: *WifiHotspot, client_idx: usize): void {
        var state = &self.wpa_states[client_idx]
        const client = &self.clients[client_idx]

        // PTK = PRF-384(PMK, "Pairwise key expansion", Min(AA, SPA) || Max(AA, SPA) || Min(ANonce, SNonce) || Max(ANonce, SNonce))
        var data: [76]u8 = undefined

        // Sort MAC addresses
        if std.mem.lessThan(u8, &self.bssid, &client.mac_address) {
            @memcpy(data[0..6], &self.bssid)
            @memcpy(data[6..12], &client.mac_address)
        } else {
            @memcpy(data[0..6], &client.mac_address)
            @memcpy(data[6..12], &self.bssid)
        }

        // Sort nonces
        if std.mem.lessThan(u8, &state.anonce, &state.snonce) {
            @memcpy(data[12..44], &state.anonce)
            @memcpy(data[44..76], &state.snonce)
        } else {
            @memcpy(data[12..44], &state.snonce)
            @memcpy(data[44..76], &state.anonce)
        }

        // PRF-384
        crypto.prf_sha1(
            &self.pmk,
            "Pairwise key expansion",
            &data,
            &state.ptk
        )
    }

    fn verify_mic(self: *WifiHotspot, client_idx: usize, data: []const u8): bool {
        const state = &self.wpa_states[client_idx]

        // MIC is at offset 77-93
        var msg_copy: [256]u8 = undefined
        @memcpy(msg_copy[0..data.len], data)

        // Zero MIC field
        @memset(msg_copy[77..93], 0)

        // Compute MIC using KCK (first 16 bytes of PTK)
        var computed_mic: [16]u8 = undefined
        crypto.hmac_sha1(
            state.ptk[0..16],
            msg_copy[0..data.len],
            &computed_mic
        )

        return std.mem.eql(u8, computed_mic[0..16], data[77..93])
    }

    fn send_message_3(self: *WifiHotspot, client_idx: usize): bool {
        var state = &self.wpa_states[client_idx]
        state.handshake_step = 3

        // Build and send EAPOL-Key message 3
        var msg: [256]u8 = undefined
        // ... (frame construction)

        return true
    }

    fn install_keys(self: *WifiHotspot, client_idx: usize): void {
        const state = &self.wpa_states[client_idx]

        // Install temporal keys using nl80211
        var msg: Nl80211Message = undefined
        msg.init(NL80211_CMD_NEW_KEY)
        msg.put_u32(NL80211_ATTR_IFINDEX, self.interface_index)
        msg.put(NL80211_ATTR_MAC, &self.clients[client_idx].mac_address)

        // TK is at offset 32 in PTK
        msg.put(NL80211_ATTR_KEY_DATA, state.ptk[32..48])
        msg.put_u32(NL80211_ATTR_KEY_CIPHER, WLAN_CIPHER_SUITE_CCMP)

        _ = send_nl80211_msg(self.nl80211_socket, &msg)
    }

    pub fn disconnect_client(self: *WifiHotspot, client_idx: usize): void {
        if client_idx >= MAX_CLIENTS or !self.clients[client_idx].associated {
            return
        }

        // Send deauthentication frame
        var msg: Nl80211Message = undefined
        msg.init(NL80211_CMD_DEL_STATION)
        msg.put_u32(NL80211_ATTR_IFINDEX, self.interface_index)
        msg.put(NL80211_ATTR_MAC, &self.clients[client_idx].mac_address)
        msg.put_u16(NL80211_ATTR_REASON_CODE, 3)  // Deauthenticated because sending station is leaving

        _ = send_nl80211_msg(self.nl80211_socket, &msg)

        // Clear client state
        self.clients[client_idx] = ClientInfo.init()
        self.wpa_states[client_idx] = WpaState.init()

        if self.client_count > 0 {
            self.client_count -= 1
        }
    }

    pub fn disconnect_client_by_mac(self: *WifiHotspot, mac: [6]u8): bool {
        const idx = self.find_client(&mac) orelse return false
        self.disconnect_client(idx)
        return true
    }

    fn find_client(self: *WifiHotspot, mac: *const [6]u8): ?usize {
        for (0..MAX_CLIENTS) |i| {
            if self.clients[i].associated and
               std.mem.eql(u8, &self.clients[i].mac_address, mac) {
                return i
            }
        }
        return null
    }

    fn check_mac_filter(self: *WifiHotspot, mac: *const [6]u8): bool {
        if self.config.mac_filter_mode == .DISABLED {
            return true
        }

        var found = false
        for (0..self.config.mac_filter_count) |i| {
            if std.mem.eql(u8, &self.config.mac_filter_list[i], mac) {
                found = true
                break
            }
        }

        return switch self.config.mac_filter_mode {
            .WHITELIST => found,
            .BLACKLIST => !found,
            .DISABLED => true,
        }
    }

    // ============================================
    // Bandwidth Management
    // ============================================

    pub fn set_client_bandwidth_limit(self: *WifiHotspot, mac: [6]u8, limit_kbps: u32): bool {
        const idx = self.find_client(&mac) orelse return false
        self.clients[idx].bandwidth_limit = limit_kbps

        // Apply traffic shaping using tc or internal rate limiter
        return apply_rate_limit(
            self.interface_name[0..self.interface_name_len],
            &mac,
            limit_kbps
        )
    }

    // ============================================
    // Statistics
    // ============================================

    pub fn get_client_list(self: *WifiHotspot): []ClientInfo {
        return self.clients[0..self.client_count]
    }

    pub fn get_statistics(self: *WifiHotspot): HotspotStats {
        return HotspotStats{
            .total_clients = self.client_count,
            .total_rx_bytes = self.total_rx_bytes,
            .total_tx_bytes = self.total_tx_bytes,
            .total_clients_connected = self.total_clients_connected,
            .uptime = if self.state == .RUNNING { get_timestamp() - self.clients[0].connected_time } else { 0 },
        }
    }
}

// ============================================
// Supporting Types
// ============================================

const WpaState = struct {
    anonce: [32]u8
    snonce: [32]u8
    ptk: [48]u8
    handshake_step: u8
    handshake_complete: bool
    replay_counter: u64

    pub fn init(): WpaState {
        var state: WpaState = undefined
        crypto.random_bytes(&state.anonce)
        @memset(&state.snonce, 0)
        @memset(&state.ptk, 0)
        state.handshake_step = 1
        state.handshake_complete = false
        state.replay_counter = 0
        return state
    }
}

const DhcpLease = struct {
    mac_address: [6]u8
    ip_address: [4]u8
    hostname: [64]u8
    hostname_len: usize
    lease_start: u64
    lease_duration: u32
    active: bool

    pub fn init(): DhcpLease {
        var lease: DhcpLease = undefined
        @memset(&lease.mac_address, 0)
        @memset(&lease.ip_address, 0)
        @memset(&lease.hostname, 0)
        lease.hostname_len = 0
        lease.lease_start = 0
        lease.lease_duration = 0
        lease.active = false
        return lease
    }
}

const HotspotStats = struct {
    total_clients: usize
    total_rx_bytes: u64
    total_tx_bytes: u64
    total_clients_connected: u64
    uptime: u64
}

const InterfaceMode = enum {
    STATION
    AP
    MONITOR
    ADHOC
    MESH
    P2P_GO
    P2P_CLIENT
}

// ============================================
// nl80211 Message Builder
// ============================================

const Nl80211Message = struct {
    buffer: [4096]u8
    length: usize

    pub fn init(self: *Nl80211Message, cmd: u8): void {
        @memset(&self.buffer, 0)
        self.length = 0
        // Set command
        self.buffer[0] = cmd
        self.length = 16  // nlmsghdr + genlmsghdr
    }

    pub fn put_u32(self: *Nl80211Message, attr: u16, value: u32): void {
        // NLA header + value
        self.buffer[self.length] = 8  // Length
        self.buffer[self.length + 1] = 0
        self.buffer[self.length + 2] = @truncate(attr & 0xFF)
        self.buffer[self.length + 3] = @truncate((attr >> 8) & 0xFF)
        self.buffer[self.length + 4] = @truncate(value & 0xFF)
        self.buffer[self.length + 5] = @truncate((value >> 8) & 0xFF)
        self.buffer[self.length + 6] = @truncate((value >> 16) & 0xFF)
        self.buffer[self.length + 7] = @truncate((value >> 24) & 0xFF)
        self.length += 8
    }

    pub fn put_u16(self: *Nl80211Message, attr: u16, value: u16): void {
        self.buffer[self.length] = 6
        self.buffer[self.length + 1] = 0
        self.buffer[self.length + 2] = @truncate(attr & 0xFF)
        self.buffer[self.length + 3] = @truncate((attr >> 8) & 0xFF)
        self.buffer[self.length + 4] = @truncate(value & 0xFF)
        self.buffer[self.length + 5] = @truncate((value >> 8) & 0xFF)
        self.length += 8  // Align to 4
    }

    pub fn put(self: *Nl80211Message, attr: u16, data: []const u8): void {
        const aligned_len = (4 + data.len + 3) & ~@as(usize, 3)
        self.buffer[self.length] = @truncate((4 + data.len) & 0xFF)
        self.buffer[self.length + 1] = @truncate(((4 + data.len) >> 8) & 0xFF)
        self.buffer[self.length + 2] = @truncate(attr & 0xFF)
        self.buffer[self.length + 3] = @truncate((attr >> 8) & 0xFF)
        @memcpy(self.buffer[self.length + 4..self.length + 4 + data.len], data)
        self.length += aligned_len
    }

    pub fn put_flag(self: *Nl80211Message, attr: u16): void {
        self.buffer[self.length] = 4
        self.buffer[self.length + 1] = 0
        self.buffer[self.length + 2] = @truncate(attr & 0xFF)
        self.buffer[self.length + 3] = @truncate((attr >> 8) & 0xFF)
        self.length += 4
    }
}

// ============================================
// Constants
// ============================================

const NL80211_CMD_SET_INTERFACE: u8 = 6
const NL80211_CMD_SET_WIPHY: u8 = 2
const NL80211_CMD_START_AP: u8 = 15
const NL80211_CMD_STOP_AP: u8 = 16
const NL80211_CMD_NEW_KEY: u8 = 13
const NL80211_CMD_DEL_STATION: u8 = 19

const NL80211_ATTR_IFINDEX: u16 = 3
const NL80211_ATTR_IFTYPE: u16 = 5
const NL80211_ATTR_MAC: u16 = 6
const NL80211_ATTR_KEY_DATA: u16 = 7
const NL80211_ATTR_KEY_CIPHER: u16 = 9
const NL80211_ATTR_SSID: u16 = 52
const NL80211_ATTR_WIPHY_FREQ: u16 = 38
const NL80211_ATTR_CHANNEL_WIDTH: u16 = 159
const NL80211_ATTR_WIPHY_TX_POWER_SETTING: u16 = 77
const NL80211_ATTR_WIPHY_TX_POWER_LEVEL: u16 = 78
const NL80211_ATTR_BEACON_INTERVAL: u16 = 54
const NL80211_ATTR_DTIM_PERIOD: u16 = 55
const NL80211_ATTR_BEACON_HEAD: u16 = 56
const NL80211_ATTR_BEACON_TAIL: u16 = 57
const NL80211_ATTR_AUTH_TYPE: u16 = 37
const NL80211_ATTR_PRIVACY: u16 = 70
const NL80211_ATTR_HIDDEN_SSID: u16 = 80
const NL80211_ATTR_CIPHER_SUITES_PAIRWISE: u16 = 63
const NL80211_ATTR_CIPHER_SUITE_GROUP: u16 = 64
const NL80211_ATTR_AKM_SUITES: u16 = 65
const NL80211_ATTR_IE: u16 = 42
const NL80211_ATTR_REASON_CODE: u16 = 36

const NL80211_CHAN_WIDTH_20: u32 = 1
const NL80211_CHAN_WIDTH_40: u32 = 2
const NL80211_CHAN_WIDTH_80: u32 = 3
const NL80211_CHAN_WIDTH_160: u32 = 5

const NL80211_TX_POWER_FIXED: u32 = 1

const NL80211_AUTHTYPE_OPEN_SYSTEM: u32 = 0
const NL80211_HIDDEN_SSID_ZERO_LEN: u32 = 1

const WLAN_CIPHER_SUITE_CCMP: u32 = 0x000FAC04
const WLAN_CIPHER_SUITE_GCMP: u32 = 0x000FAC08
const WLAN_AKM_SUITE_PSK: u32 = 0x000FAC02
const WLAN_AKM_SUITE_SAE: u32 = 0x000FAC08

// ============================================
// Helper Functions
// ============================================

fn channel_to_frequency(channel: u8): u32 {
    if channel >= 1 and channel <= 13 {
        return 2407 + @as(u32, channel) * 5
    } else if channel == 14 {
        return 2484
    } else if channel >= 36 and channel <= 165 {
        return 5000 + @as(u32, channel) * 5
    }
    return 2412  // Default to channel 1
}

fn get_timestamp(): u64 {
    var ts: struct { tv_sec: i64, tv_nsec: i64 } = undefined
    _ = @import("time").clock_gettime(0, &ts)
    return @as(u64, @intCast(ts.tv_sec))
}

extern fn create_nl80211_socket(): i32
extern fn send_nl80211_msg(sock: i32, msg: *Nl80211Message): bool
extern fn get_interface_index(name: []const u8): u32
extern fn get_interface_mac(name: []const u8, mac: *[6]u8): void
extern fn close_socket(fd: i32): void
extern fn apply_rate_limit(iface: []const u8, mac: *const [6]u8, limit_kbps: u32): bool

// ============================================
// Public API
// ============================================

var global_hotspot: ?*WifiHotspot = null

pub fn wifi_hotspot_create(config: HotspotConfig): *WifiHotspot {
    const hotspot = @ptrCast(*WifiHotspot, alloc(@sizeOf(WifiHotspot)))
    hotspot.* = WifiHotspot.init(config)
    return hotspot
}

pub fn wifi_hotspot_start(interface: []const u8): bool {
    if global_hotspot != null {
        return false
    }

    var config = HotspotConfig.default()
    global_hotspot = wifi_hotspot_create(config)
    return global_hotspot.?.start(interface)
}

pub fn wifi_hotspot_stop(): bool {
    if global_hotspot == null {
        return false
    }

    const result = global_hotspot.?.stop()
    free(global_hotspot.?)
    global_hotspot = null
    return result
}

pub fn wifi_hotspot_get_clients(): []ClientInfo {
    if global_hotspot == null {
        return &[_]ClientInfo{}
    }
    return global_hotspot.?.get_client_list()
}

extern fn alloc(size: usize): *void
extern fn free(ptr: *void): void
