// HomeOS QoS (Quality of Service) Implementation
// Traffic shaping, prioritization, and bandwidth management
//
// Features:
// - Traffic classification (by port, protocol, IP, DSCP)
// - Multiple queuing disciplines (FIFO, SFQ, HTB, HFSC)
// - Token bucket rate limiting
// - Priority queuing for real-time traffic
// - Bandwidth reservation and guarantees
// - Per-flow and per-class statistics
// - DiffServ (DSCP) marking and remarking
// - Ingress and egress traffic shaping

import "../core/foundation.home" as foundation

// ============================================
// Constants
// ============================================

pub const MAX_CLASSES: u32 = 64
pub const MAX_FILTERS: u32 = 256
pub const MAX_QUEUES: u32 = 16

// QoS Classes
pub const QOS_CLASS_REALTIME: u32 = 0
pub const QOS_CLASS_INTERACTIVE: u32 = 1
pub const QOS_CLASS_BULK: u32 = 2
pub const QOS_CLASS_BEST_EFFORT: u32 = 3
pub const QOS_CLASS_BACKGROUND: u32 = 4

// DSCP values (6-bit, shifted left by 2)
pub const DSCP_CS0: u8 = 0x00        // Best Effort
pub const DSCP_CS1: u8 = 0x20        // Low Priority
pub const DSCP_CS2: u8 = 0x40        // OAM
pub const DSCP_CS3: u8 = 0x60        // Broadcast Video
pub const DSCP_CS4: u8 = 0x80        // Real-Time Interactive
pub const DSCP_CS5: u8 = 0xA0        // Signaling
pub const DSCP_CS6: u8 = 0xC0        // Network Control
pub const DSCP_CS7: u8 = 0xE0        // Reserved

pub const DSCP_AF11: u8 = 0x28       // Assured Forwarding
pub const DSCP_AF12: u8 = 0x30
pub const DSCP_AF13: u8 = 0x38
pub const DSCP_AF21: u8 = 0x48
pub const DSCP_AF22: u8 = 0x50
pub const DSCP_AF23: u8 = 0x58
pub const DSCP_AF31: u8 = 0x68
pub const DSCP_AF32: u8 = 0x70
pub const DSCP_AF33: u8 = 0x78
pub const DSCP_AF41: u8 = 0x88
pub const DSCP_AF42: u8 = 0x90
pub const DSCP_AF43: u8 = 0x98

pub const DSCP_EF: u8 = 0xB8         // Expedited Forwarding (voice/video)

// Traffic Class (for 802.1p priority)
pub const TC_BEST_EFFORT: u8 = 0
pub const TC_BACKGROUND: u8 = 1
pub const TC_EXCELLENT_EFFORT: u8 = 2
pub const TC_CRITICAL: u8 = 3
pub const TC_VIDEO: u8 = 4
pub const TC_VOICE: u8 = 5
pub const TC_NETWORK_CONTROL: u8 = 6

// ============================================
// Queuing Disciplines
// ============================================

pub const QdiscType = enum {
    FIFO         // First In First Out (pfifo/bfifo)
    PRIO         // Priority queuing
    SFQ          // Stochastic Fair Queuing
    TBF          // Token Bucket Filter
    HTB          // Hierarchical Token Bucket
    HFSC         // Hierarchical Fair Service Curve
    FQ_CODEL     // Fair Queueing with Controlled Delay
}

// ============================================
// Filter Match Types
// ============================================

pub const FilterType = enum {
    ALL              // Match all packets
    IP_PROTOCOL      // Match IP protocol (TCP, UDP, ICMP, etc.)
    SRC_IP           // Match source IP address
    DST_IP           // Match destination IP address
    SRC_PORT         // Match source port
    DST_PORT         // Match destination port
    DSCP             // Match DSCP value
    VLAN_PRIORITY    // Match 802.1p priority
    MARK             // Match packet mark (fwmark)
}

// ============================================
// Data Structures
// ============================================

pub struct QosQueue {
    id: u32
    class: u32
    priority: u32
    bandwidth_limit: u64      // bits per second
    burst_size: u32           // bytes
    packets_queued: u32
    bytes_queued: u32

    // Token bucket state
    tokens: i64
    last_update: u64

    // Statistics
    enqueued_packets: u64
    enqueued_bytes: u64
    dequeued_packets: u64
    dequeued_bytes: u64
    dropped_packets: u64
    dropped_bytes: u64
}

pub struct TrafficClass {
    id: u32
    name: [32]u8
    name_len: u32

    // Rate limiting (bits per second)
    rate: u64               // Guaranteed rate
    ceil: u64               // Maximum rate
    burst: u32              // Burst size in bytes

    // Priority (lower = higher priority)
    priority: u8

    // DSCP marking
    dscp_mark: u8
    dscp_enabled: bool

    // Parent class (0 = root)
    parent_id: u32

    // Statistics
    bytes: u64
    packets: u64
    drops: u64
    overlimits: u64
}

pub struct TrafficFilter {
    id: u32
    priority: u16           // Lower = checked first
    class_id: u32           // Target class

    // Match criteria
    filter_type: FilterType
    ip_protocol: u8
    src_ip: [4]u8
    src_ip_mask: [4]u8
    dst_ip: [4]u8
    dst_ip_mask: [4]u8
    src_port_start: u16
    src_port_end: u16
    dst_port_start: u16
    dst_port_end: u16
    dscp: u8
    mark: u32

    // Statistics
    match_count: u64
    match_bytes: u64
}

pub struct PacketInfo {
    src_ip: [4]u8
    dst_ip: [4]u8
    src_port: u16
    dst_port: u16
    protocol: u8
    tos: u8
    length: u32
    mark: u32
}

pub struct QosManager {
    interface: [16]u8
    interface_len: u32

    // Root qdisc type
    root_qdisc: QdiscType

    // Classes
    classes: [64]TrafficClass
    class_count: u32

    // Filters
    filters: [256]TrafficFilter
    filter_count: u32

    // Queues
    queues: [16]QosQueue
    queue_count: u32

    // Default class
    default_class_id: u32

    // Global limits
    global_rate: u64

    // Statistics
    total_packets: u64
    total_bytes: u64
    total_drops: u64

    enabled: bool
}

// ============================================
// Global State
// ============================================

var qos_managers: [8]QosManager
var qos_manager_count: u32 = 0

var qos_queues: [16]QosQueue
var qos_queue_count: u32 = 0

// ============================================
// Initialization
// ============================================

export fn qos_init() {
    qos_queue_count = 0
    qos_manager_count = 0

    // Initialize default queues
    for i in 0..16 {
        qos_queues[i].id = i
        qos_queues[i].class = QOS_CLASS_BEST_EFFORT
        qos_queues[i].priority = 7
        qos_queues[i].bandwidth_limit = 0
        qos_queues[i].burst_size = 1500
        qos_queues[i].packets_queued = 0
        qos_queues[i].bytes_queued = 0
        qos_queues[i].tokens = 0
        qos_queues[i].last_update = 0
        qos_queues[i].enqueued_packets = 0
        qos_queues[i].enqueued_bytes = 0
        qos_queues[i].dequeued_packets = 0
        qos_queues[i].dequeued_bytes = 0
        qos_queues[i].dropped_packets = 0
        qos_queues[i].dropped_bytes = 0
    }

    foundation.serial_write_string("[QoS] Initialized with HTB support\n")
}

// ============================================
// Queue Management
// ============================================

export fn qos_create_queue(class: u32, priority: u32, bandwidth_kbps: u64): u32 {
    if qos_queue_count >= 16 {
        return 0xFFFFFFFF
    }

    var id: u32 = qos_queue_count

    qos_queues[id].id = id
    qos_queues[id].class = class
    qos_queues[id].priority = priority
    qos_queues[id].bandwidth_limit = bandwidth_kbps * 1000  // Convert to bps
    qos_queues[id].burst_size = (bandwidth_kbps * 1000 / 8 / 10) as u32  // 100ms burst
    if qos_queues[id].burst_size < 1500 {
        qos_queues[id].burst_size = 1500  // Minimum one MTU
    }
    qos_queues[id].packets_queued = 0
    qos_queues[id].bytes_queued = 0
    qos_queues[id].tokens = qos_queues[id].burst_size as i64
    qos_queues[id].last_update = get_timestamp_ns()

    qos_queue_count = qos_queue_count + 1

    return id
}

export fn qos_delete_queue(queue_id: u32): bool {
    if queue_id >= qos_queue_count {
        return false
    }

    // Shift remaining queues
    for i in queue_id..(qos_queue_count - 1) {
        qos_queues[i] = qos_queues[i + 1]
        qos_queues[i].id = i
    }

    qos_queue_count = qos_queue_count - 1
    return true
}

export fn qos_set_bandwidth(queue_id: u32, bandwidth_kbps: u64): bool {
    if queue_id >= qos_queue_count {
        return false
    }

    qos_queues[queue_id].bandwidth_limit = bandwidth_kbps * 1000
    qos_queues[queue_id].burst_size = (bandwidth_kbps * 1000 / 8 / 10) as u32
    if qos_queues[queue_id].burst_size < 1500 {
        qos_queues[queue_id].burst_size = 1500
    }

    return true
}

export fn qos_set_priority(queue_id: u32, priority: u32): bool {
    if queue_id >= qos_queue_count {
        return false
    }

    qos_queues[queue_id].priority = priority
    return true
}

// ============================================
// Packet Operations
// ============================================

export fn qos_enqueue_packet(queue_id: u32, packet: *u8, length: u32): bool {
    if queue_id >= qos_queue_count {
        return false
    }

    var queue = &qos_queues[queue_id]

    // Check queue limits
    if queue.packets_queued >= 1000 or queue.bytes_queued + length > 256 * 1024 {
        queue.dropped_packets = queue.dropped_packets + 1
        queue.dropped_bytes = queue.dropped_bytes + length as u64
        return false
    }

    // Token bucket check
    if queue.bandwidth_limit > 0 {
        update_tokens(queue)

        if queue.tokens < length as i64 {
            // Over limit, drop or mark
            queue.dropped_packets = queue.dropped_packets + 1
            queue.dropped_bytes = queue.dropped_bytes + length as u64
            return false
        }
    }

    // Enqueue (simplified - actual implementation would use ring buffer)
    queue.packets_queued = queue.packets_queued + 1
    queue.bytes_queued = queue.bytes_queued + length
    queue.enqueued_packets = queue.enqueued_packets + 1
    queue.enqueued_bytes = queue.enqueued_bytes + length as u64

    return true
}

export fn qos_dequeue_packet(queue_id: u32): *u8 {
    if queue_id >= qos_queue_count {
        return null
    }

    var queue = &qos_queues[queue_id]

    if queue.packets_queued == 0 {
        return null
    }

    // Token bucket consume
    if queue.bandwidth_limit > 0 {
        update_tokens(queue)
        // Assume average packet size of 1000 bytes
        queue.tokens = queue.tokens - 1000
    }

    queue.packets_queued = queue.packets_queued - 1
    queue.dequeued_packets = queue.dequeued_packets + 1

    // Return packet data (simplified)
    return null  // Actual implementation would return packet buffer
}

export fn qos_get_next_packet(): u32 {
    // Priority-based selection
    var best_queue: u32 = 0xFFFFFFFF
    var best_priority: u32 = 0xFFFFFFFF

    for i in 0..qos_queue_count {
        if qos_queues[i].packets_queued > 0 and qos_queues[i].priority < best_priority {
            // Check if queue can send (token bucket)
            if qos_queues[i].bandwidth_limit == 0 or qos_queues[i].tokens > 0 {
                best_queue = i
                best_priority = qos_queues[i].priority
            }
        }
    }

    return best_queue
}

fn update_tokens(queue: *QosQueue) {
    var now = get_timestamp_ns()
    var elapsed = now - queue.last_update

    if elapsed > 0 and queue.bandwidth_limit > 0 {
        // Replenish tokens based on rate
        var new_tokens = (queue.bandwidth_limit * elapsed / 8_000_000_000) as i64
        queue.tokens = queue.tokens + new_tokens

        // Cap at burst size
        if queue.tokens > queue.burst_size as i64 {
            queue.tokens = queue.burst_size as i64
        }

        queue.last_update = now
    }
}

// ============================================
// Classification
// ============================================

export fn qos_classify_packet(packet: *u8, length: u32): u32 {
    if length < 34 {  // Minimum Ethernet + IP header
        return QOS_CLASS_BEST_EFFORT
    }

    // Parse packet
    var info = parse_packet(packet, length)

    // Check for real-time traffic (voice/video ports)
    if info.protocol == 17 {  // UDP
        // RTP ports commonly used for voice/video
        if info.dst_port >= 16384 and info.dst_port <= 32767 {
            return QOS_CLASS_REALTIME
        }
        // DNS
        if info.dst_port == 53 or info.src_port == 53 {
            return QOS_CLASS_INTERACTIVE
        }
    }

    if info.protocol == 6 {  // TCP
        // SSH, HTTP, HTTPS
        if info.dst_port == 22 or info.dst_port == 80 or info.dst_port == 443 {
            return QOS_CLASS_INTERACTIVE
        }
        // FTP data
        if info.dst_port == 20 or info.dst_port == 21 {
            return QOS_CLASS_BULK
        }
    }

    // Check DSCP
    var dscp = (info.tos >> 2) & 0x3F
    if dscp == (DSCP_EF >> 2) {
        return QOS_CLASS_REALTIME
    }
    if dscp >= (DSCP_AF41 >> 2) {
        return QOS_CLASS_INTERACTIVE
    }

    return QOS_CLASS_BEST_EFFORT
}

fn parse_packet(packet: *u8, length: u32): PacketInfo {
    var info: PacketInfo
    @memset(&info.src_ip, 0)
    @memset(&info.dst_ip, 0)
    info.src_port = 0
    info.dst_port = 0
    info.protocol = 0
    info.tos = 0
    info.length = length
    info.mark = 0

    if length < 34 {
        return info
    }

    // Skip Ethernet header (14 bytes)
    var ip_header = packet + 14

    // Parse IP header
    info.tos = ip_header[1]
    info.protocol = ip_header[9]
    @memcpy(&info.src_ip, ip_header + 12, 4)
    @memcpy(&info.dst_ip, ip_header + 16, 4)

    // Parse TCP/UDP ports
    var ihl = (ip_header[0] & 0x0F) * 4
    if info.protocol == 6 or info.protocol == 17 {
        var transport_header = ip_header + ihl
        info.src_port = (transport_header[0] as u16 << 8) | transport_header[1] as u16
        info.dst_port = (transport_header[2] as u16 << 8) | transport_header[3] as u16
    }

    return info
}

// ============================================
// DSCP Marking
// ============================================

export fn qos_mark_dscp(packet: *u8, length: u32, dscp: u8): bool {
    if length < 15 {
        return false
    }

    // Modify TOS byte in IP header
    var ip_header = packet + 14
    ip_header[1] = (dscp & 0xFC) | (ip_header[1] & 0x03)

    return true
}

export fn qos_get_dscp(packet: *u8, length: u32): u8 {
    if length < 15 {
        return 0
    }

    var ip_header = packet + 14
    return ip_header[1] & 0xFC
}

// ============================================
// Manager API
// ============================================

export fn qos_attach_interface(interface: *u8, interface_len: u32): *QosManager {
    if qos_manager_count >= 8 {
        return null
    }

    var mgr = &qos_managers[qos_manager_count]
    @memcpy(&mgr.interface, interface, interface_len)
    mgr.interface_len = interface_len
    mgr.root_qdisc = QdiscType.HTB
    mgr.class_count = 0
    mgr.filter_count = 0
    mgr.queue_count = 0
    mgr.default_class_id = 0
    mgr.global_rate = 0
    mgr.total_packets = 0
    mgr.total_bytes = 0
    mgr.total_drops = 0
    mgr.enabled = true

    qos_manager_count = qos_manager_count + 1

    return mgr
}

export fn qos_detach_interface(mgr: *QosManager) {
    mgr.enabled = false
}

export fn qos_add_class(mgr: *QosManager, rate_kbps: u64, ceil_kbps: u64, priority: u8): u32 {
    if mgr.class_count >= 64 {
        return 0xFFFFFFFF
    }

    var id = mgr.class_count
    var class = &mgr.classes[id]

    class.id = id
    class.rate = rate_kbps * 1000
    class.ceil = if ceil_kbps > 0 { ceil_kbps * 1000 } else { class.rate }
    class.burst = (class.rate / 8 / 10) as u32
    if class.burst < 1500 { class.burst = 1500 }
    class.priority = priority
    class.dscp_enabled = false
    class.dscp_mark = 0
    class.parent_id = 0
    class.bytes = 0
    class.packets = 0
    class.drops = 0
    class.overlimits = 0

    mgr.class_count = mgr.class_count + 1

    return id
}

export fn qos_add_filter(mgr: *QosManager, class_id: u32, filter_type: FilterType,
                         dst_port: u16, protocol: u8): u32 {
    if mgr.filter_count >= 256 {
        return 0xFFFFFFFF
    }

    var id = mgr.filter_count
    var filter = &mgr.filters[id]

    filter.id = id
    filter.priority = 100
    filter.class_id = class_id
    filter.filter_type = filter_type
    filter.ip_protocol = protocol
    filter.dst_port_start = dst_port
    filter.dst_port_end = dst_port
    filter.match_count = 0
    filter.match_bytes = 0

    mgr.filter_count = mgr.filter_count + 1

    return id
}

// ============================================
// Statistics
// ============================================

export fn qos_get_queue_stats(queue_id: u32, stats: *QosQueue): bool {
    if queue_id >= qos_queue_count {
        return false
    }

    @memcpy(stats, &qos_queues[queue_id], @sizeOf(QosQueue))
    return true
}

export fn qos_get_total_stats(total_packets: *u64, total_bytes: *u64, total_drops: *u64) {
    *total_packets = 0
    *total_bytes = 0
    *total_drops = 0

    for i in 0..qos_queue_count {
        *total_packets = *total_packets + qos_queues[i].enqueued_packets
        *total_bytes = *total_bytes + qos_queues[i].enqueued_bytes
        *total_drops = *total_drops + qos_queues[i].dropped_packets
    }
}

export fn qos_reset_stats(queue_id: u32): bool {
    if queue_id >= qos_queue_count {
        return false
    }

    qos_queues[queue_id].enqueued_packets = 0
    qos_queues[queue_id].enqueued_bytes = 0
    qos_queues[queue_id].dequeued_packets = 0
    qos_queues[queue_id].dequeued_bytes = 0
    qos_queues[queue_id].dropped_packets = 0
    qos_queues[queue_id].dropped_bytes = 0

    return true
}

// ============================================
// Helper Functions
// ============================================

fn get_timestamp_ns(): u64 {
    // Get nanosecond timestamp (would use kernel time functions)
    return 0  // Placeholder - actual implementation uses clock_gettime
}

// ============================================
// Preset Configurations
// ============================================

export fn qos_setup_voip_priority(mgr: *QosManager) {
    // Create real-time class for VoIP
    var rt_class = qos_add_class(mgr, 0, 0, 0)  // Unlimited, highest priority

    // Filter for RTP traffic (UDP 16384-32767)
    var filter = &mgr.filters[mgr.filter_count]
    filter.id = mgr.filter_count
    filter.priority = 10
    filter.class_id = rt_class
    filter.filter_type = FilterType.DST_PORT
    filter.ip_protocol = 17  // UDP
    filter.dst_port_start = 16384
    filter.dst_port_end = 32767
    mgr.filter_count = mgr.filter_count + 1

    // Filter for SIP traffic (UDP/TCP 5060)
    var sip_filter = &mgr.filters[mgr.filter_count]
    sip_filter.id = mgr.filter_count
    sip_filter.priority = 10
    sip_filter.class_id = rt_class
    sip_filter.filter_type = FilterType.DST_PORT
    sip_filter.dst_port_start = 5060
    sip_filter.dst_port_end = 5061
    mgr.filter_count = mgr.filter_count + 1

    foundation.serial_write_string("[QoS] VoIP priority configured\n")
}

export fn qos_setup_gaming(mgr: *QosManager) {
    // Create interactive class for gaming
    var gaming_class = qos_add_class(mgr, 0, 0, 1)  // Unlimited, second priority

    // Enable DSCP marking for Expedited Forwarding
    mgr.classes[gaming_class].dscp_enabled = true
    mgr.classes[gaming_class].dscp_mark = DSCP_EF

    foundation.serial_write_string("[QoS] Gaming priority configured\n")
}

export fn qos_setup_bandwidth_limit(mgr: *QosManager, download_kbps: u64, upload_kbps: u64) {
    // Set global rate limits
    mgr.global_rate = download_kbps * 1000

    // Create default class with limit
    var default_class = qos_add_class(mgr, download_kbps, download_kbps, 7)
    mgr.default_class_id = default_class

    foundation.serial_write_string("[QoS] Bandwidth limits configured\n")
}
