// home-os ARP Protocol
// Address Resolution Protocol

import "../core/foundation.home" as foundation
import "../drivers/e1000.home" as e1000

const ARP_REQUEST: u16 = 1
const ARP_REPLY: u16 = 2

struct ARPPacket {
  hw_type: u16,
  proto_type: u16,
  hw_size: u8,
  proto_size: u8,
  opcode: u16,
  sender_mac: [u8; 6],
  sender_ip: u32,
  target_mac: [u8; 6],
  target_ip: u32
}

const ARP_CACHE_SIZE: u32 = 16

struct ARPEntry {
  ip: u32,
  mac: [u8; 6],
  valid: u32
}

var arp_cache: [ARPEntry; 16]
var arp_cache_count: u32 = 0

export fn arp_init() {
  arp_cache_count = 0
  foundation.serial_write_string("[ARP] Initialized\n")
}

export fn arp_request(target_ip: u32) -> u32 {
  var packet: [u8; 64]
  var offset: u32 = 0
  
  // Ethernet header
  var i: u32 = 0
  while i < 6 {
    packet[offset + i] = 0xFF
    i = i + 1
  }
  offset = offset + 6
  
  e1000.e1000_get_mac_address(@ptrFromInt(packet) + offset)
  offset = offset + 6
  
  packet[offset] = 0x08
  packet[offset + 1] = 0x06
  offset = offset + 2
  
  // ARP packet
  packet[offset] = 0x00
  packet[offset + 1] = 0x01
  packet[offset + 2] = 0x08
  packet[offset + 3] = 0x00
  packet[offset + 4] = 6
  packet[offset + 5] = 4
  packet[offset + 6] = 0x00
  packet[offset + 7] = ARP_REQUEST
  offset = offset + 8
  
  e1000.e1000_get_mac_address(@ptrFromInt(packet) + offset)
  offset = offset + 6
  
  packet[offset] = 10
  packet[offset + 1] = 0
  packet[offset + 2] = 0
  packet[offset + 3] = 2
  offset = offset + 4
  
  i = 0
  while i < 6 {
    packet[offset + i] = 0
    i = i + 1
  }
  offset = offset + 6
  
  packet[offset] = (target_ip >> 24) & 0xFF
  packet[offset + 1] = (target_ip >> 16) & 0xFF
  packet[offset + 2] = (target_ip >> 8) & 0xFF
  packet[offset + 3] = target_ip & 0xFF
  offset = offset + 4
  
  return e1000.e1000_send_packet(@ptrFromInt(packet), offset)
}

export fn arp_lookup(ip: u32) -> u64 {
  var i: u32 = 0
  while i < arp_cache_count {
    if arp_cache[i].valid == 1 and arp_cache[i].ip == ip {
      return @ptrFromInt(arp_cache[i].mac)
    }
    i = i + 1
  }
  return 0
}

export fn arp_add_entry(ip: u32, mac: u64) {
  if arp_cache_count >= ARP_CACHE_SIZE { return }
  
  arp_cache[arp_cache_count].ip = ip
  var i: u32 = 0
  while i < 6 {
    arp_cache[arp_cache_count].mac[i] = @intToPtr(mac + i, u8)
    i = i + 1
  }
  arp_cache[arp_cache_count].valid = 1
  arp_cache_count = arp_cache_count + 1
}
