// home-os CoAP (Constrained Application Protocol)
// RFC 7252 compliant lightweight IoT protocol

import "../core/foundation.home" as foundation
import "udp.home" as udp

// CoAP Constants
const COAP_PORT: u16 = 5683
const COAP_SECURE_PORT: u16 = 5684
const COAP_VERSION: u8 = 1
const COAP_MAX_TOKEN_LEN: u8 = 8
const COAP_PAYLOAD_MARKER: u8 = 0xFF
const COAP_MAX_OPTIONS: u32 = 16
const COAP_MAX_RESOURCES: u32 = 32
const COAP_MAX_OBSERVERS: u32 = 64
const COAP_MAX_PENDING: u32 = 32
const COAP_ACK_TIMEOUT_MS: u64 = 2000
const COAP_MAX_RETRANSMIT: u8 = 4

// Message types
const COAP_TYPE_CON: u8 = 0    // Confirmable
const COAP_TYPE_NON: u8 = 1    // Non-confirmable
const COAP_TYPE_ACK: u8 = 2    // Acknowledgement
const COAP_TYPE_RST: u8 = 3    // Reset

// Method codes
const COAP_GET: u8 = 1
const COAP_POST: u8 = 2
const COAP_PUT: u8 = 3
const COAP_DELETE: u8 = 4
const COAP_FETCH: u8 = 5
const COAP_PATCH: u8 = 6
const COAP_IPATCH: u8 = 7

// Response codes (class.detail format encoded as single byte)
const COAP_RESP_CREATED: u8 = 0x41        // 2.01
const COAP_RESP_DELETED: u8 = 0x42        // 2.02
const COAP_RESP_VALID: u8 = 0x43          // 2.03
const COAP_RESP_CHANGED: u8 = 0x44        // 2.04
const COAP_RESP_CONTENT: u8 = 0x45        // 2.05
const COAP_RESP_CONTINUE: u8 = 0x5F       // 2.31
const COAP_RESP_BAD_REQUEST: u8 = 0x80    // 4.00
const COAP_RESP_UNAUTHORIZED: u8 = 0x81   // 4.01
const COAP_RESP_BAD_OPTION: u8 = 0x82     // 4.02
const COAP_RESP_FORBIDDEN: u8 = 0x83      // 4.03
const COAP_RESP_NOT_FOUND: u8 = 0x84      // 4.04
const COAP_RESP_NOT_ALLOWED: u8 = 0x85    // 4.05
const COAP_RESP_NOT_ACCEPTABLE: u8 = 0x86 // 4.06
const COAP_RESP_PRECOND_FAIL: u8 = 0x8C   // 4.12
const COAP_RESP_TOO_LARGE: u8 = 0x8D      // 4.13
const COAP_RESP_UNSUPPORTED: u8 = 0x8F    // 4.15
const COAP_RESP_INTERNAL: u8 = 0xA0       // 5.00
const COAP_RESP_NOT_IMPL: u8 = 0xA1       // 5.01
const COAP_RESP_BAD_GATEWAY: u8 = 0xA2    // 5.02
const COAP_RESP_UNAVAILABLE: u8 = 0xA3    // 5.03
const COAP_RESP_GW_TIMEOUT: u8 = 0xA4     // 5.04
const COAP_RESP_PROXY_ERROR: u8 = 0xA5    // 5.05

// Option numbers
const COAP_OPT_IF_MATCH: u16 = 1
const COAP_OPT_URI_HOST: u16 = 3
const COAP_OPT_ETAG: u16 = 4
const COAP_OPT_IF_NONE_MATCH: u16 = 5
const COAP_OPT_OBSERVE: u16 = 6
const COAP_OPT_URI_PORT: u16 = 7
const COAP_OPT_LOCATION_PATH: u16 = 8
const COAP_OPT_URI_PATH: u16 = 11
const COAP_OPT_CONTENT_FORMAT: u16 = 12
const COAP_OPT_MAX_AGE: u16 = 14
const COAP_OPT_URI_QUERY: u16 = 15
const COAP_OPT_ACCEPT: u16 = 17
const COAP_OPT_LOCATION_QUERY: u16 = 20
const COAP_OPT_BLOCK2: u16 = 23
const COAP_OPT_BLOCK1: u16 = 27
const COAP_OPT_SIZE2: u16 = 28
const COAP_OPT_PROXY_URI: u16 = 35
const COAP_OPT_PROXY_SCHEME: u16 = 39
const COAP_OPT_SIZE1: u16 = 60

// Content formats
const COAP_FMT_TEXT: u16 = 0
const COAP_FMT_LINK: u16 = 40
const COAP_FMT_XML: u16 = 41
const COAP_FMT_OCTET: u16 = 42
const COAP_FMT_EXI: u16 = 47
const COAP_FMT_JSON: u16 = 50
const COAP_FMT_CBOR: u16 = 60
const COAP_FMT_SENML_JSON: u16 = 110
const COAP_FMT_SENML_CBOR: u16 = 112

// CoAP Option
struct CoapOption {
    number: u16,
    length: u16,
    value: [u8; 256]
}

// CoAP Message
struct CoapMessage {
    version: u8,
    msg_type: u8,
    token_len: u8,
    code: u8,
    message_id: u16,
    token: [u8; 8],
    options: [CoapOption; 16],
    option_count: u8,
    payload: [u8; 1024],
    payload_len: u16,
    // Address info
    src_addr: u32,
    src_port: u16,
    dst_addr: u32,
    dst_port: u16
}

// Resource handler type
struct CoapResource {
    path: [u8; 64],
    path_len: u8,
    methods: u8,          // Bitmask of allowed methods
    observable: u8,
    content_format: u16,
    handler: u64,         // Function pointer
    active: u8
}

// Observer entry
struct CoapObserver {
    token: [u8; 8],
    token_len: u8,
    addr: u32,
    port: u16,
    resource_idx: u8,
    sequence: u32,
    last_seen: u64,
    active: u8
}

// Pending request for retransmission
struct CoapPending {
    message_id: u16,
    token: [u8; 8],
    token_len: u8,
    dst_addr: u32,
    dst_port: u16,
    data: [u8; 512],
    data_len: u16,
    retries: u8,
    timeout: u64,
    callback: u64,        // Function pointer
    user_data: u64,
    active: u8
}

// Statistics
struct CoapStats {
    messages_sent: u64,
    messages_received: u64,
    retransmissions: u32,
    timeouts: u32,
    parse_errors: u32,
    observers_count: u32
}

// Global state
var coap_socket: u32 = 0
var coap_port: u16 = 0
var coap_resources: [CoapResource; 32]
var coap_resource_count: u32 = 0
var coap_observers: [CoapObserver; 64]
var coap_observer_count: u32 = 0
var coap_pending: [CoapPending; 32]
var coap_pending_count: u32 = 0
var coap_next_message_id: u16 = 0
var coap_rx_buffer: [u8; 1500]
var coap_tx_buffer: [u8; 1500]
var coap_stats: CoapStats
var coap_initialized: u32 = 0

// Initialize CoAP stack
export fn coap_init(): u32 {
    if coap_initialized == 1 {
        return 1
    }

    coap_port = COAP_PORT
    coap_resource_count = 0
    coap_observer_count = 0
    coap_pending_count = 0
    coap_next_message_id = foundation.timer_get_ticks() ^ 0x5A5A

    // Clear resources
    var i: u32 = 0
    while i < COAP_MAX_RESOURCES {
        coap_resources[i].active = 0
        i = i + 1
    }

    // Clear observers
    i = 0
    while i < COAP_MAX_OBSERVERS {
        coap_observers[i].active = 0
        i = i + 1
    }

    // Clear pending
    i = 0
    while i < COAP_MAX_PENDING {
        coap_pending[i].active = 0
        i = i + 1
    }

    // Clear stats
    coap_stats.messages_sent = 0
    coap_stats.messages_received = 0
    coap_stats.retransmissions = 0
    coap_stats.timeouts = 0
    coap_stats.parse_errors = 0
    coap_stats.observers_count = 0

    // Create UDP socket
    coap_socket = udp.udp_socket_create(COAP_PORT)
    if coap_socket == 0xFFFFFFFF {
        foundation.serial_write_string("[CoAP] Failed to create socket\n")
        return 0
    }

    coap_initialized = 1
    foundation.serial_write_string("[CoAP] Initialized on port 5683\n")
    return 1
}

// Start CoAP server on custom port
export fn coap_start_server(port: u16): u32 {
    if coap_initialized == 0 {
        if coap_init() == 0 {
            return 0
        }
    }

    if port != coap_port {
        udp.udp_socket_close(coap_socket)
        coap_socket = udp.udp_socket_create(port)
        if coap_socket == 0xFFFFFFFF {
            return 0
        }
        coap_port = port
    }

    foundation.serial_write_string("[CoAP] Server started on port ")
    foundation.serial_write_hex(port)
    foundation.serial_write_string("\n")
    return 1
}

// Register a resource
export fn coap_register_resource(path: u64, path_len: u8, handler: u64, methods: u8, observable: u8): u32 {
    if coap_resource_count >= COAP_MAX_RESOURCES {
        return 0
    }

    // Find empty slot
    var i: u32 = 0
    while i < COAP_MAX_RESOURCES {
        if coap_resources[i].active == 0 {
            break
        }
        i = i + 1
    }

    if i >= COAP_MAX_RESOURCES {
        return 0
    }

    // Copy path
    var j: u32 = 0
    while j < path_len {
        coap_resources[i].path[j] = @intToPtr(path + j, u8)
        j = j + 1
    }
    coap_resources[i].path_len = path_len
    coap_resources[i].handler = handler
    coap_resources[i].methods = methods
    coap_resources[i].observable = observable
    coap_resources[i].content_format = COAP_FMT_TEXT
    coap_resources[i].active = 1

    coap_resource_count = coap_resource_count + 1

    foundation.serial_write_string("[CoAP] Registered resource: ")
    var k: u32 = 0
    while k < path_len {
        foundation.serial_write_char(coap_resources[i].path[k])
        k = k + 1
    }
    foundation.serial_write_string("\n")

    return 1
}

// Parse incoming CoAP message
fn coap_parse_message(data: u64, len: u32, msg: u64): u32 {
    var message: CoapMessage = @intToPtr(msg, CoapMessage)

    if len < 4 {
        coap_stats.parse_errors = coap_stats.parse_errors + 1
        return 0
    }

    // Parse fixed header
    var byte0: u8 = @intToPtr(data, u8)
    message.version = (byte0 >> 6) & 0x03
    message.msg_type = (byte0 >> 4) & 0x03
    message.token_len = byte0 & 0x0F

    if message.version != COAP_VERSION {
        coap_stats.parse_errors = coap_stats.parse_errors + 1
        return 0
    }

    if message.token_len > COAP_MAX_TOKEN_LEN {
        coap_stats.parse_errors = coap_stats.parse_errors + 1
        return 0
    }

    message.code = @intToPtr(data + 1, u8)
    message.message_id = (@intToPtr(data + 2, u8) << 8) | @intToPtr(data + 3, u8)

    var offset: u32 = 4

    // Parse token
    if message.token_len > 0 {
        if offset + message.token_len > len {
            coap_stats.parse_errors = coap_stats.parse_errors + 1
            return 0
        }
        var i: u32 = 0
        while i < message.token_len {
            message.token[i] = @intToPtr(data + offset + i, u8)
            i = i + 1
        }
        offset = offset + message.token_len
    }

    // Parse options
    message.option_count = 0
    var option_number: u16 = 0

    while offset < len {
        var byte: u8 = @intToPtr(data + offset, u8)
        if byte == COAP_PAYLOAD_MARKER {
            offset = offset + 1
            break
        }

        var delta: u16 = (byte >> 4) & 0x0F
        var opt_len: u16 = byte & 0x0F
        offset = offset + 1

        // Extended delta
        if delta == 13 {
            if offset >= len { return 0 }
            delta = @intToPtr(data + offset, u8) + 13
            offset = offset + 1
        } else if delta == 14 {
            if offset + 1 >= len { return 0 }
            delta = ((@intToPtr(data + offset, u8) << 8) | @intToPtr(data + offset + 1, u8)) + 269
            offset = offset + 2
        }

        // Extended length
        if opt_len == 13 {
            if offset >= len { return 0 }
            opt_len = @intToPtr(data + offset, u8) + 13
            offset = offset + 1
        } else if opt_len == 14 {
            if offset + 1 >= len { return 0 }
            opt_len = ((@intToPtr(data + offset, u8) << 8) | @intToPtr(data + offset + 1, u8)) + 269
            offset = offset + 2
        }

        option_number = option_number + delta

        if message.option_count < COAP_MAX_OPTIONS {
            message.options[message.option_count].number = option_number
            message.options[message.option_count].length = opt_len

            var i: u32 = 0
            while i < opt_len {
                if i < 256 {
                    message.options[message.option_count].value[i] = @intToPtr(data + offset + i, u8)
                }
                i = i + 1
            }
            message.option_count = message.option_count + 1
        }

        offset = offset + opt_len
    }

    // Parse payload
    if offset < len {
        message.payload_len = len - offset
        if message.payload_len > 1024 {
            message.payload_len = 1024
        }
        var i: u32 = 0
        while i < message.payload_len {
            message.payload[i] = @intToPtr(data + offset + i, u8)
            i = i + 1
        }
    } else {
        message.payload_len = 0
    }

    return 1
}

// Serialize CoAP message to buffer
fn coap_serialize_message(msg: u64, buffer: u64): u32 {
    var message: CoapMessage = @intToPtr(msg, CoapMessage)
    var offset: u32 = 0

    // Write header
    var byte0: u8 = ((message.version & 0x03) << 6) |
                    ((message.msg_type & 0x03) << 4) |
                    (message.token_len & 0x0F)
    @intToPtr(buffer, u8) = byte0
    @intToPtr(buffer + 1, u8) = message.code
    @intToPtr(buffer + 2, u8) = (message.message_id >> 8) & 0xFF
    @intToPtr(buffer + 3, u8) = message.message_id & 0xFF
    offset = 4

    // Write token
    var i: u32 = 0
    while i < message.token_len {
        @intToPtr(buffer + offset + i, u8) = message.token[i]
        i = i + 1
    }
    offset = offset + message.token_len

    // Write options (sorted by number)
    var prev_number: u16 = 0
    i = 0
    while i < message.option_count {
        var delta: u16 = message.options[i].number - prev_number
        var opt_len: u16 = message.options[i].length

        // Encode delta/length nibbles
        var delta_nibble: u8 = 0
        var len_nibble: u8 = 0

        if delta < 13 {
            delta_nibble = delta
        } else if delta < 269 {
            delta_nibble = 13
        } else {
            delta_nibble = 14
        }

        if opt_len < 13 {
            len_nibble = opt_len
        } else if opt_len < 269 {
            len_nibble = 13
        } else {
            len_nibble = 14
        }

        @intToPtr(buffer + offset, u8) = (delta_nibble << 4) | len_nibble
        offset = offset + 1

        // Extended delta
        if delta >= 13 {
            if delta < 269 {
                @intToPtr(buffer + offset, u8) = delta - 13
                offset = offset + 1
            } else {
                var ext: u16 = delta - 269
                @intToPtr(buffer + offset, u8) = (ext >> 8) & 0xFF
                @intToPtr(buffer + offset + 1, u8) = ext & 0xFF
                offset = offset + 2
            }
        }

        // Extended length
        if opt_len >= 13 {
            if opt_len < 269 {
                @intToPtr(buffer + offset, u8) = opt_len - 13
                offset = offset + 1
            } else {
                var ext: u16 = opt_len - 269
                @intToPtr(buffer + offset, u8) = (ext >> 8) & 0xFF
                @intToPtr(buffer + offset + 1, u8) = ext & 0xFF
                offset = offset + 2
            }
        }

        // Option value
        var j: u32 = 0
        while j < opt_len {
            @intToPtr(buffer + offset + j, u8) = message.options[i].value[j]
            j = j + 1
        }
        offset = offset + opt_len

        prev_number = message.options[i].number
        i = i + 1
    }

    // Write payload marker and payload
    if message.payload_len > 0 {
        @intToPtr(buffer + offset, u8) = COAP_PAYLOAD_MARKER
        offset = offset + 1

        i = 0
        while i < message.payload_len {
            @intToPtr(buffer + offset + i, u8) = message.payload[i]
            i = i + 1
        }
        offset = offset + message.payload_len
    }

    return offset
}

// Send CoAP message
fn coap_send_message(msg: u64): u32 {
    var message: CoapMessage = @intToPtr(msg, CoapMessage)
    var len: u32 = coap_serialize_message(msg, @ptrFromInt(coap_tx_buffer))

    var result: u32 = udp.udp_socket_sendto(
        coap_socket,
        @ptrFromInt(coap_tx_buffer),
        len,
        message.dst_addr,
        message.dst_port
    )

    if result > 0 {
        coap_stats.messages_sent = coap_stats.messages_sent + 1
    }

    return result
}

// Get next message ID
fn coap_get_message_id(): u16 {
    coap_next_message_id = coap_next_message_id + 1
    return coap_next_message_id
}

// Generate random token
fn coap_generate_token(token: u64, len: u8) {
    var ticks: u64 = foundation.timer_get_ticks()
    var i: u32 = 0
    while i < len {
        @intToPtr(token + i, u8) = (ticks >> (i * 8)) & 0xFF
        i = i + 1
    }
}

// Find resource by path
fn coap_find_resource(path: u64, path_len: u8): u32 {
    var i: u32 = 0
    while i < COAP_MAX_RESOURCES {
        if coap_resources[i].active == 1 {
            if coap_resources[i].path_len == path_len {
                var match: u32 = 1
                var j: u32 = 0
                while j < path_len {
                    if coap_resources[i].path[j] != @intToPtr(path + j, u8) {
                        match = 0
                        break
                    }
                    j = j + 1
                }
                if match == 1 {
                    return i
                }
            }
        }
        i = i + 1
    }
    return 0xFFFFFFFF
}

// Send CoAP GET request
export fn coap_get(server_ip: u32, path: u64, callback: u64, user_data: u64): u16 {
    var msg: CoapMessage
    msg.version = COAP_VERSION
    msg.msg_type = COAP_TYPE_CON
    msg.token_len = 4
    msg.code = COAP_GET
    msg.message_id = coap_get_message_id()

    coap_generate_token(@ptrFromInt(msg.token), 4)

    msg.option_count = 0
    msg.payload_len = 0
    msg.dst_addr = server_ip
    msg.dst_port = COAP_PORT

    // Add URI-Path options
    var offset: u32 = 0
    var start: u32 = 0
    if @intToPtr(path, u8) == '/' {
        start = 1
    }

    var i: u32 = start
    while i <= 128 {
        var ch: u8 = @intToPtr(path + i, u8)
        if ch == 0 || ch == '/' {
            if i > start {
                var opt_idx: u32 = msg.option_count
                msg.options[opt_idx].number = COAP_OPT_URI_PATH
                msg.options[opt_idx].length = i - start

                var j: u32 = 0
                while j < (i - start) {
                    msg.options[opt_idx].value[j] = @intToPtr(path + start + j, u8)
                    j = j + 1
                }
                msg.option_count = msg.option_count + 1
            }
            start = i + 1
        }
        if ch == 0 { break }
        i = i + 1
    }

    if coap_send_message(@ptrFromInt(msg)) == 0 {
        return 0
    }

    // Add to pending if callback provided
    if callback != 0 {
        coap_add_pending(msg.message_id, @ptrFromInt(msg.token), 4, server_ip, COAP_PORT, callback, user_data)
    }

    foundation.serial_write_string("[CoAP] GET ")
    foundation.serial_write_string(path)
    foundation.serial_write_string("\n")

    return msg.message_id
}

// Send CoAP POST request
export fn coap_post(server_ip: u32, path: u64, data: u64, length: u32): u16 {
    var msg: CoapMessage
    msg.version = COAP_VERSION
    msg.msg_type = COAP_TYPE_CON
    msg.token_len = 4
    msg.code = COAP_POST
    msg.message_id = coap_get_message_id()

    coap_generate_token(@ptrFromInt(msg.token), 4)

    msg.option_count = 0
    msg.dst_addr = server_ip
    msg.dst_port = COAP_PORT

    // Add URI-Path options
    var start: u32 = 0
    if @intToPtr(path, u8) == '/' {
        start = 1
    }

    var i: u32 = start
    while i <= 128 {
        var ch: u8 = @intToPtr(path + i, u8)
        if ch == 0 || ch == '/' {
            if i > start {
                var opt_idx: u32 = msg.option_count
                msg.options[opt_idx].number = COAP_OPT_URI_PATH
                msg.options[opt_idx].length = i - start

                var j: u32 = 0
                while j < (i - start) {
                    msg.options[opt_idx].value[j] = @intToPtr(path + start + j, u8)
                    j = j + 1
                }
                msg.option_count = msg.option_count + 1
            }
            start = i + 1
        }
        if ch == 0 { break }
        i = i + 1
    }

    // Add Content-Format option
    var cf_idx: u32 = msg.option_count
    msg.options[cf_idx].number = COAP_OPT_CONTENT_FORMAT
    msg.options[cf_idx].length = 1
    msg.options[cf_idx].value[0] = COAP_FMT_OCTET
    msg.option_count = msg.option_count + 1

    // Set payload
    if length > 1024 { length = 1024 }
    msg.payload_len = length
    i = 0
    while i < length {
        msg.payload[i] = @intToPtr(data + i, u8)
        i = i + 1
    }

    if coap_send_message(@ptrFromInt(msg)) == 0 {
        return 0
    }

    foundation.serial_write_string("[CoAP] POST ")
    foundation.serial_write_string(path)
    foundation.serial_write_string("\n")

    return msg.message_id
}

// Send CoAP PUT request
export fn coap_put(server_ip: u32, path: u64, data: u64, length: u32): u16 {
    var msg: CoapMessage
    msg.version = COAP_VERSION
    msg.msg_type = COAP_TYPE_CON
    msg.token_len = 4
    msg.code = COAP_PUT
    msg.message_id = coap_get_message_id()

    coap_generate_token(@ptrFromInt(msg.token), 4)
    msg.option_count = 0
    msg.dst_addr = server_ip
    msg.dst_port = COAP_PORT

    // Add URI-Path and payload similar to POST
    var start: u32 = 0
    if @intToPtr(path, u8) == '/' { start = 1 }

    var i: u32 = start
    while i <= 128 {
        var ch: u8 = @intToPtr(path + i, u8)
        if ch == 0 || ch == '/' {
            if i > start {
                var opt_idx: u32 = msg.option_count
                msg.options[opt_idx].number = COAP_OPT_URI_PATH
                msg.options[opt_idx].length = i - start
                var j: u32 = 0
                while j < (i - start) {
                    msg.options[opt_idx].value[j] = @intToPtr(path + start + j, u8)
                    j = j + 1
                }
                msg.option_count = msg.option_count + 1
            }
            start = i + 1
        }
        if ch == 0 { break }
        i = i + 1
    }

    if length > 1024 { length = 1024 }
    msg.payload_len = length
    i = 0
    while i < length {
        msg.payload[i] = @intToPtr(data + i, u8)
        i = i + 1
    }

    if coap_send_message(@ptrFromInt(msg)) == 0 { return 0 }

    foundation.serial_write_string("[CoAP] PUT ")
    foundation.serial_write_string(path)
    foundation.serial_write_string("\n")

    return msg.message_id
}

// Send CoAP DELETE request
export fn coap_delete(server_ip: u32, path: u64): u16 {
    var msg: CoapMessage
    msg.version = COAP_VERSION
    msg.msg_type = COAP_TYPE_CON
    msg.token_len = 4
    msg.code = COAP_DELETE
    msg.message_id = coap_get_message_id()

    coap_generate_token(@ptrFromInt(msg.token), 4)
    msg.option_count = 0
    msg.payload_len = 0
    msg.dst_addr = server_ip
    msg.dst_port = COAP_PORT

    // Add URI-Path
    var start: u32 = 0
    if @intToPtr(path, u8) == '/' { start = 1 }

    var i: u32 = start
    while i <= 128 {
        var ch: u8 = @intToPtr(path + i, u8)
        if ch == 0 || ch == '/' {
            if i > start {
                var opt_idx: u32 = msg.option_count
                msg.options[opt_idx].number = COAP_OPT_URI_PATH
                msg.options[opt_idx].length = i - start
                var j: u32 = 0
                while j < (i - start) {
                    msg.options[opt_idx].value[j] = @intToPtr(path + start + j, u8)
                    j = j + 1
                }
                msg.option_count = msg.option_count + 1
            }
            start = i + 1
        }
        if ch == 0 { break }
        i = i + 1
    }

    if coap_send_message(@ptrFromInt(msg)) == 0 { return 0 }

    foundation.serial_write_string("[CoAP] DELETE ")
    foundation.serial_write_string(path)
    foundation.serial_write_string("\n")

    return msg.message_id
}

// Add pending request
fn coap_add_pending(message_id: u16, token: u64, token_len: u8, addr: u32, port: u16, callback: u64, user_data: u64) {
    var i: u32 = 0
    while i < COAP_MAX_PENDING {
        if coap_pending[i].active == 0 {
            coap_pending[i].message_id = message_id
            var j: u32 = 0
            while j < token_len {
                coap_pending[i].token[j] = @intToPtr(token + j, u8)
                j = j + 1
            }
            coap_pending[i].token_len = token_len
            coap_pending[i].dst_addr = addr
            coap_pending[i].dst_port = port
            coap_pending[i].retries = 0
            coap_pending[i].timeout = foundation.timer_get_ticks() + COAP_ACK_TIMEOUT_MS
            coap_pending[i].callback = callback
            coap_pending[i].user_data = user_data
            coap_pending[i].active = 1
            coap_pending_count = coap_pending_count + 1
            return
        }
        i = i + 1
    }
}

// Add observer
fn coap_add_observer(msg: u64, resource_idx: u8) {
    var message: CoapMessage = @intToPtr(msg, CoapMessage)

    // Check if already observing
    var i: u32 = 0
    while i < COAP_MAX_OBSERVERS {
        if coap_observers[i].active == 1 {
            if coap_observers[i].addr == message.src_addr {
                if coap_observers[i].resource_idx == resource_idx {
                    // Update token
                    var j: u32 = 0
                    while j < message.token_len {
                        coap_observers[i].token[j] = message.token[j]
                        j = j + 1
                    }
                    coap_observers[i].token_len = message.token_len
                    coap_observers[i].last_seen = foundation.timer_get_ticks()
                    return
                }
            }
        }
        i = i + 1
    }

    // Add new observer
    i = 0
    while i < COAP_MAX_OBSERVERS {
        if coap_observers[i].active == 0 {
            var j: u32 = 0
            while j < message.token_len {
                coap_observers[i].token[j] = message.token[j]
                j = j + 1
            }
            coap_observers[i].token_len = message.token_len
            coap_observers[i].addr = message.src_addr
            coap_observers[i].port = message.src_port
            coap_observers[i].resource_idx = resource_idx
            coap_observers[i].sequence = 0
            coap_observers[i].last_seen = foundation.timer_get_ticks()
            coap_observers[i].active = 1
            coap_observer_count = coap_observer_count + 1
            coap_stats.observers_count = coap_stats.observers_count + 1
            foundation.serial_write_string("[CoAP] Observer added\n")
            return
        }
        i = i + 1
    }
}

// Notify observers of a resource
export fn coap_notify_observers(resource_path: u64, path_len: u8, payload: u64, payload_len: u16): u32 {
    var resource_idx: u32 = coap_find_resource(resource_path, path_len)
    if resource_idx == 0xFFFFFFFF {
        return 0
    }

    var notified: u32 = 0
    var i: u32 = 0
    while i < COAP_MAX_OBSERVERS {
        if coap_observers[i].active == 1 {
            if coap_observers[i].resource_idx == resource_idx {
                coap_observers[i].sequence = coap_observers[i].sequence + 1

                var msg: CoapMessage
                msg.version = COAP_VERSION
                msg.msg_type = COAP_TYPE_NON
                msg.token_len = coap_observers[i].token_len
                msg.code = COAP_RESP_CONTENT
                msg.message_id = coap_get_message_id()

                var j: u32 = 0
                while j < msg.token_len {
                    msg.token[j] = coap_observers[i].token[j]
                    j = j + 1
                }

                // Add Observe option
                msg.option_count = 1
                msg.options[0].number = COAP_OPT_OBSERVE
                var seq: u32 = coap_observers[i].sequence
                if seq < 256 {
                    msg.options[0].length = 1
                    msg.options[0].value[0] = seq & 0xFF
                } else if seq < 65536 {
                    msg.options[0].length = 2
                    msg.options[0].value[0] = (seq >> 8) & 0xFF
                    msg.options[0].value[1] = seq & 0xFF
                } else {
                    msg.options[0].length = 3
                    msg.options[0].value[0] = (seq >> 16) & 0xFF
                    msg.options[0].value[1] = (seq >> 8) & 0xFF
                    msg.options[0].value[2] = seq & 0xFF
                }

                // Set payload
                if payload_len > 1024 { payload_len = 1024 }
                msg.payload_len = payload_len
                j = 0
                while j < payload_len {
                    msg.payload[j] = @intToPtr(payload + j, u8)
                    j = j + 1
                }

                msg.dst_addr = coap_observers[i].addr
                msg.dst_port = coap_observers[i].port

                coap_send_message(@ptrFromInt(msg))
                notified = notified + 1
            }
        }
        i = i + 1
    }

    return notified
}

// Receive and process messages
export fn coap_receive() {
    if coap_initialized == 0 { return }

    var src_addr: u32 = 0
    var src_port: u16 = 0

    var len: u32 = udp.udp_socket_recvfrom(
        coap_socket,
        @ptrFromInt(coap_rx_buffer),
        1500,
        @ptrFromInt(src_addr),
        @ptrFromInt(src_port)
    )

    if len == 0 { return }

    var msg: CoapMessage
    if coap_parse_message(@ptrFromInt(coap_rx_buffer), len, @ptrFromInt(msg)) == 0 {
        return
    }

    msg.src_addr = src_addr
    msg.src_port = src_port

    coap_stats.messages_received = coap_stats.messages_received + 1

    // Handle based on message type
    if msg.msg_type == COAP_TYPE_CON || msg.msg_type == COAP_TYPE_NON {
        coap_handle_request(@ptrFromInt(msg))
    } else if msg.msg_type == COAP_TYPE_ACK {
        coap_handle_ack(@ptrFromInt(msg))
    } else if msg.msg_type == COAP_TYPE_RST {
        coap_handle_rst(@ptrFromInt(msg))
    }
}

// Handle incoming request
fn coap_handle_request(msg_ptr: u64) {
    var msg: CoapMessage = @intToPtr(msg_ptr, CoapMessage)

    // Extract path from options
    var path: [u8; 256]
    var path_len: u8 = 0

    var i: u32 = 0
    while i < msg.option_count {
        if msg.options[i].number == COAP_OPT_URI_PATH {
            if path_len > 0 {
                path[path_len] = '/'
                path_len = path_len + 1
            }
            var j: u32 = 0
            while j < msg.options[i].length {
                path[path_len] = msg.options[i].value[j]
                path_len = path_len + 1
                j = j + 1
            }
        }
        i = i + 1
    }

    // Find resource
    var resource_idx: u32 = coap_find_resource(@ptrFromInt(path), path_len)

    // Prepare response
    var response: CoapMessage
    response.version = COAP_VERSION
    if msg.msg_type == COAP_TYPE_CON {
        response.msg_type = COAP_TYPE_ACK
    } else {
        response.msg_type = COAP_TYPE_NON
    }
    response.token_len = msg.token_len
    response.message_id = msg.message_id
    response.option_count = 0
    response.payload_len = 0

    i = 0
    while i < msg.token_len {
        response.token[i] = msg.token[i]
        i = i + 1
    }

    response.dst_addr = msg.src_addr
    response.dst_port = msg.src_port

    if resource_idx == 0xFFFFFFFF {
        response.code = COAP_RESP_NOT_FOUND
    } else {
        var method_bit: u8 = 1 << (msg.code - 1)
        if (coap_resources[resource_idx].methods & method_bit) == 0 {
            response.code = COAP_RESP_NOT_ALLOWED
        } else {
            // Check for Observe option
            i = 0
            while i < msg.option_count {
                if msg.options[i].number == COAP_OPT_OBSERVE {
                    if msg.options[i].length > 0 {
                        if msg.options[i].value[0] == 0 {
                            // Register observer
                            if coap_resources[resource_idx].observable == 1 {
                                coap_add_observer(msg_ptr, resource_idx)
                            }
                        }
                    }
                    break
                }
                i = i + 1
            }

            // Call handler if exists
            if coap_resources[resource_idx].handler != 0 {
                // Handler would fill in response
                // For now, return CONTENT with empty payload
                response.code = COAP_RESP_CONTENT
            } else {
                response.code = COAP_RESP_CONTENT
            }
        }
    }

    coap_send_message(@ptrFromInt(response))
}

// Handle ACK
fn coap_handle_ack(msg_ptr: u64) {
    var msg: CoapMessage = @intToPtr(msg_ptr, CoapMessage)

    // Find and remove pending request
    var i: u32 = 0
    while i < COAP_MAX_PENDING {
        if coap_pending[i].active == 1 {
            if coap_pending[i].message_id == msg.message_id {
                // Call callback
                if coap_pending[i].callback != 0 {
                    // Would invoke callback here
                }
                coap_pending[i].active = 0
                coap_pending_count = coap_pending_count - 1
                return
            }
        }
        i = i + 1
    }
}

// Handle RST
fn coap_handle_rst(msg_ptr: u64) {
    var msg: CoapMessage = @intToPtr(msg_ptr, CoapMessage)

    // Remove pending
    var i: u32 = 0
    while i < COAP_MAX_PENDING {
        if coap_pending[i].active == 1 {
            if coap_pending[i].message_id == msg.message_id {
                coap_pending[i].active = 0
                coap_pending_count = coap_pending_count - 1
                break
            }
        }
        i = i + 1
    }

    // Remove observer with matching token
    i = 0
    while i < COAP_MAX_OBSERVERS {
        if coap_observers[i].active == 1 {
            if coap_observers[i].addr == msg.src_addr {
                if coap_observers[i].token_len == msg.token_len {
                    var match: u32 = 1
                    var j: u32 = 0
                    while j < msg.token_len {
                        if coap_observers[i].token[j] != msg.token[j] {
                            match = 0
                            break
                        }
                        j = j + 1
                    }
                    if match == 1 {
                        coap_observers[i].active = 0
                        coap_observer_count = coap_observer_count - 1
                        coap_stats.observers_count = coap_stats.observers_count - 1
                    }
                }
            }
        }
        i = i + 1
    }
}

// Process timeouts and retransmissions
export fn coap_process() {
    if coap_initialized == 0 { return }

    var now: u64 = foundation.timer_get_ticks()

    // Process pending requests
    var i: u32 = 0
    while i < COAP_MAX_PENDING {
        if coap_pending[i].active == 1 {
            if now >= coap_pending[i].timeout {
                if coap_pending[i].retries >= COAP_MAX_RETRANSMIT {
                    // Timeout
                    coap_stats.timeouts = coap_stats.timeouts + 1
                    coap_pending[i].active = 0
                    coap_pending_count = coap_pending_count - 1
                } else {
                    // Retransmit
                    coap_pending[i].retries = coap_pending[i].retries + 1
                    coap_pending[i].timeout = now + (COAP_ACK_TIMEOUT_MS << coap_pending[i].retries)
                    coap_stats.retransmissions = coap_stats.retransmissions + 1

                    if coap_pending[i].data_len > 0 {
                        udp.udp_socket_sendto(
                            coap_socket,
                            @ptrFromInt(coap_pending[i].data),
                            coap_pending[i].data_len,
                            coap_pending[i].dst_addr,
                            coap_pending[i].dst_port
                        )
                    }
                }
            }
        }
        i = i + 1
    }

    // Cleanup stale observers (24 hour timeout)
    var observer_timeout: u64 = 86400000
    i = 0
    while i < COAP_MAX_OBSERVERS {
        if coap_observers[i].active == 1 {
            if now - coap_observers[i].last_seen > observer_timeout {
                coap_observers[i].active = 0
                coap_observer_count = coap_observer_count - 1
                coap_stats.observers_count = coap_stats.observers_count - 1
            }
        }
        i = i + 1
    }
}

// Get statistics
export fn coap_get_stats(): u64 {
    return @ptrFromInt(coap_stats)
}

// Shutdown CoAP
export fn coap_shutdown() {
    if coap_initialized == 0 { return }

    udp.udp_socket_close(coap_socket)

    coap_initialized = 0
    foundation.serial_write_string("[CoAP] Shutdown complete\n")
}
