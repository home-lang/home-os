// home-os Kernel - Full TCP/IP Stack
// Complete TCP implementation with state machine, retransmission, and congestion control

import "../core/foundation.home" as foundation
import "../core/memory.home" as memory
import "../drivers/e1000.home" as e1000

// ============================================================================
// CONSTANTS
// ============================================================================

const IP_PROTO_ICMP: u8 = 1
const IP_PROTO_TCP: u8 = 6
const IP_PROTO_UDP: u8 = 17

// TCP Flags
const TCP_FIN: u8 = 0x01
const TCP_SYN: u8 = 0x02
const TCP_RST: u8 = 0x04
const TCP_PSH: u8 = 0x08
const TCP_ACK: u8 = 0x10
const TCP_URG: u8 = 0x20
const TCP_ECE: u8 = 0x40
const TCP_CWR: u8 = 0x80

// TCP States (RFC 793)
const TCP_STATE_CLOSED: u32 = 0
const TCP_STATE_LISTEN: u32 = 1
const TCP_STATE_SYN_SENT: u32 = 2
const TCP_STATE_SYN_RECEIVED: u32 = 3
const TCP_STATE_ESTABLISHED: u32 = 4
const TCP_STATE_FIN_WAIT_1: u32 = 5
const TCP_STATE_FIN_WAIT_2: u32 = 6
const TCP_STATE_CLOSE_WAIT: u32 = 7
const TCP_STATE_CLOSING: u32 = 8
const TCP_STATE_LAST_ACK: u32 = 9
const TCP_STATE_TIME_WAIT: u32 = 10

// TCP Options
const TCP_OPT_END: u8 = 0
const TCP_OPT_NOP: u8 = 1
const TCP_OPT_MSS: u8 = 2
const TCP_OPT_WINDOW_SCALE: u8 = 3
const TCP_OPT_SACK_PERMITTED: u8 = 4
const TCP_OPT_SACK: u8 = 5
const TCP_OPT_TIMESTAMP: u8 = 8

// Configuration
const MAX_TCP_CONNECTIONS: u32 = 256
const TCP_MSS: u32 = 1460
const TCP_WINDOW_SIZE: u32 = 65535
const TCP_MAX_RETRIES: u32 = 5
const TCP_INITIAL_RTO: u32 = 1000      // 1 second in ms
const TCP_MIN_RTO: u32 = 200           // 200ms
const TCP_MAX_RTO: u32 = 60000         // 60 seconds
const TCP_TIME_WAIT_TIMEOUT: u32 = 120000  // 2 minutes (2MSL)
const TCP_KEEPALIVE_IDLE: u32 = 7200000    // 2 hours
const TCP_KEEPALIVE_INTERVAL: u32 = 75000  // 75 seconds
const TCP_KEEPALIVE_COUNT: u32 = 9

// Congestion control
const TCP_INITIAL_CWND: u32 = 10       // Initial congestion window (segments)
const TCP_INITIAL_SSTHRESH: u32 = 65535

// ============================================================================
// DATA STRUCTURES
// ============================================================================

struct EthHeader {
  dst_mac: [u8; 6],
  src_mac: [u8; 6],
  ethertype: u16
}

struct IPHeader {
  version_ihl: u8,
  tos: u8,
  total_length: u16,
  id: u16,
  flags_offset: u16,
  ttl: u8,
  protocol: u8,
  checksum: u16,
  src_ip: u32,
  dst_ip: u32
}

struct TCPHeader {
  src_port: u16,
  dst_port: u16,
  seq_num: u32,
  ack_num: u32,
  data_offset: u8,   // Upper 4 bits = offset in 32-bit words
  flags: u8,
  window: u16,
  checksum: u16,
  urgent_ptr: u16
}

// Segment in retransmission queue
struct TcpSegment {
  seq_num: u32,
  data: u64,
  data_len: u32,
  flags: u8,
  retries: u32,
  sent_time: u64,
  next: u64
}

// TCP Control Block (TCB)
struct TcpConnection {
  id: u32,
  state: u32,

  // Local and remote addresses
  local_ip: u32,
  local_port: u16,
  remote_ip: u32,
  remote_port: u16,

  // Sequence numbers
  snd_una: u32,      // Send unacknowledged
  snd_nxt: u32,      // Send next
  snd_wnd: u32,      // Send window
  snd_wl1: u32,      // Segment seq used for last window update
  snd_wl2: u32,      // Segment ack used for last window update
  iss: u32,          // Initial send sequence number

  rcv_nxt: u32,      // Receive next
  rcv_wnd: u32,      // Receive window
  irs: u32,          // Initial receive sequence number

  // MSS negotiated
  snd_mss: u32,
  rcv_mss: u32,

  // Window scaling
  snd_scale: u8,
  rcv_scale: u8,

  // Congestion control
  cwnd: u32,         // Congestion window
  ssthresh: u32,     // Slow start threshold

  // RTT estimation (Jacobson/Karels algorithm)
  srtt: u32,         // Smoothed RTT (in ms * 8)
  rttvar: u32,       // RTT variance (in ms * 4)
  rto: u32,          // Retransmission timeout (ms)

  // Timers
  retransmit_timer: u64,
  time_wait_timer: u64,
  keepalive_timer: u64,
  persist_timer: u64,

  // Retransmission queue
  retx_queue_head: u64,
  retx_queue_tail: u64,

  // Receive buffer
  recv_buffer: u64,
  recv_buffer_size: u32,
  recv_buffer_used: u32,

  // Send buffer
  send_buffer: u64,
  send_buffer_size: u32,
  send_buffer_used: u32,

  // Flags
  keepalive_enabled: u32,
  nagle_enabled: u32,

  // Statistics
  bytes_sent: u64,
  bytes_received: u64,
  segments_sent: u64,
  segments_received: u64,
  retransmissions: u64
}

struct TcpStats {
  active_connections: u32,
  passive_opens: u64,
  active_opens: u64,
  failed_attempts: u64,
  resets_received: u64,
  resets_sent: u64,
  segments_sent: u64,
  segments_received: u64,
  retransmissions: u64,
  checksum_errors: u64
}

// ============================================================================
// GLOBAL STATE
// ============================================================================

var tcp_connections: [TcpConnection; 256]
var tcp_connection_count: u32 = 0
var tcp_stats: TcpStats
var tcp_initialized: u32 = 0

var local_ip: u32 = 0x0A000002   // 10.0.0.2
var gateway_ip: u32 = 0x0A000001 // 10.0.0.1
var local_mac: [u8; 6]

var ip_id_counter: u16 = 0
var tcp_port_counter: u16 = 49152  // Ephemeral port range start

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

fn get_timestamp(): u64 {
  // Get current timestamp in milliseconds
  // In real implementation, read from system timer
  return foundation.get_ticks()
}

fn generate_isn(): u32 {
  // Generate Initial Sequence Number
  // RFC 6528 recommends using a pseudo-random generator
  var timestamp: u64 = get_timestamp()
  var isn: u32 = (timestamp * 250000) & 0xFFFFFFFF
  return isn
}

fn allocate_ephemeral_port(): u16 {
  var port: u16 = tcp_port_counter
  tcp_port_counter = tcp_port_counter + 1
  if tcp_port_counter >= 65535 {
    tcp_port_counter = 49152
  }
  return port
}

// ============================================================================
// CHECKSUM CALCULATION
// ============================================================================

fn ip_checksum(data: u64, len: u32): u16 {
  var sum: u32 = 0
  var ptr: *u8 = @ptrFromInt(data)
  var i: u32 = 0

  while i < len - 1 {
    var word: u16 = (ptr[i] << 8) | ptr[i + 1]
    sum = sum + word
    i = i + 2
  }

  if i < len {
    sum = sum + (ptr[i] << 8)
  }

  while (sum >> 16) != 0 {
    sum = (sum & 0xFFFF) + (sum >> 16)
  }

  return (~sum) & 0xFFFF
}

fn tcp_checksum(src_ip: u32, dst_ip: u32, tcp_data: u64, tcp_len: u32): u16 {
  var sum: u32 = 0

  // Pseudo-header
  sum = sum + ((src_ip >> 16) & 0xFFFF)
  sum = sum + (src_ip & 0xFFFF)
  sum = sum + ((dst_ip >> 16) & 0xFFFF)
  sum = sum + (dst_ip & 0xFFFF)
  sum = sum + IP_PROTO_TCP
  sum = sum + tcp_len

  // TCP header + data
  var ptr: *u8 = @ptrFromInt(tcp_data)
  var i: u32 = 0
  while i < tcp_len - 1 {
    var word: u16 = (ptr[i] << 8) | ptr[i + 1]
    sum = sum + word
    i = i + 2
  }

  if i < tcp_len {
    sum = sum + (ptr[i] << 8)
  }

  while (sum >> 16) != 0 {
    sum = (sum & 0xFFFF) + (sum >> 16)
  }

  return (~sum) & 0xFFFF
}

// ============================================================================
// CONNECTION MANAGEMENT
// ============================================================================

fn find_connection(local_port: u16, remote_ip: u32, remote_port: u16): u32 {
  var i: u32 = 0
  while i < MAX_TCP_CONNECTIONS {
    if tcp_connections[i].state != TCP_STATE_CLOSED {
      if tcp_connections[i].local_port == local_port and
         tcp_connections[i].remote_ip == remote_ip and
         tcp_connections[i].remote_port == remote_port {
        return i
      }
    }
    i = i + 1
  }
  return 0xFFFFFFFF
}

fn find_listening_connection(local_port: u16): u32 {
  var i: u32 = 0
  while i < MAX_TCP_CONNECTIONS {
    if tcp_connections[i].state == TCP_STATE_LISTEN and
       tcp_connections[i].local_port == local_port {
      return i
    }
    i = i + 1
  }
  return 0xFFFFFFFF
}

fn allocate_connection(): u32 {
  var i: u32 = 0
  while i < MAX_TCP_CONNECTIONS {
    if tcp_connections[i].state == TCP_STATE_CLOSED {
      return i
    }
    i = i + 1
  }
  return 0xFFFFFFFF
}

fn init_connection(conn_idx: u32) {
  tcp_connections[conn_idx].id = conn_idx
  tcp_connections[conn_idx].state = TCP_STATE_CLOSED
  tcp_connections[conn_idx].snd_mss = TCP_MSS
  tcp_connections[conn_idx].rcv_mss = TCP_MSS
  tcp_connections[conn_idx].rcv_wnd = TCP_WINDOW_SIZE
  tcp_connections[conn_idx].cwnd = TCP_INITIAL_CWND * TCP_MSS
  tcp_connections[conn_idx].ssthresh = TCP_INITIAL_SSTHRESH
  tcp_connections[conn_idx].rto = TCP_INITIAL_RTO
  tcp_connections[conn_idx].nagle_enabled = 1
  tcp_connections[conn_idx].keepalive_enabled = 0
  tcp_connections[conn_idx].snd_scale = 0
  tcp_connections[conn_idx].rcv_scale = 0

  // Allocate buffers
  tcp_connections[conn_idx].recv_buffer = memory.kmalloc(65536)
  tcp_connections[conn_idx].recv_buffer_size = 65536
  tcp_connections[conn_idx].recv_buffer_used = 0

  tcp_connections[conn_idx].send_buffer = memory.kmalloc(65536)
  tcp_connections[conn_idx].send_buffer_size = 65536
  tcp_connections[conn_idx].send_buffer_used = 0

  tcp_connections[conn_idx].retx_queue_head = 0
  tcp_connections[conn_idx].retx_queue_tail = 0
}

fn free_connection(conn_idx: u32) {
  // Free retransmission queue
  var seg: u64 = tcp_connections[conn_idx].retx_queue_head
  while seg != 0 {
    var next: u64 = @intToPtr(seg + 24, u64)  // next pointer
    var data: u64 = @intToPtr(seg + 8, u64)
    if data != 0 {
      memory.kfree(data)
    }
    memory.kfree(seg)
    seg = next
  }

  // Free buffers
  if tcp_connections[conn_idx].recv_buffer != 0 {
    memory.kfree(tcp_connections[conn_idx].recv_buffer)
  }
  if tcp_connections[conn_idx].send_buffer != 0 {
    memory.kfree(tcp_connections[conn_idx].send_buffer)
  }

  tcp_connections[conn_idx].state = TCP_STATE_CLOSED
  tcp_connections[conn_idx].retx_queue_head = 0
  tcp_connections[conn_idx].retx_queue_tail = 0
}

// ============================================================================
// PACKET BUILDING AND SENDING
// ============================================================================

fn build_tcp_packet(conn_idx: u32, flags: u8, data: u64, data_len: u32, packet: u64): u32 {
  var pkt: *u8 = @ptrFromInt(packet)
  var offset: u32 = 0

  // Ethernet header (14 bytes)
  var i: u32 = 0
  while i < 6 {
    pkt[offset + i] = 0xFF  // Broadcast MAC (would use ARP in real implementation)
    i = i + 1
  }
  offset = offset + 6

  // Source MAC
  e1000.e1000_get_mac_address(packet + offset)
  offset = offset + 6

  // EtherType (IPv4)
  pkt[offset] = 0x08
  pkt[offset + 1] = 0x00
  offset = offset + 2

  // IP header (20 bytes)
  var ip_start: u32 = offset
  pkt[offset] = 0x45          // Version 4, IHL 5
  pkt[offset + 1] = 0         // TOS

  var tcp_header_len: u32 = 20
  if (flags & TCP_SYN) != 0 {
    tcp_header_len = 24  // With MSS option
  }
  var total_len: u16 = 20 + tcp_header_len + data_len
  pkt[offset + 2] = (total_len >> 8) & 0xFF
  pkt[offset + 3] = total_len & 0xFF

  pkt[offset + 4] = (ip_id_counter >> 8) & 0xFF
  pkt[offset + 5] = ip_id_counter & 0xFF
  ip_id_counter = ip_id_counter + 1

  pkt[offset + 6] = 0x40      // Don't fragment
  pkt[offset + 7] = 0
  pkt[offset + 8] = 64        // TTL
  pkt[offset + 9] = IP_PROTO_TCP
  pkt[offset + 10] = 0        // Checksum (fill later)
  pkt[offset + 11] = 0

  // Source IP
  pkt[offset + 12] = (tcp_connections[conn_idx].local_ip >> 24) & 0xFF
  pkt[offset + 13] = (tcp_connections[conn_idx].local_ip >> 16) & 0xFF
  pkt[offset + 14] = (tcp_connections[conn_idx].local_ip >> 8) & 0xFF
  pkt[offset + 15] = tcp_connections[conn_idx].local_ip & 0xFF

  // Destination IP
  pkt[offset + 16] = (tcp_connections[conn_idx].remote_ip >> 24) & 0xFF
  pkt[offset + 17] = (tcp_connections[conn_idx].remote_ip >> 16) & 0xFF
  pkt[offset + 18] = (tcp_connections[conn_idx].remote_ip >> 8) & 0xFF
  pkt[offset + 19] = tcp_connections[conn_idx].remote_ip & 0xFF

  // Calculate IP checksum
  var ip_csum: u16 = ip_checksum(packet + ip_start, 20)
  pkt[ip_start + 10] = (ip_csum >> 8) & 0xFF
  pkt[ip_start + 11] = ip_csum & 0xFF

  offset = offset + 20

  // TCP header
  var tcp_start: u32 = offset

  // Source port
  pkt[offset] = (tcp_connections[conn_idx].local_port >> 8) & 0xFF
  pkt[offset + 1] = tcp_connections[conn_idx].local_port & 0xFF

  // Destination port
  pkt[offset + 2] = (tcp_connections[conn_idx].remote_port >> 8) & 0xFF
  pkt[offset + 3] = tcp_connections[conn_idx].remote_port & 0xFF

  // Sequence number
  var seq: u32 = tcp_connections[conn_idx].snd_nxt
  pkt[offset + 4] = (seq >> 24) & 0xFF
  pkt[offset + 5] = (seq >> 16) & 0xFF
  pkt[offset + 6] = (seq >> 8) & 0xFF
  pkt[offset + 7] = seq & 0xFF

  // Acknowledgment number
  var ack: u32 = tcp_connections[conn_idx].rcv_nxt
  pkt[offset + 8] = (ack >> 24) & 0xFF
  pkt[offset + 9] = (ack >> 16) & 0xFF
  pkt[offset + 10] = (ack >> 8) & 0xFF
  pkt[offset + 11] = ack & 0xFF

  // Data offset (header length in 32-bit words) and flags
  var data_off: u8 = (tcp_header_len / 4) << 4
  pkt[offset + 12] = data_off
  pkt[offset + 13] = flags

  // Window size
  var wnd: u16 = tcp_connections[conn_idx].rcv_wnd >> tcp_connections[conn_idx].rcv_scale
  if wnd > 65535 { wnd = 65535 }
  pkt[offset + 14] = (wnd >> 8) & 0xFF
  pkt[offset + 15] = wnd & 0xFF

  // Checksum (fill later)
  pkt[offset + 16] = 0
  pkt[offset + 17] = 0

  // Urgent pointer
  pkt[offset + 18] = 0
  pkt[offset + 19] = 0

  offset = offset + 20

  // TCP Options (MSS for SYN)
  if (flags & TCP_SYN) != 0 {
    pkt[offset] = TCP_OPT_MSS
    pkt[offset + 1] = 4
    pkt[offset + 2] = (TCP_MSS >> 8) & 0xFF
    pkt[offset + 3] = TCP_MSS & 0xFF
    offset = offset + 4
  }

  // Copy data
  if data != 0 and data_len > 0 {
    var src: *u8 = @ptrFromInt(data)
    i = 0
    while i < data_len {
      pkt[offset + i] = src[i]
      i = i + 1
    }
    offset = offset + data_len
  }

  // Calculate TCP checksum
  var tcp_len: u32 = tcp_header_len + data_len
  var tcp_csum: u16 = tcp_checksum(
    tcp_connections[conn_idx].local_ip,
    tcp_connections[conn_idx].remote_ip,
    packet + tcp_start,
    tcp_len
  )
  pkt[tcp_start + 16] = (tcp_csum >> 8) & 0xFF
  pkt[tcp_start + 17] = tcp_csum & 0xFF

  return offset
}

fn send_tcp_segment(conn_idx: u32, flags: u8, data: u64, data_len: u32): u32 {
  var packet: [u8; 1600]
  var pkt_len: u32 = build_tcp_packet(conn_idx, flags, data, data_len, @ptrFromInt(&packet))

  var result: u32 = e1000.e1000_send_packet(@ptrFromInt(&packet), pkt_len)

  if result != 0 {
    tcp_connections[conn_idx].segments_sent = tcp_connections[conn_idx].segments_sent + 1
    tcp_stats.segments_sent = tcp_stats.segments_sent + 1

    // Update snd_nxt for data-carrying segments
    if data_len > 0 {
      tcp_connections[conn_idx].snd_nxt = tcp_connections[conn_idx].snd_nxt + data_len
    }
    if (flags & TCP_SYN) != 0 or (flags & TCP_FIN) != 0 {
      tcp_connections[conn_idx].snd_nxt = tcp_connections[conn_idx].snd_nxt + 1
    }
  }

  return result
}

// ============================================================================
// RETRANSMISSION QUEUE
// ============================================================================

fn add_to_retx_queue(conn_idx: u32, seq: u32, data: u64, data_len: u32, flags: u8) {
  var seg: u64 = memory.kmalloc(32)  // TcpSegment size
  if seg == 0 { return }

  @ptrToInt(seg, u32) = seq           // seq_num

  // Copy data
  var data_copy: u64 = 0
  if data_len > 0 {
    data_copy = memory.kmalloc(data_len)
    if data_copy != 0 {
      var src: *u8 = @ptrFromInt(data)
      var dst: *u8 = @ptrFromInt(data_copy)
      var i: u32 = 0
      while i < data_len {
        dst[i] = src[i]
        i = i + 1
      }
    }
  }

  @ptrToInt(seg + 8, u64) = data_copy   // data pointer
  @ptrToInt(seg + 16, u32) = data_len   // data_len
  @ptrToInt(seg + 20, u8) = flags       // flags
  @ptrToInt(seg + 21, u32) = 0          // retries
  @ptrToInt(seg + 25, u64) = get_timestamp()  // sent_time
  @ptrToInt(seg + 33, u64) = 0          // next

  // Add to queue
  if tcp_connections[conn_idx].retx_queue_tail == 0 {
    tcp_connections[conn_idx].retx_queue_head = seg
    tcp_connections[conn_idx].retx_queue_tail = seg
  } else {
    @ptrToInt(tcp_connections[conn_idx].retx_queue_tail + 33, u64) = seg
    tcp_connections[conn_idx].retx_queue_tail = seg
  }

  // Start retransmit timer if not running
  if tcp_connections[conn_idx].retransmit_timer == 0 {
    tcp_connections[conn_idx].retransmit_timer = get_timestamp() + tcp_connections[conn_idx].rto
  }
}

fn process_ack(conn_idx: u32, ack_num: u32) {
  // Remove acknowledged segments from retx queue
  var prev: u64 = 0
  var seg: u64 = tcp_connections[conn_idx].retx_queue_head

  while seg != 0 {
    var seg_seq: u32 = @intToPtr(seg, u32)
    var seg_len: u32 = @intToPtr(seg + 16, u32)
    var seg_flags: u8 = @intToPtr(seg + 20, u8)
    var next: u64 = @intToPtr(seg + 33, u64)

    // Calculate end sequence
    var seg_end: u32 = seg_seq + seg_len
    if (seg_flags & TCP_SYN) != 0 or (seg_flags & TCP_FIN) != 0 {
      seg_end = seg_end + 1
    }

    // Check if fully acknowledged
    if seq_before_eq(seg_end, ack_num) {
      // Update RTT estimation
      var sent_time: u64 = @intToPtr(seg + 25, u64)
      var retries: u32 = @intToPtr(seg + 21, u32)
      if retries == 0 {
        update_rtt(conn_idx, get_timestamp() - sent_time)
      }

      // Remove from queue
      if prev == 0 {
        tcp_connections[conn_idx].retx_queue_head = next
      } else {
        @ptrToInt(prev + 33, u64) = next
      }

      if next == 0 {
        tcp_connections[conn_idx].retx_queue_tail = prev
      }

      // Free segment
      var seg_data: u64 = @intToPtr(seg + 8, u64)
      if seg_data != 0 {
        memory.kfree(seg_data)
      }
      memory.kfree(seg)

      seg = next
    } else {
      prev = seg
      seg = next
    }
  }

  // Reset retransmit timer if queue is empty
  if tcp_connections[conn_idx].retx_queue_head == 0 {
    tcp_connections[conn_idx].retransmit_timer = 0
  } else {
    tcp_connections[conn_idx].retransmit_timer = get_timestamp() + tcp_connections[conn_idx].rto
  }

  // Update snd_una
  tcp_connections[conn_idx].snd_una = ack_num
}

fn retransmit_segment(conn_idx: u32, seg: u64) {
  var seg_seq: u32 = @intToPtr(seg, u32)
  var seg_data: u64 = @intToPtr(seg + 8, u64)
  var seg_len: u32 = @intToPtr(seg + 16, u32)
  var seg_flags: u8 = @intToPtr(seg + 20, u8)
  var retries: u32 = @intToPtr(seg + 21, u32)

  // Temporarily set snd_nxt for retransmission
  var saved_snd_nxt: u32 = tcp_connections[conn_idx].snd_nxt
  tcp_connections[conn_idx].snd_nxt = seg_seq

  send_tcp_segment(conn_idx, seg_flags, seg_data, seg_len)

  tcp_connections[conn_idx].snd_nxt = saved_snd_nxt

  // Update retries
  @ptrToInt(seg + 21, u32) = retries + 1
  @ptrToInt(seg + 25, u64) = get_timestamp()

  tcp_connections[conn_idx].retransmissions = tcp_connections[conn_idx].retransmissions + 1
  tcp_stats.retransmissions = tcp_stats.retransmissions + 1
}

// ============================================================================
// RTT AND CONGESTION CONTROL
// ============================================================================

fn seq_before(a: u32, b: u32): u32 {
  return ((a - b) & 0x80000000) != 0
}

fn seq_before_eq(a: u32, b: u32): u32 {
  return a == b or seq_before(a, b) != 0
}

fn update_rtt(conn_idx: u32, rtt_sample: u64) {
  // Jacobson/Karels algorithm
  var sample: u32 = rtt_sample
  if sample > 60000 { sample = 60000 }  // Cap at 60 seconds

  if tcp_connections[conn_idx].srtt == 0 {
    // First measurement
    tcp_connections[conn_idx].srtt = sample << 3       // SRTT = R
    tcp_connections[conn_idx].rttvar = sample << 1     // RTTVAR = R/2
  } else {
    // Subsequent measurements
    var delta: i32 = sample - (tcp_connections[conn_idx].srtt >> 3)
    tcp_connections[conn_idx].srtt = tcp_connections[conn_idx].srtt + delta

    if delta < 0 { delta = -delta }
    tcp_connections[conn_idx].rttvar = tcp_connections[conn_idx].rttvar +
                                       (delta - (tcp_connections[conn_idx].rttvar >> 2))
  }

  // RTO = SRTT + 4*RTTVAR
  var rto: u32 = (tcp_connections[conn_idx].srtt >> 3) + tcp_connections[conn_idx].rttvar
  if rto < TCP_MIN_RTO { rto = TCP_MIN_RTO }
  if rto > TCP_MAX_RTO { rto = TCP_MAX_RTO }
  tcp_connections[conn_idx].rto = rto
}

fn congestion_event(conn_idx: u32) {
  // Multiplicative decrease
  tcp_connections[conn_idx].ssthresh = tcp_connections[conn_idx].cwnd / 2
  if tcp_connections[conn_idx].ssthresh < 2 * TCP_MSS {
    tcp_connections[conn_idx].ssthresh = 2 * TCP_MSS
  }
  tcp_connections[conn_idx].cwnd = TCP_MSS
}

fn update_cwnd(conn_idx: u32, bytes_acked: u32) {
  if tcp_connections[conn_idx].cwnd < tcp_connections[conn_idx].ssthresh {
    // Slow start: increase cwnd by 1 MSS per ACK
    tcp_connections[conn_idx].cwnd = tcp_connections[conn_idx].cwnd + TCP_MSS
  } else {
    // Congestion avoidance: increase cwnd by MSS^2/cwnd per ACK
    var inc: u32 = (TCP_MSS * TCP_MSS) / tcp_connections[conn_idx].cwnd
    if inc < 1 { inc = 1 }
    tcp_connections[conn_idx].cwnd = tcp_connections[conn_idx].cwnd + inc
  }
}

// ============================================================================
// TIMER PROCESSING
// ============================================================================

fn process_timers(conn_idx: u32) {
  var now: u64 = get_timestamp()

  // Retransmit timer
  if tcp_connections[conn_idx].retransmit_timer != 0 and
     now >= tcp_connections[conn_idx].retransmit_timer {

    var seg: u64 = tcp_connections[conn_idx].retx_queue_head
    if seg != 0 {
      var retries: u32 = @intToPtr(seg + 21, u32)

      if retries >= TCP_MAX_RETRIES {
        // Connection failed
        foundation.serial_write_string("[TCP] Max retries exceeded, closing connection\n")
        tcp_connections[conn_idx].state = TCP_STATE_CLOSED
        free_connection(conn_idx)
        return
      }

      // Exponential backoff
      tcp_connections[conn_idx].rto = tcp_connections[conn_idx].rto * 2
      if tcp_connections[conn_idx].rto > TCP_MAX_RTO {
        tcp_connections[conn_idx].rto = TCP_MAX_RTO
      }

      // Congestion control: treat timeout as congestion
      congestion_event(conn_idx)

      // Retransmit
      retransmit_segment(conn_idx, seg)

      // Reset timer
      tcp_connections[conn_idx].retransmit_timer = now + tcp_connections[conn_idx].rto
    }
  }

  // TIME_WAIT timer
  if tcp_connections[conn_idx].state == TCP_STATE_TIME_WAIT and
     tcp_connections[conn_idx].time_wait_timer != 0 and
     now >= tcp_connections[conn_idx].time_wait_timer {
    tcp_connections[conn_idx].state = TCP_STATE_CLOSED
    free_connection(conn_idx)
  }

  // Keep-alive timer
  if tcp_connections[conn_idx].keepalive_enabled == 1 and
     tcp_connections[conn_idx].state == TCP_STATE_ESTABLISHED and
     tcp_connections[conn_idx].keepalive_timer != 0 and
     now >= tcp_connections[conn_idx].keepalive_timer {
    // Send keep-alive probe (ACK with seq = snd_una - 1)
    var saved_nxt: u32 = tcp_connections[conn_idx].snd_nxt
    tcp_connections[conn_idx].snd_nxt = tcp_connections[conn_idx].snd_una - 1
    send_tcp_segment(conn_idx, TCP_ACK, 0, 0)
    tcp_connections[conn_idx].snd_nxt = saved_nxt

    tcp_connections[conn_idx].keepalive_timer = now + TCP_KEEPALIVE_INTERVAL
  }
}

// ============================================================================
// PACKET RECEPTION
// ============================================================================

fn parse_tcp_options(conn_idx: u32, options: u64, options_len: u32) {
  var ptr: *u8 = @ptrFromInt(options)
  var i: u32 = 0

  while i < options_len {
    var opt_type: u8 = ptr[i]

    if opt_type == TCP_OPT_END {
      break
    }

    if opt_type == TCP_OPT_NOP {
      i = i + 1
      continue
    }

    var opt_len: u8 = ptr[i + 1]
    if opt_len < 2 or i + opt_len > options_len {
      break
    }

    if opt_type == TCP_OPT_MSS and opt_len == 4 {
      var mss: u16 = (ptr[i + 2] << 8) | ptr[i + 3]
      tcp_connections[conn_idx].snd_mss = mss
    } else if opt_type == TCP_OPT_WINDOW_SCALE and opt_len == 3 {
      tcp_connections[conn_idx].snd_scale = ptr[i + 2]
      if tcp_connections[conn_idx].snd_scale > 14 {
        tcp_connections[conn_idx].snd_scale = 14
      }
    }

    i = i + opt_len
  }
}

fn handle_tcp_packet(src_ip: u32, tcp_data: u64, tcp_len: u32) {
  var ptr: *u8 = @ptrFromInt(tcp_data)

  // Parse TCP header
  var src_port: u16 = (ptr[0] << 8) | ptr[1]
  var dst_port: u16 = (ptr[2] << 8) | ptr[3]
  var seq_num: u32 = (ptr[4] << 24) | (ptr[5] << 16) | (ptr[6] << 8) | ptr[7]
  var ack_num: u32 = (ptr[8] << 24) | (ptr[9] << 16) | (ptr[10] << 8) | ptr[11]
  var data_offset: u8 = (ptr[12] >> 4) * 4
  var flags: u8 = ptr[13]
  var window: u16 = (ptr[14] << 8) | ptr[15]

  tcp_stats.segments_received = tcp_stats.segments_received + 1

  // Find connection
  var conn_idx: u32 = find_connection(dst_port, src_ip, src_port)

  // Handle SYN to listening socket
  if conn_idx == 0xFFFFFFFF and (flags & TCP_SYN) != 0 {
    var listen_idx: u32 = find_listening_connection(dst_port)
    if listen_idx != 0xFFFFFFFF {
      // Create new connection for incoming SYN
      conn_idx = allocate_connection()
      if conn_idx != 0xFFFFFFFF {
        init_connection(conn_idx)
        tcp_connections[conn_idx].local_ip = local_ip
        tcp_connections[conn_idx].local_port = dst_port
        tcp_connections[conn_idx].remote_ip = src_ip
        tcp_connections[conn_idx].remote_port = src_port
        tcp_connections[conn_idx].state = TCP_STATE_LISTEN
        tcp_stats.passive_opens = tcp_stats.passive_opens + 1
      }
    }
  }

  if conn_idx == 0xFFFFFFFF {
    // No connection found, send RST
    return
  }

  tcp_connections[conn_idx].segments_received = tcp_connections[conn_idx].segments_received + 1

  // Parse options if present
  if data_offset > 20 {
    parse_tcp_options(conn_idx, tcp_data + 20, data_offset - 20)
  }

  // Update window
  tcp_connections[conn_idx].snd_wnd = window << tcp_connections[conn_idx].snd_scale

  // Handle RST
  if (flags & TCP_RST) != 0 {
    tcp_connections[conn_idx].state = TCP_STATE_CLOSED
    free_connection(conn_idx)
    tcp_stats.resets_received = tcp_stats.resets_received + 1
    return
  }

  // State machine
  var state: u32 = tcp_connections[conn_idx].state

  if state == TCP_STATE_LISTEN {
    if (flags & TCP_SYN) != 0 {
      // Received SYN
      tcp_connections[conn_idx].irs = seq_num
      tcp_connections[conn_idx].rcv_nxt = seq_num + 1
      tcp_connections[conn_idx].iss = generate_isn()
      tcp_connections[conn_idx].snd_nxt = tcp_connections[conn_idx].iss
      tcp_connections[conn_idx].snd_una = tcp_connections[conn_idx].iss

      // Send SYN-ACK
      send_tcp_segment(conn_idx, TCP_SYN | TCP_ACK, 0, 0)
      add_to_retx_queue(conn_idx, tcp_connections[conn_idx].iss, 0, 0, TCP_SYN | TCP_ACK)

      tcp_connections[conn_idx].state = TCP_STATE_SYN_RECEIVED
    }
  } else if state == TCP_STATE_SYN_SENT {
    if (flags & TCP_SYN) != 0 and (flags & TCP_ACK) != 0 {
      // Received SYN-ACK
      tcp_connections[conn_idx].irs = seq_num
      tcp_connections[conn_idx].rcv_nxt = seq_num + 1

      // Process ACK
      process_ack(conn_idx, ack_num)

      // Send ACK
      send_tcp_segment(conn_idx, TCP_ACK, 0, 0)

      tcp_connections[conn_idx].state = TCP_STATE_ESTABLISHED
      tcp_stats.active_connections = tcp_stats.active_connections + 1

      foundation.serial_write_string("[TCP] Connection established\n")
    } else if (flags & TCP_SYN) != 0 {
      // Simultaneous open
      tcp_connections[conn_idx].irs = seq_num
      tcp_connections[conn_idx].rcv_nxt = seq_num + 1

      send_tcp_segment(conn_idx, TCP_SYN | TCP_ACK, 0, 0)
      tcp_connections[conn_idx].state = TCP_STATE_SYN_RECEIVED
    }
  } else if state == TCP_STATE_SYN_RECEIVED {
    if (flags & TCP_ACK) != 0 {
      process_ack(conn_idx, ack_num)
      tcp_connections[conn_idx].state = TCP_STATE_ESTABLISHED
      tcp_stats.active_connections = tcp_stats.active_connections + 1
      foundation.serial_write_string("[TCP] Connection established (server)\n")
    }
  } else if state == TCP_STATE_ESTABLISHED {
    // Process ACK
    if (flags & TCP_ACK) != 0 {
      if seq_before(tcp_connections[conn_idx].snd_una, ack_num) != 0 and
         seq_before_eq(ack_num, tcp_connections[conn_idx].snd_nxt) != 0 {
        var bytes_acked: u32 = ack_num - tcp_connections[conn_idx].snd_una
        update_cwnd(conn_idx, bytes_acked)
        process_ack(conn_idx, ack_num)
      }
    }

    // Process data
    var data_start: u32 = data_offset
    var data_len: u32 = tcp_len - data_offset

    if data_len > 0 and seq_num == tcp_connections[conn_idx].rcv_nxt {
      // Copy data to receive buffer
      var space: u32 = tcp_connections[conn_idx].recv_buffer_size -
                       tcp_connections[conn_idx].recv_buffer_used
      if data_len > space { data_len = space }

      var dst: *u8 = @ptrFromInt(tcp_connections[conn_idx].recv_buffer +
                                  tcp_connections[conn_idx].recv_buffer_used)
      var src: *u8 = @ptrFromInt(tcp_data + data_start)
      var i: u32 = 0
      while i < data_len {
        dst[i] = src[i]
        i = i + 1
      }

      tcp_connections[conn_idx].recv_buffer_used = tcp_connections[conn_idx].recv_buffer_used + data_len
      tcp_connections[conn_idx].rcv_nxt = tcp_connections[conn_idx].rcv_nxt + data_len
      tcp_connections[conn_idx].bytes_received = tcp_connections[conn_idx].bytes_received + data_len

      // Update receive window
      tcp_connections[conn_idx].rcv_wnd = tcp_connections[conn_idx].recv_buffer_size -
                                          tcp_connections[conn_idx].recv_buffer_used

      // Send ACK
      send_tcp_segment(conn_idx, TCP_ACK, 0, 0)
    }

    // Handle FIN
    if (flags & TCP_FIN) != 0 {
      tcp_connections[conn_idx].rcv_nxt = tcp_connections[conn_idx].rcv_nxt + 1
      send_tcp_segment(conn_idx, TCP_ACK, 0, 0)
      tcp_connections[conn_idx].state = TCP_STATE_CLOSE_WAIT
    }
  } else if state == TCP_STATE_FIN_WAIT_1 {
    if (flags & TCP_ACK) != 0 {
      process_ack(conn_idx, ack_num)
      tcp_connections[conn_idx].state = TCP_STATE_FIN_WAIT_2
    }
    if (flags & TCP_FIN) != 0 {
      tcp_connections[conn_idx].rcv_nxt = tcp_connections[conn_idx].rcv_nxt + 1
      send_tcp_segment(conn_idx, TCP_ACK, 0, 0)
      if tcp_connections[conn_idx].state == TCP_STATE_FIN_WAIT_2 {
        tcp_connections[conn_idx].state = TCP_STATE_TIME_WAIT
        tcp_connections[conn_idx].time_wait_timer = get_timestamp() + TCP_TIME_WAIT_TIMEOUT
      } else {
        tcp_connections[conn_idx].state = TCP_STATE_CLOSING
      }
    }
  } else if state == TCP_STATE_FIN_WAIT_2 {
    if (flags & TCP_FIN) != 0 {
      tcp_connections[conn_idx].rcv_nxt = tcp_connections[conn_idx].rcv_nxt + 1
      send_tcp_segment(conn_idx, TCP_ACK, 0, 0)
      tcp_connections[conn_idx].state = TCP_STATE_TIME_WAIT
      tcp_connections[conn_idx].time_wait_timer = get_timestamp() + TCP_TIME_WAIT_TIMEOUT
    }
  } else if state == TCP_STATE_CLOSING {
    if (flags & TCP_ACK) != 0 {
      process_ack(conn_idx, ack_num)
      tcp_connections[conn_idx].state = TCP_STATE_TIME_WAIT
      tcp_connections[conn_idx].time_wait_timer = get_timestamp() + TCP_TIME_WAIT_TIMEOUT
    }
  } else if state == TCP_STATE_LAST_ACK {
    if (flags & TCP_ACK) != 0 {
      tcp_connections[conn_idx].state = TCP_STATE_CLOSED
      free_connection(conn_idx)
      tcp_stats.active_connections = tcp_stats.active_connections - 1
    }
  }
}

// ============================================================================
// PUBLIC API
// ============================================================================

export fn tcp_init() {
  if tcp_initialized == 1 { return }

  // Initialize connections
  var i: u32 = 0
  while i < MAX_TCP_CONNECTIONS {
    tcp_connections[i].state = TCP_STATE_CLOSED
    tcp_connections[i].id = i
    i = i + 1
  }

  tcp_connection_count = 0

  // Initialize stats
  tcp_stats.active_connections = 0
  tcp_stats.passive_opens = 0
  tcp_stats.active_opens = 0
  tcp_stats.segments_sent = 0
  tcp_stats.segments_received = 0
  tcp_stats.retransmissions = 0
  tcp_stats.checksum_errors = 0

  tcp_initialized = 1
  foundation.serial_write_string("[TCP] Full TCP stack initialized (256 connections, congestion control)\n")
}

export fn tcp_connect(host: u64, port: u16): u32 {
  var conn_idx: u32 = allocate_connection()
  if conn_idx == 0xFFFFFFFF {
    tcp_stats.failed_attempts = tcp_stats.failed_attempts + 1
    return 0xFFFFFFFF
  }

  init_connection(conn_idx)

  tcp_connections[conn_idx].local_ip = local_ip
  tcp_connections[conn_idx].local_port = allocate_ephemeral_port()
  tcp_connections[conn_idx].remote_ip = gateway_ip  // Simplified: use gateway
  tcp_connections[conn_idx].remote_port = port

  // Initialize sequence numbers
  tcp_connections[conn_idx].iss = generate_isn()
  tcp_connections[conn_idx].snd_nxt = tcp_connections[conn_idx].iss
  tcp_connections[conn_idx].snd_una = tcp_connections[conn_idx].iss

  // Send SYN
  send_tcp_segment(conn_idx, TCP_SYN, 0, 0)
  add_to_retx_queue(conn_idx, tcp_connections[conn_idx].iss, 0, 0, TCP_SYN)

  tcp_connections[conn_idx].state = TCP_STATE_SYN_SENT
  tcp_stats.active_opens = tcp_stats.active_opens + 1
  tcp_connection_count = tcp_connection_count + 1

  foundation.serial_write_string("[TCP] Connecting to port ")
  foundation.serial_write_u32(port)
  foundation.serial_write_string("\n")

  return conn_idx
}

export fn tcp_listen(port: u16): u32 {
  var conn_idx: u32 = allocate_connection()
  if conn_idx == 0xFFFFFFFF {
    return 0xFFFFFFFF
  }

  init_connection(conn_idx)

  tcp_connections[conn_idx].local_ip = local_ip
  tcp_connections[conn_idx].local_port = port
  tcp_connections[conn_idx].state = TCP_STATE_LISTEN

  tcp_connection_count = tcp_connection_count + 1

  foundation.serial_write_string("[TCP] Listening on port ")
  foundation.serial_write_u32(port)
  foundation.serial_write_string("\n")

  return conn_idx
}

export fn tcp_send(conn_id: u32, data: u64, length: u32): u32 {
  if conn_id >= MAX_TCP_CONNECTIONS {
    return 0
  }

  if tcp_connections[conn_id].state != TCP_STATE_ESTABLISHED {
    return 0
  }

  var sent: u32 = 0
  var remaining: u32 = length
  var src: *u8 = @ptrFromInt(data)

  while remaining > 0 {
    // Calculate how much we can send
    var send_wnd: u32 = tcp_connections[conn_id].snd_wnd
    var cwnd: u32 = tcp_connections[conn_id].cwnd
    var effective_wnd: u32 = send_wnd
    if cwnd < send_wnd { effective_wnd = cwnd }

    var in_flight: u32 = tcp_connections[conn_id].snd_nxt - tcp_connections[conn_id].snd_una
    var available: u32 = 0
    if effective_wnd > in_flight {
      available = effective_wnd - in_flight
    }

    if available == 0 {
      // Window is full, need to wait
      break
    }

    var chunk: u32 = remaining
    if chunk > tcp_connections[conn_id].snd_mss { chunk = tcp_connections[conn_id].snd_mss }
    if chunk > available { chunk = available }

    // Send segment
    var seq: u32 = tcp_connections[conn_id].snd_nxt
    send_tcp_segment(conn_id, TCP_ACK | TCP_PSH, data + sent, chunk)
    add_to_retx_queue(conn_id, seq, data + sent, chunk, TCP_ACK | TCP_PSH)

    sent = sent + chunk
    remaining = remaining - chunk
    tcp_connections[conn_id].bytes_sent = tcp_connections[conn_id].bytes_sent + chunk
  }

  return sent
}

export fn tcp_receive(conn_id: u32, buffer: u64, max_length: u32): u32 {
  if conn_id >= MAX_TCP_CONNECTIONS {
    return 0
  }

  if tcp_connections[conn_id].state != TCP_STATE_ESTABLISHED and
     tcp_connections[conn_id].state != TCP_STATE_CLOSE_WAIT {
    return 0
  }

  var available: u32 = tcp_connections[conn_id].recv_buffer_used
  if available == 0 {
    return 0
  }

  var to_copy: u32 = available
  if to_copy > max_length { to_copy = max_length }

  // Copy from receive buffer
  var src: *u8 = @ptrFromInt(tcp_connections[conn_id].recv_buffer)
  var dst: *u8 = @ptrFromInt(buffer)
  var i: u32 = 0
  while i < to_copy {
    dst[i] = src[i]
    i = i + 1
  }

  // Move remaining data to front of buffer
  var remaining: u32 = available - to_copy
  i = 0
  while i < remaining {
    src[i] = src[to_copy + i]
    i = i + 1
  }

  tcp_connections[conn_id].recv_buffer_used = remaining
  tcp_connections[conn_id].rcv_wnd = tcp_connections[conn_id].recv_buffer_size - remaining

  return to_copy
}

export fn tcp_close(conn_id: u32): u32 {
  if conn_id >= MAX_TCP_CONNECTIONS {
    return 1
  }

  var state: u32 = tcp_connections[conn_id].state

  if state == TCP_STATE_ESTABLISHED {
    // Send FIN
    send_tcp_segment(conn_id, TCP_FIN | TCP_ACK, 0, 0)
    add_to_retx_queue(conn_id, tcp_connections[conn_id].snd_nxt - 1, 0, 0, TCP_FIN | TCP_ACK)
    tcp_connections[conn_id].state = TCP_STATE_FIN_WAIT_1
  } else if state == TCP_STATE_CLOSE_WAIT {
    send_tcp_segment(conn_id, TCP_FIN | TCP_ACK, 0, 0)
    tcp_connections[conn_id].state = TCP_STATE_LAST_ACK
  } else if state == TCP_STATE_LISTEN or state == TCP_STATE_SYN_SENT {
    free_connection(conn_id)
    tcp_connection_count = tcp_connection_count - 1
  }

  return 0
}

export fn tcp_get_state(conn_id: u32): u32 {
  if conn_id >= MAX_TCP_CONNECTIONS {
    return TCP_STATE_CLOSED
  }
  return tcp_connections[conn_id].state
}

export fn tcp_poll() {
  // Process incoming packets
  var packet: [u8; 2048]
  var len: u32 = e1000.e1000_receive_packet(@ptrFromInt(&packet), 2048)

  if len > 0 {
    // Check if IPv4
    if packet[12] == 0x08 and packet[13] == 0x00 {
      // Check if TCP
      if packet[23] == IP_PROTO_TCP {
        var src_ip: u32 = (packet[26] << 24) | (packet[27] << 16) | (packet[28] << 8) | packet[29]
        var ip_hdr_len: u32 = (packet[14] & 0x0F) * 4
        var tcp_start: u32 = 14 + ip_hdr_len
        var tcp_len: u32 = len - tcp_start

        handle_tcp_packet(src_ip, @ptrFromInt(&packet) + tcp_start, tcp_len)
      }
    }
  }

  // Process timers for all connections
  var i: u32 = 0
  while i < MAX_TCP_CONNECTIONS {
    if tcp_connections[i].state != TCP_STATE_CLOSED {
      process_timers(i)
    }
    i = i + 1
  }
}

export fn tcp_set_keepalive(conn_id: u32, enabled: u32): u32 {
  if conn_id >= MAX_TCP_CONNECTIONS {
    return 1
  }
  tcp_connections[conn_id].keepalive_enabled = enabled
  if enabled == 1 {
    tcp_connections[conn_id].keepalive_timer = get_timestamp() + TCP_KEEPALIVE_IDLE
  }
  return 0
}

export fn tcp_set_nodelay(conn_id: u32, enabled: u32): u32 {
  if conn_id >= MAX_TCP_CONNECTIONS {
    return 1
  }
  tcp_connections[conn_id].nagle_enabled = if enabled == 1 then 0 else 1
  return 0
}

export fn tcp_get_stats(): *TcpStats {
  return @ptrFromInt(&tcp_stats)
}

export fn tcp_print_stats() {
  foundation.serial_write_string("[TCP Stats]\n")
  foundation.serial_write_string("  Active connections: ")
  foundation.serial_write_u32(tcp_stats.active_connections)
  foundation.serial_write_string("\n  Active opens: ")
  foundation.serial_write_u64(tcp_stats.active_opens)
  foundation.serial_write_string("\n  Passive opens: ")
  foundation.serial_write_u64(tcp_stats.passive_opens)
  foundation.serial_write_string("\n  Segments sent: ")
  foundation.serial_write_u64(tcp_stats.segments_sent)
  foundation.serial_write_string("\n  Segments received: ")
  foundation.serial_write_u64(tcp_stats.segments_received)
  foundation.serial_write_string("\n  Retransmissions: ")
  foundation.serial_write_u64(tcp_stats.retransmissions)
  foundation.serial_write_string("\n")
}
