// home-os Kernel - TCP/IP Stack
// Real implementation

import "../core/foundation.home" as foundation
import "../drivers/e1000.home" as e1000

// TCP/IP constants
const IP_PROTO_ICMP: u8 = 1
const IP_PROTO_TCP: u8 = 6
const IP_PROTO_UDP: u8 = 17

const TCP_FIN: u8 = 0x01
const TCP_SYN: u8 = 0x02
const TCP_RST: u8 = 0x04
const TCP_PSH: u8 = 0x08
const TCP_ACK: u8 = 0x10

// Ethernet frame
struct EthFrame {
  dst_mac: [u8; 6],
  src_mac: [u8; 6],
  ethertype: u16,
  payload: [u8; 1500]
}

// IP header
struct IPHeader {
  version_ihl: u8,
  tos: u8,
  total_length: u16,
  id: u16,
  flags_offset: u16,
  ttl: u8,
  protocol: u8,
  checksum: u16,
  src_ip: u32,
  dst_ip: u32
}

// TCP header
struct TCPHeader {
  src_port: u16,
  dst_port: u16,
  seq: u32,
  ack: u32,
  offset_flags: u16,
  window: u16,
  checksum: u16,
  urgent: u16
}

var local_ip: u32 = 0x0A000002  // 10.0.0.2
var gateway_ip: u32 = 0x0A000001  // 10.0.0.1

export fn tcp_init() {
  foundation.serial_write_string("[TCP] Initialized\n")
}

fn checksum(data: u64, len: u32): u16 {
  var sum: u32 = 0
  var i: u32 = 0
  
  while i < len - 1 {
    var word: u16 = (@intToPtr(data + i, u8) << 8) | @intToPtr(data + i + 1, u8)
    sum = sum + word
    i = i + 2
  }
  
  if i < len {
    sum = sum + (@intToPtr(data + i, u8) << 8)
  }
  
  while (sum >> 16) != 0 {
    sum = (sum & 0xFFFF) + (sum >> 16)
  }
  
  return ~sum
}

export fn tcp_send(dst_ip: u32, dst_port: u16, src_port: u16, data: u64, len: u32): u32 {
  var packet: [u8; 1500]
  var offset: u32 = 0
  
  // Ethernet header
  var i: u32 = 0
  while i < 6 {
    packet[offset + i] = 0xFF  // Broadcast for now
    i = i + 1
  }
  offset = offset + 6
  
  e1000.e1000_get_mac_address(@ptrFromInt(packet) + offset)
  offset = offset + 6
  
  packet[offset] = 0x08
  packet[offset + 1] = 0x00  // IPv4
  offset = offset + 2
  
  // IP header
  var ip_start: u32 = offset
  packet[offset] = 0x45  // Version 4, IHL 5
  packet[offset + 1] = 0  // TOS
  var total_len: u16 = 20 + 20 + len  // IP + TCP + data
  packet[offset + 2] = (total_len >> 8) & 0xFF
  packet[offset + 3] = total_len & 0xFF
  packet[offset + 4] = 0  // ID
  packet[offset + 5] = 0
  packet[offset + 6] = 0x40  // Don't fragment
  packet[offset + 7] = 0
  packet[offset + 8] = 64  // TTL
  packet[offset + 9] = IP_PROTO_TCP
  packet[offset + 10] = 0  // Checksum (calculate later)
  packet[offset + 11] = 0
  
  // Source IP
  packet[offset + 12] = (local_ip >> 24) & 0xFF
  packet[offset + 13] = (local_ip >> 16) & 0xFF
  packet[offset + 14] = (local_ip >> 8) & 0xFF
  packet[offset + 15] = local_ip & 0xFF
  
  // Dest IP
  packet[offset + 16] = (dst_ip >> 24) & 0xFF
  packet[offset + 17] = (dst_ip >> 16) & 0xFF
  packet[offset + 18] = (dst_ip >> 8) & 0xFF
  packet[offset + 19] = dst_ip & 0xFF
  
  offset = offset + 20
  
  // TCP header
  packet[offset] = (src_port >> 8) & 0xFF
  packet[offset + 1] = src_port & 0xFF
  packet[offset + 2] = (dst_port >> 8) & 0xFF
  packet[offset + 3] = dst_port & 0xFF
  packet[offset + 4] = 0  // Seq
  packet[offset + 5] = 0
  packet[offset + 6] = 0
  packet[offset + 7] = 1
  packet[offset + 8] = 0  // Ack
  packet[offset + 9] = 0
  packet[offset + 10] = 0
  packet[offset + 11] = 0
  packet[offset + 12] = 0x50  // Offset 5, no flags
  packet[offset + 13] = TCP_SYN
  packet[offset + 14] = 0x20  // Window
  packet[offset + 15] = 0x00
  packet[offset + 16] = 0  // Checksum
  packet[offset + 17] = 0
  packet[offset + 18] = 0  // Urgent
  packet[offset + 19] = 0
  
  offset = offset + 20
  
  // Copy data
  i = 0
  while i < len {
    packet[offset + i] = @intToPtr(data + i, u8)
    i = i + 1
  }
  
  // Calculate IP checksum
  var ip_csum: u16 = checksum(@ptrFromInt(packet) + ip_start, 20)
  packet[ip_start + 10] = (ip_csum >> 8) & 0xFF
  packet[ip_start + 11] = ip_csum & 0xFF
  
  // Send packet
  return e1000.e1000_send_packet(@ptrFromInt(packet), offset + len)
}

export fn tcp_receive(buffer: u64, max_len: u32): u32 {
  var packet: [u8; 2048]
  var len: u32 = e1000.e1000_receive_packet(@ptrFromInt(packet), 2048)
  
  if len == 0 { return 0 }
  
  // Skip Ethernet header (14 bytes)
  var offset: u32 = 14
  
  // Check if IP
  if packet[12] != 0x08 or packet[13] != 0x00 { return 0 }
  
  // Check if TCP
  if packet[offset + 9] != IP_PROTO_TCP { return 0 }
  
  // Skip IP header (20 bytes)
  offset = offset + 20
  
  // Skip TCP header (20 bytes)
  offset = offset + 20
  
  // Copy payload
  var payload_len: u32 = len - offset
  if payload_len > max_len { payload_len = max_len }
  
  var i: u32 = 0
  while i < payload_len {
    @ptrToInt(buffer + i, u8) = packet[offset + i]
    i = i + 1
  }
  
  return payload_len
}
