// HomeOS End-to-End GUI Verification Test Suite
// Tests the complete GUI stack: boot → compositor → window manager → core GUI apps
//
// This module verifies that the full GUI pipeline works correctly on Pi 4/5
// hardware, including proper initialization sequence and component interaction.

const serial = @import("../../kernel/src/drivers/serial.home")
const compositor = @import("../../kernel/src/video/compositor.home")
const window_manager = @import("../../kernel/src/gui/window_manager.home")
const craft_ui = @import("../../kernel/src/gui/craft_integration.home")
const test_framework = @import("../../tools/testing/test_framework.home")

// ============================================================================
// Test Configuration
// ============================================================================

const TEST_WINDOW_WIDTH: u32 = 800
const TEST_WINDOW_HEIGHT: u32 = 600
const TEST_TIMEOUT_MS: u32 = 5000
const MAX_TEST_ITERATIONS: u32 = 100

// Test result tracking
var tests_passed: u32 = 0
var tests_failed: u32 = 0
var tests_skipped: u32 = 0

// ============================================================================
// Test Utilities
// ============================================================================

fn log_test_start(name: []const u8) void {
    serial.write_string("\n[TEST] Starting: ")
    serial.write_string(name)
    serial.write_string("\n")
}

fn log_test_pass(name: []const u8) void {
    serial.write_string("[PASS] ")
    serial.write_string(name)
    serial.write_string("\n")
    tests_passed += 1
}

fn log_test_fail(name: []const u8, reason: []const u8) void {
    serial.write_string("[FAIL] ")
    serial.write_string(name)
    serial.write_string(" - ")
    serial.write_string(reason)
    serial.write_string("\n")
    tests_failed += 1
}

fn log_test_skip(name: []const u8, reason: []const u8) void {
    serial.write_string("[SKIP] ")
    serial.write_string(name)
    serial.write_string(" - ")
    serial.write_string(reason)
    serial.write_string("\n")
    tests_skipped += 1
}

// ============================================================================
// Phase 1: Boot Verification Tests
// ============================================================================

// Test 1.1: Verify kernel boot sequence completed
export fn test_boot_kernel_initialized() u32 {
    log_test_start("Boot: Kernel Initialized")

    // Check that serial output is working (if we got here, it is)
    serial.write_string("  Checking serial output... ")

    // Verify basic kernel services are available
    // This is verified by the fact we can run this code
    serial.write_string("OK\n")

    log_test_pass("Boot: Kernel Initialized")
    return 1
}

// Test 1.2: Verify memory management is operational
export fn test_boot_memory_available() u32 {
    log_test_start("Boot: Memory Management")

    // Try to query memory statistics
    serial.write_string("  Checking memory subsystem... ")

    // If we can allocate test structures, memory is working
    var test_val: u64 = 0x12345678
    if (test_val != 0x12345678) {
        log_test_fail("Boot: Memory Management", "Memory corruption detected")
        return 0
    }

    serial.write_string("OK\n")
    log_test_pass("Boot: Memory Management")
    return 1
}

// Test 1.3: Verify framebuffer is available
export fn test_boot_framebuffer_available() u32 {
    log_test_start("Boot: Framebuffer Available")

    serial.write_string("  Checking framebuffer... ")

    // Check if compositor can report display info
    var display_count: u32 = compositor.compositor_get_display_count()
    if (display_count == 0) {
        log_test_skip("Boot: Framebuffer Available", "No display detected (headless mode?)")
        return 2  // Skip, not fail
    }

    serial.write_string("Found ")
    serial.write_u32(display_count)
    serial.write_string(" display(s)\n")

    log_test_pass("Boot: Framebuffer Available")
    return 1
}

// ============================================================================
// Phase 2: Compositor Verification Tests
// ============================================================================

// Test 2.1: Compositor initialization
export fn test_compositor_init() u32 {
    log_test_start("Compositor: Initialization")

    serial.write_string("  Initializing compositor... ")

    var result: u32 = compositor.compositor_init()
    if (result != 0) {
        log_test_fail("Compositor: Initialization", "compositor_init() failed")
        return 0
    }

    serial.write_string("OK\n")
    log_test_pass("Compositor: Initialization")
    return 1
}

// Test 2.2: Window creation
export fn test_compositor_create_window() u32 {
    log_test_start("Compositor: Window Creation")

    serial.write_string("  Creating test window... ")

    var window_id: u32 = compositor.compositor_create_window(
        100,  // x
        100,  // y
        TEST_WINDOW_WIDTH,
        TEST_WINDOW_HEIGHT,
        "Test Window"
    )

    if (window_id == 0 or window_id == 0xFFFFFFFF) {
        log_test_fail("Compositor: Window Creation", "Failed to create window")
        return 0
    }

    serial.write_string("Created window ID: ")
    serial.write_u32(window_id)
    serial.write_string("\n")

    // Clean up
    compositor.compositor_destroy_window(window_id)

    log_test_pass("Compositor: Window Creation")
    return 1
}

// Test 2.3: Window operations (move, resize)
export fn test_compositor_window_operations() u32 {
    log_test_start("Compositor: Window Operations")

    // Create a window for testing
    var window_id: u32 = compositor.compositor_create_window(
        50, 50, 400, 300, "Operations Test"
    )

    if (window_id == 0 or window_id == 0xFFFFFFFF) {
        log_test_fail("Compositor: Window Operations", "Failed to create test window")
        return 0
    }

    // Test move
    serial.write_string("  Testing window move... ")
    compositor.compositor_move_window(window_id, 200, 200)
    serial.write_string("OK\n")

    // Test resize
    serial.write_string("  Testing window resize... ")
    compositor.compositor_resize_window(window_id, 600, 400)
    serial.write_string("OK\n")

    // Test show/hide
    serial.write_string("  Testing show/hide... ")
    compositor.compositor_hide_window(window_id)
    compositor.compositor_show_window(window_id)
    serial.write_string("OK\n")

    // Clean up
    compositor.compositor_destroy_window(window_id)

    log_test_pass("Compositor: Window Operations")
    return 1
}

// Test 2.4: Multi-window management
export fn test_compositor_multi_window() u32 {
    log_test_start("Compositor: Multi-Window Management")

    const NUM_WINDOWS: u32 = 5
    var window_ids: [16]u32 = undefined
    var created: u32 = 0

    serial.write_string("  Creating ")
    serial.write_u32(NUM_WINDOWS)
    serial.write_string(" windows... ")

    var i: u32 = 0
    while (i < NUM_WINDOWS) {
        window_ids[i] = compositor.compositor_create_window(
            50 + i * 50,
            50 + i * 30,
            300,
            200,
            "Multi Window Test"
        )

        if (window_ids[i] != 0 and window_ids[i] != 0xFFFFFFFF) {
            created += 1
        }
        i += 1
    }

    serial.write_string("Created ")
    serial.write_u32(created)
    serial.write_string("\n")

    if (created != NUM_WINDOWS) {
        log_test_fail("Compositor: Multi-Window Management", "Failed to create all windows")

        // Clean up what we created
        i = 0
        while (i < created) {
            compositor.compositor_destroy_window(window_ids[i])
            i += 1
        }
        return 0
    }

    // Test focus switching
    serial.write_string("  Testing focus switching... ")
    i = 0
    while (i < NUM_WINDOWS) {
        compositor.compositor_focus_window(window_ids[i])
        i += 1
    }
    serial.write_string("OK\n")

    // Clean up all windows
    serial.write_string("  Destroying windows... ")
    i = 0
    while (i < NUM_WINDOWS) {
        compositor.compositor_destroy_window(window_ids[i])
        i += 1
    }
    serial.write_string("OK\n")

    log_test_pass("Compositor: Multi-Window Management")
    return 1
}

// Test 2.5: Compositor rendering
export fn test_compositor_render() u32 {
    log_test_start("Compositor: Rendering")

    serial.write_string("  Testing render cycle... ")

    var window_id: u32 = compositor.compositor_create_window(
        100, 100, 400, 300, "Render Test"
    )

    if (window_id == 0 or window_id == 0xFFFFFFFF) {
        log_test_fail("Compositor: Rendering", "Failed to create window")
        return 0
    }

    // Trigger render
    compositor.compositor_render()

    // Check statistics
    var stats = compositor.compositor_get_stats()
    serial.write_string("OK (")
    serial.write_u32(stats.frame_count)
    serial.write_string(" frames)\n")

    compositor.compositor_destroy_window(window_id)

    log_test_pass("Compositor: Rendering")
    return 1
}

// ============================================================================
// Phase 3: Window Manager Verification Tests
// ============================================================================

// Test 3.1: Window manager initialization
export fn test_window_manager_init() u32 {
    log_test_start("Window Manager: Initialization")

    serial.write_string("  Initializing window manager... ")

    window_manager.wm_init()

    serial.write_string("OK\n")
    log_test_pass("Window Manager: Initialization")
    return 1
}

// Test 3.2: Workspace creation and switching
export fn test_window_manager_workspaces() u32 {
    log_test_start("Window Manager: Workspaces")

    // Test workspace switching
    serial.write_string("  Testing workspace switching... ")

    var i: u32 = 0
    while (i < 5) {
        window_manager.wm_switch_workspace(i)
        var current: u32 = window_manager.wm_get_current_workspace()
        if (current != i) {
            log_test_fail("Window Manager: Workspaces", "Workspace switch failed")
            return 0
        }
        i += 1
    }

    // Return to workspace 0
    window_manager.wm_switch_workspace(0)

    serial.write_string("OK\n")
    log_test_pass("Window Manager: Workspaces")
    return 1
}

// Test 3.3: Layout management
export fn test_window_manager_layouts() u32 {
    log_test_start("Window Manager: Layouts")

    serial.write_string("  Testing layout modes... ")

    // Test each layout type
    window_manager.wm_set_layout(0)  // Horizontal
    window_manager.wm_set_layout(1)  // Vertical
    window_manager.wm_set_layout(2)  // Grid
    window_manager.wm_set_layout(3)  // Master+Stack
    window_manager.wm_set_layout(4)  // Fibonacci

    // Return to horizontal
    window_manager.wm_set_layout(0)

    serial.write_string("OK\n")
    log_test_pass("Window Manager: Layouts")
    return 1
}

// Test 3.4: Window snapping
export fn test_window_manager_snapping() u32 {
    log_test_start("Window Manager: Snapping")

    serial.write_string("  Creating window for snap test... ")

    var window_id: u32 = compositor.compositor_create_window(
        100, 100, 400, 300, "Snap Test"
    )

    if (window_id == 0 or window_id == 0xFFFFFFFF) {
        log_test_fail("Window Manager: Snapping", "Failed to create window")
        return 0
    }

    serial.write_string("OK\n")

    // Test snap directions
    serial.write_string("  Testing snap directions... ")

    window_manager.wm_snap_window(window_id, 0)  // Left
    window_manager.wm_snap_window(window_id, 1)  // Right
    window_manager.wm_snap_window(window_id, 2)  // Top
    window_manager.wm_snap_window(window_id, 3)  // Bottom
    window_manager.wm_snap_window(window_id, 4)  // Top-left
    window_manager.wm_snap_window(window_id, 5)  // Top-right
    window_manager.wm_snap_window(window_id, 6)  // Bottom-left
    window_manager.wm_snap_window(window_id, 7)  // Bottom-right

    serial.write_string("OK\n")

    compositor.compositor_destroy_window(window_id)

    log_test_pass("Window Manager: Snapping")
    return 1
}

// ============================================================================
// Phase 4: Craft UI Framework Verification Tests
// ============================================================================

// Test 4.1: Craft UI initialization
export fn test_craft_ui_init() u32 {
    log_test_start("Craft UI: Initialization")

    serial.write_string("  Initializing Craft UI... ")

    craft_ui.craft_init()

    serial.write_string("OK\n")
    log_test_pass("Craft UI: Initialization")
    return 1
}

// Test 4.2: Widget creation
export fn test_craft_ui_widgets() u32 {
    log_test_start("Craft UI: Widget Creation")

    // Create a window
    serial.write_string("  Creating Craft window... ")
    var window_id: u32 = craft_ui.craft_create_window(
        100, 100, 500, 400, "Widget Test"
    )

    if (window_id == 0 or window_id == 0xFFFFFFFF) {
        log_test_fail("Craft UI: Widget Creation", "Failed to create window")
        return 0
    }
    serial.write_string("OK\n")

    // Test button widget
    serial.write_string("  Creating button widget... ")
    var button_id: u32 = craft_ui.craft_create_button(window_id, 10, 10, 100, 30, "Click Me")
    if (button_id == 0 or button_id == 0xFFFFFFFF) {
        log_test_fail("Craft UI: Widget Creation", "Failed to create button")
        craft_ui.craft_destroy_window(window_id)
        return 0
    }
    serial.write_string("OK\n")

    // Test label widget
    serial.write_string("  Creating label widget... ")
    var label_id: u32 = craft_ui.craft_create_label(window_id, 10, 50, 200, 20, "Test Label")
    if (label_id == 0 or label_id == 0xFFFFFFFF) {
        log_test_fail("Craft UI: Widget Creation", "Failed to create label")
        craft_ui.craft_destroy_window(window_id)
        return 0
    }
    serial.write_string("OK\n")

    // Test textbox widget
    serial.write_string("  Creating textbox widget... ")
    var textbox_id: u32 = craft_ui.craft_create_textbox(window_id, 10, 80, 200, 25)
    if (textbox_id == 0 or textbox_id == 0xFFFFFFFF) {
        log_test_fail("Craft UI: Widget Creation", "Failed to create textbox")
        craft_ui.craft_destroy_window(window_id)
        return 0
    }
    serial.write_string("OK\n")

    // Test checkbox widget
    serial.write_string("  Creating checkbox widget... ")
    var checkbox_id: u32 = craft_ui.craft_create_checkbox(window_id, 10, 115, "Enable Feature")
    if (checkbox_id == 0 or checkbox_id == 0xFFFFFFFF) {
        log_test_fail("Craft UI: Widget Creation", "Failed to create checkbox")
        craft_ui.craft_destroy_window(window_id)
        return 0
    }
    serial.write_string("OK\n")

    // Clean up
    craft_ui.craft_destroy_window(window_id)

    log_test_pass("Craft UI: Widget Creation")
    return 1
}

// Test 4.3: Event system
export fn test_craft_ui_events() u32 {
    log_test_start("Craft UI: Event System")

    serial.write_string("  Testing event queue... ")

    // Push a test event
    craft_ui.craft_push_event(1, 0, 100, 100, 0)  // Mouse move event

    // Verify event can be processed
    var event = craft_ui.craft_pop_event()

    serial.write_string("OK\n")
    log_test_pass("Craft UI: Event System")
    return 1
}

// Test 4.4: Text rendering
export fn test_craft_ui_text_rendering() u32 {
    log_test_start("Craft UI: Text Rendering")

    serial.write_string("  Creating window with text... ")

    var window_id: u32 = craft_ui.craft_create_window(
        100, 100, 400, 200, "Text Rendering Test"
    )

    if (window_id == 0 or window_id == 0xFFFFFFFF) {
        log_test_fail("Craft UI: Text Rendering", "Failed to create window")
        return 0
    }

    // Create multiple labels with different text
    craft_ui.craft_create_label(window_id, 10, 10, 380, 20, "Hello, HomeOS!")
    craft_ui.craft_create_label(window_id, 10, 40, 380, 20, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
    craft_ui.craft_create_label(window_id, 10, 70, 380, 20, "abcdefghijklmnopqrstuvwxyz")
    craft_ui.craft_create_label(window_id, 10, 100, 380, 20, "0123456789 !@#$%^&*()")

    serial.write_string("OK\n")

    // Trigger paint
    craft_ui.craft_paint_window(window_id)

    craft_ui.craft_destroy_window(window_id)

    log_test_pass("Craft UI: Text Rendering")
    return 1
}

// ============================================================================
// Phase 5: Integration Tests
// ============================================================================

// Test 5.1: Full stack integration
export fn test_integration_full_stack() u32 {
    log_test_start("Integration: Full Stack")

    serial.write_string("  Creating integrated application window... ")

    // Create a complete application window with multiple widgets
    var app_window: u32 = craft_ui.craft_create_window(
        50, 50, 640, 480, "HomeOS Test Application"
    )

    if (app_window == 0 or app_window == 0xFFFFFFFF) {
        log_test_fail("Integration: Full Stack", "Failed to create application window")
        return 0
    }
    serial.write_string("OK\n")

    // Add a title label
    serial.write_string("  Adding UI components... ")
    craft_ui.craft_create_label(app_window, 10, 10, 300, 25, "HomeOS E2E Test Application")

    // Add buttons
    craft_ui.craft_create_button(app_window, 10, 50, 100, 30, "Button 1")
    craft_ui.craft_create_button(app_window, 120, 50, 100, 30, "Button 2")
    craft_ui.craft_create_button(app_window, 230, 50, 100, 30, "Button 3")

    // Add text input area
    craft_ui.craft_create_label(app_window, 10, 100, 100, 20, "Username:")
    craft_ui.craft_create_textbox(app_window, 110, 95, 200, 25)

    craft_ui.craft_create_label(app_window, 10, 135, 100, 20, "Password:")
    craft_ui.craft_create_textbox(app_window, 110, 130, 200, 25)

    // Add checkboxes
    craft_ui.craft_create_checkbox(app_window, 10, 170, "Remember me")
    craft_ui.craft_create_checkbox(app_window, 10, 195, "Auto-login")

    // Add an action button
    craft_ui.craft_create_button(app_window, 10, 240, 150, 35, "Login")
    craft_ui.craft_create_button(app_window, 170, 240, 150, 35, "Cancel")

    serial.write_string("OK\n")

    // Paint the window
    serial.write_string("  Rendering application... ")
    craft_ui.craft_paint_window(app_window)
    compositor.compositor_render()
    serial.write_string("OK\n")

    // Test window manager integration
    serial.write_string("  Testing window manager integration... ")
    window_manager.wm_snap_window(app_window, 0)  // Snap left
    window_manager.wm_snap_window(app_window, 8)  // Restore (center)
    serial.write_string("OK\n")

    // Clean up
    craft_ui.craft_destroy_window(app_window)

    log_test_pass("Integration: Full Stack")
    return 1
}

// Test 5.2: Performance verification
export fn test_integration_performance() u32 {
    log_test_start("Integration: Performance")

    serial.write_string("  Running render performance test... ")

    // Create a test window
    var window_id: u32 = compositor.compositor_create_window(
        100, 100, 800, 600, "Performance Test"
    )

    if (window_id == 0 or window_id == 0xFFFFFFFF) {
        log_test_fail("Integration: Performance", "Failed to create window")
        return 0
    }

    // Perform multiple render cycles
    var start_frame: u32 = compositor.compositor_get_stats().frame_count
    var i: u32 = 0
    while (i < 60) {  // Simulate 60 frames
        compositor.compositor_render()
        i += 1
    }
    var end_frame: u32 = compositor.compositor_get_stats().frame_count

    var frames_rendered: u32 = end_frame - start_frame
    serial.write_string("Rendered ")
    serial.write_u32(frames_rendered)
    serial.write_string(" frames\n")

    compositor.compositor_destroy_window(window_id)

    if (frames_rendered < 30) {
        log_test_fail("Integration: Performance", "Low frame count")
        return 0
    }

    log_test_pass("Integration: Performance")
    return 1
}

// Test 5.3: Stress test - many windows
export fn test_integration_stress() u32 {
    log_test_start("Integration: Stress Test")

    const STRESS_WINDOW_COUNT: u32 = 20
    var window_ids: [32]u32 = undefined
    var created: u32 = 0

    serial.write_string("  Creating ")
    serial.write_u32(STRESS_WINDOW_COUNT)
    serial.write_string(" windows... ")

    var i: u32 = 0
    while (i < STRESS_WINDOW_COUNT) {
        window_ids[i] = compositor.compositor_create_window(
            (i % 10) * 80,
            (i / 10) * 80,
            200,
            150,
            "Stress Window"
        )

        if (window_ids[i] != 0 and window_ids[i] != 0xFFFFFFFF) {
            created += 1
        }
        i += 1
    }

    serial.write_string("Created ")
    serial.write_u32(created)
    serial.write_string("\n")

    // Render with all windows
    serial.write_string("  Rendering all windows... ")
    compositor.compositor_render()
    serial.write_string("OK\n")

    // Move all windows
    serial.write_string("  Moving all windows... ")
    i = 0
    while (i < created) {
        compositor.compositor_move_window(window_ids[i], 100 + i * 10, 100 + i * 10)
        i += 1
    }
    serial.write_string("OK\n")

    // Clean up
    serial.write_string("  Destroying all windows... ")
    i = 0
    while (i < created) {
        compositor.compositor_destroy_window(window_ids[i])
        i += 1
    }
    serial.write_string("OK\n")

    if (created < STRESS_WINDOW_COUNT / 2) {
        log_test_fail("Integration: Stress Test", "Failed to create enough windows")
        return 0
    }

    log_test_pass("Integration: Stress Test")
    return 1
}

// ============================================================================
// Test Runner
// ============================================================================

export fn run_all_gui_e2e_tests() void {
    serial.write_string("\n")
    serial.write_string("========================================\n")
    serial.write_string("HomeOS End-to-End GUI Verification Tests\n")
    serial.write_string("========================================\n")
    serial.write_string("\n")

    // Phase 1: Boot Verification
    serial.write_string("=== Phase 1: Boot Verification ===\n")
    test_boot_kernel_initialized()
    test_boot_memory_available()
    test_boot_framebuffer_available()

    // Phase 2: Compositor Tests
    serial.write_string("\n=== Phase 2: Compositor Tests ===\n")
    test_compositor_init()
    test_compositor_create_window()
    test_compositor_window_operations()
    test_compositor_multi_window()
    test_compositor_render()

    // Phase 3: Window Manager Tests
    serial.write_string("\n=== Phase 3: Window Manager Tests ===\n")
    test_window_manager_init()
    test_window_manager_workspaces()
    test_window_manager_layouts()
    test_window_manager_snapping()

    // Phase 4: Craft UI Tests
    serial.write_string("\n=== Phase 4: Craft UI Tests ===\n")
    test_craft_ui_init()
    test_craft_ui_widgets()
    test_craft_ui_events()
    test_craft_ui_text_rendering()

    // Phase 5: Integration Tests
    serial.write_string("\n=== Phase 5: Integration Tests ===\n")
    test_integration_full_stack()
    test_integration_performance()
    test_integration_stress()

    // Print summary
    serial.write_string("\n")
    serial.write_string("========================================\n")
    serial.write_string("Test Summary\n")
    serial.write_string("========================================\n")
    serial.write_string("Passed:  ")
    serial.write_u32(tests_passed)
    serial.write_string("\n")
    serial.write_string("Failed:  ")
    serial.write_u32(tests_failed)
    serial.write_string("\n")
    serial.write_string("Skipped: ")
    serial.write_u32(tests_skipped)
    serial.write_string("\n")
    serial.write_string("Total:   ")
    serial.write_u32(tests_passed + tests_failed + tests_skipped)
    serial.write_string("\n")
    serial.write_string("========================================\n")

    if (tests_failed == 0) {
        serial.write_string("\n[SUCCESS] All GUI E2E tests passed!\n")
    } else {
        serial.write_string("\n[FAILURE] Some tests failed.\n")
    }
}

// Entry point for test execution
export fn gui_e2e_test_main() void {
    run_all_gui_e2e_tests()
}
