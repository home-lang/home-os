// HomeOS libc - File Control (fcntl.h)
// POSIX-compatible file control operations

const basics = @import("basics")

// ============================================
// Open Flags
// ============================================

export const O_RDONLY: i32 = 0x0000
export const O_WRONLY: i32 = 0x0001
export const O_RDWR: i32 = 0x0002
export const O_ACCMODE: i32 = 0x0003

export const O_CREAT: i32 = 0x0040
export const O_EXCL: i32 = 0x0080
export const O_NOCTTY: i32 = 0x0100
export const O_TRUNC: i32 = 0x0200
export const O_APPEND: i32 = 0x0400
export const O_NONBLOCK: i32 = 0x0800
export const O_DSYNC: i32 = 0x1000
export const O_SYNC: i32 = 0x101000
export const O_RSYNC: i32 = O_SYNC
export const O_DIRECTORY: i32 = 0x10000
export const O_NOFOLLOW: i32 = 0x20000
export const O_CLOEXEC: i32 = 0x80000
export const O_ASYNC: i32 = 0x2000
export const O_DIRECT: i32 = 0x4000
export const O_LARGEFILE: i32 = 0x8000
export const O_NOATIME: i32 = 0x40000
export const O_PATH: i32 = 0x200000
export const O_TMPFILE: i32 = 0x400000

export const O_NDELAY: i32 = O_NONBLOCK

// ============================================
// fcntl Commands
// ============================================

export const F_DUPFD: i32 = 0
export const F_GETFD: i32 = 1
export const F_SETFD: i32 = 2
export const F_GETFL: i32 = 3
export const F_SETFL: i32 = 4
export const F_GETLK: i32 = 5
export const F_SETLK: i32 = 6
export const F_SETLKW: i32 = 7
export const F_SETOWN: i32 = 8
export const F_GETOWN: i32 = 9
export const F_SETSIG: i32 = 10
export const F_GETSIG: i32 = 11
export const F_DUPFD_CLOEXEC: i32 = 1030
export const F_SETPIPE_SZ: i32 = 1031
export const F_GETPIPE_SZ: i32 = 1032
export const F_ADD_SEALS: i32 = 1033
export const F_GET_SEALS: i32 = 1034
export const F_GET_RW_HINT: i32 = 1035
export const F_SET_RW_HINT: i32 = 1036
export const F_GET_FILE_RW_HINT: i32 = 1037
export const F_SET_FILE_RW_HINT: i32 = 1038

// ============================================
// File Descriptor Flags
// ============================================

export const FD_CLOEXEC: i32 = 1

// ============================================
// File Seals
// ============================================

export const F_SEAL_SEAL: i32 = 0x0001
export const F_SEAL_SHRINK: i32 = 0x0002
export const F_SEAL_GROW: i32 = 0x0004
export const F_SEAL_WRITE: i32 = 0x0008
export const F_SEAL_FUTURE_WRITE: i32 = 0x0010

// ============================================
// Lock Types
// ============================================

export const F_RDLCK: i32 = 0
export const F_WRLCK: i32 = 1
export const F_UNLCK: i32 = 2

// ============================================
// Advisory Record Locking
// ============================================

pub struct flock {
    l_type: i16
    l_whence: i16
    l_start: i64
    l_len: i64
    l_pid: i32
}

// ============================================
// Access Test Modes
// ============================================

export const AT_FDCWD: i32 = -100
export const AT_SYMLINK_NOFOLLOW: i32 = 0x100
export const AT_REMOVEDIR: i32 = 0x200
export const AT_SYMLINK_FOLLOW: i32 = 0x400
export const AT_NO_AUTOMOUNT: i32 = 0x800
export const AT_EMPTY_PATH: i32 = 0x1000
export const AT_EACCESS: i32 = 0x200

// ============================================
// File Control Functions
// ============================================

export fn open(pathname: *const u8, flags: i32, ...): i32 {
    // Mode is optional, only used with O_CREAT
    var mode: u32 = 0
    if (flags & O_CREAT) != 0 {
        mode = 0o666  // Default mode, will be passed via varargs
    }
    return basics.open(pathname, flags, mode)
}

export fn openat(dirfd: i32, pathname: *const u8, flags: i32, ...): i32 {
    var mode: u32 = 0
    if (flags & O_CREAT) != 0 {
        mode = 0o666
    }
    return basics.openat(dirfd, pathname, flags, mode)
}

export fn creat(pathname: *const u8, mode: u32): i32 {
    return open(pathname, O_CREAT | O_WRONLY | O_TRUNC, mode)
}

export fn fcntl(fd: i32, cmd: i32, ...): i32 {
    // arg is optional depending on cmd
    return basics.fcntl(fd, cmd, 0)
}

export fn fcntl_int(fd: i32, cmd: i32, arg: i32): i32 {
    return basics.fcntl(fd, cmd, arg)
}

export fn fcntl_ptr(fd: i32, cmd: i32, arg: *void): i32 {
    return basics.fcntl_ptr(fd, cmd, arg)
}

// ============================================
// POSIX Advisory Locking
// ============================================

export fn posix_fadvise(fd: i32, offset: i64, len: i64, advice: i32): i32 {
    return basics.fadvise(fd, offset, len, advice)
}

export fn posix_fallocate(fd: i32, offset: i64, len: i64): i32 {
    return basics.fallocate(fd, 0, offset, len)
}

export fn fallocate(fd: i32, mode: i32, offset: i64, len: i64): i32 {
    return basics.fallocate(fd, mode, offset, len)
}

// Advisory constants
export const POSIX_FADV_NORMAL: i32 = 0
export const POSIX_FADV_RANDOM: i32 = 1
export const POSIX_FADV_SEQUENTIAL: i32 = 2
export const POSIX_FADV_WILLNEED: i32 = 3
export const POSIX_FADV_DONTNEED: i32 = 4
export const POSIX_FADV_NOREUSE: i32 = 5

// Fallocate modes
export const FALLOC_FL_KEEP_SIZE: i32 = 0x01
export const FALLOC_FL_PUNCH_HOLE: i32 = 0x02
export const FALLOC_FL_NO_HIDE_STALE: i32 = 0x04
export const FALLOC_FL_COLLAPSE_RANGE: i32 = 0x08
export const FALLOC_FL_ZERO_RANGE: i32 = 0x10
export const FALLOC_FL_INSERT_RANGE: i32 = 0x20
export const FALLOC_FL_UNSHARE_RANGE: i32 = 0x40

// ============================================
// File Locking Helper Functions
// ============================================

export fn lockf(fd: i32, cmd: i32, len: i64): i32 {
    var fl: flock
    fl.l_type = if cmd == F_LOCK or cmd == F_TLOCK { F_WRLCK as i16 } else { F_UNLCK as i16 }
    fl.l_whence = 1  // SEEK_CUR
    fl.l_start = 0
    fl.l_len = len
    fl.l_pid = 0

    switch cmd {
        F_LOCK => {
            return fcntl_ptr(fd, F_SETLKW, &fl)
        }
        F_TLOCK => {
            return fcntl_ptr(fd, F_SETLK, &fl)
        }
        F_ULOCK => {
            fl.l_type = F_UNLCK as i16
            return fcntl_ptr(fd, F_SETLK, &fl)
        }
        F_TEST => {
            fl.l_type = F_WRLCK as i16
            if fcntl_ptr(fd, F_GETLK, &fl) < 0 {
                return -1
            }
            if fl.l_type == F_UNLCK as i16 {
                return 0
            }
            return -1
        }
        else => return -1
    }
}

// lockf commands
const F_LOCK: i32 = 1
const F_TLOCK: i32 = 2
const F_ULOCK: i32 = 0
const F_TEST: i32 = 3

// ============================================
// BSD Flock Compatibility
// ============================================

export const LOCK_SH: i32 = 1
export const LOCK_EX: i32 = 2
export const LOCK_NB: i32 = 4
export const LOCK_UN: i32 = 8

export fn flock(fd: i32, operation: i32): i32 {
    return basics.flock(fd, operation)
}

// ============================================
// Directory Entry Reading
// ============================================

pub struct dirent {
    d_ino: u64
    d_off: i64
    d_reclen: u16
    d_type: u8
    d_name: [256]u8
}

pub type DIR = struct {
    fd: i32
    buf: [4096]u8
    buf_pos: u32
    buf_end: u32
    tell: i64
}

export const DT_UNKNOWN: u8 = 0
export const DT_FIFO: u8 = 1
export const DT_CHR: u8 = 2
export const DT_DIR: u8 = 4
export const DT_BLK: u8 = 6
export const DT_REG: u8 = 8
export const DT_LNK: u8 = 10
export const DT_SOCK: u8 = 12
export const DT_WHT: u8 = 14

export fn opendir(name: *const u8): *DIR {
    let fd = open(name, O_RDONLY | O_DIRECTORY | O_CLOEXEC)
    if fd < 0 {
        return null
    }

    let dir = basics.malloc(@sizeOf(DIR)) as *DIR
    if dir == null {
        basics.close(fd)
        return null
    }

    dir.fd = fd
    dir.buf_pos = 0
    dir.buf_end = 0
    dir.tell = 0

    return dir
}

export fn fdopendir(fd: i32): *DIR {
    let dir = basics.malloc(@sizeOf(DIR)) as *DIR
    if dir == null {
        return null
    }

    dir.fd = fd
    dir.buf_pos = 0
    dir.buf_end = 0
    dir.tell = 0

    return dir
}

export fn closedir(dirp: *DIR): i32 {
    let result = basics.close(dirp.fd)
    basics.free(dirp)
    return result
}

export fn readdir(dirp: *DIR): *dirent {
    if dirp.buf_pos >= dirp.buf_end {
        let n = basics.getdents(dirp.fd, &dirp.buf, 4096)
        if n <= 0 {
            return null
        }
        dirp.buf_pos = 0
        dirp.buf_end = n as u32
    }

    let entry = (&dirp.buf + dirp.buf_pos) as *dirent
    dirp.buf_pos = dirp.buf_pos + entry.d_reclen as u32
    dirp.tell = entry.d_off

    return entry
}

export fn readdir_r(dirp: *DIR, entry: *dirent, result: **dirent): i32 {
    let ent = readdir(dirp)
    if ent == null {
        *result = null
        return 0
    }

    basics.memcpy(entry, ent, @sizeOf(dirent))
    *result = entry
    return 0
}

export fn rewinddir(dirp: *DIR): void {
    basics.lseek(dirp.fd, 0, 0)  // SEEK_SET
    dirp.buf_pos = 0
    dirp.buf_end = 0
    dirp.tell = 0
}

export fn seekdir(dirp: *DIR, loc: i64): void {
    basics.lseek(dirp.fd, loc, 0)  // SEEK_SET
    dirp.buf_pos = 0
    dirp.buf_end = 0
    dirp.tell = loc
}

export fn telldir(dirp: *DIR): i64 {
    return dirp.tell
}

export fn dirfd(dirp: *DIR): i32 {
    return dirp.fd
}

export fn scandir(dirp: *const u8, namelist: ***dirent, filter: fn(*const dirent): i32, compar: fn(**const dirent, **const dirent): i32): i32 {
    let dir = opendir(dirp)
    if dir == null {
        return -1
    }

    var entries: [1024]*dirent
    var count: i32 = 0

    var entry = readdir(dir)
    while entry != null {
        if filter == null or filter(entry) != 0 {
            let copy = basics.malloc(@sizeOf(dirent)) as *dirent
            if copy == null {
                // Free previously allocated entries
                var i: i32 = 0
                while i < count {
                    basics.free(entries[i as u32])
                    i = i + 1
                }
                closedir(dir)
                return -1
            }
            basics.memcpy(copy, entry, @sizeOf(dirent))
            entries[count as u32] = copy
            count = count + 1
        }
        entry = readdir(dir)
    }

    closedir(dir)

    // Sort if comparator provided
    if compar != null and count > 1 {
        // Simple bubble sort
        var i: i32 = 0
        while i < count - 1 {
            var j: i32 = 0
            while j < count - i - 1 {
                if compar(&entries[j as u32], &entries[(j + 1) as u32]) > 0 {
                    let tmp = entries[j as u32]
                    entries[j as u32] = entries[(j + 1) as u32]
                    entries[(j + 1) as u32] = tmp
                }
                j = j + 1
            }
            i = i + 1
        }
    }

    // Allocate result array
    let result = basics.malloc(count as u32 * @sizeOf(*dirent)) as **dirent
    if result == null {
        var i: i32 = 0
        while i < count {
            basics.free(entries[i as u32])
            i = i + 1
        }
        return -1
    }

    var i: i32 = 0
    while i < count {
        result[i as u32] = entries[i as u32]
        i = i + 1
    }

    *namelist = result
    return count
}

// Standard comparison functions for scandir
export fn alphasort(a: **const dirent, b: **const dirent): i32 {
    return basics.strcmp((*a).d_name, (*b).d_name)
}

export fn versionsort(a: **const dirent, b: **const dirent): i32 {
    return basics.strverscmp((*a).d_name, (*b).d_name)
}
