// HomeOS libc - Standard Library (stdlib.h)
// POSIX-compatible standard library functions

const basics = @import("basics")
const string = @import("string")

// ============================================
// Memory Allocation
// ============================================

export fn malloc(size: u32): *void {
    return basics.malloc(size)
}

export fn calloc(nmemb: u32, size: u32): *void {
    let total = nmemb * size
    let ptr = basics.malloc(total)
    if ptr != null {
        string.memset(ptr, 0, total)
    }
    return ptr
}

export fn realloc(ptr: *void, size: u32): *void {
    if ptr == null {
        return basics.malloc(size)
    }
    if size == 0 {
        basics.free(ptr)
        return null
    }

    let new_ptr = basics.malloc(size)
    if new_ptr != null {
        // Copy old data - we don't know the old size, so copy up to new size
        string.memcpy(new_ptr, ptr, size)
        basics.free(ptr)
    }
    return new_ptr
}

export fn free(ptr: *void): void {
    basics.free(ptr)
}

export fn aligned_alloc(alignment: u32, size: u32): *void {
    // Ensure alignment is power of 2 and size is multiple of alignment
    if alignment == 0 or (alignment & (alignment - 1)) != 0 {
        return null
    }

    // Allocate extra space for alignment
    let total = size + alignment - 1 + @sizeOf(*void)
    let raw = basics.malloc(total)
    if raw == null {
        return null
    }

    // Align the pointer
    let aligned = ((raw as u64 + @sizeOf(*void) + alignment - 1) & ~(alignment as u64 - 1)) as *void

    // Store original pointer before aligned address
    let header = (aligned as *u64) - 1
    *header = raw as u64

    return aligned
}

export fn posix_memalign(memptr: **void, alignment: u32, size: u32): i32 {
    if alignment < @sizeOf(*void) or (alignment & (alignment - 1)) != 0 {
        return 22  // EINVAL
    }

    let ptr = aligned_alloc(alignment, size)
    if ptr == null {
        return 12  // ENOMEM
    }

    *memptr = ptr
    return 0
}

// ============================================
// String to Number Conversion
// ============================================

export fn atoi(str: *const u8): i32 {
    var result: i32 = 0
    var negative: bool = false
    var i: u32 = 0

    // Skip whitespace
    while str[i] == ' ' or str[i] == '\t' or str[i] == '\n' {
        i = i + 1
    }

    // Handle sign
    if str[i] == '-' {
        negative = true
        i = i + 1
    } else if str[i] == '+' {
        i = i + 1
    }

    // Parse digits
    while str[i] >= '0' and str[i] <= '9' {
        result = result * 10 + (str[i] - '0') as i32
        i = i + 1
    }

    return if negative { -result } else { result }
}

export fn atol(str: *const u8): i64 {
    var result: i64 = 0
    var negative: bool = false
    var i: u32 = 0

    while str[i] == ' ' or str[i] == '\t' or str[i] == '\n' {
        i = i + 1
    }

    if str[i] == '-' {
        negative = true
        i = i + 1
    } else if str[i] == '+' {
        i = i + 1
    }

    while str[i] >= '0' and str[i] <= '9' {
        result = result * 10 + (str[i] - '0') as i64
        i = i + 1
    }

    return if negative { -result } else { result }
}

export fn atof(str: *const u8): f64 {
    var result: f64 = 0.0
    var negative: bool = false
    var i: u32 = 0

    while str[i] == ' ' or str[i] == '\t' or str[i] == '\n' {
        i = i + 1
    }

    if str[i] == '-' {
        negative = true
        i = i + 1
    } else if str[i] == '+' {
        i = i + 1
    }

    // Integer part
    while str[i] >= '0' and str[i] <= '9' {
        result = result * 10.0 + (str[i] - '0') as f64
        i = i + 1
    }

    // Fractional part
    if str[i] == '.' {
        i = i + 1
        var fraction: f64 = 0.1
        while str[i] >= '0' and str[i] <= '9' {
            result = result + (str[i] - '0') as f64 * fraction
            fraction = fraction * 0.1
            i = i + 1
        }
    }

    // Exponent
    if str[i] == 'e' or str[i] == 'E' {
        i = i + 1
        var exp_negative: bool = false
        var exp: i32 = 0

        if str[i] == '-' {
            exp_negative = true
            i = i + 1
        } else if str[i] == '+' {
            i = i + 1
        }

        while str[i] >= '0' and str[i] <= '9' {
            exp = exp * 10 + (str[i] - '0') as i32
            i = i + 1
        }

        var multiplier: f64 = 1.0
        var j: i32 = 0
        while j < exp {
            multiplier = multiplier * 10.0
            j = j + 1
        }

        if exp_negative {
            result = result / multiplier
        } else {
            result = result * multiplier
        }
    }

    return if negative { -result } else { result }
}

export fn strtol(str: *const u8, endptr: **u8, base: i32): i64 {
    var result: i64 = 0
    var negative: bool = false
    var i: u32 = 0
    var actual_base = base

    while str[i] == ' ' or str[i] == '\t' or str[i] == '\n' {
        i = i + 1
    }

    if str[i] == '-' {
        negative = true
        i = i + 1
    } else if str[i] == '+' {
        i = i + 1
    }

    // Auto-detect base
    if actual_base == 0 {
        if str[i] == '0' {
            if str[i + 1] == 'x' or str[i + 1] == 'X' {
                actual_base = 16
                i = i + 2
            } else {
                actual_base = 8
                i = i + 1
            }
        } else {
            actual_base = 10
        }
    } else if actual_base == 16 and str[i] == '0' and (str[i + 1] == 'x' or str[i + 1] == 'X') {
        i = i + 2
    }

    while true {
        var digit: i32 = -1

        if str[i] >= '0' and str[i] <= '9' {
            digit = (str[i] - '0') as i32
        } else if str[i] >= 'a' and str[i] <= 'z' {
            digit = (str[i] - 'a' + 10) as i32
        } else if str[i] >= 'A' and str[i] <= 'Z' {
            digit = (str[i] - 'A' + 10) as i32
        }

        if digit < 0 or digit >= actual_base {
            break
        }

        result = result * actual_base as i64 + digit as i64
        i = i + 1
    }

    if endptr != null {
        *endptr = (str + i) as *u8
    }

    return if negative { -result } else { result }
}

export fn strtoul(str: *const u8, endptr: **u8, base: i32): u64 {
    var result: u64 = 0
    var i: u32 = 0
    var actual_base = base

    while str[i] == ' ' or str[i] == '\t' or str[i] == '\n' {
        i = i + 1
    }

    if str[i] == '+' {
        i = i + 1
    }

    if actual_base == 0 {
        if str[i] == '0' {
            if str[i + 1] == 'x' or str[i + 1] == 'X' {
                actual_base = 16
                i = i + 2
            } else {
                actual_base = 8
                i = i + 1
            }
        } else {
            actual_base = 10
        }
    } else if actual_base == 16 and str[i] == '0' and (str[i + 1] == 'x' or str[i + 1] == 'X') {
        i = i + 2
    }

    while true {
        var digit: i32 = -1

        if str[i] >= '0' and str[i] <= '9' {
            digit = (str[i] - '0') as i32
        } else if str[i] >= 'a' and str[i] <= 'z' {
            digit = (str[i] - 'a' + 10) as i32
        } else if str[i] >= 'A' and str[i] <= 'Z' {
            digit = (str[i] - 'A' + 10) as i32
        }

        if digit < 0 or digit >= actual_base {
            break
        }

        result = result * actual_base as u64 + digit as u64
        i = i + 1
    }

    if endptr != null {
        *endptr = (str + i) as *u8
    }

    return result
}

export fn strtod(str: *const u8, endptr: **u8): f64 {
    let result = atof(str)

    if endptr != null {
        // Find end of number
        var i: u32 = 0
        while str[i] == ' ' or str[i] == '\t' or str[i] == '\n' {
            i = i + 1
        }
        if str[i] == '-' or str[i] == '+' {
            i = i + 1
        }
        while str[i] >= '0' and str[i] <= '9' {
            i = i + 1
        }
        if str[i] == '.' {
            i = i + 1
            while str[i] >= '0' and str[i] <= '9' {
                i = i + 1
            }
        }
        if str[i] == 'e' or str[i] == 'E' {
            i = i + 1
            if str[i] == '-' or str[i] == '+' {
                i = i + 1
            }
            while str[i] >= '0' and str[i] <= '9' {
                i = i + 1
            }
        }
        *endptr = (str + i) as *u8
    }

    return result
}

// ============================================
// Number to String Conversion
// ============================================

fn reverse_string(str: *u8, len: u32): void {
    var i: u32 = 0
    var j: u32 = len - 1
    while i < j {
        let tmp = str[i]
        str[i] = str[j]
        str[j] = tmp
        i = i + 1
        j = j - 1
    }
}

export fn itoa(value: i32, str: *u8, base: i32): *u8 {
    var num = value
    var i: u32 = 0
    var negative: bool = false

    if num == 0 {
        str[i] = '0'
        i = i + 1
        str[i] = 0
        return str
    }

    if num < 0 and base == 10 {
        negative = true
        num = -num
    }

    while num != 0 {
        let rem = num % base
        str[i] = if rem > 9 { ('a' + rem - 10) as u8 } else { ('0' + rem) as u8 }
        i = i + 1
        num = num / base
    }

    if negative {
        str[i] = '-'
        i = i + 1
    }

    str[i] = 0
    reverse_string(str, i)

    return str
}

// ============================================
// Random Number Generation
// ============================================

var rand_seed: u32 = 1

export fn srand(seed: u32): void {
    rand_seed = seed
}

export fn rand(): i32 {
    // Linear congruential generator
    rand_seed = rand_seed * 1103515245 + 12345
    return ((rand_seed / 65536) % 32768) as i32
}

export fn rand_r(seedp: *u32): i32 {
    *seedp = *seedp * 1103515245 + 12345
    return ((*seedp / 65536) % 32768) as i32
}

// POSIX random()
var random_state: [32]u32 = [_]u32{0} ** 32
var random_ptr: u32 = 0

export fn srandom(seed: u32): void {
    random_state[0] = seed
    var i: u32 = 1
    while i < 31 {
        random_state[i] = (16807 * random_state[i - 1]) % 2147483647
        i = i + 1
    }
    random_ptr = 0
}

export fn random(): i64 {
    let i = random_ptr
    let j = if random_ptr >= 28 { random_ptr - 28 } else { random_ptr + 3 }

    random_state[i] = random_state[i] + random_state[j]
    let result = (random_state[i] >> 1) as i64

    random_ptr = if random_ptr >= 30 { 0 } else { random_ptr + 1 }

    return result
}

// ============================================
// Sorting and Searching
// ============================================

export fn qsort(base: *void, nmemb: u32, size: u32, compar: fn(*const void, *const void): i32): void {
    if nmemb < 2 {
        return
    }

    // Simple insertion sort for small arrays, quicksort for larger
    if nmemb <= 10 {
        insertion_sort(base, nmemb, size, compar)
    } else {
        quicksort_recursive(base, 0, nmemb - 1, size, compar)
    }
}

fn insertion_sort(base: *void, nmemb: u32, size: u32, compar: fn(*const void, *const void): i32): void {
    let arr = base as *u8
    var temp = basics.malloc(size)

    var i: u32 = 1
    while i < nmemb {
        string.memcpy(temp, arr + i * size, size)

        var j: i32 = i as i32 - 1
        while j >= 0 and compar(arr + j as u32 * size, temp) > 0 {
            string.memcpy(arr + (j as u32 + 1) * size, arr + j as u32 * size, size)
            j = j - 1
        }

        string.memcpy(arr + (j as u32 + 1) * size, temp, size)
        i = i + 1
    }

    basics.free(temp)
}

fn quicksort_recursive(base: *void, low: u32, high: u32, size: u32, compar: fn(*const void, *const void): i32): void {
    if low >= high {
        return
    }

    let arr = base as *u8
    var temp = basics.malloc(size)

    // Partition
    let pivot = arr + high * size
    var i: i32 = low as i32 - 1

    var j: u32 = low
    while j < high {
        if compar(arr + j * size, pivot) <= 0 {
            i = i + 1
            // Swap
            string.memcpy(temp, arr + i as u32 * size, size)
            string.memcpy(arr + i as u32 * size, arr + j * size, size)
            string.memcpy(arr + j * size, temp, size)
        }
        j = j + 1
    }

    // Swap pivot to correct position
    i = i + 1
    string.memcpy(temp, arr + i as u32 * size, size)
    string.memcpy(arr + i as u32 * size, arr + high * size, size)
    string.memcpy(arr + high * size, temp, size)

    basics.free(temp)

    let pivot_idx = i as u32
    if pivot_idx > 0 {
        quicksort_recursive(base, low, pivot_idx - 1, size, compar)
    }
    quicksort_recursive(base, pivot_idx + 1, high, size, compar)
}

export fn bsearch(key: *const void, base: *const void, nmemb: u32, size: u32, compar: fn(*const void, *const void): i32): *void {
    let arr = base as *const u8
    var low: u32 = 0
    var high: u32 = nmemb

    while low < high {
        let mid = low + (high - low) / 2
        let elem = arr + mid * size
        let cmp = compar(key, elem)

        if cmp == 0 {
            return elem as *void
        } else if cmp < 0 {
            high = mid
        } else {
            low = mid + 1
        }
    }

    return null
}

// ============================================
// Environment Variables
// ============================================

var environ: [256]*u8 = [_]*u8{null} ** 256
var environ_count: u32 = 0

export fn getenv(name: *const u8): *u8 {
    let name_len = string.strlen(name)

    var i: u32 = 0
    while i < environ_count {
        if environ[i] != null {
            // Check if starts with name=
            var match: bool = true
            var j: u32 = 0
            while j < name_len {
                if environ[i][j] != name[j] {
                    match = false
                    break
                }
                j = j + 1
            }

            if match and environ[i][name_len] == '=' {
                return environ[i] + name_len + 1
            }
        }
        i = i + 1
    }

    return null
}

export fn setenv(name: *const u8, value: *const u8, overwrite: i32): i32 {
    let name_len = string.strlen(name)
    let value_len = string.strlen(value)

    // Check if already exists
    var i: u32 = 0
    while i < environ_count {
        if environ[i] != null {
            var match: bool = true
            var j: u32 = 0
            while j < name_len {
                if environ[i][j] != name[j] {
                    match = false
                    break
                }
                j = j + 1
            }

            if match and environ[i][name_len] == '=' {
                if overwrite == 0 {
                    return 0
                }

                // Replace value
                basics.free(environ[i])
                environ[i] = basics.malloc(name_len + 1 + value_len + 1) as *u8
                string.strcpy(environ[i], name)
                environ[i][name_len] = '='
                string.strcpy(environ[i] + name_len + 1, value)
                return 0
            }
        }
        i = i + 1
    }

    // Add new entry
    if environ_count >= 256 {
        return -1
    }

    environ[environ_count] = basics.malloc(name_len + 1 + value_len + 1) as *u8
    string.strcpy(environ[environ_count], name)
    environ[environ_count][name_len] = '='
    string.strcpy(environ[environ_count] + name_len + 1, value)
    environ_count = environ_count + 1

    return 0
}

export fn unsetenv(name: *const u8): i32 {
    let name_len = string.strlen(name)

    var i: u32 = 0
    while i < environ_count {
        if environ[i] != null {
            var match: bool = true
            var j: u32 = 0
            while j < name_len {
                if environ[i][j] != name[j] {
                    match = false
                    break
                }
                j = j + 1
            }

            if match and environ[i][name_len] == '=' {
                basics.free(environ[i])
                // Shift remaining entries
                while i < environ_count - 1 {
                    environ[i] = environ[i + 1]
                    i = i + 1
                }
                environ[environ_count - 1] = null
                environ_count = environ_count - 1
                return 0
            }
        }
        i = i + 1
    }

    return 0
}

export fn putenv(str: *u8): i32 {
    // Find '='
    var i: u32 = 0
    while str[i] != 0 and str[i] != '=' {
        i = i + 1
    }

    if str[i] != '=' {
        return -1
    }

    // Add to environment (takes ownership)
    if environ_count >= 256 {
        return -1
    }

    environ[environ_count] = str
    environ_count = environ_count + 1

    return 0
}

// ============================================
// Program Execution
// ============================================

export fn exit(status: i32): never {
    basics.exit(status)
}

export fn _Exit(status: i32): never {
    basics.exit(status)
}

export fn abort(): never {
    // Send SIGABRT
    basics.abort()
}

var atexit_funcs: [32]fn(): void = [_]fn(): void{null} ** 32
var atexit_count: u32 = 0

export fn atexit(func: fn(): void): i32 {
    if atexit_count >= 32 {
        return -1
    }

    atexit_funcs[atexit_count] = func
    atexit_count = atexit_count + 1

    return 0
}

export fn system(command: *const u8): i32 {
    if command == null {
        return 1  // Shell is available
    }

    return basics.system(command)
}

// ============================================
// Absolute Value
// ============================================

export fn abs(j: i32): i32 {
    return if j < 0 { -j } else { j }
}

export fn labs(j: i64): i64 {
    return if j < 0 { -j } else { j }
}

export fn llabs(j: i64): i64 {
    return if j < 0 { -j } else { j }
}

// ============================================
// Division
// ============================================

struct div_t {
    quot: i32
    rem: i32
}

struct ldiv_t {
    quot: i64
    rem: i64
}

export fn div(numer: i32, denom: i32): div_t {
    return div_t{
        quot: numer / denom,
        rem: numer % denom
    }
}

export fn ldiv(numer: i64, denom: i64): ldiv_t {
    return ldiv_t{
        quot: numer / denom,
        rem: numer % denom
    }
}

// ============================================
// Multibyte/Wide Character Conversion
// ============================================

export fn mblen(s: *const u8, n: u32): i32 {
    if s == null {
        return 0  // Stateless encoding
    }

    if n == 0 or s[0] == 0 {
        return 0
    }

    // UTF-8 length detection
    if (s[0] & 0x80) == 0 {
        return 1  // ASCII
    } else if (s[0] & 0xE0) == 0xC0 {
        return 2  // 2-byte
    } else if (s[0] & 0xF0) == 0xE0 {
        return 3  // 3-byte
    } else if (s[0] & 0xF8) == 0xF0 {
        return 4  // 4-byte
    }

    return -1  // Invalid
}

export fn mbtowc(pwc: *u32, s: *const u8, n: u32): i32 {
    if s == null {
        return 0
    }

    if n == 0 or s[0] == 0 {
        if pwc != null {
            *pwc = 0
        }
        return 0
    }

    // UTF-8 decoding
    if (s[0] & 0x80) == 0 {
        if pwc != null {
            *pwc = s[0] as u32
        }
        return 1
    } else if (s[0] & 0xE0) == 0xC0 and n >= 2 {
        if pwc != null {
            *pwc = ((s[0] & 0x1F) as u32 << 6) | (s[1] & 0x3F) as u32
        }
        return 2
    } else if (s[0] & 0xF0) == 0xE0 and n >= 3 {
        if pwc != null {
            *pwc = ((s[0] & 0x0F) as u32 << 12) | ((s[1] & 0x3F) as u32 << 6) | (s[2] & 0x3F) as u32
        }
        return 3
    } else if (s[0] & 0xF8) == 0xF0 and n >= 4 {
        if pwc != null {
            *pwc = ((s[0] & 0x07) as u32 << 18) | ((s[1] & 0x3F) as u32 << 12) | ((s[2] & 0x3F) as u32 << 6) | (s[3] & 0x3F) as u32
        }
        return 4
    }

    return -1
}

export fn wctomb(s: *u8, wchar: u32): i32 {
    if s == null {
        return 0
    }

    // UTF-8 encoding
    if wchar < 0x80 {
        s[0] = wchar as u8
        return 1
    } else if wchar < 0x800 {
        s[0] = (0xC0 | (wchar >> 6)) as u8
        s[1] = (0x80 | (wchar & 0x3F)) as u8
        return 2
    } else if wchar < 0x10000 {
        s[0] = (0xE0 | (wchar >> 12)) as u8
        s[1] = (0x80 | ((wchar >> 6) & 0x3F)) as u8
        s[2] = (0x80 | (wchar & 0x3F)) as u8
        return 3
    } else if wchar < 0x110000 {
        s[0] = (0xF0 | (wchar >> 18)) as u8
        s[1] = (0x80 | ((wchar >> 12) & 0x3F)) as u8
        s[2] = (0x80 | ((wchar >> 6) & 0x3F)) as u8
        s[3] = (0x80 | (wchar & 0x3F)) as u8
        return 4
    }

    return -1
}
