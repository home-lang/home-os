// HomeOS libc - Math Library (math.h)
// POSIX-compatible mathematical functions

// ============================================
// Constants
// ============================================

export const M_E: f64 = 2.71828182845904523536
export const M_LOG2E: f64 = 1.44269504088896340736
export const M_LOG10E: f64 = 0.43429448190325182765
export const M_LN2: f64 = 0.69314718055994530942
export const M_LN10: f64 = 2.30258509299404568402
export const M_PI: f64 = 3.14159265358979323846
export const M_PI_2: f64 = 1.57079632679489661923
export const M_PI_4: f64 = 0.78539816339744830962
export const M_1_PI: f64 = 0.31830988618379067154
export const M_2_PI: f64 = 0.63661977236758134308
export const M_2_SQRTPI: f64 = 1.12837916709551257390
export const M_SQRT2: f64 = 1.41421356237309504880
export const M_SQRT1_2: f64 = 0.70710678118654752440

const INFINITY: f64 = 1.0 / 0.0
const NAN: f64 = 0.0 / 0.0

// ============================================
// Basic Operations
// ============================================

export fn fabs(x: f64): f64 {
    return if x < 0.0 { -x } else { x }
}

export fn fabsf(x: f32): f32 {
    return if x < 0.0 { -x } else { x }
}

export fn fmod(x: f64, y: f64): f64 {
    if y == 0.0 {
        return NAN
    }
    let quotient = x / y
    let truncated = if quotient >= 0.0 {
        floor(quotient)
    } else {
        ceil(quotient)
    }
    return x - truncated * y
}

export fn fmodf(x: f32, y: f32): f32 {
    return fmod(x as f64, y as f64) as f32
}

export fn remainder(x: f64, y: f64): f64 {
    if y == 0.0 {
        return NAN
    }
    let quotient = x / y
    let n = round(quotient)
    return x - n * y
}

export fn copysign(x: f64, y: f64): f64 {
    let abs_x = fabs(x)
    return if y < 0.0 { -abs_x } else { abs_x }
}

export fn copysignf(x: f32, y: f32): f32 {
    let abs_x = fabsf(x)
    return if y < 0.0 { -abs_x } else { abs_x }
}

// ============================================
// Rounding Functions
// ============================================

export fn floor(x: f64): f64 {
    let int_part = x as i64
    if x >= 0.0 or x == int_part as f64 {
        return int_part as f64
    }
    return (int_part - 1) as f64
}

export fn floorf(x: f32): f32 {
    return floor(x as f64) as f32
}

export fn ceil(x: f64): f64 {
    let int_part = x as i64
    if x <= 0.0 or x == int_part as f64 {
        return int_part as f64
    }
    return (int_part + 1) as f64
}

export fn ceilf(x: f32): f32 {
    return ceil(x as f64) as f32
}

export fn trunc(x: f64): f64 {
    return (x as i64) as f64
}

export fn truncf(x: f32): f32 {
    return (x as i32) as f32
}

export fn round(x: f64): f64 {
    if x >= 0.0 {
        return floor(x + 0.5)
    } else {
        return ceil(x - 0.5)
    }
}

export fn roundf(x: f32): f32 {
    return round(x as f64) as f32
}

export fn rint(x: f64): f64 {
    // Round to nearest even
    let rounded = round(x)
    let diff = fabs(x - rounded)

    if diff == 0.5 {
        let int_val = rounded as i64
        if int_val % 2 != 0 {
            return if x > 0.0 { rounded - 1.0 } else { rounded + 1.0 }
        }
    }

    return rounded
}

export fn nearbyint(x: f64): f64 {
    return rint(x)
}

export fn modf(x: f64, iptr: *f64): f64 {
    let int_part = trunc(x)
    *iptr = int_part
    return x - int_part
}

// ============================================
// Power and Logarithmic Functions
// ============================================

export fn sqrt(x: f64): f64 {
    if x < 0.0 {
        return NAN
    }
    if x == 0.0 {
        return 0.0
    }

    // Newton-Raphson method
    var guess = x / 2.0
    var prev: f64 = 0.0
    var i: i32 = 0

    while i < 100 {
        prev = guess
        guess = (guess + x / guess) / 2.0
        if fabs(guess - prev) < 1e-15 {
            break
        }
        i = i + 1
    }

    return guess
}

export fn sqrtf(x: f32): f32 {
    return sqrt(x as f64) as f32
}

export fn cbrt(x: f64): f64 {
    if x == 0.0 {
        return 0.0
    }

    let negative = x < 0.0
    let abs_x = fabs(x)

    // Newton-Raphson for cube root
    var guess = abs_x / 3.0
    var i: i32 = 0

    while i < 100 {
        let prev = guess
        guess = (2.0 * guess + abs_x / (guess * guess)) / 3.0
        if fabs(guess - prev) < 1e-15 {
            break
        }
        i = i + 1
    }

    return if negative { -guess } else { guess }
}

export fn hypot(x: f64, y: f64): f64 {
    return sqrt(x * x + y * y)
}

export fn pow(base: f64, exp: f64): f64 {
    if exp == 0.0 {
        return 1.0
    }
    if base == 0.0 {
        return if exp > 0.0 { 0.0 } else { INFINITY }
    }
    if base < 0.0 {
        // Check if exponent is integer
        let int_exp = exp as i64
        if exp != int_exp as f64 {
            return NAN
        }
        let result = exp_impl(exp * log_impl(fabs(base)))
        return if int_exp % 2 == 0 { result } else { -result }
    }

    return exp_impl(exp * log_impl(base))
}

export fn powf(base: f32, exp: f32): f32 {
    return pow(base as f64, exp as f64) as f32
}

fn exp_impl(x: f64): f64 {
    if x == 0.0 {
        return 1.0
    }
    if x > 709.0 {
        return INFINITY
    }
    if x < -709.0 {
        return 0.0
    }

    // Range reduction: e^x = 2^k * e^r where r = x - k*ln(2)
    let k = round(x / M_LN2)
    let r = x - k * M_LN2

    // Taylor series for e^r
    var result: f64 = 1.0
    var term: f64 = 1.0
    var i: i32 = 1

    while i < 30 {
        term = term * r / i as f64
        result = result + term
        if fabs(term) < 1e-15 {
            break
        }
        i = i + 1
    }

    // Multiply by 2^k
    let k_int = k as i32
    if k_int > 0 {
        var j: i32 = 0
        while j < k_int {
            result = result * 2.0
            j = j + 1
        }
    } else if k_int < 0 {
        var j: i32 = 0
        while j < -k_int {
            result = result / 2.0
            j = j + 1
        }
    }

    return result
}

export fn exp(x: f64): f64 {
    return exp_impl(x)
}

export fn expf(x: f32): f32 {
    return exp(x as f64) as f32
}

export fn exp2(x: f64): f64 {
    return pow(2.0, x)
}

export fn expm1(x: f64): f64 {
    // More accurate for small x
    if fabs(x) < 1e-5 {
        return x + x * x / 2.0 + x * x * x / 6.0
    }
    return exp(x) - 1.0
}

fn log_impl(x: f64): f64 {
    if x <= 0.0 {
        return if x == 0.0 { -INFINITY } else { NAN }
    }
    if x == 1.0 {
        return 0.0
    }

    // Range reduction: x = 2^k * m where 1 <= m < 2
    var k: i32 = 0
    var m = x

    while m >= 2.0 {
        m = m / 2.0
        k = k + 1
    }
    while m < 1.0 {
        m = m * 2.0
        k = k - 1
    }

    // ln(x) = k*ln(2) + ln(m)
    // Use series for ln(1 + y) where y = m - 1
    let y = m - 1.0
    var result: f64 = 0.0
    var term = y
    var i: i32 = 1

    while i < 100 {
        result = result + term / i as f64
        term = -term * y
        if fabs(term / i as f64) < 1e-15 {
            break
        }
        i = i + 1
    }

    return k as f64 * M_LN2 + result
}

export fn log(x: f64): f64 {
    return log_impl(x)
}

export fn logf(x: f32): f32 {
    return log(x as f64) as f32
}

export fn log10(x: f64): f64 {
    return log(x) / M_LN10
}

export fn log10f(x: f32): f32 {
    return log10(x as f64) as f32
}

export fn log2(x: f64): f64 {
    return log(x) / M_LN2
}

export fn log2f(x: f32): f32 {
    return log2(x as f64) as f32
}

export fn log1p(x: f64): f64 {
    // More accurate for small x
    if fabs(x) < 1e-5 {
        return x - x * x / 2.0 + x * x * x / 3.0
    }
    return log(1.0 + x)
}

export fn logb(x: f64): f64 {
    if x == 0.0 {
        return -INFINITY
    }

    var abs_x = fabs(x)
    var exp: i32 = 0

    while abs_x >= 2.0 {
        abs_x = abs_x / 2.0
        exp = exp + 1
    }
    while abs_x < 1.0 {
        abs_x = abs_x * 2.0
        exp = exp - 1
    }

    return exp as f64
}

export fn ilogb(x: f64): i32 {
    return logb(x) as i32
}

export fn ldexp(x: f64, exp: i32): f64 {
    var result = x
    if exp > 0 {
        var i: i32 = 0
        while i < exp {
            result = result * 2.0
            i = i + 1
        }
    } else if exp < 0 {
        var i: i32 = 0
        while i < -exp {
            result = result / 2.0
            i = i + 1
        }
    }
    return result
}

export fn scalbn(x: f64, n: i32): f64 {
    return ldexp(x, n)
}

export fn frexp(x: f64, exp: *i32): f64 {
    if x == 0.0 {
        *exp = 0
        return 0.0
    }

    var abs_x = fabs(x)
    var e: i32 = 0

    while abs_x >= 1.0 {
        abs_x = abs_x / 2.0
        e = e + 1
    }
    while abs_x < 0.5 {
        abs_x = abs_x * 2.0
        e = e - 1
    }

    *exp = e
    return if x < 0.0 { -abs_x } else { abs_x }
}

// ============================================
// Trigonometric Functions
// ============================================

fn reduce_angle(x: f64): f64 {
    // Reduce angle to [-pi, pi]
    let two_pi = 2.0 * M_PI
    var result = fmod(x, two_pi)

    if result > M_PI {
        result = result - two_pi
    } else if result < -M_PI {
        result = result + two_pi
    }

    return result
}

export fn sin(x: f64): f64 {
    let reduced = reduce_angle(x)

    // Taylor series for sin
    var result: f64 = 0.0
    var term = reduced
    var i: i32 = 1

    while i < 30 {
        result = result + term
        term = -term * reduced * reduced / ((2 * i) as f64 * (2 * i + 1) as f64)
        if fabs(term) < 1e-15 {
            break
        }
        i = i + 1
    }

    return result
}

export fn sinf(x: f32): f32 {
    return sin(x as f64) as f32
}

export fn cos(x: f64): f64 {
    let reduced = reduce_angle(x)

    // Taylor series for cos
    var result: f64 = 1.0
    var term: f64 = 1.0
    var i: i32 = 1

    while i < 30 {
        term = -term * reduced * reduced / ((2 * i - 1) as f64 * (2 * i) as f64)
        result = result + term
        if fabs(term) < 1e-15 {
            break
        }
        i = i + 1
    }

    return result
}

export fn cosf(x: f32): f32 {
    return cos(x as f64) as f32
}

export fn tan(x: f64): f64 {
    let c = cos(x)
    if fabs(c) < 1e-15 {
        return if sin(x) > 0.0 { INFINITY } else { -INFINITY }
    }
    return sin(x) / c
}

export fn tanf(x: f32): f32 {
    return tan(x as f64) as f32
}

export fn sincos(x: f64, sin_val: *f64, cos_val: *f64): void {
    *sin_val = sin(x)
    *cos_val = cos(x)
}

// ============================================
// Inverse Trigonometric Functions
// ============================================

export fn asin(x: f64): f64 {
    if x < -1.0 or x > 1.0 {
        return NAN
    }
    if x == 1.0 {
        return M_PI_2
    }
    if x == -1.0 {
        return -M_PI_2
    }

    // Use atan2 for better accuracy
    return atan2(x, sqrt(1.0 - x * x))
}

export fn asinf(x: f32): f32 {
    return asin(x as f64) as f32
}

export fn acos(x: f64): f64 {
    if x < -1.0 or x > 1.0 {
        return NAN
    }
    return M_PI_2 - asin(x)
}

export fn acosf(x: f32): f32 {
    return acos(x as f64) as f32
}

export fn atan(x: f64): f64 {
    // Range reduction
    if x > 1.0 {
        return M_PI_2 - atan(1.0 / x)
    }
    if x < -1.0 {
        return -M_PI_2 - atan(1.0 / x)
    }

    // Taylor series for atan
    var result: f64 = 0.0
    var term = x
    var i: i32 = 0

    while i < 50 {
        let sign = if i % 2 == 0 { 1.0 } else { -1.0 }
        result = result + sign * term / (2 * i + 1) as f64
        term = term * x * x
        if fabs(term / (2 * i + 3) as f64) < 1e-15 {
            break
        }
        i = i + 1
    }

    return result
}

export fn atanf(x: f32): f32 {
    return atan(x as f64) as f32
}

export fn atan2(y: f64, x: f64): f64 {
    if x == 0.0 {
        if y > 0.0 {
            return M_PI_2
        }
        if y < 0.0 {
            return -M_PI_2
        }
        return 0.0  // Both zero
    }

    let angle = atan(y / x)

    if x > 0.0 {
        return angle
    }
    if y >= 0.0 {
        return angle + M_PI
    }
    return angle - M_PI
}

export fn atan2f(y: f32, x: f32): f32 {
    return atan2(y as f64, x as f64) as f32
}

// ============================================
// Hyperbolic Functions
// ============================================

export fn sinh(x: f64): f64 {
    if fabs(x) < 1e-5 {
        return x + x * x * x / 6.0
    }
    let ex = exp(x)
    return (ex - 1.0 / ex) / 2.0
}

export fn sinhf(x: f32): f32 {
    return sinh(x as f64) as f32
}

export fn cosh(x: f64): f64 {
    let ex = exp(x)
    return (ex + 1.0 / ex) / 2.0
}

export fn coshf(x: f32): f32 {
    return cosh(x as f64) as f32
}

export fn tanh(x: f64): f64 {
    if x > 20.0 {
        return 1.0
    }
    if x < -20.0 {
        return -1.0
    }
    let e2x = exp(2.0 * x)
    return (e2x - 1.0) / (e2x + 1.0)
}

export fn tanhf(x: f32): f32 {
    return tanh(x as f64) as f32
}

export fn asinh(x: f64): f64 {
    return log(x + sqrt(x * x + 1.0))
}

export fn acosh(x: f64): f64 {
    if x < 1.0 {
        return NAN
    }
    return log(x + sqrt(x * x - 1.0))
}

export fn atanh(x: f64): f64 {
    if fabs(x) >= 1.0 {
        return if x == 1.0 { INFINITY } else if x == -1.0 { -INFINITY } else { NAN }
    }
    return 0.5 * log((1.0 + x) / (1.0 - x))
}

// ============================================
// Special Functions
// ============================================

export fn erf(x: f64): f64 {
    // Approximation using Horner's method
    let t = 1.0 / (1.0 + 0.5 * fabs(x))

    let tau = t * exp(-x * x - 1.26551223 +
        t * (1.00002368 +
        t * (0.37409196 +
        t * (0.09678418 +
        t * (-0.18628806 +
        t * (0.27886807 +
        t * (-1.13520398 +
        t * (1.48851587 +
        t * (-0.82215223 +
        t * 0.17087277)))))))))

    return if x >= 0.0 { 1.0 - tau } else { tau - 1.0 }
}

export fn erfc(x: f64): f64 {
    return 1.0 - erf(x)
}

export fn tgamma(x: f64): f64 {
    // Lanczos approximation
    if x <= 0.0 {
        let int_x = x as i64
        if x == int_x as f64 {
            return INFINITY  // Pole at negative integers
        }
        // Reflection formula
        return M_PI / (sin(M_PI * x) * tgamma(1.0 - x))
    }

    if x < 0.5 {
        return M_PI / (sin(M_PI * x) * tgamma(1.0 - x))
    }

    let g: f64 = 7.0
    let coefficients = [_]f64{
        0.99999999999980993,
        676.5203681218851,
        -1259.1392167224028,
        771.32342877765313,
        -176.61502916214059,
        12.507343278686905,
        -0.13857109526572012,
        9.9843695780195716e-6,
        1.5056327351493116e-7
    }

    let z = x - 1.0
    var sum = coefficients[0]
    var i: u32 = 1
    while i < 9 {
        sum = sum + coefficients[i] / (z + i as f64)
        i = i + 1
    }

    let t = z + g + 0.5
    return sqrt(2.0 * M_PI) * pow(t, z + 0.5) * exp(-t) * sum
}

export fn lgamma(x: f64): f64 {
    return log(fabs(tgamma(x)))
}

// ============================================
// Min/Max Functions
// ============================================

export fn fmin(x: f64, y: f64): f64 {
    return if x < y { x } else { y }
}

export fn fminf(x: f32, y: f32): f32 {
    return if x < y { x } else { y }
}

export fn fmax(x: f64, y: f64): f64 {
    return if x > y { x } else { y }
}

export fn fmaxf(x: f32, y: f32): f32 {
    return if x > y { x } else { y }
}

export fn fdim(x: f64, y: f64): f64 {
    return if x > y { x - y } else { 0.0 }
}

// ============================================
// Classification Functions
// ============================================

export fn isnan(x: f64): i32 {
    return if x != x { 1 } else { 0 }
}

export fn isinf(x: f64): i32 {
    if x == INFINITY {
        return 1
    }
    if x == -INFINITY {
        return -1
    }
    return 0
}

export fn isfinite(x: f64): i32 {
    return if isnan(x) == 0 and isinf(x) == 0 { 1 } else { 0 }
}

export fn isnormal(x: f64): i32 {
    return if isfinite(x) != 0 and x != 0.0 { 1 } else { 0 }
}

export fn signbit(x: f64): i32 {
    return if x < 0.0 { 1 } else { 0 }
}

export fn nan(tagp: *const u8): f64 {
    return NAN
}

// ============================================
// Fused Multiply-Add
// ============================================

export fn fma(x: f64, y: f64, z: f64): f64 {
    return x * y + z
}

export fn fmaf(x: f32, y: f32, z: f32): f32 {
    return x * y + z
}
