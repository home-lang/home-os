// HomeOS libc - POSIX System Calls (unistd.h)
// POSIX-compatible system call wrappers

const basics = @import("basics")
const string = @import("string")
const errno = @import("errno")

// ============================================
// Constants
// ============================================

// Standard file descriptors
export const STDIN_FILENO: i32 = 0
export const STDOUT_FILENO: i32 = 1
export const STDERR_FILENO: i32 = 2

// Seek constants
export const SEEK_SET: i32 = 0
export const SEEK_CUR: i32 = 1
export const SEEK_END: i32 = 2

// Access mode constants
export const F_OK: i32 = 0  // Existence test
export const X_OK: i32 = 1  // Execute permission
export const W_OK: i32 = 2  // Write permission
export const R_OK: i32 = 4  // Read permission

// File type constants for pathconf/fpathconf
export const _PC_LINK_MAX: i32 = 0
export const _PC_MAX_CANON: i32 = 1
export const _PC_MAX_INPUT: i32 = 2
export const _PC_NAME_MAX: i32 = 3
export const _PC_PATH_MAX: i32 = 4
export const _PC_PIPE_BUF: i32 = 5
export const _PC_CHOWN_RESTRICTED: i32 = 6
export const _PC_NO_TRUNC: i32 = 7
export const _PC_VDISABLE: i32 = 8

// sysconf constants
export const _SC_ARG_MAX: i32 = 0
export const _SC_CHILD_MAX: i32 = 1
export const _SC_CLK_TCK: i32 = 2
export const _SC_NGROUPS_MAX: i32 = 3
export const _SC_OPEN_MAX: i32 = 4
export const _SC_STREAM_MAX: i32 = 5
export const _SC_TZNAME_MAX: i32 = 6
export const _SC_PAGE_SIZE: i32 = 30
export const _SC_PAGESIZE: i32 = _SC_PAGE_SIZE
export const _SC_NPROCESSORS_CONF: i32 = 83
export const _SC_NPROCESSORS_ONLN: i32 = 84
export const _SC_PHYS_PAGES: i32 = 85

// ============================================
// Process Control
// ============================================

export fn fork(): i32 {
    return basics.fork()
}

export fn vfork(): i32 {
    return basics.vfork()
}

export fn execve(pathname: *const u8, argv: **const u8, envp: **const u8): i32 {
    return basics.execve(pathname, argv, envp)
}

export fn execv(pathname: *const u8, argv: **const u8): i32 {
    return basics.execv(pathname, argv)
}

export fn execvp(file: *const u8, argv: **const u8): i32 {
    return basics.execvp(file, argv)
}

export fn execl(pathname: *const u8, arg: *const u8, ...): i32 {
    // Variadic - build argv array
    return basics.execl(pathname, arg)
}

export fn execlp(file: *const u8, arg: *const u8, ...): i32 {
    return basics.execlp(file, arg)
}

export fn _exit(status: i32): never {
    basics.exit(status)
}

export fn getpid(): i32 {
    return basics.getpid()
}

export fn getppid(): i32 {
    return basics.getppid()
}

export fn getpgrp(): i32 {
    return basics.getpgrp()
}

export fn setpgid(pid: i32, pgid: i32): i32 {
    return basics.setpgid(pid, pgid)
}

export fn getpgid(pid: i32): i32 {
    return basics.getpgid(pid)
}

export fn setsid(): i32 {
    return basics.setsid()
}

export fn getsid(pid: i32): i32 {
    return basics.getsid(pid)
}

// ============================================
// User/Group ID
// ============================================

export fn getuid(): u32 {
    return basics.getuid()
}

export fn geteuid(): u32 {
    return basics.geteuid()
}

export fn getgid(): u32 {
    return basics.getgid()
}

export fn getegid(): u32 {
    return basics.getegid()
}

export fn setuid(uid: u32): i32 {
    return basics.setuid(uid)
}

export fn seteuid(uid: u32): i32 {
    return basics.seteuid(uid)
}

export fn setgid(gid: u32): i32 {
    return basics.setgid(gid)
}

export fn setegid(gid: u32): i32 {
    return basics.setegid(gid)
}

export fn setreuid(ruid: u32, euid: u32): i32 {
    return basics.setreuid(ruid, euid)
}

export fn setregid(rgid: u32, egid: u32): i32 {
    return basics.setregid(rgid, egid)
}

export fn getgroups(size: i32, list: *u32): i32 {
    return basics.getgroups(size, list)
}

export fn setgroups(size: u32, list: *const u32): i32 {
    return basics.setgroups(size, list)
}

export fn getlogin(): *u8 {
    return basics.getlogin()
}

export fn getlogin_r(buf: *u8, bufsize: u32): i32 {
    let login = basics.getlogin()
    if login == null {
        return errno.ENOENT
    }
    let len = string.strlen(login)
    if len >= bufsize {
        return errno.ERANGE
    }
    string.strcpy(buf, login)
    return 0
}

// ============================================
// File Operations
// ============================================

export fn read(fd: i32, buf: *void, count: u32): i64 {
    return basics.read(fd, buf, count)
}

export fn write(fd: i32, buf: *const void, count: u32): i64 {
    return basics.write(fd, buf, count)
}

export fn pread(fd: i32, buf: *void, count: u32, offset: i64): i64 {
    return basics.pread(fd, buf, count, offset)
}

export fn pwrite(fd: i32, buf: *const void, count: u32, offset: i64): i64 {
    return basics.pwrite(fd, buf, count, offset)
}

export fn close(fd: i32): i32 {
    return basics.close(fd)
}

export fn lseek(fd: i32, offset: i64, whence: i32): i64 {
    return basics.lseek(fd, offset, whence)
}

export fn dup(oldfd: i32): i32 {
    return basics.dup(oldfd)
}

export fn dup2(oldfd: i32, newfd: i32): i32 {
    return basics.dup2(oldfd, newfd)
}

export fn dup3(oldfd: i32, newfd: i32, flags: i32): i32 {
    return basics.dup3(oldfd, newfd, flags)
}

export fn pipe(pipefd: *[2]i32): i32 {
    return basics.pipe(pipefd)
}

export fn pipe2(pipefd: *[2]i32, flags: i32): i32 {
    return basics.pipe2(pipefd, flags)
}

export fn fsync(fd: i32): i32 {
    return basics.fsync(fd)
}

export fn fdatasync(fd: i32): i32 {
    return basics.fdatasync(fd)
}

export fn syncfs(fd: i32): i32 {
    return basics.syncfs(fd)
}

export fn sync(): void {
    basics.sync()
}

export fn truncate(path: *const u8, length: i64): i32 {
    return basics.truncate(path, length)
}

export fn ftruncate(fd: i32, length: i64): i32 {
    return basics.ftruncate(fd, length)
}

// ============================================
// File System Operations
// ============================================

export fn access(pathname: *const u8, mode: i32): i32 {
    return basics.access(pathname, mode)
}

export fn faccessat(dirfd: i32, pathname: *const u8, mode: i32, flags: i32): i32 {
    return basics.faccessat(dirfd, pathname, mode, flags)
}

export fn chdir(path: *const u8): i32 {
    return basics.chdir(path)
}

export fn fchdir(fd: i32): i32 {
    return basics.fchdir(fd)
}

export fn getcwd(buf: *u8, size: u32): *u8 {
    return basics.getcwd(buf, size)
}

export fn link(oldpath: *const u8, newpath: *const u8): i32 {
    return basics.link(oldpath, newpath)
}

export fn linkat(olddirfd: i32, oldpath: *const u8, newdirfd: i32, newpath: *const u8, flags: i32): i32 {
    return basics.linkat(olddirfd, oldpath, newdirfd, newpath, flags)
}

export fn unlink(pathname: *const u8): i32 {
    return basics.unlink(pathname)
}

export fn unlinkat(dirfd: i32, pathname: *const u8, flags: i32): i32 {
    return basics.unlinkat(dirfd, pathname, flags)
}

export fn rmdir(pathname: *const u8): i32 {
    return basics.rmdir(pathname)
}

export fn symlink(target: *const u8, linkpath: *const u8): i32 {
    return basics.symlink(target, linkpath)
}

export fn symlinkat(target: *const u8, newdirfd: i32, linkpath: *const u8): i32 {
    return basics.symlinkat(target, newdirfd, linkpath)
}

export fn readlink(pathname: *const u8, buf: *u8, bufsiz: u32): i64 {
    return basics.readlink(pathname, buf, bufsiz)
}

export fn readlinkat(dirfd: i32, pathname: *const u8, buf: *u8, bufsiz: u32): i64 {
    return basics.readlinkat(dirfd, pathname, buf, bufsiz)
}

export fn rename(oldpath: *const u8, newpath: *const u8): i32 {
    return basics.rename(oldpath, newpath)
}

export fn renameat(olddirfd: i32, oldpath: *const u8, newdirfd: i32, newpath: *const u8): i32 {
    return basics.renameat(olddirfd, oldpath, newdirfd, newpath)
}

export fn chown(pathname: *const u8, owner: u32, group: u32): i32 {
    return basics.chown(pathname, owner, group)
}

export fn fchown(fd: i32, owner: u32, group: u32): i32 {
    return basics.fchown(fd, owner, group)
}

export fn lchown(pathname: *const u8, owner: u32, group: u32): i32 {
    return basics.lchown(pathname, owner, group)
}

export fn fchownat(dirfd: i32, pathname: *const u8, owner: u32, group: u32, flags: i32): i32 {
    return basics.fchownat(dirfd, pathname, owner, group, flags)
}

// ============================================
// Terminal Control
// ============================================

export fn isatty(fd: i32): i32 {
    return basics.isatty(fd)
}

export fn ttyname(fd: i32): *u8 {
    return basics.ttyname(fd)
}

export fn ttyname_r(fd: i32, buf: *u8, buflen: u32): i32 {
    let name = basics.ttyname(fd)
    if name == null {
        return errno.ENOTTY
    }
    let len = string.strlen(name)
    if len >= buflen {
        return errno.ERANGE
    }
    string.strcpy(buf, name)
    return 0
}

export fn tcgetpgrp(fd: i32): i32 {
    return basics.tcgetpgrp(fd)
}

export fn tcsetpgrp(fd: i32, pgrp: i32): i32 {
    return basics.tcsetpgrp(fd, pgrp)
}

// ============================================
// System Information
// ============================================

export fn gethostname(name: *u8, len: u32): i32 {
    return basics.gethostname(name, len)
}

export fn sethostname(name: *const u8, len: u32): i32 {
    return basics.sethostname(name, len)
}

export fn getdomainname(name: *u8, len: u32): i32 {
    return basics.getdomainname(name, len)
}

export fn setdomainname(name: *const u8, len: u32): i32 {
    return basics.setdomainname(name, len)
}

export fn sysconf(name: i32): i64 {
    switch name {
        _SC_ARG_MAX => return 131072
        _SC_CHILD_MAX => return 32768
        _SC_CLK_TCK => return 100
        _SC_NGROUPS_MAX => return 65536
        _SC_OPEN_MAX => return 1024
        _SC_STREAM_MAX => return 16
        _SC_TZNAME_MAX => return 6
        _SC_PAGE_SIZE => return 4096
        _SC_NPROCESSORS_CONF => return basics.get_nprocs_conf()
        _SC_NPROCESSORS_ONLN => return basics.get_nprocs()
        _SC_PHYS_PAGES => return basics.get_phys_pages()
        else => return -1
    }
}

export fn pathconf(path: *const u8, name: i32): i64 {
    switch name {
        _PC_LINK_MAX => return 127
        _PC_MAX_CANON => return 255
        _PC_MAX_INPUT => return 255
        _PC_NAME_MAX => return 255
        _PC_PATH_MAX => return 4096
        _PC_PIPE_BUF => return 4096
        _PC_CHOWN_RESTRICTED => return 1
        _PC_NO_TRUNC => return 1
        _PC_VDISABLE => return 0
        else => return -1
    }
}

export fn fpathconf(fd: i32, name: i32): i64 {
    // Same limits for all files
    return pathconf(null, name)
}

export fn confstr(name: i32, buf: *u8, len: u32): u32 {
    // Return configuration strings
    return 0
}

// ============================================
// Sleep Functions
// ============================================

export fn sleep(seconds: u32): u32 {
    return basics.sleep(seconds)
}

export fn usleep(usec: u32): i32 {
    return basics.usleep(usec)
}

export fn pause(): i32 {
    return basics.pause()
}

// ============================================
// Alarm
// ============================================

export fn alarm(seconds: u32): u32 {
    return basics.alarm(seconds)
}

// ============================================
// Memory Mapping
// ============================================

export fn brk(addr: *void): i32 {
    return basics.brk(addr)
}

export fn sbrk(increment: i64): *void {
    return basics.sbrk(increment)
}

// ============================================
// Miscellaneous
// ============================================

export fn nice(inc: i32): i32 {
    return basics.nice(inc)
}

export fn getopt(argc: i32, argv: **u8, optstring: *const u8): i32 {
    return basics.getopt(argc, argv, optstring)
}

var optarg_val: *u8 = null
var optind_val: i32 = 1
var opterr_val: i32 = 1
var optopt_val: i32 = 0

export fn get_optarg(): *u8 {
    return optarg_val
}

export fn set_optarg(val: *u8): void {
    optarg_val = val
}

export fn get_optind(): i32 {
    return optind_val
}

export fn set_optind(val: i32): void {
    optind_val = val
}

export fn get_opterr(): i32 {
    return opterr_val
}

export fn set_opterr(val: i32): void {
    opterr_val = val
}

export fn get_optopt(): i32 {
    return optopt_val
}

export fn set_optopt(val: i32): void {
    optopt_val = val
}

export fn crypt(key: *const u8, salt: *const u8): *u8 {
    return basics.crypt(key, salt)
}

export fn encrypt(block: *u8, edflag: i32): void {
    basics.encrypt(block, edflag)
}

export fn swab(from: *const void, to: *void, n: i64): void {
    let f = from as *const u8
    let t = to as *u8
    var i: i64 = 0

    while i < n - 1 {
        t[i] = f[i + 1]
        t[i + 1] = f[i]
        i = i + 2
    }
}

export fn getentropy(buffer: *void, length: u32): i32 {
    return basics.getrandom(buffer, length, 0)
}
