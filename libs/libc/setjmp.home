// HomeOS libc - Non-Local Jumps (setjmp.h)
// POSIX-compatible setjmp/longjmp functions

const signal = @import("signal")

// ============================================
// Type Definitions
// ============================================

// jmp_buf stores the CPU state for x86_64
// Must be large enough to hold all callee-saved registers
pub struct jmp_buf {
    // Callee-saved registers
    rbx: u64
    rbp: u64
    r12: u64
    r13: u64
    r14: u64
    r15: u64
    rsp: u64
    rip: u64
    // For signal mask support
    sigmask: signal.sigset_t
    sigmask_saved: i32
}

pub type jmp_buf_t = [1]jmp_buf

// sigjmp_buf includes signal mask
pub type sigjmp_buf = jmp_buf_t

// ============================================
// setjmp/longjmp
// ============================================

// setjmp - save the current execution context
// Returns 0 when called directly, non-zero when returning from longjmp
export fn setjmp(env: *jmp_buf): i32 {
    // This would normally be implemented in assembly
    // Here's the conceptual implementation:
    //
    // Save callee-saved registers:
    // mov [env + 0], rbx
    // mov [env + 8], rbp
    // mov [env + 16], r12
    // mov [env + 24], r13
    // mov [env + 32], r14
    // mov [env + 40], r15
    // lea rax, [rsp + 8]    ; Skip return address
    // mov [env + 48], rax   ; Save stack pointer
    // mov rax, [rsp]        ; Get return address
    // mov [env + 56], rax   ; Save instruction pointer
    // xor eax, eax          ; Return 0
    // ret

    // Mark that signal mask was not saved
    env.sigmask_saved = 0

    // In actual implementation, inline assembly would be used
    return asm_setjmp(env)
}

// longjmp - restore a saved execution context
export fn longjmp(env: *jmp_buf, val: i32): never {
    // This would normally be implemented in assembly
    // Here's the conceptual implementation:
    //
    // mov rbx, [env + 0]
    // mov rbp, [env + 8]
    // mov r12, [env + 16]
    // mov r13, [env + 24]
    // mov r14, [env + 32]
    // mov r15, [env + 40]
    // mov rsp, [env + 48]
    // mov rax, val
    // test eax, eax
    // jnz .nonzero
    // inc eax               ; Ensure non-zero return
    // .nonzero:
    // jmp [env + 56]        ; Jump to saved instruction pointer

    // Ensure val is non-zero
    let return_val = if val == 0 { 1 } else { val }

    asm_longjmp(env, return_val)
}

// ============================================
// sigsetjmp/siglongjmp
// ============================================

// sigsetjmp - save execution context with optional signal mask
export fn sigsetjmp(env: *jmp_buf, savesigs: i32): i32 {
    if savesigs != 0 {
        // Save the current signal mask
        signal.sigprocmask(signal.SIG_BLOCK, null, &env.sigmask)
        env.sigmask_saved = 1
    } else {
        env.sigmask_saved = 0
    }

    return asm_setjmp(env)
}

// siglongjmp - restore execution context with signal mask
export fn siglongjmp(env: *jmp_buf, val: i32): never {
    // Restore signal mask if it was saved
    if env.sigmask_saved != 0 {
        signal.sigprocmask(signal.SIG_SETMASK, &env.sigmask, null)
    }

    let return_val = if val == 0 { 1 } else { val }
    asm_longjmp(env, return_val)
}

// ============================================
// _setjmp/_longjmp (BSD compatibility)
// ============================================

// _setjmp - like setjmp but never saves signal mask
export fn _setjmp(env: *jmp_buf): i32 {
    env.sigmask_saved = 0
    return asm_setjmp(env)
}

// _longjmp - like longjmp but never restores signal mask
export fn _longjmp(env: *jmp_buf, val: i32): never {
    let return_val = if val == 0 { 1 } else { val }
    asm_longjmp(env, return_val)
}

// ============================================
// Assembly Implementations
// ============================================

// These are placeholders - actual implementation would be in assembly
fn asm_setjmp(env: *jmp_buf): i32 {
    // x86_64 implementation
    asm volatile {
        "mov %rbx, 0(%rdi)"
        "mov %rbp, 8(%rdi)"
        "mov %r12, 16(%rdi)"
        "mov %r13, 24(%rdi)"
        "mov %r14, 32(%rdi)"
        "mov %r15, 40(%rdi)"
        "lea 8(%rsp), %rax"
        "mov %rax, 48(%rdi)"
        "mov (%rsp), %rax"
        "mov %rax, 56(%rdi)"
        "xor %eax, %eax"
    }
    return 0
}

fn asm_longjmp(env: *jmp_buf, val: i32): never {
    asm volatile {
        "mov %esi, %eax"
        "test %eax, %eax"
        "jnz 1f"
        "inc %eax"
        "1:"
        "mov 0(%rdi), %rbx"
        "mov 8(%rdi), %rbp"
        "mov 16(%rdi), %r12"
        "mov 24(%rdi), %r13"
        "mov 32(%rdi), %r14"
        "mov 40(%rdi), %r15"
        "mov 48(%rdi), %rsp"
        "jmp *56(%rdi)"
    }
    loop {}  // Never reached
}

// ============================================
// ARM64 Support
// ============================================

// For ARM64, the jmp_buf layout would be different:
// pub struct jmp_buf_arm64 {
//     x19: u64  // Callee-saved registers x19-x28
//     x20: u64
//     x21: u64
//     x22: u64
//     x23: u64
//     x24: u64
//     x25: u64
//     x26: u64
//     x27: u64
//     x28: u64
//     x29: u64  // Frame pointer
//     x30: u64  // Link register (return address)
//     sp: u64   // Stack pointer
//     d8: u64   // Callee-saved FP registers d8-d15
//     d9: u64
//     d10: u64
//     d11: u64
//     d12: u64
//     d13: u64
//     d14: u64
//     d15: u64
//     sigmask: sigset_t
//     sigmask_saved: i32
// }

// ============================================
// Exception Handling Support
// ============================================

// Context for stack unwinding (simplified)
pub struct ucontext_t {
    uc_flags: u64
    uc_link: *ucontext_t
    uc_stack: stack_t
    uc_mcontext: mcontext_t
    uc_sigmask: signal.sigset_t
}

pub struct stack_t {
    ss_sp: *void
    ss_flags: i32
    ss_size: u64
}

pub struct mcontext_t {
    // General purpose registers
    gregs: [23]u64
    // Floating point state
    fpregs: *void
}

// Register indices for mcontext_t.gregs
const REG_R8: u32 = 0
const REG_R9: u32 = 1
const REG_R10: u32 = 2
const REG_R11: u32 = 3
const REG_R12: u32 = 4
const REG_R13: u32 = 5
const REG_R14: u32 = 6
const REG_R15: u32 = 7
const REG_RDI: u32 = 8
const REG_RSI: u32 = 9
const REG_RBP: u32 = 10
const REG_RBX: u32 = 11
const REG_RDX: u32 = 12
const REG_RAX: u32 = 13
const REG_RCX: u32 = 14
const REG_RSP: u32 = 15
const REG_RIP: u32 = 16
const REG_EFL: u32 = 17
const REG_CSGSFS: u32 = 18
const REG_ERR: u32 = 19
const REG_TRAPNO: u32 = 20
const REG_OLDMASK: u32 = 21
const REG_CR2: u32 = 22

// Context manipulation functions
export fn getcontext(ucp: *ucontext_t): i32 {
    // Save current context
    // This requires assembly implementation
    return 0
}

export fn setcontext(ucp: *const ucontext_t): i32 {
    // Restore context - does not return on success
    return -1
}

export fn makecontext(ucp: *ucontext_t, func: fn(): void, argc: i32, ...): void {
    // Set up context to call function
    // Stack and entry point setup
}

export fn swapcontext(oucp: *ucontext_t, ucp: *const ucontext_t): i32 {
    // Save current context to oucp, switch to ucp
    let result = getcontext(oucp)
    if result == 0 {
        return setcontext(ucp)
    }
    return result
}
