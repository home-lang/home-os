// HomeOS libc - String Operations (string.h)
// POSIX-compatible string manipulation functions

const basics = @import("basics")

// ============================================
// String Copy Functions
// ============================================

export fn strcpy(dest: *u8, src: *const u8): *u8 {
    var i: u32 = 0
    while src[i] != 0 {
        dest[i] = src[i]
        i = i + 1
    }
    dest[i] = 0
    return dest
}

export fn strncpy(dest: *u8, src: *const u8, n: u32): *u8 {
    var i: u32 = 0

    // Copy up to n characters
    while i < n and src[i] != 0 {
        dest[i] = src[i]
        i = i + 1
    }

    // Pad with nulls
    while i < n {
        dest[i] = 0
        i = i + 1
    }

    return dest
}

export fn strcat(dest: *u8, src: *const u8): *u8 {
    var dest_len: u32 = 0
    while dest[dest_len] != 0 {
        dest_len = dest_len + 1
    }

    var i: u32 = 0
    while src[i] != 0 {
        dest[dest_len + i] = src[i]
        i = i + 1
    }
    dest[dest_len + i] = 0

    return dest
}

export fn strncat(dest: *u8, src: *const u8, n: u32): *u8 {
    var dest_len: u32 = 0
    while dest[dest_len] != 0 {
        dest_len = dest_len + 1
    }

    var i: u32 = 0
    while i < n and src[i] != 0 {
        dest[dest_len + i] = src[i]
        i = i + 1
    }
    dest[dest_len + i] = 0

    return dest
}

export fn strdup(s: *const u8): *u8 {
    let len = strlen(s)
    let copy = basics.malloc(len + 1) as *u8
    if copy != null {
        strcpy(copy, s)
    }
    return copy
}

export fn strndup(s: *const u8, n: u32): *u8 {
    var len: u32 = 0
    while len < n and s[len] != 0 {
        len = len + 1
    }

    let copy = basics.malloc(len + 1) as *u8
    if copy != null {
        strncpy(copy, s, len)
        copy[len] = 0
    }
    return copy
}

// ============================================
// String Length Functions
// ============================================

export fn strlen(s: *const u8): u32 {
    var len: u32 = 0
    while s[len] != 0 {
        len = len + 1
    }
    return len
}

export fn strnlen(s: *const u8, maxlen: u32): u32 {
    var len: u32 = 0
    while len < maxlen and s[len] != 0 {
        len = len + 1
    }
    return len
}

// ============================================
// String Comparison Functions
// ============================================

export fn strcmp(s1: *const u8, s2: *const u8): i32 {
    var i: u32 = 0
    while s1[i] != 0 and s2[i] != 0 {
        if s1[i] != s2[i] {
            return (s1[i] as i32) - (s2[i] as i32)
        }
        i = i + 1
    }
    return (s1[i] as i32) - (s2[i] as i32)
}

export fn strncmp(s1: *const u8, s2: *const u8, n: u32): i32 {
    var i: u32 = 0
    while i < n and s1[i] != 0 and s2[i] != 0 {
        if s1[i] != s2[i] {
            return (s1[i] as i32) - (s2[i] as i32)
        }
        i = i + 1
    }
    if i == n {
        return 0
    }
    return (s1[i] as i32) - (s2[i] as i32)
}

export fn strcasecmp(s1: *const u8, s2: *const u8): i32 {
    var i: u32 = 0
    while s1[i] != 0 and s2[i] != 0 {
        let c1 = tolower(s1[i])
        let c2 = tolower(s2[i])
        if c1 != c2 {
            return (c1 as i32) - (c2 as i32)
        }
        i = i + 1
    }
    return (tolower(s1[i]) as i32) - (tolower(s2[i]) as i32)
}

export fn strncasecmp(s1: *const u8, s2: *const u8, n: u32): i32 {
    var i: u32 = 0
    while i < n and s1[i] != 0 and s2[i] != 0 {
        let c1 = tolower(s1[i])
        let c2 = tolower(s2[i])
        if c1 != c2 {
            return (c1 as i32) - (c2 as i32)
        }
        i = i + 1
    }
    if i == n {
        return 0
    }
    return (tolower(s1[i]) as i32) - (tolower(s2[i]) as i32)
}

fn tolower(c: u8): u8 {
    if c >= 'A' and c <= 'Z' {
        return c + ('a' - 'A')
    }
    return c
}

// ============================================
// String Search Functions
// ============================================

export fn strchr(s: *const u8, c: i32): *u8 {
    var i: u32 = 0
    let ch = c as u8

    while s[i] != 0 {
        if s[i] == ch {
            return (s + i) as *u8
        }
        i = i + 1
    }

    if ch == 0 {
        return (s + i) as *u8
    }

    return null
}

export fn strrchr(s: *const u8, c: i32): *u8 {
    let len = strlen(s)
    let ch = c as u8

    var i: i32 = len as i32
    while i >= 0 {
        if s[i as u32] == ch {
            return (s + i as u32) as *u8
        }
        i = i - 1
    }

    return null
}

export fn strstr(haystack: *const u8, needle: *const u8): *u8 {
    if needle[0] == 0 {
        return haystack as *u8
    }

    let needle_len = strlen(needle)
    var i: u32 = 0

    while haystack[i] != 0 {
        if haystack[i] == needle[0] {
            var match: bool = true
            var j: u32 = 1

            while j < needle_len {
                if haystack[i + j] != needle[j] {
                    match = false
                    break
                }
                j = j + 1
            }

            if match {
                return (haystack + i) as *u8
            }
        }
        i = i + 1
    }

    return null
}

export fn strcasestr(haystack: *const u8, needle: *const u8): *u8 {
    if needle[0] == 0 {
        return haystack as *u8
    }

    let needle_len = strlen(needle)
    var i: u32 = 0

    while haystack[i] != 0 {
        if tolower(haystack[i]) == tolower(needle[0]) {
            var match: bool = true
            var j: u32 = 1

            while j < needle_len {
                if tolower(haystack[i + j]) != tolower(needle[j]) {
                    match = false
                    break
                }
                j = j + 1
            }

            if match {
                return (haystack + i) as *u8
            }
        }
        i = i + 1
    }

    return null
}

export fn strpbrk(s: *const u8, accept: *const u8): *u8 {
    var i: u32 = 0
    while s[i] != 0 {
        var j: u32 = 0
        while accept[j] != 0 {
            if s[i] == accept[j] {
                return (s + i) as *u8
            }
            j = j + 1
        }
        i = i + 1
    }
    return null
}

export fn strspn(s: *const u8, accept: *const u8): u32 {
    var count: u32 = 0

    while s[count] != 0 {
        var found: bool = false
        var j: u32 = 0

        while accept[j] != 0 {
            if s[count] == accept[j] {
                found = true
                break
            }
            j = j + 1
        }

        if not found {
            break
        }
        count = count + 1
    }

    return count
}

export fn strcspn(s: *const u8, reject: *const u8): u32 {
    var count: u32 = 0

    while s[count] != 0 {
        var j: u32 = 0
        while reject[j] != 0 {
            if s[count] == reject[j] {
                return count
            }
            j = j + 1
        }
        count = count + 1
    }

    return count
}

// ============================================
// Tokenization
// ============================================

var strtok_pos: *u8 = null

export fn strtok(str: *u8, delim: *const u8): *u8 {
    return strtok_r(str, delim, &strtok_pos)
}

export fn strtok_r(str: *u8, delim: *const u8, saveptr: **u8): *u8 {
    var s = if str != null { str } else { *saveptr }

    if s == null {
        return null
    }

    // Skip leading delimiters
    s = s + strspn(s, delim)

    if s[0] == 0 {
        *saveptr = null
        return null
    }

    // Find end of token
    let token = s
    s = s + strcspn(s, delim)

    if s[0] != 0 {
        s[0] = 0
        *saveptr = s + 1
    } else {
        *saveptr = null
    }

    return token
}

// ============================================
// Memory Functions
// ============================================

export fn memcpy(dest: *void, src: *const void, n: u32): *void {
    let d = dest as *u8
    let s = src as *const u8

    var i: u32 = 0
    while i < n {
        d[i] = s[i]
        i = i + 1
    }

    return dest
}

export fn memmove(dest: *void, src: *const void, n: u32): *void {
    let d = dest as *u8
    let s = src as *const u8

    if d < s {
        var i: u32 = 0
        while i < n {
            d[i] = s[i]
            i = i + 1
        }
    } else if d > s {
        var i: u32 = n
        while i > 0 {
            i = i - 1
            d[i] = s[i]
        }
    }

    return dest
}

export fn memset(dest: *void, c: i32, n: u32): *void {
    let d = dest as *u8
    let ch = c as u8

    var i: u32 = 0
    while i < n {
        d[i] = ch
        i = i + 1
    }

    return dest
}

export fn memcmp(s1: *const void, s2: *const void, n: u32): i32 {
    let p1 = s1 as *const u8
    let p2 = s2 as *const u8

    var i: u32 = 0
    while i < n {
        if p1[i] != p2[i] {
            return (p1[i] as i32) - (p2[i] as i32)
        }
        i = i + 1
    }

    return 0
}

export fn memchr(s: *const void, c: i32, n: u32): *void {
    let p = s as *const u8
    let ch = c as u8

    var i: u32 = 0
    while i < n {
        if p[i] == ch {
            return (p + i) as *void
        }
        i = i + 1
    }

    return null
}

export fn memrchr(s: *const void, c: i32, n: u32): *void {
    let p = s as *const u8
    let ch = c as u8

    var i: u32 = n
    while i > 0 {
        i = i - 1
        if p[i] == ch {
            return (p + i) as *void
        }
    }

    return null
}

export fn memmem(haystack: *const void, haystacklen: u32, needle: *const void, needlelen: u32): *void {
    if needlelen == 0 {
        return haystack as *void
    }

    if haystacklen < needlelen {
        return null
    }

    let h = haystack as *const u8
    let n = needle as *const u8

    var i: u32 = 0
    while i <= haystacklen - needlelen {
        if memcmp(h + i, n, needlelen) == 0 {
            return (h + i) as *void
        }
        i = i + 1
    }

    return null
}

// ============================================
// Error Strings
// ============================================

const error_strings = [_]*const u8 {
    "Success",                      // 0
    "Operation not permitted",      // 1 EPERM
    "No such file or directory",    // 2 ENOENT
    "No such process",              // 3 ESRCH
    "Interrupted system call",      // 4 EINTR
    "I/O error",                    // 5 EIO
    "No such device or address",    // 6 ENXIO
    "Argument list too long",       // 7 E2BIG
    "Exec format error",            // 8 ENOEXEC
    "Bad file descriptor",          // 9 EBADF
    "No child processes",           // 10 ECHILD
    "Try again",                    // 11 EAGAIN
    "Out of memory",                // 12 ENOMEM
    "Permission denied",            // 13 EACCES
    "Bad address",                  // 14 EFAULT
    "Block device required",        // 15 ENOTBLK
    "Device or resource busy",      // 16 EBUSY
    "File exists",                  // 17 EEXIST
    "Cross-device link",            // 18 EXDEV
    "No such device",               // 19 ENODEV
    "Not a directory",              // 20 ENOTDIR
    "Is a directory",               // 21 EISDIR
    "Invalid argument",             // 22 EINVAL
    "File table overflow",          // 23 ENFILE
    "Too many open files",          // 24 EMFILE
    "Not a typewriter",             // 25 ENOTTY
    "Text file busy",               // 26 ETXTBSY
    "File too large",               // 27 EFBIG
    "No space left on device",      // 28 ENOSPC
    "Illegal seek",                 // 29 ESPIPE
    "Read-only file system",        // 30 EROFS
    "Too many links",               // 31 EMLINK
    "Broken pipe",                  // 32 EPIPE
}

export fn strerror(errnum: i32): *const u8 {
    if errnum >= 0 and errnum < error_strings.len as i32 {
        return error_strings[errnum as u32]
    }
    return "Unknown error"
}

export fn strerror_r(errnum: i32, buf: *u8, buflen: u32): i32 {
    let msg = strerror(errnum)
    let len = strlen(msg)

    if len >= buflen {
        if buflen > 0 {
            strncpy(buf, msg, buflen - 1)
            buf[buflen - 1] = 0
        }
        return -1
    }

    strcpy(buf, msg)
    return 0
}
