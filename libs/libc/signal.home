// HomeOS libc - Signal Handling (signal.h)
// POSIX-compatible signal functions

const basics = @import("basics")
const string = @import("string")

// ============================================
// Type Definitions
// ============================================

pub type sig_atomic_t = i32
pub type sigset_t = u64

pub type sighandler_t = fn(i32): void

pub struct sigaction_t {
    sa_handler: sighandler_t
    sa_sigaction: fn(i32, *siginfo_t, *void): void
    sa_mask: sigset_t
    sa_flags: i32
    sa_restorer: fn(): void
}

pub struct siginfo_t {
    si_signo: i32
    si_errno: i32
    si_code: i32
    si_pid: i32
    si_uid: u32
    si_status: i32
    si_addr: *void
    si_value: sigval_t
    si_band: i64
}

pub union sigval_t {
    sival_int: i32
    sival_ptr: *void
}

pub struct stack_t {
    ss_sp: *void
    ss_flags: i32
    ss_size: u32
}

pub struct ucontext_t {
    uc_flags: u64
    uc_link: *ucontext_t
    uc_stack: stack_t
    uc_mcontext: mcontext_t
    uc_sigmask: sigset_t
}

pub struct mcontext_t {
    gregs: [23]u64
    fpregs: *void
}

// ============================================
// Signal Numbers
// ============================================

export const SIGHUP: i32 = 1      // Hangup
export const SIGINT: i32 = 2      // Interrupt
export const SIGQUIT: i32 = 3     // Quit
export const SIGILL: i32 = 4      // Illegal instruction
export const SIGTRAP: i32 = 5     // Trace/breakpoint trap
export const SIGABRT: i32 = 6     // Aborted
export const SIGBUS: i32 = 7      // Bus error
export const SIGFPE: i32 = 8      // Floating point exception
export const SIGKILL: i32 = 9     // Killed
export const SIGUSR1: i32 = 10    // User-defined signal 1
export const SIGSEGV: i32 = 11    // Segmentation fault
export const SIGUSR2: i32 = 12    // User-defined signal 2
export const SIGPIPE: i32 = 13    // Broken pipe
export const SIGALRM: i32 = 14    // Alarm clock
export const SIGTERM: i32 = 15    // Terminated
export const SIGSTKFLT: i32 = 16  // Stack fault
export const SIGCHLD: i32 = 17    // Child exited
export const SIGCONT: i32 = 18    // Continued
export const SIGSTOP: i32 = 19    // Stopped (signal)
export const SIGTSTP: i32 = 20    // Stopped
export const SIGTTIN: i32 = 21    // Stopped (tty input)
export const SIGTTOU: i32 = 22    // Stopped (tty output)
export const SIGURG: i32 = 23     // Urgent I/O condition
export const SIGXCPU: i32 = 24    // CPU time limit exceeded
export const SIGXFSZ: i32 = 25    // File size limit exceeded
export const SIGVTALRM: i32 = 26  // Virtual timer expired
export const SIGPROF: i32 = 27    // Profiling timer expired
export const SIGWINCH: i32 = 28   // Window changed
export const SIGIO: i32 = 29      // I/O possible
export const SIGPOLL: i32 = SIGIO // Pollable event
export const SIGPWR: i32 = 30     // Power failure
export const SIGSYS: i32 = 31     // Bad system call

export const NSIG: i32 = 65       // Maximum signal number + 1

// Real-time signals
export const SIGRTMIN: i32 = 32
export const SIGRTMAX: i32 = 64

// ============================================
// Signal Handler Constants
// ============================================

export const SIG_DFL: sighandler_t = @intToPtr(sighandler_t, 0)
export const SIG_IGN: sighandler_t = @intToPtr(sighandler_t, 1)
export const SIG_ERR: sighandler_t = @intToPtr(sighandler_t, ~0 as u64)

// ============================================
// Signal Action Flags
// ============================================

export const SA_NOCLDSTOP: i32 = 1
export const SA_NOCLDWAIT: i32 = 2
export const SA_SIGINFO: i32 = 4
export const SA_ONSTACK: i32 = 0x08000000
export const SA_RESTART: i32 = 0x10000000
export const SA_NODEFER: i32 = 0x40000000
export const SA_RESETHAND: i32 = 0x80000000

// ============================================
// Signal Set Manipulation Flags
// ============================================

export const SIG_BLOCK: i32 = 0
export const SIG_UNBLOCK: i32 = 1
export const SIG_SETMASK: i32 = 2

// ============================================
// Signal Code Values
// ============================================

export const SI_USER: i32 = 0
export const SI_KERNEL: i32 = 128
export const SI_QUEUE: i32 = -1
export const SI_TIMER: i32 = -2
export const SI_MESGQ: i32 = -3
export const SI_ASYNCIO: i32 = -4
export const SI_SIGIO: i32 = -5
export const SI_TKILL: i32 = -6

// SIGILL codes
export const ILL_ILLOPC: i32 = 1
export const ILL_ILLOPN: i32 = 2
export const ILL_ILLADR: i32 = 3
export const ILL_ILLTRP: i32 = 4
export const ILL_PRVOPC: i32 = 5
export const ILL_PRVREG: i32 = 6
export const ILL_COPROC: i32 = 7
export const ILL_BADSTK: i32 = 8

// SIGFPE codes
export const FPE_INTDIV: i32 = 1
export const FPE_INTOVF: i32 = 2
export const FPE_FLTDIV: i32 = 3
export const FPE_FLTOVF: i32 = 4
export const FPE_FLTUND: i32 = 5
export const FPE_FLTRES: i32 = 6
export const FPE_FLTINV: i32 = 7
export const FPE_FLTSUB: i32 = 8

// SIGSEGV codes
export const SEGV_MAPERR: i32 = 1
export const SEGV_ACCERR: i32 = 2

// SIGBUS codes
export const BUS_ADRALN: i32 = 1
export const BUS_ADRERR: i32 = 2
export const BUS_OBJERR: i32 = 3

// SIGCHLD codes
export const CLD_EXITED: i32 = 1
export const CLD_KILLED: i32 = 2
export const CLD_DUMPED: i32 = 3
export const CLD_TRAPPED: i32 = 4
export const CLD_STOPPED: i32 = 5
export const CLD_CONTINUED: i32 = 6

// ============================================
// Signal Handler Storage
// ============================================

var signal_handlers: [NSIG]sighandler_t = [_]sighandler_t{SIG_DFL} ** NSIG
var signal_actions: [NSIG]sigaction_t

// ============================================
// Signal Functions
// ============================================

export fn signal(signum: i32, handler: sighandler_t): sighandler_t {
    if signum < 1 or signum >= NSIG {
        return SIG_ERR
    }

    // Can't catch SIGKILL or SIGSTOP
    if signum == SIGKILL or signum == SIGSTOP {
        return SIG_ERR
    }

    let old_handler = signal_handlers[signum as u32]
    signal_handlers[signum as u32] = handler

    basics.signal(signum, handler)

    return old_handler
}

export fn sigaction(signum: i32, act: *const sigaction_t, oldact: *sigaction_t): i32 {
    if signum < 1 or signum >= NSIG {
        return -1
    }

    if signum == SIGKILL or signum == SIGSTOP {
        return -1
    }

    if oldact != null {
        *oldact = signal_actions[signum as u32]
    }

    if act != null {
        signal_actions[signum as u32] = *act
        signal_handlers[signum as u32] = act.sa_handler
        basics.sigaction(signum, act, null)
    }

    return 0
}

export fn raise(sig: i32): i32 {
    return basics.raise(sig)
}

export fn kill(pid: i32, sig: i32): i32 {
    return basics.kill(pid, sig)
}

export fn killpg(pgrp: i32, sig: i32): i32 {
    return basics.killpg(pgrp, sig)
}

export fn pthread_kill(thread: u64, sig: i32): i32 {
    return basics.pthread_kill(thread, sig)
}

export fn sigqueue(pid: i32, sig: i32, value: sigval_t): i32 {
    return basics.sigqueue(pid, sig, value)
}

// ============================================
// Signal Set Functions
// ============================================

export fn sigemptyset(set: *sigset_t): i32 {
    *set = 0
    return 0
}

export fn sigfillset(set: *sigset_t): i32 {
    *set = ~0 as u64
    return 0
}

export fn sigaddset(set: *sigset_t, signum: i32): i32 {
    if signum < 1 or signum >= NSIG {
        return -1
    }
    *set = *set | (1 as u64 << (signum as u32 - 1))
    return 0
}

export fn sigdelset(set: *sigset_t, signum: i32): i32 {
    if signum < 1 or signum >= NSIG {
        return -1
    }
    *set = *set & ~(1 as u64 << (signum as u32 - 1))
    return 0
}

export fn sigismember(set: *const sigset_t, signum: i32): i32 {
    if signum < 1 or signum >= NSIG {
        return -1
    }
    return if (*set & (1 as u64 << (signum as u32 - 1))) != 0 { 1 } else { 0 }
}

export fn sigisemptyset(set: *const sigset_t): i32 {
    return if *set == 0 { 1 } else { 0 }
}

export fn sigandset(dest: *sigset_t, left: *const sigset_t, right: *const sigset_t): i32 {
    *dest = *left & *right
    return 0
}

export fn sigorset(dest: *sigset_t, left: *const sigset_t, right: *const sigset_t): i32 {
    *dest = *left | *right
    return 0
}

// ============================================
// Signal Mask Functions
// ============================================

export fn sigprocmask(how: i32, set: *const sigset_t, oldset: *sigset_t): i32 {
    return basics.sigprocmask(how, set, oldset)
}

export fn pthread_sigmask(how: i32, set: *const sigset_t, oldset: *sigset_t): i32 {
    return sigprocmask(how, set, oldset)
}

export fn sigpending(set: *sigset_t): i32 {
    return basics.sigpending(set)
}

export fn sigsuspend(mask: *const sigset_t): i32 {
    return basics.sigsuspend(mask)
}

export fn sigwait(set: *const sigset_t, sig: *i32): i32 {
    return basics.sigwait(set, sig)
}

export fn sigwaitinfo(set: *const sigset_t, info: *siginfo_t): i32 {
    return basics.sigwaitinfo(set, info)
}

export fn sigtimedwait(set: *const sigset_t, info: *siginfo_t, timeout: *const void): i32 {
    return basics.sigtimedwait(set, info, timeout)
}

// ============================================
// Alternate Signal Stack
// ============================================

export fn sigaltstack(ss: *const stack_t, old_ss: *stack_t): i32 {
    return basics.sigaltstack(ss, old_ss)
}

// ============================================
// Signal Names
// ============================================

const signal_names = [_]*const u8{
    "Unknown signal 0",
    "SIGHUP",
    "SIGINT",
    "SIGQUIT",
    "SIGILL",
    "SIGTRAP",
    "SIGABRT",
    "SIGBUS",
    "SIGFPE",
    "SIGKILL",
    "SIGUSR1",
    "SIGSEGV",
    "SIGUSR2",
    "SIGPIPE",
    "SIGALRM",
    "SIGTERM",
    "SIGSTKFLT",
    "SIGCHLD",
    "SIGCONT",
    "SIGSTOP",
    "SIGTSTP",
    "SIGTTIN",
    "SIGTTOU",
    "SIGURG",
    "SIGXCPU",
    "SIGXFSZ",
    "SIGVTALRM",
    "SIGPROF",
    "SIGWINCH",
    "SIGIO",
    "SIGPWR",
    "SIGSYS"
}

const signal_descriptions = [_]*const u8{
    "Unknown signal 0",
    "Hangup",
    "Interrupt",
    "Quit",
    "Illegal instruction",
    "Trace/breakpoint trap",
    "Aborted",
    "Bus error",
    "Floating point exception",
    "Killed",
    "User defined signal 1",
    "Segmentation fault",
    "User defined signal 2",
    "Broken pipe",
    "Alarm clock",
    "Terminated",
    "Stack fault",
    "Child exited",
    "Continued",
    "Stopped (signal)",
    "Stopped",
    "Stopped (tty input)",
    "Stopped (tty output)",
    "Urgent I/O condition",
    "CPU time limit exceeded",
    "File size limit exceeded",
    "Virtual timer expired",
    "Profiling timer expired",
    "Window changed",
    "I/O possible",
    "Power failure",
    "Bad system call"
}

export fn strsignal(signum: i32): *u8 {
    if signum >= 1 and signum < 32 {
        return signal_descriptions[signum as u32] as *u8
    }

    if signum >= SIGRTMIN and signum <= SIGRTMAX {
        return "Real-time signal" as *u8
    }

    return "Unknown signal" as *u8
}

export fn sig2str(signum: i32, str: *u8): i32 {
    if signum >= 1 and signum < 32 {
        string.strcpy(str, signal_names[signum as u32])
        return 0
    }

    if signum >= SIGRTMIN and signum <= SIGRTMAX {
        // Format as RTMIN+N or RTMAX-N
        let offset = signum - SIGRTMIN
        string.strcpy(str, "RTMIN+")
        // Add number (simplified)
        let len = string.strlen(str)
        str[len] = ('0' + offset) as u8
        str[len + 1] = 0
        return 0
    }

    return -1
}

export fn str2sig(str: *const u8, signum: *i32): i32 {
    var i: u32 = 1
    while i < 32 {
        if string.strcmp(str, signal_names[i]) == 0 {
            *signum = i as i32
            return 0
        }
        i = i + 1
    }

    // Check for RT signals
    if string.strncmp(str, "RTMIN", 5) == 0 {
        if str[5] == 0 {
            *signum = SIGRTMIN
            return 0
        }
        if str[5] == '+' {
            let offset = string.atoi(str + 6)
            *signum = SIGRTMIN + offset
            return 0
        }
    }

    if string.strncmp(str, "RTMAX", 5) == 0 {
        if str[5] == 0 {
            *signum = SIGRTMAX
            return 0
        }
        if str[5] == '-' {
            let offset = string.atoi(str + 6)
            *signum = SIGRTMAX - offset
            return 0
        }
    }

    return -1
}

// ============================================
// Signal Interrupt Handling
// ============================================

export fn siginterrupt(signum: i32, flag: i32): i32 {
    var act: sigaction_t
    let result = sigaction(signum, null, &act)
    if result != 0 {
        return result
    }

    if flag != 0 {
        act.sa_flags = act.sa_flags & ~SA_RESTART
    } else {
        act.sa_flags = act.sa_flags | SA_RESTART
    }

    return sigaction(signum, &act, null)
}

// ============================================
// BSD Signal Functions (compatibility)
// ============================================

export fn sigblock(mask: i32): i32 {
    var oldset: sigset_t
    var newset: sigset_t = mask as u64
    sigprocmask(SIG_BLOCK, &newset, &oldset)
    return oldset as i32
}

export fn sigsetmask(mask: i32): i32 {
    var oldset: sigset_t
    var newset: sigset_t = mask as u64
    sigprocmask(SIG_SETMASK, &newset, &oldset)
    return oldset as i32
}

export fn siggetmask(): i32 {
    var set: sigset_t
    sigprocmask(SIG_SETMASK, null, &set)
    return set as i32
}

// ============================================
// Atomic Flag Type
// ============================================

pub struct atomic_flag {
    value: u32
}

export fn atomic_flag_test_and_set(flag: *atomic_flag): bool {
    return basics.atomic_cmpxchg(&flag.value, 0, 1) == 0
}

export fn atomic_flag_clear(flag: *atomic_flag): void {
    basics.atomic_store(&flag.value, 0)
}
