// HomeOS libc - Time Functions (time.h)
// POSIX-compatible time manipulation functions

const basics = @import("basics")
const string = @import("string")

// ============================================
// Type Definitions
// ============================================

pub type time_t = i64
pub type clock_t = i64
pub type suseconds_t = i64

pub struct tm {
    tm_sec: i32       // Seconds [0,60]
    tm_min: i32       // Minutes [0,59]
    tm_hour: i32      // Hour [0,23]
    tm_mday: i32      // Day of month [1,31]
    tm_mon: i32       // Month [0,11]
    tm_year: i32      // Years since 1900
    tm_wday: i32      // Day of week [0,6] (Sunday = 0)
    tm_yday: i32      // Day of year [0,365]
    tm_isdst: i32     // Daylight saving time flag
    tm_gmtoff: i64    // Offset from UTC in seconds
    tm_zone: *const u8 // Timezone name
}

pub struct timespec {
    tv_sec: time_t
    tv_nsec: i64
}

pub struct timeval {
    tv_sec: time_t
    tv_usec: suseconds_t
}

pub struct timezone {
    tz_minuteswest: i32
    tz_dsttime: i32
}

pub struct itimerspec {
    it_interval: timespec
    it_value: timespec
}

// ============================================
// Constants
// ============================================

const CLOCKS_PER_SEC: clock_t = 1000000

const CLOCK_REALTIME: i32 = 0
const CLOCK_MONOTONIC: i32 = 1
const CLOCK_PROCESS_CPUTIME_ID: i32 = 2
const CLOCK_THREAD_CPUTIME_ID: i32 = 3
const CLOCK_MONOTONIC_RAW: i32 = 4
const CLOCK_REALTIME_COARSE: i32 = 5
const CLOCK_MONOTONIC_COARSE: i32 = 6
const CLOCK_BOOTTIME: i32 = 7

// Days per month (non-leap year)
const days_per_month = [_]i32{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}

// Day names
const day_names = [_]*const u8{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}
const full_day_names = [_]*const u8{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}

// Month names
const month_names = [_]*const u8{"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}
const full_month_names = [_]*const u8{"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}

// ============================================
// Helper Functions
// ============================================

fn is_leap_year(year: i32): bool {
    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)
}

fn days_in_month(month: i32, year: i32): i32 {
    if month == 1 and is_leap_year(year) {
        return 29
    }
    return days_per_month[month as u32]
}

fn days_in_year(year: i32): i32 {
    return if is_leap_year(year) { 366 } else { 365 }
}

// ============================================
// Time Functions
// ============================================

export fn time(tloc: *time_t): time_t {
    let t = basics.time()
    if tloc != null {
        *tloc = t
    }
    return t
}

export fn clock(): clock_t {
    return basics.clock()
}

export fn clock_gettime(clk_id: i32, tp: *timespec): i32 {
    return basics.clock_gettime(clk_id, tp)
}

export fn clock_settime(clk_id: i32, tp: *const timespec): i32 {
    return basics.clock_settime(clk_id, tp)
}

export fn clock_getres(clk_id: i32, res: *timespec): i32 {
    if res != null {
        res.tv_sec = 0
        res.tv_nsec = 1  // 1 nanosecond resolution
    }
    return 0
}

export fn gettimeofday(tv: *timeval, tz: *timezone): i32 {
    var ts: timespec
    let result = clock_gettime(CLOCK_REALTIME, &ts)

    if result == 0 and tv != null {
        tv.tv_sec = ts.tv_sec
        tv.tv_usec = ts.tv_nsec / 1000
    }

    if tz != null {
        tz.tz_minuteswest = 0
        tz.tz_dsttime = 0
    }

    return result
}

export fn settimeofday(tv: *const timeval, tz: *const timezone): i32 {
    if tv != null {
        var ts: timespec
        ts.tv_sec = tv.tv_sec
        ts.tv_nsec = tv.tv_usec * 1000
        return clock_settime(CLOCK_REALTIME, &ts)
    }
    return 0
}

// ============================================
// Time Conversion Functions
// ============================================

// Static buffer for gmtime/localtime
var tm_buffer: tm

export fn gmtime(timep: *const time_t): *tm {
    return gmtime_r(timep, &tm_buffer)
}

export fn gmtime_r(timep: *const time_t, result: *tm): *tm {
    var t = *timep
    var days = t / 86400
    var remaining = t % 86400

    if remaining < 0 {
        remaining = remaining + 86400
        days = days - 1
    }

    result.tm_sec = (remaining % 60) as i32
    result.tm_min = ((remaining / 60) % 60) as i32
    result.tm_hour = (remaining / 3600) as i32

    // Day of week (Jan 1, 1970 was Thursday = 4)
    result.tm_wday = ((days + 4) % 7) as i32
    if result.tm_wday < 0 {
        result.tm_wday = result.tm_wday + 7
    }

    // Calculate year and day of year
    var year: i32 = 1970
    var day_count = days

    if day_count >= 0 {
        while day_count >= days_in_year(year) {
            day_count = day_count - days_in_year(year) as i64
            year = year + 1
        }
    } else {
        while day_count < 0 {
            year = year - 1
            day_count = day_count + days_in_year(year) as i64
        }
    }

    result.tm_year = year - 1900
    result.tm_yday = day_count as i32

    // Calculate month and day
    var month: i32 = 0
    var mday = day_count as i32

    while mday >= days_in_month(month, year) {
        mday = mday - days_in_month(month, year)
        month = month + 1
    }

    result.tm_mon = month
    result.tm_mday = mday + 1
    result.tm_isdst = 0
    result.tm_gmtoff = 0
    result.tm_zone = "UTC"

    return result
}

export fn localtime(timep: *const time_t): *tm {
    return localtime_r(timep, &tm_buffer)
}

export fn localtime_r(timep: *const time_t, result: *tm): *tm {
    // For now, just use UTC
    // TODO: Implement timezone support
    return gmtime_r(timep, result)
}

export fn mktime(timeptr: *tm): time_t {
    var year = timeptr.tm_year + 1900
    var month = timeptr.tm_mon
    var day = timeptr.tm_mday

    // Normalize month
    while month < 0 {
        month = month + 12
        year = year - 1
    }
    while month > 11 {
        month = month - 12
        year = year + 1
    }

    // Calculate days since epoch
    var days: i64 = 0

    // Years
    if year >= 1970 {
        var y = 1970
        while y < year {
            days = days + days_in_year(y) as i64
            y = y + 1
        }
    } else {
        var y = year
        while y < 1970 {
            days = days - days_in_year(y) as i64
            y = y + 1
        }
    }

    // Months
    var m: i32 = 0
    while m < month {
        days = days + days_in_month(m, year) as i64
        m = m + 1
    }

    // Days
    days = days + (day - 1) as i64

    // Calculate time
    let t = days * 86400 +
            timeptr.tm_hour as i64 * 3600 +
            timeptr.tm_min as i64 * 60 +
            timeptr.tm_sec as i64

    // Normalize timeptr
    gmtime_r(&t, timeptr)

    return t
}

export fn timegm(timeptr: *tm): time_t {
    return mktime(timeptr)
}

export fn difftime(time1: time_t, time0: time_t): f64 {
    return (time1 - time0) as f64
}

// ============================================
// Time String Functions
// ============================================

var asctime_buffer: [26]u8

export fn asctime(timeptr: *const tm): *u8 {
    return asctime_r(timeptr, &asctime_buffer)
}

export fn asctime_r(timeptr: *const tm, buf: *u8): *u8 {
    // Format: "Day Mon DD HH:MM:SS YYYY\n\0"
    let day = day_names[timeptr.tm_wday as u32]
    let mon = month_names[timeptr.tm_mon as u32]

    // Copy day name
    var pos: u32 = 0
    var i: u32 = 0
    while day[i] != 0 {
        buf[pos] = day[i]
        pos = pos + 1
        i = i + 1
    }
    buf[pos] = ' '
    pos = pos + 1

    // Copy month name
    i = 0
    while mon[i] != 0 {
        buf[pos] = mon[i]
        pos = pos + 1
        i = i + 1
    }
    buf[pos] = ' '
    pos = pos + 1

    // Day of month
    if timeptr.tm_mday < 10 {
        buf[pos] = ' '
    } else {
        buf[pos] = ('0' + timeptr.tm_mday / 10) as u8
    }
    pos = pos + 1
    buf[pos] = ('0' + timeptr.tm_mday % 10) as u8
    pos = pos + 1
    buf[pos] = ' '
    pos = pos + 1

    // Hour
    buf[pos] = ('0' + timeptr.tm_hour / 10) as u8
    pos = pos + 1
    buf[pos] = ('0' + timeptr.tm_hour % 10) as u8
    pos = pos + 1
    buf[pos] = ':'
    pos = pos + 1

    // Minute
    buf[pos] = ('0' + timeptr.tm_min / 10) as u8
    pos = pos + 1
    buf[pos] = ('0' + timeptr.tm_min % 10) as u8
    pos = pos + 1
    buf[pos] = ':'
    pos = pos + 1

    // Second
    buf[pos] = ('0' + timeptr.tm_sec / 10) as u8
    pos = pos + 1
    buf[pos] = ('0' + timeptr.tm_sec % 10) as u8
    pos = pos + 1
    buf[pos] = ' '
    pos = pos + 1

    // Year
    let year = timeptr.tm_year + 1900
    buf[pos] = ('0' + year / 1000) as u8
    pos = pos + 1
    buf[pos] = ('0' + (year / 100) % 10) as u8
    pos = pos + 1
    buf[pos] = ('0' + (year / 10) % 10) as u8
    pos = pos + 1
    buf[pos] = ('0' + year % 10) as u8
    pos = pos + 1
    buf[pos] = '\n'
    pos = pos + 1
    buf[pos] = 0

    return buf
}

export fn ctime(timep: *const time_t): *u8 {
    return asctime(localtime(timep))
}

export fn ctime_r(timep: *const time_t, buf: *u8): *u8 {
    var tm_buf: tm
    return asctime_r(localtime_r(timep, &tm_buf), buf)
}

export fn strftime(s: *u8, maxsize: u32, format: *const u8, timeptr: *const tm): u32 {
    var pos: u32 = 0
    var i: u32 = 0

    while format[i] != 0 and pos < maxsize - 1 {
        if format[i] != '%' {
            s[pos] = format[i]
            pos = pos + 1
            i = i + 1
            continue
        }

        i = i + 1  // Skip '%'

        if format[i] == 0 {
            break
        }

        switch format[i] {
            'a' => {
                // Abbreviated weekday
                let name = day_names[timeptr.tm_wday as u32]
                var j: u32 = 0
                while name[j] != 0 and pos < maxsize - 1 {
                    s[pos] = name[j]
                    pos = pos + 1
                    j = j + 1
                }
            }
            'A' => {
                // Full weekday
                let name = full_day_names[timeptr.tm_wday as u32]
                var j: u32 = 0
                while name[j] != 0 and pos < maxsize - 1 {
                    s[pos] = name[j]
                    pos = pos + 1
                    j = j + 1
                }
            }
            'b', 'h' => {
                // Abbreviated month
                let name = month_names[timeptr.tm_mon as u32]
                var j: u32 = 0
                while name[j] != 0 and pos < maxsize - 1 {
                    s[pos] = name[j]
                    pos = pos + 1
                    j = j + 1
                }
            }
            'B' => {
                // Full month
                let name = full_month_names[timeptr.tm_mon as u32]
                var j: u32 = 0
                while name[j] != 0 and pos < maxsize - 1 {
                    s[pos] = name[j]
                    pos = pos + 1
                    j = j + 1
                }
            }
            'd' => {
                // Day of month (01-31)
                if pos + 2 <= maxsize - 1 {
                    s[pos] = ('0' + timeptr.tm_mday / 10) as u8
                    s[pos + 1] = ('0' + timeptr.tm_mday % 10) as u8
                    pos = pos + 2
                }
            }
            'e' => {
                // Day of month (space-padded)
                if pos + 2 <= maxsize - 1 {
                    if timeptr.tm_mday < 10 {
                        s[pos] = ' '
                    } else {
                        s[pos] = ('0' + timeptr.tm_mday / 10) as u8
                    }
                    s[pos + 1] = ('0' + timeptr.tm_mday % 10) as u8
                    pos = pos + 2
                }
            }
            'H' => {
                // Hour (00-23)
                if pos + 2 <= maxsize - 1 {
                    s[pos] = ('0' + timeptr.tm_hour / 10) as u8
                    s[pos + 1] = ('0' + timeptr.tm_hour % 10) as u8
                    pos = pos + 2
                }
            }
            'I' => {
                // Hour (01-12)
                var hour = timeptr.tm_hour % 12
                if hour == 0 {
                    hour = 12
                }
                if pos + 2 <= maxsize - 1 {
                    s[pos] = ('0' + hour / 10) as u8
                    s[pos + 1] = ('0' + hour % 10) as u8
                    pos = pos + 2
                }
            }
            'j' => {
                // Day of year (001-366)
                let yday = timeptr.tm_yday + 1
                if pos + 3 <= maxsize - 1 {
                    s[pos] = ('0' + yday / 100) as u8
                    s[pos + 1] = ('0' + (yday / 10) % 10) as u8
                    s[pos + 2] = ('0' + yday % 10) as u8
                    pos = pos + 3
                }
            }
            'm' => {
                // Month (01-12)
                let mon = timeptr.tm_mon + 1
                if pos + 2 <= maxsize - 1 {
                    s[pos] = ('0' + mon / 10) as u8
                    s[pos + 1] = ('0' + mon % 10) as u8
                    pos = pos + 2
                }
            }
            'M' => {
                // Minute (00-59)
                if pos + 2 <= maxsize - 1 {
                    s[pos] = ('0' + timeptr.tm_min / 10) as u8
                    s[pos + 1] = ('0' + timeptr.tm_min % 10) as u8
                    pos = pos + 2
                }
            }
            'n' => {
                s[pos] = '\n'
                pos = pos + 1
            }
            'p' => {
                // AM/PM
                let ampm = if timeptr.tm_hour < 12 { "AM" } else { "PM" }
                if pos + 2 <= maxsize - 1 {
                    s[pos] = ampm[0]
                    s[pos + 1] = ampm[1]
                    pos = pos + 2
                }
            }
            'S' => {
                // Second (00-60)
                if pos + 2 <= maxsize - 1 {
                    s[pos] = ('0' + timeptr.tm_sec / 10) as u8
                    s[pos + 1] = ('0' + timeptr.tm_sec % 10) as u8
                    pos = pos + 2
                }
            }
            't' => {
                s[pos] = '\t'
                pos = pos + 1
            }
            'u' => {
                // Day of week (1-7, Monday = 1)
                let wday = if timeptr.tm_wday == 0 { 7 } else { timeptr.tm_wday }
                s[pos] = ('0' + wday) as u8
                pos = pos + 1
            }
            'w' => {
                // Day of week (0-6, Sunday = 0)
                s[pos] = ('0' + timeptr.tm_wday) as u8
                pos = pos + 1
            }
            'y' => {
                // Year without century
                let year = timeptr.tm_year % 100
                if pos + 2 <= maxsize - 1 {
                    s[pos] = ('0' + year / 10) as u8
                    s[pos + 1] = ('0' + year % 10) as u8
                    pos = pos + 2
                }
            }
            'Y' => {
                // Year with century
                let year = timeptr.tm_year + 1900
                if pos + 4 <= maxsize - 1 {
                    s[pos] = ('0' + year / 1000) as u8
                    s[pos + 1] = ('0' + (year / 100) % 10) as u8
                    s[pos + 2] = ('0' + (year / 10) % 10) as u8
                    s[pos + 3] = ('0' + year % 10) as u8
                    pos = pos + 4
                }
            }
            'Z' => {
                // Timezone name
                if timeptr.tm_zone != null {
                    var j: u32 = 0
                    while timeptr.tm_zone[j] != 0 and pos < maxsize - 1 {
                        s[pos] = timeptr.tm_zone[j]
                        pos = pos + 1
                        j = j + 1
                    }
                }
            }
            '%' => {
                s[pos] = '%'
                pos = pos + 1
            }
            else => {
                // Unknown format, copy as-is
                s[pos] = '%'
                pos = pos + 1
                if pos < maxsize - 1 {
                    s[pos] = format[i]
                    pos = pos + 1
                }
            }
        }

        i = i + 1
    }

    s[pos] = 0
    return pos
}

export fn strptime(s: *const u8, format: *const u8, tm: *tm): *u8 {
    var spos: u32 = 0
    var fpos: u32 = 0

    while format[fpos] != 0 {
        if format[fpos] != '%' {
            if s[spos] != format[fpos] {
                return null
            }
            spos = spos + 1
            fpos = fpos + 1
            continue
        }

        fpos = fpos + 1  // Skip '%'

        switch format[fpos] {
            'd', 'e' => {
                // Day of month
                while s[spos] == ' ' {
                    spos = spos + 1
                }
                if s[spos] < '0' or s[spos] > '9' {
                    return null
                }
                tm.tm_mday = (s[spos] - '0') as i32
                spos = spos + 1
                if s[spos] >= '0' and s[spos] <= '9' {
                    tm.tm_mday = tm.tm_mday * 10 + (s[spos] - '0') as i32
                    spos = spos + 1
                }
            }
            'H' => {
                // Hour (24-hour)
                if s[spos] < '0' or s[spos] > '9' {
                    return null
                }
                tm.tm_hour = (s[spos] - '0') as i32
                spos = spos + 1
                if s[spos] >= '0' and s[spos] <= '9' {
                    tm.tm_hour = tm.tm_hour * 10 + (s[spos] - '0') as i32
                    spos = spos + 1
                }
            }
            'I' => {
                // Hour (12-hour)
                if s[spos] < '0' or s[spos] > '9' {
                    return null
                }
                tm.tm_hour = (s[spos] - '0') as i32
                spos = spos + 1
                if s[spos] >= '0' and s[spos] <= '9' {
                    tm.tm_hour = tm.tm_hour * 10 + (s[spos] - '0') as i32
                    spos = spos + 1
                }
            }
            'm' => {
                // Month
                if s[spos] < '0' or s[spos] > '9' {
                    return null
                }
                tm.tm_mon = (s[spos] - '0') as i32
                spos = spos + 1
                if s[spos] >= '0' and s[spos] <= '9' {
                    tm.tm_mon = tm.tm_mon * 10 + (s[spos] - '0') as i32
                    spos = spos + 1
                }
                tm.tm_mon = tm.tm_mon - 1  // Adjust to 0-11
            }
            'M' => {
                // Minute
                if s[spos] < '0' or s[spos] > '9' {
                    return null
                }
                tm.tm_min = (s[spos] - '0') as i32
                spos = spos + 1
                if s[spos] >= '0' and s[spos] <= '9' {
                    tm.tm_min = tm.tm_min * 10 + (s[spos] - '0') as i32
                    spos = spos + 1
                }
            }
            'S' => {
                // Second
                if s[spos] < '0' or s[spos] > '9' {
                    return null
                }
                tm.tm_sec = (s[spos] - '0') as i32
                spos = spos + 1
                if s[spos] >= '0' and s[spos] <= '9' {
                    tm.tm_sec = tm.tm_sec * 10 + (s[spos] - '0') as i32
                    spos = spos + 1
                }
            }
            'Y' => {
                // Year (4 digits)
                var year: i32 = 0
                var count: i32 = 0
                while s[spos] >= '0' and s[spos] <= '9' and count < 4 {
                    year = year * 10 + (s[spos] - '0') as i32
                    spos = spos + 1
                    count = count + 1
                }
                tm.tm_year = year - 1900
            }
            'y' => {
                // Year (2 digits)
                if s[spos] < '0' or s[spos] > '9' {
                    return null
                }
                tm.tm_year = (s[spos] - '0') as i32
                spos = spos + 1
                if s[spos] >= '0' and s[spos] <= '9' {
                    tm.tm_year = tm.tm_year * 10 + (s[spos] - '0') as i32
                    spos = spos + 1
                }
                // Assume 2000s for years 00-68, 1900s for 69-99
                if tm.tm_year < 69 {
                    tm.tm_year = tm.tm_year + 100
                }
            }
            'p' => {
                // AM/PM
                if (s[spos] == 'P' or s[spos] == 'p') and (s[spos + 1] == 'M' or s[spos + 1] == 'm') {
                    if tm.tm_hour < 12 {
                        tm.tm_hour = tm.tm_hour + 12
                    }
                    spos = spos + 2
                } else if (s[spos] == 'A' or s[spos] == 'a') and (s[spos + 1] == 'M' or s[spos + 1] == 'm') {
                    if tm.tm_hour == 12 {
                        tm.tm_hour = 0
                    }
                    spos = spos + 2
                }
            }
            '%' => {
                if s[spos] != '%' {
                    return null
                }
                spos = spos + 1
            }
            else => {
                // Skip unknown format
            }
        }

        fpos = fpos + 1
    }

    return (s + spos) as *u8
}

// ============================================
// Sleep Functions
// ============================================

export fn nanosleep(req: *const timespec, rem: *timespec): i32 {
    return basics.nanosleep(req, rem)
}

export fn sleep(seconds: u32): u32 {
    var req: timespec
    req.tv_sec = seconds as time_t
    req.tv_nsec = 0

    var rem: timespec
    if nanosleep(&req, &rem) == 0 {
        return 0
    }
    return rem.tv_sec as u32
}

export fn usleep(usec: u32): i32 {
    var req: timespec
    req.tv_sec = (usec / 1000000) as time_t
    req.tv_nsec = (usec % 1000000) as i64 * 1000

    return nanosleep(&req, null)
}

// ============================================
// Timer Functions
// ============================================

export fn timer_create(clockid: i32, evp: *void, timerid: *u32): i32 {
    return basics.timer_create(clockid, evp, timerid)
}

export fn timer_delete(timerid: u32): i32 {
    return basics.timer_delete(timerid)
}

export fn timer_settime(timerid: u32, flags: i32, new_value: *const itimerspec, old_value: *itimerspec): i32 {
    return basics.timer_settime(timerid, flags, new_value, old_value)
}

export fn timer_gettime(timerid: u32, curr_value: *itimerspec): i32 {
    return basics.timer_gettime(timerid, curr_value)
}

export fn timer_getoverrun(timerid: u32): i32 {
    return basics.timer_getoverrun(timerid)
}

// ============================================
// Timezone Functions
// ============================================

var tzname_storage: [2][32]u8 = [_][32]u8{[_]u8{0} ** 32} ** 2
export var tzname: [2]*u8 = [_]*u8{&tzname_storage[0], &tzname_storage[1]}
export var timezone_offset: i64 = 0
export var daylight: i32 = 0

export fn tzset(): void {
    // TODO: Parse TZ environment variable
    // For now, just set to UTC
    string.strcpy(tzname[0], "UTC")
    string.strcpy(tzname[1], "UTC")
    timezone_offset = 0
    daylight = 0
}
