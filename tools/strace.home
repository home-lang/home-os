// home-os - System Call Tracer (strace)
// Trace system calls and signals

import "../kernel/src/core/foundation.home" as foundation
import "../kernel/src/debug/ptrace.home" as ptrace

const MAX_SYSCALLS: u32 = 512

var syscall_names: [u64; 512]
var syscall_count: [u64; 512]
var strace_initialized: u32 = 0
var trace_enabled: u32 = 1
var show_timestamps: u32 = 0
var show_duration: u32 = 0

export fn strace_init() {
  if strace_initialized == 1 { return }
  
  // Initialize syscall name table
  strace_init_syscall_names()
  
  var i: u32 = 0
  while i < MAX_SYSCALLS {
    syscall_count[i] = 0
    i = i + 1
  }
  
  strace_initialized = 1
  foundation.serial_write_string("[strace] System call tracer initialized\n")
}

fn strace_init_syscall_names() {
  syscall_names[0] = @ptrFromInt("read")
  syscall_names[1] = @ptrFromInt("write")
  syscall_names[2] = @ptrFromInt("open")
  syscall_names[3] = @ptrFromInt("close")
  syscall_names[4] = @ptrFromInt("stat")
  syscall_names[5] = @ptrFromInt("fstat")
  syscall_names[9] = @ptrFromInt("mmap")
  syscall_names[11] = @ptrFromInt("munmap")
  syscall_names[39] = @ptrFromInt("getpid")
  syscall_names[57] = @ptrFromInt("fork")
  syscall_names[59] = @ptrFromInt("execve")
  syscall_names[60] = @ptrFromInt("exit")
  syscall_names[61] = @ptrFromInt("wait4")
  syscall_names[62] = @ptrFromInt("kill")
  // Add more syscall names...
}

export fn strace_attach(pid: u32) -> u32 {
  foundation.serial_write_string("[strace] Attaching to process ")
  foundation.serial_write_hex(pid)
  foundation.serial_write_string("\n")
  
  // Attach with ptrace
  var result: i64 = ptrace.ptrace(16, pid, 0, 0)  // PTRACE_ATTACH
  if result < 0 {
    foundation.serial_write_string("[strace] Failed to attach\n")
    return 0
  }
  
  // Set ptrace options to trace syscalls
  ptrace.ptrace(0x4200, pid, 0, 1)  // PTRACE_SETOPTIONS, PTRACE_O_TRACESYSGOOD
  
  return 1
}

export fn strace_trace(pid: u32) {
  foundation.serial_write_string("[strace] Tracing process ")
  foundation.serial_write_hex(pid)
  foundation.serial_write_string("\n\n")
  
  var in_syscall: u32 = 0
  var syscall_nr: u32 = 0
  var start_time: u64 = 0
  
  while 1 == 1 {
    // Continue and wait for next syscall
    ptrace.ptrace(24, pid, 0, 0)  // PTRACE_SYSCALL
    
    // Wait for process to stop
    var status: u32 = strace_wait_for_stop(pid)
    
    if status == 0 {
      break  // Process exited
    }
    
    if in_syscall == 0 {
      // Entering syscall
      var regs: [u64; 16]
      ptrace.ptrace(12, pid, 0, @ptrFromInt(regs))  // PTRACE_GETREGS
      
      syscall_nr = @truncate(regs[0], u32)  // RAX contains syscall number
      
      if show_timestamps == 1 {
        foundation.serial_write_hex(@truncate(foundation.timer_get_ticks(), u32))
        foundation.serial_write_string(" ")
      }
      
      strace_print_syscall_entry(syscall_nr, regs)
      
      start_time = foundation.timer_get_ticks()
      in_syscall = 1
      
    } else {
      // Exiting syscall
      var regs: [u64; 16]
      ptrace.ptrace(12, pid, 0, @ptrFromInt(regs))  // PTRACE_GETREGS
      
      var return_value: i64 = @bitCast(regs[0], i64)
      
      strace_print_syscall_exit(return_value)
      
      if show_duration == 1 {
        var duration: u64 = foundation.timer_get_ticks() - start_time
        foundation.serial_write_string(" <")
        foundation.serial_write_hex(@truncate(duration, u32))
        foundation.serial_write_string(" us>")
      }
      
      foundation.serial_write_string("\n")
      
      syscall_count[syscall_nr] = syscall_count[syscall_nr] + 1
      in_syscall = 0
    }
  }
  
  strace_print_summary()
}

fn strace_wait_for_stop(pid: u32) -> u32 {
  // Wait for process to stop (simplified)
  foundation.delay_ms(10)
  return 1
}

fn strace_print_syscall_entry(syscall_nr: u32, regs: [u64; 16]) {
  var name: u64 = syscall_names[syscall_nr]
  
  if name != 0 {
    foundation.serial_write_string(name)
  } else {
    foundation.serial_write_string("syscall_")
    foundation.serial_write_hex(syscall_nr)
  }
  
  foundation.serial_write_string("(")
  
  // Print arguments (RDI, RSI, RDX, R10, R8, R9)
  foundation.serial_write_hex(@truncate(regs[7], u32))  // RDI
  foundation.serial_write_string(", ")
  foundation.serial_write_hex(@truncate(regs[6], u32))  // RSI
  foundation.serial_write_string(", ")
  foundation.serial_write_hex(@truncate(regs[3], u32))  // RDX
  foundation.serial_write_string(")")
}

fn strace_print_syscall_exit(return_value: i64) {
  foundation.serial_write_string(" = ")
  
  if return_value < 0 {
    foundation.serial_write_string("-")
    foundation.serial_write_hex(@truncate(-return_value, u32))
    foundation.serial_write_string(" (")
    strace_print_errno(@truncate(-return_value, u32))
    foundation.serial_write_string(")")
  } else {
    foundation.serial_write_hex(@truncate(return_value, u32))
  }
}

fn strace_print_errno(errno: u32) {
  if errno == 1 {
    foundation.serial_write_string("EPERM")
  } else if errno == 2 {
    foundation.serial_write_string("ENOENT")
  } else if errno == 3 {
    foundation.serial_write_string("ESRCH")
  } else if errno == 4 {
    foundation.serial_write_string("EINTR")
  } else if errno == 5 {
    foundation.serial_write_string("EIO")
  } else {
    foundation.serial_write_string("errno ")
    foundation.serial_write_hex(errno)
  }
}

fn strace_print_summary() {
  foundation.serial_write_string("\n[strace] System call summary:\n")
  foundation.serial_write_string("syscall              calls\n")
  foundation.serial_write_string("-------------------- -----\n")
  
  var i: u32 = 0
  while i < MAX_SYSCALLS {
    if syscall_count[i] > 0 {
      var name: u64 = syscall_names[i]
      
      if name != 0 {
        foundation.serial_write_string(name)
        
        var len: u32 = 0
        while @intToPtr(name + len, u8) != 0 { len = len + 1 }
        
        var j: u32 = len
        while j < 20 {
          foundation.serial_write_string(" ")
          j = j + 1
        }
      } else {
        foundation.serial_write_string("syscall_")
        foundation.serial_write_hex(i)
        foundation.serial_write_string("         ")
      }
      
      foundation.serial_write_hex(@truncate(syscall_count[i], u32))
      foundation.serial_write_string("\n")
    }
    i = i + 1
  }
}

export fn strace_set_options(timestamps: u32, duration: u32) {
  show_timestamps = timestamps
  show_duration = duration
}

export fn main() {
  strace_init()
  
  foundation.serial_write_string("strace - System Call Tracer\n")
  foundation.serial_write_string("Usage: strace <pid>\n\n")
  
  // Example: trace PID 1
  if strace_attach(1) == 1 {
    strace_set_options(1, 1)
    strace_trace(1)
  }
}
