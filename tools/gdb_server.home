// home-os - GDB Remote Server
// Remote debugging protocol for GDB integration

import "../kernel/src/core/foundation.home" as foundation
import "../kernel/src/debug/ptrace.home" as ptrace
import "../kernel/src/network/network.home" as network

const GDB_PORT: u16 = 1234
const MAX_PACKET_SIZE: u32 = 4096

var gdb_socket: u32 = 0
var target_pid: u32 = 0
var gdb_connected: u32 = 0

export fn gdb_server_init() {
  foundation.serial_write_string("[GDB] Starting GDB remote server on port ")
  foundation.serial_write_hex(GDB_PORT)
  foundation.serial_write_string("\n")
  
  // Create listening socket
  gdb_socket = network.socket_create(2, 1, 0)  // AF_INET, SOCK_STREAM
  
  if gdb_socket == 0xFFFFFFFF {
    foundation.serial_write_string("[GDB] Failed to create socket\n")
    return
  }
  
  // Bind to port
  network.socket_bind(gdb_socket, 0, GDB_PORT)
  
  // Listen
  network.socket_listen(gdb_socket, 1)
  
  foundation.serial_write_string("[GDB] Waiting for connection...\n")
}

export fn gdb_server_run() {
  // Accept connection
  var client_socket: u32 = network.socket_accept(gdb_socket)
  
  if client_socket == 0xFFFFFFFF {
    foundation.serial_write_string("[GDB] Failed to accept connection\n")
    return
  }
  
  gdb_connected = 1
  foundation.serial_write_string("[GDB] Client connected\n")
  
  // Main protocol loop
  while gdb_connected == 1 {
    var packet: [u8; 4096]
    var len: u32 = gdb_recv_packet(client_socket, @ptrFromInt(packet), MAX_PACKET_SIZE)
    
    if len == 0 {
      break
    }
    
    gdb_handle_packet(client_socket, @ptrFromInt(packet), len)
  }
  
  network.socket_close(client_socket)
  foundation.serial_write_string("[GDB] Client disconnected\n")
}

fn gdb_recv_packet(socket: u32, buffer: u64, max_len: u32) -> u32 {
  // Receive GDB packet: $<data>#<checksum>
  var pos: u32 = 0
  var in_packet: u32 = 0
  
  while pos < max_len {
    var ch: u8 = 0
    var received: u32 = network.socket_recv(socket, @ptrFromInt(ch), 1)
    
    if received == 0 {
      return 0
    }
    
    if ch == '$' {
      in_packet = 1
      pos = 0
    } else if ch == '#' {
      // Read checksum
      var checksum: [u8; 2]
      network.socket_recv(socket, @ptrFromInt(checksum), 2)
      
      // Send ACK
      gdb_send_ack(socket)
      
      return pos
    } else if in_packet == 1 {
      @intToPtr(buffer + pos, u8) = ch
      pos = pos + 1
    }
  }
  
  return 0
}

fn gdb_send_packet(socket: u32, data: u64, len: u32) {
  // Send: $<data>#<checksum>
  var packet: [u8; 4096]
  
  packet[0] = '$'
  
  var i: u32 = 0
  while i < len {
    packet[1 + i] = @intToPtr(data + i, u8)
    i = i + 1
  }
  
  // Calculate checksum
  var checksum: u8 = 0
  i = 0
  while i < len {
    checksum = checksum + @intToPtr(data + i, u8)
    i = i + 1
  }
  
  packet[1 + len] = '#'
  packet[2 + len] = gdb_hex_char((checksum >> 4) & 0xF)
  packet[3 + len] = gdb_hex_char(checksum & 0xF)
  
  network.socket_send(socket, @ptrFromInt(packet), 4 + len)
}

fn gdb_send_ack(socket: u32) {
  var ack: u8 = '+'
  network.socket_send(socket, @ptrFromInt(ack), 1)
}

fn gdb_hex_char(nibble: u8) -> u8 {
  if nibble < 10 {
    return '0' + nibble
  }
  return 'a' + (nibble - 10)
}

fn gdb_handle_packet(socket: u32, data: u64, len: u32) {
  var cmd: u8 = @intToPtr(data, u8)
  
  if cmd == 'g' {
    // Read registers
    gdb_cmd_read_registers(socket)
  } else if cmd == 'G' {
    // Write registers
    gdb_cmd_write_registers(socket, data + 1, len - 1)
  } else if cmd == 'm' {
    // Read memory
    gdb_cmd_read_memory(socket, data + 1, len - 1)
  } else if cmd == 'M' {
    // Write memory
    gdb_cmd_write_memory(socket, data + 1, len - 1)
  } else if cmd == 'c' {
    // Continue
    gdb_cmd_continue(socket)
  } else if cmd == 's' {
    // Step
    gdb_cmd_step(socket)
  } else if cmd == 'Z' {
    // Insert breakpoint
    gdb_cmd_insert_breakpoint(socket, data + 1, len - 1)
  } else if cmd == 'z' {
    // Remove breakpoint
    gdb_cmd_remove_breakpoint(socket, data + 1, len - 1)
  } else if cmd == '?' {
    // Query halt reason
    gdb_cmd_halt_reason(socket)
  } else if cmd == 'q' {
    // Query
    gdb_cmd_query(socket, data + 1, len - 1)
  } else {
    // Unsupported
    gdb_send_packet(socket, @ptrFromInt(""), 0)
  }
}

fn gdb_cmd_read_registers(socket: u32) {
  var regs: [u64; 16]
  ptrace.ptrace(12, target_pid, 0, @ptrFromInt(regs))  // PTRACE_GETREGS
  
  // Format registers as hex string
  var response: [u8; 256]
  var pos: u32 = 0
  
  var i: u32 = 0
  while i < 16 {
    var j: u32 = 0
    while j < 16 {
      var nibble: u8 = @truncate((regs[i] >> ((15 - j) * 4)) & 0xF, u8)
      response[pos] = gdb_hex_char(nibble)
      pos = pos + 1
      j = j + 1
    }
    i = i + 1
  }
  
  gdb_send_packet(socket, @ptrFromInt(response), pos)
}

fn gdb_cmd_write_registers(socket: u32, data: u64, len: u32) {
  // Parse hex string and write registers
  gdb_send_packet(socket, @ptrFromInt("OK"), 2)
}

fn gdb_cmd_read_memory(socket: u32, data: u64, len: u32) {
  // Parse: m<addr>,<length>
  var addr: u64 = gdb_parse_hex(data, len)
  var read_len: u32 = 64  // Simplified
  
  var response: [u8; 256]
  var pos: u32 = 0
  
  var i: u32 = 0
  while i < read_len {
    var value: i64 = ptrace.ptrace(2, target_pid, addr + i, 0)  // PTRACE_PEEKDATA
    var byte: u8 = @truncate(value, u8)
    
    response[pos] = gdb_hex_char((byte >> 4) & 0xF)
    response[pos + 1] = gdb_hex_char(byte & 0xF)
    pos = pos + 2
    
    i = i + 1
  }
  
  gdb_send_packet(socket, @ptrFromInt(response), pos)
}

fn gdb_cmd_write_memory(socket: u32, data: u64, len: u32) {
  gdb_send_packet(socket, @ptrFromInt("OK"), 2)
}

fn gdb_cmd_continue(socket: u32) {
  ptrace.ptrace(7, target_pid, 0, 0)  // PTRACE_CONT
  gdb_send_packet(socket, @ptrFromInt("OK"), 2)
}

fn gdb_cmd_step(socket: u32) {
  ptrace.ptrace(9, target_pid, 0, 0)  // PTRACE_SINGLESTEP
  gdb_send_packet(socket, @ptrFromInt("S05"), 3)  // SIGTRAP
}

fn gdb_cmd_insert_breakpoint(socket: u32, data: u64, len: u32) {
  gdb_send_packet(socket, @ptrFromInt("OK"), 2)
}

fn gdb_cmd_remove_breakpoint(socket: u32, data: u64, len: u32) {
  gdb_send_packet(socket, @ptrFromInt("OK"), 2)
}

fn gdb_cmd_halt_reason(socket: u32) {
  gdb_send_packet(socket, @ptrFromInt("S05"), 3)  // SIGTRAP
}

fn gdb_cmd_query(socket: u32, data: u64, len: u32) {
  // Handle qSupported, qAttached, etc.
  gdb_send_packet(socket, @ptrFromInt(""), 0)
}

fn gdb_parse_hex(data: u64, len: u32) -> u64 {
  var result: u64 = 0
  
  var i: u32 = 0
  while i < len {
    var ch: u8 = @intToPtr(data + i, u8)
    
    if ch >= '0' and ch <= '9' {
      result = (result << 4) | (ch - '0')
    } else if ch >= 'a' and ch <= 'f' {
      result = (result << 4) | (ch - 'a' + 10)
    } else if ch >= 'A' and ch <= 'F' {
      result = (result << 4) | (ch - 'A' + 10)
    } else {
      break
    }
    
    i = i + 1
  }
  
  return result
}

export fn gdb_attach(pid: u32) {
  target_pid = pid
  ptrace.ptrace(16, pid, 0, 0)  // PTRACE_ATTACH
  
  foundation.serial_write_string("[GDB] Attached to process ")
  foundation.serial_write_hex(pid)
  foundation.serial_write_string("\n")
}

export fn main() {
  foundation.serial_write_string("GDB Remote Server\n")
  
  gdb_server_init()
  gdb_attach(1)  // Attach to init
  gdb_server_run()
}
