// home-os - Performance Profiler (perf)
// CPU profiling and performance analysis

import "../kernel/src/core/foundation.home" as foundation
import "../kernel/src/perf/profiler.home" as profiler

const MAX_SAMPLES: u32 = 100000
const SAMPLE_FREQ_HZ: u32 = 1000

struct PerfSample {
  rip: u64,
  pid: u32,
  cpu: u32,
  timestamp: u64
}

struct PerfSymbol {
  addr: u64,
  name: [u8; 128],
  samples: u32
}

var samples: [PerfSample; 100000]
var sample_count: u32 = 0
var symbols: [PerfSymbol; 1000]
var symbol_count: u32 = 0
var perf_running: u32 = 0

export fn perf_init() {
  sample_count = 0
  symbol_count = 0
  perf_running = 0
  
  foundation.serial_write_string("[perf] Performance profiler initialized\n")
}

export fn perf_record(duration_sec: u32) {
  foundation.serial_write_string("[perf] Recording for ")
  foundation.serial_write_hex(duration_sec)
  foundation.serial_write_string(" seconds...\n")
  
  perf_running = 1
  sample_count = 0
  
  // Setup timer interrupt for sampling
  perf_setup_sampling(SAMPLE_FREQ_HZ)
  
  // Wait for duration
  var elapsed: u32 = 0
  while elapsed < duration_sec {
    foundation.delay_ms(1000)
    elapsed = elapsed + 1
    
    foundation.serial_write_string(".")
  }
  
  foundation.serial_write_string("\n")
  
  perf_running = 0
  perf_stop_sampling()
  
  foundation.serial_write_string("[perf] Recorded ")
  foundation.serial_write_hex(sample_count)
  foundation.serial_write_string(" samples\n")
}

fn perf_setup_sampling(freq_hz: u32) {
  // Setup performance counter to generate interrupts
  foundation.setup_perf_counter(freq_hz)
}

fn perf_stop_sampling() {
  foundation.stop_perf_counter()
}

export fn perf_sample_handler(rip: u64, pid: u32, cpu: u32) {
  if perf_running == 0 { return }
  if sample_count >= MAX_SAMPLES { return }
  
  samples[sample_count].rip = rip
  samples[sample_count].pid = pid
  samples[sample_count].cpu = cpu
  samples[sample_count].timestamp = foundation.timer_get_ticks()
  
  sample_count = sample_count + 1
}

export fn perf_report() {
  foundation.serial_write_string("\n[perf] Performance Report\n\n")
  
  // Aggregate samples by address
  perf_aggregate_samples()
  
  // Sort symbols by sample count
  perf_sort_symbols()
  
  // Print top functions
  foundation.serial_write_string("Overhead  Samples  Function\n")
  foundation.serial_write_string("--------  -------  --------\n")
  
  var i: u32 = 0
  while i < symbol_count and i < 20 {
    var overhead: u32 = (symbols[i].samples * 100) / sample_count
    
    foundation.serial_write_hex(overhead)
    foundation.serial_write_string("%      ")
    foundation.serial_write_hex(symbols[i].samples)
    foundation.serial_write_string("      ")
    foundation.serial_write_string(@ptrFromInt(symbols[i].name))
    foundation.serial_write_string("\n")
    
    i = i + 1
  }
  
  foundation.serial_write_string("\n")
}

fn perf_aggregate_samples() {
  symbol_count = 0
  
  var i: u32 = 0
  while i < sample_count {
    var rip: u64 = samples[i].rip
    
    // Find or create symbol
    var symbol_idx: u32 = perf_find_symbol(rip)
    
    if symbol_idx == 0xFFFFFFFF {
      if symbol_count < 1000 {
        symbols[symbol_count].addr = rip
        symbols[symbol_count].samples = 1
        perf_resolve_symbol(rip, @ptrFromInt(symbols[symbol_count].name))
        symbol_count = symbol_count + 1
      }
    } else {
      symbols[symbol_idx].samples = symbols[symbol_idx].samples + 1
    }
    
    i = i + 1
  }
}

fn perf_find_symbol(addr: u64) -> u32 {
  var i: u32 = 0
  while i < symbol_count {
    if symbols[i].addr == addr {
      return i
    }
    i = i + 1
  }
  return 0xFFFFFFFF
}

fn perf_resolve_symbol(addr: u64, name_out: u64) {
  // Resolve address to symbol name (simplified)
  foundation.serial_write_string("0x")
  foundation.serial_write_hex(@truncate(addr, u32))
  
  var i: u32 = 0
  while i < 128 {
    @intToPtr(name_out + i, u8) = 0
    i = i + 1
  }
  
  // Copy "0x..." to name
  @intToPtr(name_out, u8) = '0'
  @intToPtr(name_out + 1, u8) = 'x'
  
  var hex_chars: [u8; 16]
  hex_chars[0] = '0'
  hex_chars[1] = '1'
  hex_chars[2] = '2'
  hex_chars[3] = '3'
  hex_chars[4] = '4'
  hex_chars[5] = '5'
  hex_chars[6] = '6'
  hex_chars[7] = '7'
  hex_chars[8] = '8'
  hex_chars[9] = '9'
  hex_chars[10] = 'a'
  hex_chars[11] = 'b'
  hex_chars[12] = 'c'
  hex_chars[13] = 'd'
  hex_chars[14] = 'e'
  hex_chars[15] = 'f'
  
  var j: u32 = 0
  while j < 8 {
    var nibble: u8 = @truncate((addr >> ((7 - j) * 4)) & 0xF, u8)
    @intToPtr(name_out + 2 + j, u8) = hex_chars[nibble]
    j = j + 1
  }
}

fn perf_sort_symbols() {
  // Bubble sort by sample count
  var i: u32 = 0
  while i < symbol_count - 1 {
    var j: u32 = 0
    while j < symbol_count - i - 1 {
      if symbols[j].samples < symbols[j + 1].samples {
        var temp: PerfSymbol = symbols[j]
        symbols[j] = symbols[j + 1]
        symbols[j + 1] = temp
      }
      j = j + 1
    }
    i = i + 1
  }
}

export fn perf_stat(command: u64) {
  foundation.serial_write_string("[perf] Running: ")
  foundation.serial_write_string(command)
  foundation.serial_write_string("\n\n")
  
  var start_time: u64 = foundation.timer_get_ticks()
  
  // Execute command and collect stats
  foundation.exec_command(command)
  
  var end_time: u64 = foundation.timer_get_ticks()
  var duration: u64 = end_time - start_time
  
  foundation.serial_write_string("\n Performance counter stats:\n\n")
  foundation.serial_write_string("  ")
  foundation.serial_write_hex(@truncate(duration, u32))
  foundation.serial_write_string(" ms elapsed\n")
  
  // Get CPU cycles
  var cycles: u64 = foundation.read_perf_counter(0)
  foundation.serial_write_string("  ")
  foundation.serial_write_hex(@truncate(cycles, u32))
  foundation.serial_write_string(" cycles\n")
  
  // Get instructions
  var instructions: u64 = foundation.read_perf_counter(1)
  foundation.serial_write_string("  ")
  foundation.serial_write_hex(@truncate(instructions, u32))
  foundation.serial_write_string(" instructions\n")
  
  // Calculate IPC
  if cycles > 0 {
    var ipc: u32 = @truncate((instructions * 100) / cycles, u32)
    foundation.serial_write_string("  ")
    foundation.serial_write_hex(ipc / 100)
    foundation.serial_write_string(".")
    foundation.serial_write_hex(ipc % 100)
    foundation.serial_write_string(" IPC\n")
  }
}

export fn main() {
  perf_init()
  
  foundation.serial_write_string("perf - Performance Profiler\n")
  foundation.serial_write_string("Commands:\n")
  foundation.serial_write_string("  perf record <duration>  - Record samples\n")
  foundation.serial_write_string("  perf report             - Show report\n")
  foundation.serial_write_string("  perf stat <command>     - Run and show stats\n\n")
  
  // Example: record for 5 seconds
  perf_record(5)
  perf_report()
}
